{
  "course_name": "Angular",
  "description": "Angular is a framework for building client applications in HTML and TypeScript. Learn Angular step-by-step with easy-to-follow pages and runnable JS-only examples. We use standalone components, modern control flow, and the built-in Router and HttpClient in examples. Prerequisites: Our \"Show Angular\" tool makes it easy to demonstrate Angular. It shows both the code and the result. Run Example » Many chapters in this tutorial end with an exercise where you can check you level of knowledge. See all Angular Exercises REMOVE ADS Test your Angular skills with a quiz. Angular Quiz Sign Up for Free Note: This is an optional feature. You can study at W3Schools without creating an account.",
  "course_summary": [
    {
      "title": "Angular Intro",
      "summary": "Angular helps you build scalable single-page applications with TypeScript.\nWhat is Angular?\nAngular is a full-featured front-end framework for building web applications.\nBuilt with TypeScript\nUses components and templates\nIncludes routing, forms, HTTP, and dependency injection\nSupports standalone APIs (no NgModules needed)\nWorks great for single-page applications (SPAs)\nREMOVE ADS\nHow Angular Works\nAngular compiles your templates into efficient JavaScript and updates the DOM when your component state changes.\nDeclare UI with HTML-based templates\nBind data with interpolation and directives\nHandle events and user input\nFetch data with the HttpClient (Observables)\nNavigate with the Router\nWhat You Should Already Know\nBefore you start, you should know the basics of:\nHTML\nCSS\nJavaScript\nBasic TypeScript helps\nAngular Example\nExampleGet your own Angular Server\nRun Example »",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: `<h2>Welcome to Angular!</h2>` }) export class App {} bootstrapApplication(App);",
        "<app-root></app-root>"
      ]
    },
    {
      "title": "Angular Get Started",
      "summary": "To use Angular, you need npm which is included with Node.js.\nCheck Node.js\nAngular's tooling (the CLI and build tools) runs on Node.js and uses npm to install packages.\nRun these to confirm Node.js and npm are installed and on your PATH:\nThis prints your installed Node.js version, like:\nAngular works best with the current LTS (Long Term Support) release (18 or 20).\nIf you get a \"command not found\" error, install Node.js (visit our Node.js tutorial for details).\nYou can also check npm:\nnpm is Node's package manager.\nThis prints your npm version, like:\nnpm should be automatically installed with Node.js.\nInstall Angular CLI\nThe Angular CLI is the official tool to create, build, and serve Angular apps.\nThe CLI (Command Line Interface) creates projects, runs a dev server, and provides helpful commands.\nInstall the Angular CLI globally:\nInstalling it globally makes the ng command available everywhere.\nYou can also use npx without a global install.\nIf you hit permission errors, use npx or run your terminal with elevated rights.\nREMOVE ADS\nVerify Angular CLI\nVerify the installation to ensure ng is on your PATH and versions are compatible.\nDisplays the Angular CLI, Node.js, and Angular package versions so you can confirm the installation:\nPATH is the list of folders your system searches for commands like ng.\nCreate an Angular Application\nCreate a project named my-angular-app:\nThis creates the project files and folders and installs dependencies.\nIt may take a few minutes and will ask a few prompts (see recommended choices below).\nRecommended choices when prompted:\nStylesheet format: CSS (you can change later)\nServer-side rendering (SSR): No for now (you can add later with ng add @angular/ssr)\nZoneless application: No for now (you can change later with ng add @angular/zoneless)\nOther prompts: keep the defaults\nIf you don't want to install the CLI globally, you can use npx:\nRun the Angular Application\ncd enters your new project folder.\nng serve starts a local dev server and watches for changes.\nThe first build can take a minute.\nYou can add the --open flag to automatically open the app in your default browser:\nBy default the dev server runs on http://localhost:4200.",
      "examples": [
        "node -v",
        "v20.x.x",
        "npm -v",
        "10.x.x",
        "npm install -g @angular/cli",
        "ng version",
        "Angular CLI: 18.x.x\nNode: 20.x.x\nPackage Manager: npm 10.x.x",
        "ng new my-angular-app",
        "npx @angular/cli@latest new my-angular-app",
        "cd my-angular-app\nng serve",
        "✔ Compiled successfully. ✔ Browser application bundle generation complete.",
        "ng serve --open",
        "ng",
        "npx",
        "PATH",
        "my-angular-app",
        "ng add @angular/ssr",
        "ng add @angular/zoneless",
        "cd",
        "ng serve",
        "--open",
        "http://localhost:4200"
      ]
    },
    {
      "title": "Angular First App",
      "summary": "Now that your environment is ready, let's create a simple Angular app\nStep 1: Open src/main.ts\nAngular 20 apps bootstrap a standalone root component.\nYou can define it inline in main.ts.\nOpen it an replace the code with:\nExampleGet your own Angular Server\nRun Example »\nLive reload: When the Angular App is running (Started with ng serve as shown in last chapter), the browser reloads automatically on save.\nQuick primer: components\nA component is a class that controls a view (its template).\nEach component has a selector (e.g., app-root) that you place in HTML.\nThe root component renders inside index.html's <app-root>.\nWe'll explore components in depth later: Components.\nStep 2: Host element in index.html\nAngular renders the root component where its selector appears.\nOpen src/index.html and make sure the root tag is inside <body>.\nThe tag must match your component selector from Step 1 (here it is app-root).\nIf you created the project with the CLI, this tag is usually already present:\nExample: Minimal index.html\nKeep <base href=\"/\"> in <head> so routing works later.\nREMOVE ADS\nStep 3: Bind some data\nAdd a property and show it with interpolation:\nExample\nRun Example »\nInterpolation updates the view automatically when the component property changes.\nTip: Keep expressions simple.\nUse properties over calling methods directly in templates for performance.\nProject Structure\nKey files in a minimal Angular workspace:\nsrc/main.ts - Boots the app with bootstrapApplication.\nsrc/app/app.component.ts - Root component (if used). You can also define the root inline in main.ts.\nsrc/app/ - Where you add your components and features.\nsrc/index.html - Host page that contains <app-root>.\nsrc/styles.css - Global styles for the app.\nangular.json - Angular workspace configuration (build, serve, test).\npackage.json - Scripts and dependencies.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: `<h1>Hello, World!</h1>` }) class App {} bootstrapApplication(App);",
        "<!doctype html> <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <title>My Angular App</title> <base href=\"/\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> </head> <body> <!-- Host element --> <app-root></app-root> </body> </html>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: `<h1>Hello, {{ name }}!</h1>` }) class App { name = 'Angular 20'; } bootstrapApplication(App);",
        "src/main.ts",
        "main.ts",
        "ng serve",
        "app-root",
        "index.html",
        "<app-root>",
        "src/index.html",
        "<body>",
        "<base href=\"/\">",
        "<head>",
        "bootstrapApplication",
        "src/app/app.component.ts",
        "src/app/",
        "src/styles.css",
        "angular.json",
        "package.json"
      ]
    },
    {
      "title": "Angular Templates",
      "summary": "Templates are the HTML that a component renders.\nTemplates combine plain HTML with Angular template syntax to show data and react to user events.\nComponents, Templates, and Selectors\nA component is a class that controls a view (its template).\nEach component has a selector (e.g., app-root) that you place in HTML.\nThe root component renders inside index.html's <app-root>.\nHow templates work\nInitial render: Angular creates the component and processes the template, wiring bindings between the DOM and component fields.\nChange detection: On user events, timers, or async work, Angular re-evaluates template expressions and updates only what changed.\nDirectives: Create/destroy embedded views (DOM fragments) based on state.\nBinding flow: Interpolation/Property binding push data to the view. Event binding captures browser events back to the component.\nNote: Interpolation escapes HTML.\nUse property/attribute bindings for dynamic attributes. Use ?. to avoid null errors.\nSyntaxGet your own Angular Server\nRun Example »\nExample explained\n{{ name }}: Interpolation reads the name field and inserts it as text.\n(click): Event binding updates the component state when the button is clicked.\nNote: Template expressions run in the component context.\nKeep them fast and side-effect free; do work in the class, not inline in the template.\nTemplate Essentials\nKey concepts:\nTemplates are the HTML that Angular renders for a component.\nBindings: interpolation {{ ... }}, property [prop], and event (event).\nTemplate refs: local names like #box to reference elements or directives.\nStructural directives (*ngIf, *ngFor) change the DOM layout.\nCode explained\n{{ name }}: Interpolation for text.\n[src]: Property binding to set an element property.\n(error): Event binding to react to the image error event.\n#box: Template reference variable; box.value reads the current input value.\n*ngFor ... index as i: Structural directive to loop with the zero-based index.\nNote: See Data Binding for property/class/style binding, and Conditional Rendering for showing/hiding content.\nREMOVE ADS\nTemplates Overview\nExplore templates step by step in these next chapters:\nInterpolation - show values with {{ ... }}.\nTemplate Reference Variables - use #var to reference elements.\nNull-Safe Navigation (?.) - read optional values safely.\nStructural Directives: Micro-syntax - the * shorthand.\nngTemplateOutlet - render a template by reference.\nTemplate Statements and $event - handle events and inputs.\nAlias with as in *ngIf - create local aliases.\nPipes in Templates (|) - format and transform values.\nAttribute Binding with attr. - bind to HTML attributes.\nTrackBy with *ngFor - keep lists fast and stable.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Hello {{ name }}</h3> <button (click)=\"name = 'Angular'\">Reset</button> ` }) export class App { name = 'World'; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<p>Hello {{ name }}</p> <img [src]=\"url\" (error)=\"onMissing()\"> <input #box (input)=\"save(box.value)\"> <li *ngFor=\"let item of items; index as i\">{{ i }}. {{ item }}</li>",
        "app-root",
        "index.html",
        "<app-root>",
        "?.",
        "{{ name }}",
        "name",
        "(click)",
        "{{ ... }}",
        "[prop]",
        "(event)",
        "#box",
        "*ngIf",
        "*ngFor",
        "[src]",
        "(error)",
        "box.value",
        "*ngFor ... index as i",
        "#var",
        "*"
      ]
    },
    {
      "title": "Angular Templates: Interpolation",
      "summary": "Display component values with {{ ... }}.\nWhat is Interpolation?\nDisplays component values in the DOM with double curly braces.\nRead it as: “take this value and print it as text”.\nOne-way only: data → view.\nWhen to use Interpolation\nShow text values and simple, fast expressions (no side effects).\nUse property/attribute binding for dynamic attributes.\nFor HTML content, consider [innerHTML] with care.\n{{ expression }}: Evaluates against the component and inserts the result as text (HTML-escaped).\nREMOVE ADS\nExample\nUse interpolation to display component values in the DOM:\nExampleGet your own Angular Server\nRun Example »\nExample explained\nInterpolation {{ expression }}: Angular evaluates the expression against the component and inserts the result as text (HTML-escaped).\nProperty values: {{ title }} and {{ name }} read component fields.\nExpressions: {{ 2 + 3 }} evaluates arithmetic; {{ name.toUpperCase() }} calls a method on the string value.\nText vs HTML: Interpolation escapes HTML. To render HTML, bind with [innerHTML] carefully.\nKeep expressions light: Avoid heavy work in {{ ... }}; compute values in the component.\nText, not HTML: Interpolation escapes HTML for safety. To insert HTML, use [innerHTML] carefully.\nNo side effects: Don't change state inside template expressions. Keep them pure.",
      "examples": [
        "{{ expression }}",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>{{ title }}</h3> <p>Hello {{ name }}!</p> <p>2 + 3 = {{ 2 + 3 }}</p> <p>Upper: {{ name.toUpperCase() }}</p> ` }) export class App { title = 'Templates & Interpolation'; name = 'Angular'; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "{{ ... }}",
        "[innerHTML]",
        "{{ title }}",
        "{{ name }}",
        "{{ 2 + 3 }}",
        "{{ name.toUpperCase() }}"
      ]
    },
    {
      "title": "Angular Template Reference Variables",
      "summary": "Give elements a local #var and read values or call methods.\nWhat is a Template Reference Variable?\nGives a local name (e.g., #box) to an element or directive instance.\nLets you read values or call methods directly in the template.\nScoped to the template where it is declared.\nWhen to use Template Reference Variables\nSimple interactions (read input value, focus an element).\nAccess directive/component API in the view without extra bindings.\nFor complex logic, Use component methods and state.\nExample\nUse template reference variables to read values or call methods directly in the template:\nCode explained\n#box: Declares a local template reference to the input element instance.\nRead value: box.value gets the current text of the input.\nCall method: box.focus() calls the native focus() on the input.\nExample\nUse template reference variables to read values or call methods directly in the template:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n#box: A template reference variable bound to the input element instance.\nRead a value: box.value reads the input's current text.\nCall a method: box.focus() calls the input's focus method.\nUpdate state: (input)=\"current = box.value\" copies the current input text into the component's current field.\nScope: The variable exists only in the template where it is declared.",
      "examples": [
        "<input #box (input)=\"val = box.value\"> <button (click)=\"box.focus()\">Focus</button>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], styles: [` .toolbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; } input { padding: 6px 8px; } `], template: ` <h3>Template Reference Variables (#var)</h3> <div class=\"toolbar\"> <input #box type=\"text\" placeholder=\"Type something\" (input)=\"current = box.value\" /> <button (click)=\"read(box.value)\">Read value</button> <button (click)=\"box.focus()\">Focus input</button> <span style=\"margin-left:8px;color:#666\">length={{ box.value?.length || 0 }}</span> </div> <p>Current: {{ current || '(empty)' }}</p> ` }) export class App { current = ''; read(val: string) { this.current = val ?? ''; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "#var",
        "#box",
        "box.value",
        "box.focus()",
        "focus()",
        "(input)=\"current = box.value\"",
        "current"
      ]
    },
    {
      "title": "Angular Templates: Null-Safe Navigation (?.)",
      "summary": "Safely read optional values with ?. and provide defaults with ??.\nWhat is Null-Safe Navigation (?.)?\n?. reads values that might be missing without throwing errors.\nIf any segment is null or undefined, the result is undefined.\nImproves safety for deep property paths in templates.\nWhen to use Null-Safe Navigation\nAsync or optional data where properties may be absent.\nUse ?. (and optional chaining in code) over verbose checks.\nCombine with ?? to provide default values.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nOptional chaining (?.): user?.profile?.email reads email only if user and profile are defined; otherwise the whole expression is undefined (no error).\nFallback: || '(none)' shows a placeholder when the expression is falsy; prefer ?? when you want to treat 0 or empty strings as valid.\nToggle: Clicking “Toggle user” alternates user between undefined and an object to demonstrate safe access.\nNullish coalescing (??): Use a ?? b over a || b when you want to keep valid falsy values like 0 or ''.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <button (click)=\"toggle()\">Toggle user</button> <p>Email: {{ user?.profile?.email || '(none)' }}</p> ` }) export class App { user: { profile?: { email?: string } } | undefined = undefined; toggle() { this.user = this.user ? undefined : { profile: { email: 'a@example.com' } }; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "?.",
        "??",
        "null",
        "undefined",
        "user?.profile?.email",
        "|| '(none)'",
        "0",
        "user",
        "a ?? b",
        "a || b",
        "''"
      ]
    },
    {
      "title": "Angular Templates: Structural Directives Micro-syntax",
      "summary": "Use * shorthand for structural directives; Angular expands it to <ng-template>.\nWhat is the Structural Directives micro-syntax?\n* is shorthand that expands to an underlying <ng-template>.\nProvides context variables (e.g., index as i, else).\nAngular rewrites *ngIf, *ngFor, etc., using this syntax.\nImportant: In Angular 17+, prefer the new control flow syntax (@if, @for, @switch).\nThe micro-syntax for *ngIf/*ngFor remains supported for existing code. See Control Flow.\nWhen to use the micro-syntax\nWith structural directives to add/remove DOM based on state.\nTo iterate lists concisely with *ngFor.\nUse shorthand for readability; use explicit <ng-template> when needed.\nExample\nUse the * micro-syntax to expand structural directives and expose context variables:\nCode explained\n*ngIf=\"ok; else other\": Renders the block when ok is truthy; otherwise renders the #other template.\n*ngFor=\"...; index as i\": Loops over items and exposes the zero‑based index as i.\n* shorthand: Angular rewrites *... into an underlying <ng-template>.\nSee Conditional Rendering for *ngIf and Lists for *ngFor, micro-syntax (index as i, else), and more examples.\nREMOVE ADS\nExample\nUse micro-syntax with *ngIf and *ngFor to conditionally render or iterate:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n* shorthand: *ngIf and *ngFor are shorthand that Angular rewrites to an underlying <ng-template>.\n*ngIf=\"ok; else other\": Renders the block when ok is true; otherwise renders the template referenced by #other.\n*ngFor=\"let item of items; index as i\": Iterates the array items; item is the current element and i is the zero-based index.",
      "examples": [
        "<div *ngIf=\"ok; else other\">OK</div> <ng-template #other>Not OK</ng-template> <li *ngFor=\"let item of items; index as i\">{{ i }} {{ item }}</li>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <button (click)=\"ok = !ok\">Toggle</button> <div *ngIf=\"ok; else other\">OK</div> <ng-template #other>Not OK</ng-template> <ul> <li *ngFor=\"let item of items; index as i\">{{ i }} - {{ item }}</li> </ul> ` }) export class App { ok = true; items = ['A','B','C']; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "*",
        "<ng-template>",
        "index as i",
        "else",
        "*ngIf",
        "*ngFor",
        "@if",
        "@for",
        "@switch",
        "*ngIf=\"ok; else other\"",
        "ok",
        "#other",
        "*ngFor=\"...; index as i\"",
        "items",
        "i",
        "*...",
        "*ngFor=\"let item of items; index as i\"",
        "item"
      ]
    },
    {
      "title": "Angular Templates: ngTemplateOutlet",
      "summary": "Reuse and render a referenced template with [ngTemplateOutlet].\nWhat is ngTemplateOutlet?\n<ng-template> defines a reusable chunk of template (a “recipe”).\nRender it with [ngTemplateOutlet].\nPass values via [ngTemplateOutletContext] and read with let- variables.\nWhen to use ngTemplateOutlet\nReuse UI patterns with different data or rendering variations.\nUse components for complex, reusable logic.\nUse templates for lightweight, view-only reuse.\nTip: Use <ng-container> as a logical wrapper that does not add extra DOM elements.\nRelated: see Components for content projection with <ng-content>.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n<ng-template>: Defines a reusable template block (not rendered until referenced).\n[ngTemplateOutlet]: Chooses which template to render (here via a ternary expression based on type).\n[ngTemplateOutletContext]: Passes values into the template. The $implicit key is read by a matching let- variable.\nlet-text: Declares a local variable inside the template that reads the $implicit value from the context.\n<ng-container>: A logical wrapper that does not create extra DOM elements.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>Templates with ngTemplateOutlet</h3> <label> Type: <select (change)=\"type = $any($event.target).value\"> <option value=\"info\">info</option> <option value=\"warning\">warning</option> <option value=\"success\">success</option> </select> </label> <label> Message: <input (input)=\"msg = $any($event.target).value\" [value]=\"msg\" /> </label> <ng-container [ngTemplateOutlet]=\"type === 'info' ? infoTpl : (type === 'warning' ? warnTpl : successTpl)\" [ngTemplateOutletContext]=\"{ $implicit: msg }\"> </ng-container> <ng-template #infoTpl let-text> <p style=\"color:royalblue\">Info: {{ text }}</p> </ng-template> <ng-template #warnTpl let-text> <p style=\"color:darkorange\">Warning: {{ text }}</p> </ng-template> <ng-template #successTpl let-text> <p style=\"color:seagreen\">Success: {{ text }}</p> </ng-template> ` }) export class App { type: 'info' | 'warning' | 'success' = 'info'; msg = 'Hello'; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "[ngTemplateOutlet]",
        "<ng-template>",
        "[ngTemplateOutletContext]",
        "let-",
        "<ng-container>",
        "<ng-content>",
        "type",
        "$implicit",
        "let-text"
      ]
    },
    {
      "title": "Angular Template Statements and $event",
      "summary": "Handle user events in the template and access the native event via $event.\nWhat are Template Statements and $event?\nRun in response to events bound with (click), (input), etc.\nUse $event for the native event object.\nUse $any(...) to help with types like target.value.\nWhen to use Template Statements\nSimple UI interactions and state updates from events.\nKeep template logic minimal; move complex logic to the component class.\nPair with template reference variables for straightforward interactions.\nCode explained\n(click): Binds a click handler that updates component state.\n$event: The native event object; $any($event.target).value reads the input text.\nExample\nHandle events in the template and use $event to access native values:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n(click)=\"count = count + 1\": Executes the statement in the component's context when the button is clicked, updating the count field.\n$event: The native event object. $any($event.target).value reads the current input text (casted to satisfy TypeScript).\n[value]=\"text\": One-way property binding that reflects the current component state back to the input element.\nKeep logic small: Do simple assignments in the template; move multi-step logic into component methods.\nSee Events for more on event binding and keyboard events.",
      "examples": [
        "<button (click)=\"count = count + 1\">Add</button> <input (input)=\"text = $any($event.target).value\">",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <button (click)=\"count = count + 1\">Increment</button> <input placeholder=\"Type\" (input)=\"text = $any($event.target).value\" [value]=\"text\" /> <p>Count: {{ count }}</p> <p>Text: {{ text || '(empty)' }}</p> ` }) export class App { count = 0; text = ''; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "$event",
        "(click)",
        "(input)",
        "$any(...)",
        "target.value",
        "$any($event.target).value",
        "(click)=\"count = count + 1\"",
        "count",
        "[value]=\"text\""
      ]
    },
    {
      "title": "Angular Templates: Alias with as in *ngIf",
      "summary": "Create a local alias from a truthy value using as to avoid repeating expressions.\nWhat is alias with as in *ngIf?\nCreate a local alias for the truthy value of the condition.\nExample: *ngIf=\"user as u\" then use u inside.\nMakes templates cleaner by not repeating expressions.\nWhen to use alias with as\nWhen the same expression is referenced several times.\nWhen using an else template that also needs the value.\nTo improve readability and reduce duplication.\nExamples live under Conditional Rendering (*ngIf with as and else).\nExampleGet your own Angular Server\nRun Example »\nExample explained\n*ngIf=\"user as u\": When user is truthy, create a local alias u that holds the value of user.\nAlias use: Inside the block, use u.name instead of repeating user.name.\nelse empty: When user is falsy, render the template referenced by #empty.\ntoggle(): The button switches user between null and an object to demonstrate both paths.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <button (click)=\"toggle()\">Toggle user</button> <p *ngIf=\"user as u; else empty\">Hello {{ u.name }}!</p> <ng-template #empty>No user</ng-template> ` }) export class App { user: { name: string } | null = { name: 'Ada' }; toggle() { this.user = this.user ? null : { name: 'Ada' }; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "as",
        "*ngIf",
        "*ngIf=\"user as u\"",
        "u",
        "else",
        "user",
        "u.name",
        "user.name",
        "else empty",
        "#empty",
        "toggle()",
        "null"
      ]
    },
    {
      "title": "Angular Templates: Pipes in Templates (|)",
      "summary": "Format and transform values inline using the | operator.\nWhat are Pipes in Templates (|)?\nTransform values for display using the | operator.\nAccept optional arguments (e.g., formats, locales).\nMultiple pipes can be chained.\nWhen to use Pipes\nFormat dates, numbers, and text directly in the template.\nUse pure pipes for performance.\nMove complex or side-effectful logic to the component.\n{{ amount | currency:'USD' }}: Formats amount as US dollars using the built-in CurrencyPipe.\nExample\nTransform values using pipes:\nExampleGet your own Angular Server\nRun Example »\nExample explained\ndate:'yyyy-MM-dd': Formats the today Date using the provided format string (year-month-day). Locale defaults apply unless specified.\nuppercase: Transforms the string value of name to upper case.\npercent:'1.0-2': Formats ratio as a percentage with digitsInfo (minInteger.minFraction-maxFraction): 1 integer digit, 0–2 fraction digits.\nChaining: Pipes run left to right. ratio | percent:'1.0-2' | uppercase first formats a percent string, then uppercases it.\nSee Pipes for a full tour and custom pipes.",
      "examples": [
        "{{ amount | currency:'USD' }}",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>Built-in pipes</h3> <p>Today: {{ today | date:'yyyy-MM-dd' }}</p> <p>Name: {{ name | uppercase }}</p> <p>Chained: {{ ratio | percent:'1.0-2' | uppercase }}</p> ` }) export class App { today = new Date(); name = 'Ada Lovelace'; ratio = 0.756; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "|",
        "amount",
        "date:'yyyy-MM-dd'",
        "today",
        "Date",
        "uppercase",
        "name",
        "percent:'1.0-2'",
        "ratio",
        "digitsInfo",
        "minInteger.minFraction-maxFraction",
        "ratio | percent:'1.0-2' | uppercase"
      ]
    },
    {
      "title": "Angular Templates: Attribute Binding with attr.",
      "summary": "Bind to HTML attributes with [attr.name] when no DOM property exists.\nWhat is Attribute Binding with attr.?\nUse [attr.name] to set HTML attributes.\nFor attributes that do not map to DOM properties (e.g., ARIA, colspan).\nDistinct from property binding.\nWhen to use Attribute Binding\nWhen no corresponding DOM property exists.\nUse property binding for normal element properties.\nCommon with ARIA attributes and table attr like colspan.\nCode explained\n[attr.aria-label]: Sets the HTML aria-label attribute using the component value.\nattr.: Prefer attr. when there is no matching DOM property (e.g., ARIA, colspan).\nProperty vs attribute: For normal element properties, use property binding (e.g., [disabled]), not attr..\nREMOVE ADS\nExample\nBind to attributes using attr.:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n[attr.aria-label]=\"label\": Binds the aria-label HTML attribute to the string returned by the component's label getter.\n[attr.colspan]=\"wide ? 2 : 1\": Sets the table cell's colspan attribute based on state. Use attr. because colspan is an attribute, not a plain DOM property.\nget label(): Computes a descriptive string from the current wide value.\ntoggle(): Flips wide to update both the label and the cell span.\nDetails: Data Binding (property vs attribute binding).",
      "examples": [
        "<button [attr.aria-label]=\"label\">Click</button>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Attribute binding (attr.)</h3> <button [attr.aria-label]=\"label\" (click)=\"toggle()\">Toggle label</button> <table border=\"1\" style=\"margin-top:8px\"> <tr><th>A</th><th>B</th><th>C</th></tr> <tr><td [attr.colspan]=\"wide ? 2 : 1\">Row 1</td><td>Cell</td><td>Cell</td></tr> </table> ` }) export class App { wide = true; get label() { return this.wide ? 'Table is wide' : 'Table is narrow'; } toggle() { this.wide = !this.wide; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "[attr.name]",
        "colspan",
        "[attr.aria-label]",
        "aria-label",
        "attr.",
        "[disabled]",
        "[attr.aria-label]=\"label\"",
        "label",
        "[attr.colspan]=\"wide ? 2 : 1\"",
        "get label()",
        "wide",
        "toggle()"
      ]
    },
    {
      "title": "Angular Templates: TrackBy with *ngFor",
      "summary": "Keep lists fast and stable by identifying items with a unique key via trackBy.\nWhat is TrackBy with *ngFor?\nDefines how Angular identifies list items.\nEnables DOM node reuse when items move, insert, or remove.\nTypically returns a unique ID for each item.\nWhen to use TrackBy\nLists that are frequently reordered, inserted, or removed.\nTo avoid unnecessary re-rendering and improve performance.\nWhen items have stable, unique identifiers.\nDetails and examples: Lists (*ngFor, trackBy).\nExampleGet your own Angular Server\nRun Example »\nExample explained\n*ngFor ... trackBy: trackById: Uses trackById to give each item a stable identity so Angular can reuse DOM nodes when the list order changes.\ntrackById(index, item): Returns the unique key for an item. Here, it returns item.id regardless of index.\nshuffle(): Reverses the array to demonstrate that with trackBy, Angular moves existing DOM nodes instead of destroying and recreating them.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; type Item = { id: number; name: string }; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <button (click)=\"shuffle()\">Shuffle</button> <ul> <li *ngFor=\"let it of items; trackBy: trackById\">{{ it.id }} - {{ it.name }}</li> </ul> ` }) export class App { items: Item[] = [ { id: 1, name: 'Alpha' }, { id: 2, name: 'Beta' }, { id: 3, name: 'Gamma' } ]; shuffle() { this.items = [...this.items].reverse(); } trackById(_i: number, it: Item) { return it.id; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "trackBy",
        "*ngFor",
        "trackById",
        "item.id",
        "index"
      ]
    },
    {
      "title": "Angular Components",
      "summary": "Components are the building blocks of Angular apps. Each component controls a view (its template).\nComponent Essentials\nBuild reusable UI blocks with components.\n@Component ties together selector, template, styles, and logic; use the selector (e.g., <hello-comp>) in templates.\nCommunicate with parents via @Input() and @Output().\nProject parent content with <ng-content>.\nNote: Related: Data Binding, Events, Templates. For on‑demand UIs, see Dynamic Components (createComponent(), *ngComponentOutlet).\nAnatomy of a Component\nSelector: the tag you place in templates (e.g., <app-root>).\nTemplate and styles: inline or external files.\nStandalone: set standalone: true and import dependencies in imports.\nREMOVE ADS\nComponent Input\nPass data from parent to child with @Input().\nBind from the parent template with [prop] (e.g., [name]=\"parentValue\").\nOne-way flow: parent → child.\nProvide defaults and clear types for predictable templates.\nExample\nPass data from a parent to a child with @Input() and bind with [prop]:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n@Input() name: Declares an input property on the child component.\n[name]=\"user\": Binds the parent's user value to the child's name input.\nOne-way flow: Data flows parent → child. To update parent state, emit an output from the child.\nNotes:\nInput names matter: The template binds to the property name (or an alias if you provide one).\nDon't mutate inputs: Avoid mutating input objects in children; emit an event and let the parent update.\nComponent Output\nNotify the parent of events with @Output().\nEmit via EventEmitter<T>; the parent listens with (event)=\"handler($event)\".\nSend simple, well-typed payloads.\nExample\nEmit events from a child with @Output() and listen in the parent:\nExample\nRun Example »\nExample explained\n@Output() clicked = new EventEmitter<number>(): Declares an output that emits a number to the parent.\n(clicked)=\"onChildClicked($event)\": The parent listens for the clicked event; $event carries the emitted number.\ncount/step: The child increments count by step and emits the updated total.\nNote: Use outputs to notify actions; keep data fetching and other side effects in services.\nContent Projection\nRender parent-provided content inside a child component.\nMark insertion points with <ng-content>.\nUse select to target specific slots (e.g., title vs body).\nExample\nProject parent content into a child component with <ng-content> slots:\nExample\nRun Example »\nExample explained\n<ng-content>: Projects parent content into the child component's template.\nselect=\"[card-title]\": Defines a named slot; only elements with the card-title attribute are projected there.\nDefault slot: Unqualified <ng-content> renders all remaining projected content.\nNote: Define and document projection slots with <ng-content select> so consumers know what to pass.\nLifecycle Hooks\nInitialization: Use ngOnInit for setup that needs bindings to be resolved.\nTeardown: Use ngOnDestroy to clean up timers/subscriptions.\nOther hooks include ngOnChanges, ngAfterViewInit, etc.",
      "examples": [
        "@Component({ selector: 'hello-comp' }) <hello-comp></hello-comp>",
        "import { Component } from '@angular/core'; @Component({ selector: 'hello-comp', standalone: true, imports: [], styles: [`:host { display: block; }`], template: `<p>Hello!</p>` }) export class HelloComponent {}",
        "@Input() name: string; <hello-comp [name]=\"parentValue\"></hello-comp>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Input } from '@angular/core'; @Component({ selector: 'hello-comp', standalone: true, template: `<p>Hello {{ name }} from child!</p>` }) export class HelloComponent { @Input() name = ''; } @Component({ selector: 'app-root', standalone: true, imports: [HelloComponent], template: ` <h3>Parent Component</h3> <hello-comp [name]=\"user\"></hello-comp> ` }) export class App { user = 'Angular'; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "@Output() saved = new EventEmitter<number>(); <child-comp (saved)=\"onSaved($event)\"></child-comp>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Input, Output, EventEmitter } from '@angular/core'; @Component({ selector: 'counter-button', standalone: true, template: ` <button (click)=\"inc()\">Clicked {{ count }} times</button> ` }) export class CounterButton { @Input() step = 1; @Output() /** @type {import('@angular/core').EventEmitter<number>} */ clicked = new EventEmitter(); count = 0; inc() { this.count += this.step; this.clicked.emit(this.count); } } @Component({ selector: 'app-root', standalone: true, imports: [CounterButton], template: ` <h3>Component Output</h3> <counter-button [step]=\"2\" (clicked)=\"onChildClicked($event)\"></counter-button> <p>Parent received: {{ lastCount }}</p> ` }) export class App { lastCount = 0; /** @param {number} n */ onChildClicked(n) { this.lastCount = n; } } bootstrapApplication(App);",
        "<ng-content></ng-content> <ng-content select=\"[card-title]\"></ng-content>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'w3-card', standalone: true, styles: [` .card { border: 1px solid #ccc; border-radius: 8px; padding: 12px; max-width: 360px; } .card-header { font-weight: 600; margin-bottom: 6px; } .card-body { color: #333; } `], template: ` <div class=\"card\"> <div class=\"card-header\"><ng-content select=\"[card-title]\"></ng-content></div> <div class=\"card-body\"><ng-content></ng-content></div> </div> ` }) export class CardComponent {} @Component({ selector: 'app-root', standalone: true, imports: [CardComponent], template: ` <h3>Content Projection (ng-content)</h3> <w3-card> <span card-title>Welcome</span> <p>Project any markup into a reusable shell component.</p> </w3-card> <br> <w3-card> <span card-title>Another Card</span> <ul> <li>Works with lists</li> <li>Images, buttons, etc.</li> </ul> </w3-card> ` }) export class App {} bootstrapApplication(App);",
        "import { Component, OnInit, OnDestroy } from '@angular/core'; @Component({ selector: 'demo', standalone: true, template: `<p>Lifecycle</p>` }) export class Demo implements OnInit, OnDestroy { intervalId: any; ngOnInit() { this.intervalId = setInterval(() => {/* ... */}, 1000); } ngOnDestroy() { clearInterval(this.intervalId); } }",
        "@Component",
        "<hello-comp>",
        "@Input()",
        "@Output()",
        "<ng-content>",
        "createComponent()",
        "*ngComponentOutlet",
        "<app-root>",
        "standalone: true",
        "imports",
        "[prop]",
        "[name]=\"parentValue\"",
        "parent → child",
        "@Input() name",
        "[name]=\"user\"",
        "user",
        "name",
        "Input names matter:",
        "Don't mutate inputs:",
        "EventEmitter<T>",
        "(event)=\"handler($event)\"",
        "@Output() clicked = new EventEmitter<number>()",
        "(clicked)=\"onChildClicked($event)\"",
        "clicked",
        "$event",
        "count/step",
        "count",
        "step",
        "select",
        "select=\"[card-title]\"",
        "card-title",
        "<ng-content select>",
        "ngOnInit",
        "ngOnDestroy",
        "ngOnChanges",
        "ngAfterViewInit"
      ]
    },
    {
      "title": "Angular Data Binding",
      "summary": "Data binding connects your component's state to the template.\nData Binding Essentials\nConnect component state and template markup.\nUse interpolation for text, property binding for DOM properties, and event binding for user actions.\nUse two-way binding for form inputs that both display and update state.\nBind attributes with [attr.*], and classes/styles with [class.*]/[style.*].\nNotes:\nRelated: See Templates for interpolation basics, Events for handling user input, and Conditional Rendering to show/hide content based on state.\nFor two-way binding with ngModel, import FormsModule.\nBasic Data Binding\nInterpolation: {{ value }} prints text.\nProperty binding: [prop]=\"value\" sets element/DOM properties.\nEvent binding: (event)=\"handler($event)\" listens to user actions.\nREMOVE ADS\nExample\nBind values and handle events to keep the view in sync with component state:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n{{ name }}: Interpolation prints the current name value as text.\n[value]=\"name\": Property binding sets the input's value from the component state.\n(input)=\"name = $any($event.target).value\": Event binding updates name from the input's current text.\n(click)=\"count = count + 1\": Increments the count field when the button is clicked.\n[disabled]=\"isDisabled\": Disables the button when isDisabled is true.\nNotes:\nKeep expressions light: Avoid heavy work in {{ ... }}; compute in the component.\nNo side effects: Don't mutate state or call state-changing functions inside bindings.\nAccessibility: If you disable elements, communicate why (e.g., helper text or ARIA) so users aren't confused.\nTwo-way Binding\nSync template and component: page ↔ component.\nUse [(ngModel)] for form controls.\nConceptually equals [value] + (input).\nRequires FormsModule.\nExample\nUse [(ngModel)] to read and update form values:\nExample\nRun Example »\nExample explained\n[(ngModel)]=\"name\": Two-way binds the input to the name field (requires FormsModule).\n[(ngModel)]=\"favorite\": Keeps the select and the favorite field in sync.\nConcept: Equivalent to [value] plus (input) wiring under the hood.\nNote: [(ngModel)] won't work unless FormsModule is imported.\nAttribute Binding\nSome values are attributes, not DOM properties (e.g., colspan).\nUse [attr.*] when no property exists.\nUse [class.*] and [style.*] for classes and styles.\nExample\nBind attributes, classes, and styles from component state:\nExample\nRun Example »\nExample explained\n[attr.title]=\"title\": Sets the table's title attribute from the title field.\n[attr.colspan]=\"span\": Binds the cell's colspan attribute to the number in span.\nRange input: Adjusts span by reading $event.target.value; the template reflects the change.\nConditional cells: *ngIf shows/hides extra columns based on the current span.\nNote: Use property binding when available; use [attr.*] only when no property exists (e.g., colspan).",
      "examples": [
        "{{ value }} [prop]=\"value\" (event)=\"handler($event)\" [(ngModel)]=\"value\"",
        "{{ name }} [value]=\"name\" (input)=\"name = $any($event.target).value\"",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Data Binding</h3> <input [value]=\"name\" (input)=\"name = $any($event.target).value\" placeholder=\"Type your name\"> <p>Hello {{ name }}!</p> <button (click)=\"count = count + 1\">Clicked {{ count }} times</button> <button [disabled]=\"isDisabled\">Can't click me</button> ` }) export class App { name = 'Angular'; count = 0; isDisabled = true; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<input [(ngModel)]=\"name\">",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, FormsModule], template: ` <h3>Two-way Binding (ngModel)</h3> <label> Name: <input [(ngModel)]=\"name\" placeholder=\"Type your name\" /> </label> <label style=\"margin-left:12px\"> Favorite: <select [(ngModel)]=\"favorite\"> <option value=\"Angular\">Angular</option> <option value=\"TypeScript\">TypeScript</option> <option value=\"JavaScript\">JavaScript</option> </select> </label> <p>Hello {{ name || 'friend' }}!</p> <p>Favorite: {{ favorite }}</p> ` }) export class App { name = 'Angular'; favorite = 'Angular'; } bootstrapApplication(App);",
        "[attr.colspan]=\"span\" [class.active]=\"isActive\" [style.color]=\"color\"",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], styles: [` table { border-collapse: collapse; margin-top: 10px; } th, td { border:1px solid #ccc; padding:8px 10px; } .toolbar { display:flex; gap:10px; align-items:center; } `], template: ` <h3>Attribute Binding (attr.*)</h3> <div class=\"toolbar\"> <label>Colspan: <input type=\"range\" min=\"1\" max=\"3\" [value]=\"span\" (input)=\"span = +$any($event.target).value\"> {{ span }}</label> <label>Title: <input [value]=\"title\" (input)=\"title = $any($event.target).value\"></label> </div> <table [attr.title]=\"title\"> <thead> <tr><th>A</th><th>B</th><th>C</th></tr> </thead> <tbody> <tr> <td [attr.colspan]=\"span\" style=\"background:#f9fbff\">colspan={{ span }}</td> <td *ngIf=\"span < 2\">B</td> <td *ngIf=\"span < 3\">C</td> </tr> </tbody> </table> ` }) export class App { span = 1; title = 'Data table'; } bootstrapApplication(App);",
        "[attr.*]",
        "[class.*]",
        "[style.*]",
        "ngModel",
        "FormsModule",
        "Interpolation:",
        "{{ value }}",
        "Property binding:",
        "[prop]=\"value\"",
        "Event binding:",
        "(event)=\"handler($event)\"",
        "{{ name }}",
        "name",
        "[value]=\"name\"",
        "(input)=\"name = $any($event.target).value\"",
        "(click)=\"count = count + 1\"",
        "count",
        "[disabled]=\"isDisabled\"",
        "isDisabled",
        "Keep expressions light:",
        "{{ ... }}",
        "No side effects:",
        "Accessibility:",
        "[(ngModel)]",
        "[value]",
        "(input)",
        "[(ngModel)]=\"name\"",
        "[(ngModel)]=\"favorite\"",
        "select",
        "favorite",
        "colspan",
        "[attr.title]=\"title\"",
        "title",
        "[attr.colspan]=\"span\"",
        "span",
        "$event.target.value",
        "*ngIf"
      ]
    },
    {
      "title": "Angular Directives",
      "summary": "Directives add behavior to existing elements and components.\nDirective Essentials\nAdd behavior to elements with @Directive and a selector.\nStructural directives (*ngIf, *ngFor) add/remove DOM.\nAttribute directives ([ngClass], custom [w3X]) change look/behavior without creating/removing nodes.\nStar syntax (*) is sugar that expands to <ng-template>.\nExpose directive inputs with @Input(); alias with @Input('alias') to bind via [alias].\nNotes:\nRelated: See Templates, Data Binding, Conditional Rendering, and Lists.\nBasic Directives\n*ngIf shows/hides content based on a condition.\n*ngFor repeats a block for each list item.\nToggle a flag to add/remove the list; render items with *ngFor.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n*ngIf: Adds/removes the paragraph from the DOM when the condition is truthy/falsy.\n*ngFor: Repeats the <li> block for each item in items.\nToggle: The button flips show, which changes the computed items getter.\nNotes:\nCommonModule required: Import CommonModule when using built-in directives in standalone components.\nStar syntax is sugar: *ngIf/*ngFor expand to <ng-template>; the DOM nodes truly appear/disappear.\nAvoid heavy work in templates: Don't call expensive functions in *ngFor. Compute in the component instead. For long lists, see Lists and use trackBy.\nOne structural per host: Don't put two * directives on the same element. Wrap one in <ng-container> if needed.\nREMOVE ADS\nngIf with else\nPoint *ngIf to a fallback template with else.\nUse then/else syntax to make both branches explicit.\nAngular adds/removes DOM blocks entirely.\nExample\nRun Example »\nExample explained\n*ngIf ... else: Renders the main block when the condition is true; otherwise renders the template referenced by #loggedOut.\nthen/else: The then/else form makes both branches explicit via named templates.\nState: Buttons toggle loggedIn and hasAccess to demonstrate both branches.\nNotes:\nTemplate refs: The #ref you pass to else/then references an <ng-template>. Remember this code won't exist in the DOM until rendered.\nAvoid extra DOM: Use <ng-container> to group structure without adding extra elements.\nAttribute Directive (hover highlight)\nRuns on an existing element (no DOM created/destroyed).\nChanges appearance or behavior (e.g., add styles, classes, attributes).\nExample uses @HostBinding and @HostListener to set background on hover.\nExample\nRun Example »\nExample explained\n[w3Highlight]=\"'lightyellow'\": Passes a color into the directive via its input alias.\n@HostBinding: Binds the element's style.backgroundColor and transition properties from directive fields.\n@HostListener: Reacts to mouseenter/mouseleave to set/clear the background color.\nNotes:\nSelector collisions: Use specific selectors for custom directives (e.g., [w3Highlight]) to avoid clashing with other libraries.\nPerformance: Keep host listeners light; avoid heavy synchronous work in @HostListener handlers.",
      "examples": [
        "*ngIf=\"condition\" *ngFor=\"let item of items\" @Directive({ selector: '[w3Highlight]' }) <div w3Highlight></div>",
        "<p *ngIf=\"items.length > 0\">We have {{ items.length }} items</p> <li *ngFor=\"let item of items\">{{ item }}</li>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>Directives</h3> <p *ngIf=\"items.length > 0\">We have {{ items.length }} items</p> <ul> <li *ngFor=\"let item of items\">{{ item }}</li> </ul> <button (click)=\"toggle()\">Toggle Items</button> ` }) export class App { show = true; get items() { return this.show ? ['Angular', 'Components', 'Directives'] : []; } toggle() { this.show = !this.show; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<ng-container *ngIf=\"loggedIn; else loggedOut\"></ng-container> <ng-template #loggedOut>...</ng-template> <ng-container *ngIf=\"hasAccess; then accessTpl; else noAccessTpl\"></ng-container>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>ngIf with else</h3> <button (click)=\"loggedIn = !loggedIn\"> {{ loggedIn ? 'Log out' : 'Log in' }} </button> <ng-container *ngIf=\"loggedIn; else loggedOut\"> <p>Welcome back, {{ user }}!</p> </ng-container> <ng-template #loggedOut> <p>Please log in to continue.</p> </ng-template> <hr> <h4>ngIf then/else syntax</h4> <button (click)=\"hasAccess = !hasAccess\"> Toggle Access ({{ hasAccess ? 'granted' : 'denied' }}) </button> <ng-container *ngIf=\"hasAccess; then accessTpl; else noAccessTpl\"></ng-container> <ng-template #accessTpl> <p style=\"color: seagreen\">Access granted.</p> </ng-template> <ng-template #noAccessTpl> <p style=\"color: crimson\">Access denied.</p> </ng-template> ` }) export class App { loggedIn = false; user = 'Angular User'; hasAccess = true; } bootstrapApplication(App);",
        "@Directive({ selector: '[w3Highlight]' }) <div [w3Highlight]=\"'lightyellow'\">Hover me</div>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Directive, Input, HostBinding, HostListener } from '@angular/core'; import { CommonModule } from '@angular/common'; @Directive({ selector: '[w3Highlight]', standalone: true }) export class HighlightDirective { @Input('w3Highlight') highlightColor = 'lightyellow'; @HostBinding('style.transition') transition = 'background-color 150ms ease-in-out'; @HostBinding('style.backgroundColor') bg = ''; @HostListener('mouseenter') onEnter() { this.bg = this.highlightColor; } @HostListener('mouseleave') onLeave() { this.bg = ''; } } @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, HighlightDirective], styles: [` .box { padding: 10px; border: 1px dashed #bbb; border-radius: 6px; } `], template: ` <h3>Attribute Directive (highlight)</h3> <p>Hover the first box to see the effect:</p> <div class=\"box\" [w3Highlight]=\"'lightyellow'\">I get highlighted on hover</div> <div class=\"box\" style=\"margin-top:8px\">I do not</div> ` }) export class App {} bootstrapApplication(App);",
        "@Directive",
        "*ngIf",
        "*ngFor",
        "[ngClass]",
        "[w3X]",
        "*",
        "<ng-template>",
        "@Input()",
        "@Input('alias')",
        "[alias]",
        "<li>",
        "items",
        "show",
        "CommonModule",
        "trackBy",
        "<ng-container>",
        "else",
        "then/else",
        "#loggedOut",
        "loggedIn",
        "hasAccess",
        "#ref",
        "then",
        "@HostBinding",
        "@HostListener",
        "style.backgroundColor",
        "mouseenter",
        "mouseleave",
        "[w3Highlight]"
      ]
    },
    {
      "title": "Angular Events",
      "summary": "Events let your template react to user actions.\nEvent Binding Essentials\nBind with (event) to run a component method; $event is the native Event.\nUse common DOM events like (click), (input), and key filters like (keyup.enter).\nDebounce handlers to limit work during fast input.\nBubbling: Child events bubble up; call $event.stopPropagation() when needed.\nNote: See Templates for markup and interpolation, Data Binding for property/two-way binding, and Conditional Rendering for showing/hiding content.\nBasic Events\nHandle (click) to update component state.\nRead input values from $event.target (cast or use $any when needed).\nTrack the last key pressed via (keyup).\nExample\nHandle common events and keep component state in sync with user input:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n(click)=\"increment()\": Calls the component method to increase the count.\n(input)=\"onInput($event)\": Reads the input's current text from $event.target.value and stores it in value.\n(keyup)=\"lastKey = $any($event).key\": Stores the last pressed key in lastKey.\nDisplay: {{ count }}, {{ value }}, and {{ lastKey }} show the component fields.\nNotes:\nKeep handlers small: Do minimal work in event handlers; delegate heavy work to services.\nType the event: Narrow $event or use $any($event.target) when reading inputs.\nPropagation/default: Use $event.stopPropagation() / $event.preventDefault() when needed.\nREMOVE ADS\nEvent Filtering (keyup.enter)\nUse key aliases to run handlers only on specific keys (e.g., Enter).\nKeep UI reactive by updating state on filtered events.\nExample\nFilter keyboard events with key aliases like keyup.enter:\nExample\nRun Example »\nExample explained\n(keyup.enter)=\"add()\": Runs only when the Enter key is pressed, adding the current draft.\n[value]=\"draft\"/(input): Keeps the input element and the draft field in sync.\nList: New items are appended immutably and rendered with *ngFor; lastKey shows the last pressed key.\nButtons: \"Add\" and \"Clear\" call component methods to update the list state.\nNotes:\nUse key aliases: Use (keyup.enter) instead of checking key codes manually.\nImmutable updates: Add/remove items with new array references (e.g., spread) to keep change detection predictable.\nDebounced Input\nDelay updates until typing pauses to avoid excessive work.\nUse setTimeout or RxJS to debounce input changes.\nExample\nDebounce user input to reduce work during fast typing:\nExample\nRun Example »\nExample explained\nImmediate vs debounced: immediate updates on every input; debounced updates after 400ms of no typing.\nonInput(e): Reads e.target.value, sets immediate, clears any pending timer, and schedules a new timeout to set debounced.\nTimer handle: handle stores the timeout ID so it can be cleared on the next keystroke.\nNotes:\nCleanup timers: Clear pending timers on each input to avoid stale updates.\nRight delay: Choose a debounce that fits UX (e.g., 300-500ms).\nFor streams, consider RxJS in advanced cases.",
      "examples": [
        "<button (click)=\"onClick()\">Click</button> <input (input)=\"onInput($event)\" (keyup.enter)=\"submit()\"> <div (click)=\"onParentClick()\"> <button (click)=\"onChildClick($event)\">Child</button> </div>",
        "<button (click)=\"increment()\">Click me</button> <input (input)=\"onInput($event)\" (keyup)=\"lastKey = $any($event).key\">",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Events</h3> <p>Count: {{ count }}</p> <button (click)=\"increment()\">Click me</button> <div style=\"margin-top:12px\"> <input placeholder=\"Type...\" (input)=\"onInput($event)\" (keyup)=\"lastKey = $any($event).key\"> <p>Value: {{ value }}</p> <p>Last key: {{ lastKey }}</p> </div> ` }) export class App { count = 0; value = ''; lastKey = ''; increment() { this.count++; } onInput(e: Event) { this.value = (e.target as HTMLInputElement).value; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<input (keyup.enter)=\"add()\" (keyup)=\"lastKey = $any($event).key\">",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], styles: [` .toolbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; } ul { margin-top: 10px; } li { line-height: 1.8; } input[type=\"text\"] { padding: 6px 8px; } `], template: ` <h3>Event Filtering (keyup.enter)</h3> <div class=\"toolbar\"> <input type=\"text\" placeholder=\"Add item and press Enter\" [value]=\"draft\" (input)=\"draft = $any($event.target).value\" (keyup)=\"lastKey = $any($event).key\" (keyup.enter)=\"add()\"> <button (click)=\"add()\">Add</button> <button (click)=\"clear()\" [disabled]=\"items.length === 0\">Clear</button> <span style=\"margin-left:8px;color:#666\">Last key: {{ lastKey }}</span> </div> <ul> <li *ngFor=\"let it of items; let i = index\">{{ i + 1 }}. {{ it }}</li> </ul> ` }) export class App { draft = ''; lastKey = ''; items = ['Buy milk', 'Learn Angular']; add() { const v = (this.draft || '').trim(); if (!v) return; this.items = [...this.items, v]; this.draft = ''; } clear() { this.items = []; } } bootstrapApplication(App);",
        "// Pseudo handle: any; onInput(e) { clearTimeout(handle); handle = setTimeout(() => doWork(e), 400); }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Debounced Input</h3> <input type=\"text\" placeholder=\"Type here\" (input)=\"onInput($event)\"> <p>Immediate: {{ immediate }}</p> <p>Debounced (400ms): {{ debounced }}</p> ` }) export class App { immediate = ''; debounced = ''; private handle: any; onInput(e: Event) { const v = (e.target as HTMLInputElement)?.value ?? ''; this.immediate = v; clearTimeout(this.handle); this.handle = setTimeout(() => this.debounced = v, 400); } } bootstrapApplication(App);",
        "(event)",
        "$event",
        "(click)",
        "(input)",
        "(keyup.enter)",
        "$event.stopPropagation()",
        "$event.target",
        "$any",
        "(keyup)",
        "(click)=\"increment()\"",
        "count",
        "(input)=\"onInput($event)\"",
        "$event.target.value",
        "value",
        "(keyup)=\"lastKey = $any($event).key\"",
        "lastKey",
        "{{ count }}",
        "{{ value }}",
        "{{ lastKey }}",
        "$any($event.target)",
        "$event.preventDefault()",
        "keyup.enter",
        "(keyup.enter)=\"add()\"",
        "[value]=\"draft\"",
        "draft",
        "*ngFor",
        "setTimeout",
        "immediate",
        "debounced",
        "onInput(e)",
        "e.target.value",
        "handle"
      ]
    },
    {
      "title": "Angular Conditional Rendering",
      "summary": "Conditional rendering shows or hides parts of the template based on state.\nConditional Rendering Essentials\nUse @if / @else if / @else for conditional logic.\nUse @switch to select one view among many.\nSignals: Drive conditions from signals and read them with sig() in templates.\nHide vs remove: @if removes from the DOM; use [hidden] or CSS to hide without destroying.\nLegacy: *ngIf and [ngSwitch] remain supported but are not shown here.\nNote: See Control Flow for @if/@switch/@for, Templates for markup/interpolation, Events for handling input, and Lists for rendering collections.\nBasic Conditional Rendering\nRender content with @if / @else.\nDrive booleans from signals; keep template expressions simple.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n@if (show()): Reads the show signal; renders the first block when true, otherwise the @else block.\nToggle: The button calls show.set(!show()) to flip the signal value.\nSignals in templates: Read signals by calling them (e.g., show()).\nNotes:\nKeep expressions light: Avoid calling methods in templates; update signals in handlers/services.\nLegacy: *ngIf with then/else remains supported.\nBe explicit: Use clear conditions (e.g., isVisible) over complex truthy/falsy checks.\nREMOVE ADS\n@switch\nSwitch on a single value with @switch and render the matching case.\nAlways provide an explicit default for unexpected values with @default.\nExample\nRun Example »\nExample explained\n@switch (status()): Chooses one case to render based on the current status signal value.\n@case / @default: Renders the matching @case; falls back to @default when no case matches.\nChange handler: The select sets status via status.set($any($event.target).value).\nNotes:\nDefault matters: Always provide an @default case for unexpected values.\nStable values: Switch on simple primitives (e.g., strings) rather than objects for predictable matching.\nMulti-state with @if\nUse @if / @else if / @else for readable multi-state flows.\nDrive state transitions from the component (e.g., timers, flags) via signals.\nExample\nRun Example »\nExample explained\nMulti-branch @if: Renders success, loading, or error sections based on the loading() and error() signals.\nstartLoading(): Sets loading to true, clears error, then turns loading off after 800ms (simulating async work).\nshowError() / reset(): showError() sets error and clears loading; reset() clears both.\nNotes:\nReadable flows: Prefer @else if chains for multi-state UIs; use named templates only when you need to reference blocks dynamically.\nAvoid flicker: Drive state from the component; clear timers and async work to prevent UI flicker during transitions.",
      "examples": [
        "@if (condition) { <p>Shown</p> } @else { <p>Hidden</p> } @switch (value) { @case ('x') { <p>X</p> } @default { <p>Other</p> } } <div [hidden]=\"!isVisible\">Hidden but in DOM</div>",
        "@if (show()) { <p>Now you see me!</p> } @else { <p>Now I'm hidden.</p> }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Conditional Rendering</h3> <button (click)=\"show.set(!show())\">Toggle</button> @if (show()) { <p>Now you see me!</p> } @else { <p>Now I'm hidden.</p> } ` }) export class App { show = signal(true); } bootstrapApplication(App);",
        "<app-root></app-root>",
        "@switch (status) { @case ('loading') { <p>Loading...</p> } @case ('success') { <p>Success!</p> } @case ('error') { <p style=\"color:crimson\">Error!</p> } @default { <p>Unknown status</p> } }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Conditional Rendering with @switch</h3> <label> Status: <select (change)=\"status.set($any($event.target).value)\"> <option value=\"loading\">loading</option> <option value=\"success\">success</option> <option value=\"error\">error</option> </select> </label> @switch (status()) { @case ('loading') { <p>Loading...</p> } @case ('success') { <p>Success!</p> } @case ('error') { <p style=\"color:crimson\">Error!</p> } @default { <p>Unknown status</p> } } ` }) export class App { status = signal<'loading' | 'success' | 'error' | string>('loading'); } bootstrapApplication(App);",
        "@if (!loading() && !error()) { <p>Content loaded successfully.</p> } @else if (loading()) { <p>Loading...</p> } @else { <p style=\"color:crimson\">Something went wrong.</p> }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, styles: [` .toolbar { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; } `], template: ` <h3>Multi-state with @if</h3> <div class=\"toolbar\"> <button (click)=\"startLoading()\">Start Loading</button> <button (click)=\"showError()\">Set Error</button> <button (click)=\"reset()\">Reset</button> <span style=\"margin-left:8px;color:#666\">loading={{ loading() }} error={{ error() }}</span> </div> @if (!loading() && !error()) { <p>Content loaded successfully.</p> } @else if (loading()) { <p>Loading...</p> } @else { <p style=\"color:crimson\">Something went wrong.</p> } ` }) export class App { loading = signal(false); error = signal(false); private _timer: any; startLoading() { this.loading.set(true); this.error.set(false); clearTimeout(this._timer); this._timer = setTimeout(() => { this.loading.set(false); }, 800); } showError() { this.error.set(true); this.loading.set(false); } reset() { this.loading.set(false); this.error.set(false); } } bootstrapApplication(App);",
        "@if",
        "@else if",
        "@else",
        "@switch",
        "sig()",
        "[hidden]",
        "*ngIf",
        "[ngSwitch]",
        "@for",
        "show",
        "show.set(!show())",
        "show()",
        "then/else",
        "isVisible",
        "@default",
        "status",
        "@case",
        "select",
        "status.set($any($event.target).value)",
        "loading()",
        "error()",
        "loading",
        "showError()",
        "error",
        "reset()"
      ]
    },
    {
      "title": "Angular Lists",
      "summary": "Lists display collections of items in the template.\nList Rendering Essentials\nLoop: Use @for with track for stable identity and @empty for empty states.\nSignals: Store list state in a signal (e.g., items = signal([...])) and update immutably with set()/update().\nIdentity: Track by a stable key (e.g., it.id) to avoid unnecessary DOM work.\nDerived views: Filter/sort copies of your data for the UI; keep the source list intact (use computed() for derived state).\nNote: See Control Flow for @for, Conditional Rendering, and Templates for interpolation and basics.\nBasic Lists\nUse @for to loop; expose the index with let i = $index.\nUpdate immutably with signals (e.g., items.update(arr => [...arr, newItem])).\nExample\nRender a basic list with @for and expose the index:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n@for (item of items(); let i = $index; track item): Loops over the items signal; exposes the zero-based index as i; uses the primitive item itself as identity.\nButtons: add() appends immutably, clear() sets an empty list, reset() restores defaults.\n@empty: Renders the fallback list item when there are no items.\nNotes:\nNo import needed: @for is built into Angular's template syntax; no module import required.\nDon't mutate in place: With signals, prefer set()/update() to assign a new array and trigger updates.\nREMOVE ADS\nLists with track (@for)\nOn list changes, Angular reconciles DOM rows with data items.\ntrack provides a stable identity (e.g., an id) to minimize DOM churn and preserve focus/inputs.\nLegacy equivalence: With *ngFor, use trackBy to achieve the same effect.\nExample\nRender lists with a stable identity using track:\nExample\nRun Example »\nExample explained\ntrack it.id: Provides a stable identity so Angular reuses DOM rows when items shuffle or update, preserving focus and local state.\nrenameFirst(): Updates the first item's name immutably (new object reference) to trigger change detection.\nshuffle(): Randomizes order to demonstrate DOM reuse with track.\nadd(): Appends a new item with a unique id.\nNotes:\nAvoid index identity: Don't use the array index as identity if order can change; use a stable id.\nEnsure uniqueness: Duplicate id values cause DOM/UI desync. Use unique keys.\n*ngFor equivalence: With *ngFor, use trackBy to achieve the same behavior.\nFilter & Sort\nCompute a derived view with computed() based on signals.\nFilter and sort copies of your data; keep the source list intact for easy resets.\nExample\nFilter and sort lists using computed():\nExample\nRun Example »\nExample explained\ncomputed() view: Derives a filtered/sorted array from signals without mutating the source list.\nquery/sortKey/sortDir: Control the derived view by updating these signals from the UI.\n@for (p of view(); track p.name): Renders the derived rows; uses a stable key (p.name) for identity.\nNote: Avoid heavy work in templates; pre-compute with computed() and loop with @for to keep templates fast.",
      "examples": [
        "<ul> @for (item of items(); let i = $index; track item) { <li>{{ i + 1 }}. {{ item }}</li> } @empty { <li>No items</li> } </ul>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Lists</h3> <ul> @for (item of items(); let i = $index; track item) { <li>{{ i + 1 }}. {{ item }}</li> } @empty { <li>No items</li> } </ul> <button (click)=\"add()\">Add Item</button> <button (click)=\"clear()\">Clear</button> <button (click)=\"reset()\">Reset</button> ` }) export class App { items = signal(['Angular', 'React', 'Vue']); add() { this.items.update(arr => [...arr, 'Svelte']); } clear() { this.items.set([]); } reset() { this.items.set(['Angular', 'React', 'Vue']); } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "@for (it of items(); track it.id) { <li>{{ it.name }}</li> } @empty { <li>No items</li> }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal } from '@angular/core'; type Item = { id: number; name: string }; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Lists with track</h3> <ul> @for (it of items(); let i = $index; track it.id) { <li>{{ i + 1 }}. {{ it.name }} (id: {{ it.id }})</li> } </ul> <button (click)=\"renameFirst()\">Rename first</button> <button (click)=\"shuffle()\">Shuffle</button> <button (click)=\"add()\">Add item</button> ` }) export class App { items = signal\n([ { id: 1, name: 'Angular' }, { id: 2, name: 'React' }, { id: 3, name: 'Vue' } ]); nextId = 4; renameFirst() { this.items.update(arr => arr.map((it, i) => i === 0 ? { ...it, name: it.name + ' *' } : it)); } shuffle() { this.items.update(arr => { const copy = [...arr]; for (let i = copy.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [copy[i], copy[j]] = [copy[j], copy[i]]; } return copy; }); } add() { this.items.update(arr => [...arr, { id: this.nextId++, name: 'New ' + Date.now() }]); } } bootstrapApplication(App);",
        "import { signal, computed } from '@angular/core'; items = signal([{ name: 'Angular', price: 0 }, { name: 'React', price: 0 }]); query = signal(''); sortKey = signal<'name' | 'price'>('name'); sortDir = signal<1 | -1>(1); view = computed(() => { const q = query().toLowerCase(); const dir = sortDir(); const key = sortKey(); return items() .filter(it => it.name.toLowerCase().includes(q)) .sort((a, b) => { const av: any = (a as any)[key]; const bv: any = (b as any)[key]; return av < bv ? -1 * dir : av > bv ? 1 * dir : 0; }); }); @for (p of view(); track p.name) { <tr> <td>{{ p.name }}</td> <td>{{ p.price | currency:'USD' }}</td> </tr> }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal, computed } from '@angular/core'; import { CommonModule } from '@angular/common'; type Product = { name: string; price: number }; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>Filter & Sort</h3> <div style=\"display:flex;gap:8px;margin-bottom:8px;\"> <label>Search: <input #q (input)=\"query.set(q.value)\" placeholder=\"Type to filter...\" /></label> <button (click)=\"setSort('name')\">Sort by Name</button> <button (click)=\"setSort('price')\">Sort by Price</button> <button (click)=\"toggleDir()\">{{ sortDir() === 1 ? 'Asc' : 'Desc' }}</button> </div> <table style=\"width:100%;border-collapse:collapse;\"> <thead> <tr><th style=\"border:1px solid #ddd;padding:8px;background:#f7f7f7;\">Name</th><th style=\"border:1px solid #ddd;padding:8px;background:#f7f7f7;width:140px;\">Price</th></tr> </thead> <tbody> @for (p of view(); track p.name) { <tr> <td style=\"border:1px solid #ddd;padding:8px;\">{{ p.name }}</td> <td style=\"border:1px solid #ddd;padding:8px;\">{{ p.price | currency:'USD' }}</td> </tr> } </tbody> </table> ` }) export class App { items = signal<Product[]>([ { name: 'Angular', price: 0 }, { name: 'React', price: 0 }, { name: 'Vue', price: 0 }, { name: 'Svelte', price: 0 }, { name: 'Solid', price: 0 }, { name: 'Lit', price: 0 } ]); query = signal(''); sortKey = signal<'name' | 'price'>('name'); sortDir = signal<1 | -1>(1); // 1 asc, -1 desc view = computed(() => { const q = this.query().toLowerCase(); const dir = this.sortDir(); const key = this.sortKey(); return this.items() .filter(it => it.name.toLowerCase().includes(q)) .sort((a, b) => { const av: any = (a as any)[key]; const bv: any = (b as any)[key]; return av < bv ? -1 * dir : av > bv ? 1 * dir : 0; }); }); setSort(key: 'name' | 'price') { if (this.sortKey() === key) { this.toggleDir(); } else { this.sortKey.set(key); } } toggleDir() { this.sortDir.set(this.sortDir() === 1 ? -1 : 1); } } bootstrapApplication(App);",
        "@for",
        "track",
        "@empty",
        "items = signal([...])",
        "set()",
        "update()",
        "it.id",
        "computed()",
        "let i = $index",
        "items.update(arr => [...arr, newItem])",
        "@for (item of items(); let i = $index; track item)",
        "items",
        "i",
        "item",
        "add()",
        "clear()",
        "reset()",
        "id",
        "*ngFor",
        "trackBy",
        "track it.id",
        "renameFirst()",
        "shuffle()",
        "view",
        "query/sortKey/sortDir",
        "@for (p of view(); track p.name)",
        "p.name"
      ]
    },
    {
      "title": "Angular Forms",
      "summary": "Forms let users enter and edit data in your app.\nForms Essentials\nTwo approaches: Template-driven (HTML-first with [(ngModel)]) and Reactive (code-first with FormGroup/FormControl).\nWhen to use: Template-driven for simple forms; Reactive for complex validation, dynamic fields, and testability.\nKey concepts: A FormControl tracks a single input's value/state; a FormGroup groups controls by name.\nImports: FormsModule (template-driven) and ReactiveFormsModule (reactive).\nNotes:\nRelated: See Data Binding for [(ngModel)] and property binding, Events for handling input, and Templates for interpolation.\nImport FormsModule (template-driven) and ReactiveFormsModule (reactive).\nTemplate-driven Forms\nQuick to start and feels like plain HTML.\nBind with [(ngModel)] and unique name attributes.\nAccess overall state via exported ngForm (e.g., valid, touched).\nImport FormsModule in standalone components.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n[(ngModel)]=\"name\": Two-way binds the input to the name field.\n#f=\"ngForm\": Exports the form state (e.g., f.valid, f.invalid).\n(ngSubmit)=\"onSubmit()\": Handles submit using the component method.\nDisplay: {{ name }} shows the current value; a flag shows the submitted state.\nNotes:\nUnique name required: Each control needs a unique name to register with ngForm.\nModule imports: Template-driven forms require FormsModule (for standalone components, add it to imports).\nREMOVE ADS\nHTML Form Elements in Angular\nText/Email/Number: Bind with [(ngModel)] or formControlName.\nTextarea: Works like text inputs.\nCheckbox: Boolean value via [(ngModel)] or formControlName.\nRadio group: Share the same name; bind group with [(ngModel)] or formControlName. Use [value].\nSelect: Bind selected value; use [ngValue] when options are objects.\nFile input: Read files with (change) handler; do not two-way bind file objects.\nTip: For object options in <select>, use [ngValue] instead of value.\nRadio with non-string values\nUse [ngValue] to bind non-string values (numbers or objects) to radios.\nSelect multiple\nAdd multiple and bind to an array; use [ngValue] for non-strings.\nNumber inputs: coercion\nTemplate-driven binds values as strings; convert in code if you need numbers.\nFile input (multiple)\nRead files with a (change) handler; do not two-way bind files.\ncompareWith for select of objects\nUse [compareWith] when options are objects that may be re-created across renders.\nValidation\nAdd rules like required, minlength, and email.\nShow errors when invalid and the control is dirty or touched, or after submit.\nDisable submit when the form is invalid.\nExample\nRun Example »\nExample explained\n#name=\"ngModel\": Exports the control state for the name input.\nErrors: name.errors['required'] and name.errors['minlength'] drive specific messages.\nWhen to show: Messages appear when the control is invalid and dirty || touched || submitted.\nDisable submit: The button binds to f.invalid to prevent invalid submission.\nNotes:\nWhen to show errors: Gate messages behind dirty || touched || submitted so they don't flash too early.\nDisable submit correctly: Bind to f.invalid (template) or form.invalid (reactive).\nReactive Forms\nBuild a tree of FormGroup/FormControl in code.\nBind the template with [formGroup] and formControlName.\nGreat for complex validation, conditional fields, and dynamic forms.\nCreate controls with FormBuilder and Validators.\nExample\nRun Example »\nExample explained\n[formGroup]=\"form\": Binds the form element to the FormGroup instance.\nformControlName: Wires inputs to named controls (name, email, newsletter).\nValidators: Created with FormBuilder and Validators; error messages read control errors.\nSubmit: Disables the button when form.invalid; sets a submitted flag on submit.\nNotes:\nDon't mix paradigms: Avoid [(ngModel)] on controls that also use formControlName.\nUpdate via API: Use setValue/patchValue and validator methods rather than mutating control objects directly.\nModule imports: Reactive forms require ReactiveFormsModule.",
      "examples": [
        "<form #f=\"ngForm\" (ngSubmit)=\"onSubmit()\"> <input name=\"name\" [(ngModel)]=\"name\" required minlength=\"3\" #c=\"ngModel\"> <div *ngIf=\"c.invalid && (c.dirty || c.touched)\">Invalid</div> <button [disabled]=\"f.invalid\">Submit</button> </form>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, FormsModule], template: ` <h3>Forms</h3> <form #f=\"ngForm\" (ngSubmit)=\"onSubmit()\"> <label> Name: <input name=\"name\" [(ngModel)]=\"name\" placeholder=\"Enter your name\"> </label> <button type=\"submit\">Submit</button> </form> <p>Value: {{ name }}</p> <p *ngIf=\"submitted\">Submitted!</p> ` }) export class App { name = ''; submitted = false; onSubmit() { this.submitted = true; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<input name=\"email\" type=\"email\" [(ngModel)]=\"model.email\"> <textarea name=\"bio\" [(ngModel)]=\"model.bio\"></textarea> <label><input type=\"checkbox\" name=\"agree\" [(ngModel)]=\"model.agree\"> Agree</label> <label><input type=\"radio\" name=\"color\" [value]=\"'red'\" [(ngModel)]=\"model.color\"> Red</label> <label><input type=\"radio\" name=\"color\" [value]=\"'blue'\" [(ngModel)]=\"model.color\"> Blue</label> <select name=\"pet\" [(ngModel)]=\"model.pet\"> <option [ngValue]=\"{ id: 1, name: 'Cat' }\">Cat</option> <option [ngValue]=\"{ id: 2, name: 'Dog' }\">Dog</option> </select> <input type=\"file\" (change)=\"onFiles($event)\">",
        "<label><input type=\"radio\" name=\"size\" [ngValue]=\"1\" [(ngModel)]=\"model.size\"> Small</label> <label><input type=\"radio\" name=\"size\" [ngValue]=\"2\" [(ngModel)]=\"model.size\"> Medium</label>",
        "<select name=\"tags\" [(ngModel)]=\"model.tags\" multiple> <option [ngValue]=\"'news'\">News</option> <option [ngValue]=\"'tech'\">Tech</option> <option [ngValue]=\"'sports'\">Sports</option> </select>",
        "<input type=\"number\" name=\"age\" [ngModel]=\"age\" (ngModelChange)=\"age = $any($event)\">",
        "<input type=\"file\" multiple (change)=\"onFiles($event)\">",
        "<select name=\"pet\" [(ngModel)]=\"model.pet\" [compareWith]=\"byId\"> <option [ngValue]=\"{ id: 1, name: 'Cat' }\">Cat</option> <option [ngValue]=\"{ id: 2, name: 'Dog' }\">Dog</option> </select>",
        "byId = (a: any, b: any) => a?.id === b?.id;",
        "<input name=\"email\" [(ngModel)]=\"email\" email required #e=\"ngModel\"> <div *ngIf=\"e.invalid && (e.dirty || e.touched)\"> <small *ngIf=\"e.errors && e.errors['required']\">Required</small> <small *ngIf=\"e.errors && e.errors['email']\">Invalid email</small> </div>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, FormsModule], template: ` <h3>Forms Validation</h3> <form #f=\"ngForm\" (ngSubmit)=\"onSubmit()\" novalidate> <label> Name: <input name=\"name\" [(ngModel)]=\"model.name\" required minlength=\"3\" #name=\"ngModel\"> </label> <div *ngIf=\"name.invalid && (name.dirty || name.touched || submitted)\" style=\"color:crimson\"> <small *ngIf=\"name.errors && name.errors['required']\">Name is required.</small> <small *ngIf=\"name.errors && name.errors['minlength']\">Name must be at least 3 characters.</small> </div> <label> Email: <input name=\"email\" [(ngModel)]=\"model.email\" email required #email=\"ngModel\"> </label> <div *ngIf=\"email.invalid && (email.dirty || email.touched || submitted)\" style=\"color:crimson\"> <small *ngIf=\"email.errors && email.errors['required']\">Email is required.</small> <small *ngIf=\"email.errors && email.errors['email']\">Email must be valid.</small> </div> <button type=\"submit\" [disabled]=\"f.invalid\">Submit</button> </form> <p *ngIf=\"submitted\">Submitted: {{ model | json }}</p> ` }) export class App { model = { name: '', email: '' }; submitted = false; onSubmit() { this.submitted = true; } } bootstrapApplication(App);",
        "form = this.fb.group({ name: ['', [Validators.required, Validators.minLength(3)]], email: ['', [Validators.required, Validators.email]], }); <form [formGroup]=\"form\"> <input formControlName=\"name\"> <input formControlName=\"email\"> </form>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; import { ReactiveFormsModule, FormBuilder, Validators } from '@angular/forms'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, ReactiveFormsModule], template: ` <h3>Reactive Forms</h3> <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\"> <label> Name <input formControlName=\"name\" placeholder=\"Your name\"> </label> <div *ngIf=\"form.controls.name.invalid && (form.controls.name.dirty || form.controls.name.touched || submitted)\" style=\"color:crimson\"> <small *ngIf=\"form.controls.name.errors && form.controls.name.errors['required']\">Name is required.</small> <small *ngIf=\"form.controls.name.errors && form.controls.name.errors['minlength']\">Min 3 characters.</small> </div> <label> Email <input formControlName=\"email\" placeholder=\"you@example.com\"> </label> <div *ngIf=\"form.controls.email.invalid && (form.controls.email.dirty || form.controls.email.touched || submitted)\" style=\"color:crimson\"> <small *ngIf=\"form.controls.email.errors && form.controls.email.errors['required']\">Email is required.</small> <small *ngIf=\"form.controls.email.errors && form.controls.email.errors['email']\">Email must be valid.</small> </div> <label> <input type=\"checkbox\" formControlName=\"newsletter\"> Subscribe to newsletter </label> <button type=\"submit\" [disabled]=\"form.invalid\">Submit</button> </form> <p>Status: {{ form.status }}</p> <p>Value: {{ form.value | json }}</p> <p *ngIf=\"submitted\" style=\"color: seagreen;\">Submitted!</p> ` }) export class App { fb = new FormBuilder(); submitted = false; form = this.fb.group({ name: ['', [Validators.required, Validators.minLength(3)]], email: ['', [Validators.required, Validators.email]], newsletter: [false], }); onSubmit() { this.submitted = true; } } bootstrapApplication(App);",
        "<form #f=\"ngForm\"> <input name=\"name\" [(ngModel)]=\"name\"> </form>",
        "form = new FormGroup({ name: new FormControl('') }); <form [formGroup]=\"form\"> <input formControlName=\"name\"> </form>",
        "[(ngModel)]",
        "FormGroup",
        "FormControl",
        "FormsModule",
        "ReactiveFormsModule",
        "name",
        "ngForm",
        "valid",
        "touched",
        "f.valid",
        "f.invalid",
        "{{ name }}",
        "imports",
        "formControlName",
        "[value]",
        "[ngValue]",
        "(change)",
        "<select>",
        "value",
        "multiple",
        "[compareWith]",
        "required",
        "minlength",
        "email",
        "dirty",
        "name.errors['required']",
        "name.errors['minlength']",
        "dirty || touched || submitted",
        "form.invalid",
        "[formGroup]",
        "FormBuilder",
        "Validators",
        "newsletter",
        "setValue",
        "patchValue"
      ]
    },
    {
      "title": "Angular Router",
      "summary": "The Router maps URLs to views and lets users navigate your app.\nRouter Essentials\nURL-driven UI: The Router swaps views based on the URL.\nRouterOutlet: Placeholder where the active route's component renders.\nrouterLink: Navigate without full page reloads.\nRouterLinkActive: Adds classes to active links (use { exact: true } for root).\nPerformance & control: Lazy load feature areas; use guards to allow/block navigation.\nNotes:\nRelated: See Components for building views, Services for shared logic/guards, and Templates for markup and directives.\nStandalone apps: import RouterOutlet/RouterLink and provide routes with provideRouter().\nSandboxes/runners: use withHashLocation() so links work without server config (hash URLs look like /#/path).\nRouter Basics\nDefine a routes array that maps paths to components.\nProvide routes with provideRouter() (use withHashLocation() for sandboxes).\nUse routerLink for navigation and RouterOutlet to render views.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nprovideRouter(routes): Registers the routes for the app.\nRouterOutlet: Placeholder where the active route's component renders.\nrouterLink: Navigates without reloading the page.\nwithHashLocation(): Uses hash URLs so links work in sandboxes without server rewrites.\nNotes:\nUse routerLink, not href: href reloads the page.\nUse routerLink for SPA navigation.\nStandalone imports: Import RouterOutlet/RouterLink and provide routes with provideRouter().\nREMOVE ADS\nRouter Params\nCapture variables in paths with :id (e.g., /product/42).\nRead them via ActivatedRoute (snapshot or paramMap observable).\nExample\nRun Example »\nExample explained\nproduct/:id: Declares a path parameter named id.\nActivatedRoute: Reads id from snapshot.paramMap.get('id') in ngOnInit.\nLinks: routerLink=\"/product/1\" and /product/2 demonstrate parameterized navigation.\nParams update within the same component: If navigating to the same route with different params, subscribe to paramMap (or params) instead of using a one-time snapshot.\nActive Links\nUse routerLinkActive to toggle classes when a link matches.\nSet { exact: true } for root links like /.\nExample\nRun Example »\nExample explained\nrouterLinkActive=\"active\": Adds the active class when the link matches the current URL.\n[routerLinkActiveOptions]=\"{ exact: true }\": For the root (/), only mark active on exact match.\nRouterOutlet: Renders the matched component for the current route.\nNotes:\nExact for root: For / links, set { exact: true } so parent paths don't keep them active.\nApply on containers: Put routerLinkActive on a parent element to style groups of links.\nMultiple classes: You can add several classes: routerLinkActive=\"active bold\".\nLazy-loaded Component\nDefer loading code until navigation with loadComponent or loadChildren.\nImproves initial load time by splitting bundles.\nExample\nRun Example »\nExample explained\nloadComponent: Defers loading the route's component until navigation (here simulated with Promise.resolve).\nRoutes: Home is eager; About is lazy.\nNavigation: Clicking “About (lazy)” loads and renders the component on demand.\nNotes:\nRoute order and wildcards: Put catch-all routes last so they don't swallow other routes.\nDeep-link refreshes: Without server rewrites, refreshes may 404.\nIn demos/sandboxes use withHashLocation().\nRoute Guard (canActivate)\nGuards decide if navigation is allowed.\nReturn true (allow), false/UrlTree (block/redirect), or async equivalents.\nExample\nRun Example »\nExample explained\nauthGuard: Returns true when logged in; otherwise returns a UrlTree that redirects to /.\ninject(Router): Accesses the Router to create a redirect UrlTree inside the guard function.\ncanActivate: Applies the guard to the /protected route.\nToggle: The button flips the loggedIn state to test both branches.\nGuard return types: Return boolean, UrlTree, or an observable/promise of those.",
      "examples": [
        "import { provideRouter, withHashLocation, RouterOutlet, RouterLink } from '@angular/router'; const routes = [ { path: '', component: Home }, { path: 'about', component: About } ]; bootstrapApplication(App, { providers: [provideRouter(routes, withHashLocation())] }); // Template // <a routerLink=\"/about\">About</a> // <router-outlet></router-outlet>",
        "const routes = [ { path: '', component: Home }, { path: 'about', component: About } ]; // template // <a routerLink=\"/about\">About</a> // <router-outlet></router-outlet>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { provideRouter, RouterOutlet, RouterLink, withHashLocation } from '@angular/router'; @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet, RouterLink], template: ` <h3>Router</h3> <nav> <a routerLink=\"/\">Home</a> | <a routerLink=\"/about\">About</a> </nav> <router-outlet></router-outlet> ` }) export class App {} @Component({ standalone: true, template: `<p>Home works!</p>` }) export class Home {} @Component({ standalone: true, template: `<p>About works!</p>` }) export class About {} const routes = [ { path: '', component: Home }, { path: 'about', component: About } ]; bootstrapApplication(App, { providers: [provideRouter(routes, withHashLocation())] });",
        "<app-root></app-root>",
        "{ path: 'product/:id', component: Product } // class Product { // id = ''; // route = inject(ActivatedRoute); // ngOnInit() { this.id = this.route.snapshot.paramMap.get('id') ?? ''; } // }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, OnInit, inject } from '@angular/core'; import { provideRouter, RouterOutlet, RouterLink, RouterLinkActive, ActivatedRoute, withHashLocation } from '@angular/router'; @Component({ selector: 'home-cmp', standalone: true, template: `<p>Home works!</p>` }) export class Home {} @Component({ selector: 'product-cmp', standalone: true, template: `<p>Product ID: {{ id }}</p>` }) export class Product implements OnInit { id = ''; private route = inject(ActivatedRoute); ngOnInit() { this.id = this.route.snapshot.paramMap.get('id') ?? ''; } } @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet, RouterLink, RouterLinkActive], template: ` <h3>Router Params</h3> <nav> <a routerLink=\"/\">Home</a> | <a routerLink=\"/product/1\" routerLinkActive=\"active\">Product 1</a> | <a routerLink=\"/product/2\" routerLinkActive=\"active\">Product 2</a> </nav> <router-outlet></router-outlet> `, styles: [`nav a { margin-right: 6px; } .active { font-weight: bold; }`] }) export class App {} const routes = [ { path: '', component: Home }, { path: 'product/:id', component: Product } ]; bootstrapApplication(App, { providers: [provideRouter(routes, withHashLocation())] });",
        "<a routerLink=\"/\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{ exact: true }\">Home</a> <a routerLink=\"/about\" routerLinkActive=\"active\">About</a>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { provideRouter, RouterOutlet, RouterLink, RouterLinkActive, withHashLocation } from '@angular/router'; @Component({ standalone: true, template: `<p>Home works!</p>` }) export class Home {} @Component({ standalone: true, template: `<p>About works!</p>` }) export class About {} @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet, RouterLink, RouterLinkActive], styles: [` nav a { margin-right: 8px; text-decoration: none; } .active { font-weight: 600; color: seagreen; } `], template: ` <h3>Active Links (routerLinkActive)</h3> <nav> <a routerLink=\"/\" routerLinkActive=\"active\" [routerLinkActiveOptions]=\"{ exact: true }\">Home</a> <a routerLink=\"/about\" routerLinkActive=\"active\">About</a> </nav> <router-outlet></router-outlet> ` }) export class App {} const routes = [ { path: '', component: Home }, { path: 'about', component: About } ]; bootstrapApplication(App, { providers: [provideRouter(routes, withHashLocation())] });",
        "{ path: 'about', loadComponent: () => import('./about').then(m => m.About) }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { provideRouter, RouterOutlet, RouterLink, withHashLocation } from '@angular/router'; @Component({ standalone: true, template: `<p>Home works!</p>` }) export class Home {} @Component({ standalone: true, template: `<p>About works (lazy)!</p>` }) export class About {} @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet, RouterLink], styles: [` nav a { margin-right: 8px; text-decoration: none; } `], template: ` <h3>Lazy-loaded Component (loadComponent)</h3> <nav> <a routerLink=\"/\">Home</a> <a routerLink=\"/about\">About (lazy)</a> </nav> <router-outlet></router-outlet> ` }) export class App {} const routes = [ { path: '', component: Home }, // Use Promise.resolve to simulate lazy loading without dynamic imports { path: 'about', loadComponent: () => Promise.resolve(About) } ]; bootstrapApplication(App, { providers: [provideRouter(routes, withHashLocation())] });",
        "export const authGuard = () => isLoggedIn ? true : inject(Router).createUrlTree(['/']); { path: 'protected', component: Protected, canActivate: [authGuard] }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, inject } from '@angular/core'; import { provideRouter, RouterOutlet, RouterLink, withHashLocation, Router } from '@angular/router'; let loggedIn = false; export const authGuard = () => { if (loggedIn) return true; const router = inject(Router); return router.createUrlTree(['/']); }; @Component({ standalone: true, template: `<p>Home (public).</p> <p>Login to access protected route.</p>` }) export class Home {} @Component({ standalone: true, template: `<p>Protected works! You are logged in.</p>` }) export class Protected {} @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet, RouterLink], styles: [` nav a { margin-right: 8px; text-decoration: none; } .status { margin-left: 8px; font-weight: 600; } `], template: ` <h3>Route Guard (canActivate)</h3> <div class=\"toolbar\"> <button (click)=\"toggle()\">{{ loggedIn ? 'Log out' : 'Log in' }}</button> <span class=\"status\">Status: {{ loggedIn ? 'Logged in' : 'Logged out' }}</span> </div> <nav> <a routerLink=\"/\">Home</a> <a routerLink=\"/protected\">Protected</a> </nav> <router-outlet></router-outlet> ` }) export class App { get loggedIn() { return loggedIn; } toggle() { loggedIn = !loggedIn; } } const routes = [ { path: '', component: Home }, { path: 'protected', component: Protected, canActivate: [authGuard] } ]; bootstrapApplication(App, { providers: [provideRouter(routes, withHashLocation())] });",
        "RouterOutlet",
        "routerLink",
        "RouterLinkActive",
        "{ exact: true }",
        "RouterLink",
        "provideRouter()",
        "withHashLocation()",
        "/#/path",
        "routes",
        "provideRouter(routes)",
        "href",
        ":id",
        "/product/42",
        "ActivatedRoute",
        "snapshot",
        "paramMap",
        "product/:id",
        "id",
        "snapshot.paramMap.get('id')",
        "ngOnInit",
        "routerLink=\"/product/1\"",
        "/product/2",
        "params",
        "routerLinkActive",
        "/",
        "routerLinkActive=\"active\"",
        "[routerLinkActiveOptions]=\"{ exact: true }\"",
        "routerLinkActive=\"active bold\"",
        "loadComponent",
        "loadChildren",
        "Promise.resolve",
        "true",
        "false",
        "UrlTree",
        "authGuard",
        "inject(Router)",
        "canActivate",
        "/protected",
        "boolean"
      ]
    },
    {
      "title": "Angular Services & Dependency Injection",
      "summary": "Services organize reusable logic and state outside of components.\nServices & DI Essentials\nWhat: A service holds reusable logic/state. DI (dependency injection) supplies instances where needed.\nScope: Provide in root for a shared singleton, or provide in a component for isolated instances.\nUse cases: Data fetching, caching, business rules, cross-component state.\nMental model: DI is like a power outlet: you plug in and Angular gives you a ready instance.\nDecorator: Use @Injectable() on classes that inject other services.\nNotes:\nRelated: See Components to consume services, Router for guards using services, and HTTP for services that fetch data.\nUse @Injectable({ providedIn: 'root' }) for app-wide singletons.\nProvide at a component when you need isolated instances.\nUse inject() in functions like route guards to retrieve dependencies outside constructors.\nService Basics\nDecorate classes with @Injectable() (required if they inject other services).\nInject services into constructors to use them in components.\nUse providedIn: 'root' for a shared singleton.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n@Injectable({ providedIn: 'root' }): Registers a singleton service available app‑wide.\nInject in constructor: constructor(public counter: CounterService) exposes the service to the template.\nMethods: Call inc() / dec() / reset() to update shared state.\nNotes:\nMetadata required when injecting: If a service injects other services, add @Injectable() so DI can generate metadata.\nKeep state minimal: Avoid large shared mutable state in services; Use explicit methods and return values.\nStandalone bootstrapping: Ensure providers are registered where needed and use inject() in functional constructs (e.g., guards).\nREMOVE ADS\nShared Service Across Components\nprovidedIn: 'root' shares one instance across the app.\nUpdating in one component reflects in others using the same service.\nExample\nRun Example »\nExample explained\nprovidedIn: 'root' shares one instance across the app.\nShared state: Clicking +/− in one component updates the value shown in the other.\nTemplate access: Injected as public so the template can read counter.value and call methods.\nNotes:\nSingleton vs local: providedIn: 'root' yields a single shared instance; providing in a component creates separate instances per subtree.\nBe deliberate about scope: Provide at the level that matches your sharing needs to avoid surprises.\nComponent-Provided Service (Hierarchical DI)\nProvide a service in a component's providers to create a local instance for its subtree.\nSibling subtrees receive separate instances.\nExample\nRun Example »\nExample explained\nproviders: [LocalCounterService]: Each panel component gets its own service instance for its subtree.\nWithin a panel: Multiple CounterView children share the same local instance.\nBetween panels: Panel A and Panel B have different instances (see the different id values).\nNotes:\nMultiple instances expected: Each provided component subtree gets its own instance; siblings do not share it.\nAvoid circular dependencies: Two services injecting each other will fail; extract common logic into a third service or redesign.\nService Design Tips\nKeep services focused and easy to test:\nAvoid component coupling: Do not inject components into services; keep services UI-agnostic.\nExpose clear APIs: Use small methods returning plain values or Observables; keep internal state private.\nConfiguration via tokens: Use injection tokens (a unique lookup key, often a class or an InjectionToken object) for configurable values to simplify testing and reuse.\nScope deliberately: Use providedIn: 'root' for app-wide singletons; provide at a component for isolated instances.",
      "examples": [
        "import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class CounterService { value = 0; inc() { this.value++; } } // Inject in a component // constructor(public counter: CounterService) {}",
        "@Injectable({ providedIn: 'root' }) export class DataService {} // class App { constructor(private data: DataService) {} }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class CounterService { value = 0; inc() { this.value++; } dec() { this.value--; } reset() { this.value = 0; } } @Component({ selector: 'app-root', standalone: true, template: ` <h3>Services</h3> <p>Counter: {{ counter.value }}</p> <button (click)=\"counter.inc()\">+</button> <button (click)=\"counter.dec()\">-</button> <button (click)=\"counter.reset()\">Reset</button> ` }) export class App { constructor(public counter: CounterService) {} } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<counter-a></counter-a> <counter-b></counter-b> <!-- Both use the same service instance -->",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class CounterService { value = 0; inc() { this.value++; } dec() { this.value--; } } @Component({ selector: 'counter-a', standalone: true, template: ` <h4>Counter A</h4> <p>Value: {{ counter.value }}</p> <button (click)=\"counter.inc()\">+1</button> <button (click)=\"counter.dec()\">-1</button> ` }) export class CounterA { constructor(public counter: CounterService) {} } @Component({ selector: 'counter-b', standalone: true, template: ` <h4>Counter B</h4> <p>Value: {{ counter.value }}</p> <button (click)=\"counter.inc()\">+1</button> <button (click)=\"counter.dec()\">-1</button> ` }) export class CounterB { constructor(public counter: CounterService) {} } @Component({ selector: 'app-root', standalone: true, imports: [CounterA, CounterB], template: ` <h3>Shared Service Across Components</h3> <counter-a></counter-a> <counter-b></counter-b> <p><em>Both components use the same CounterService instance.</em></p> ` }) export class App {} bootstrapApplication(App);",
        "@Component({ providers: [LocalCounterService] }) export class Panel {}",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Injectable } from '@angular/core'; import { CommonModule } from '@angular/common'; @Injectable() export class LocalCounterService { id = Math.floor(Math.random() * 10000); value = 0; inc() { this.value++; } } @Component({ selector: 'counter-view', standalone: true, template: ` <p>Service #{{ svc.id }} value: {{ svc.value }}</p> <button (click)=\"svc.inc()\">+1</button> ` }) export class CounterView { constructor(public svc: LocalCounterService) {} } @Component({ selector: 'panel-a', standalone: true, imports: [CommonModule, CounterView], providers: [LocalCounterService], template: ` <h4>Panel A (own provider)</h4> <counter-view></counter-view> <counter-view></counter-view> ` }) export class PanelA {} @Component({ selector: 'panel-b', standalone: true, imports: [CommonModule, CounterView], providers: [LocalCounterService], template: ` <h4>Panel B (own provider)</h4> <counter-view></counter-view> <counter-view></counter-view> ` }) export class PanelB {} @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, PanelA, PanelB], styles: [` .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; } h4 { margin: 0 0 8px; } button { margin-top: 6px; } `], template: ` <h3>Component-Provided Service (Hierarchical DI)</h3> <p>Each panel provides its own service instance.</p> <p>Counters inside the same panel share the instance.</p> <p>Different panels do not.</p> <div class=\"grid\"> <panel-a></panel-a> <panel-b></panel-b> </div> ` }) export class App {} bootstrapApplication(App);",
        "root",
        "@Injectable()",
        "@Injectable({ providedIn: 'root' })",
        "inject()",
        "providedIn: 'root'",
        "constructor(public counter: CounterService)",
        "inc()",
        "dec()",
        "reset()",
        "public",
        "counter.value",
        "providers",
        "providers: [LocalCounterService]",
        "CounterView",
        "id",
        "InjectionToken"
      ]
    },
    {
      "title": "Angular HttpClient",
      "summary": "HttpClient lets your app fetch and send data over HTTP.\nHTTP Essentials\nClient: Use HttpClient to fetch and send JSON.\nObservables: HTTP methods return Observables. Use subscribe() or the async pipe.\nUX: Show loading and clear error messages.\nProvide once: Register provideHttpClient() at bootstrap.\nNotes:\nRelated: See Services to encapsulate HTTP logic, Router for navigations after requests, and Templates for rendering lists and states.\nProvide the client with provideHttpClient() at bootstrap.\nUse non-blocking UIs with loading and error states; be mindful of CORS (browser security that controls which origins can call an API) when calling public APIs.\nBase URL & env: Centralize the API base URL/config in a token or constant and reuse it in services.\nSecurity: Validate untrusted URL parts; avoid interpolating raw user input directly into request URLs.\nGET Requests\nRead data with http.get<T>().\nTrack loading and error state for UX.\nUpdate component state in the subscription.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nprovideHttpClient(): Registers HttpClient so requests work.\ninject(HttpClient): Retrieves the client in a standalone component.\nGET: http.get<any[]>(url) returns an Observable; subscribe() sets users on success and error on failure.\nUX flags: loading and error drive the template (spinner/message).\nNotes:\nStandalone-friendly: Use provideHttpClient() over importing HttpClientModule.\nCross-cutting: Use interceptors (hooks on each request/response) for auth/logging; register once at the appropriate scope.\nUX: Avoid multiple clicks by disabling the button while loading.\nCORS: If calls fail in the browser but work in curl, it may be CORS—use APIs that allow your origin or a proxy.\nTyping & options: Use get<MyType>() and build options with HttpParams/HttpHeaders.\nREMOVE ADS\nPOST Requests\nCreate data with http.post<T>().\nDisable the button while sending to prevent duplicates.\nRender the returned result or an error message.\nExample\nRun Example »\nExample explained\nPOST: http.post<T>(url, body) sends JSON and returns the created object.\nDisable while sending: The button binds to loading to prevent duplicate submissions.\nResult: On success, show the returned result; on error, show a clear message.\nNotes:\nValidate inputs: Send the minimal, validated payload the server expects; show field errors clearly.\nIdempotency: Avoid duplicate submissions; keep the button disabled while sending and after success if appropriate.\nHandle errors: Show a clear error message and let the user retry; keep the UI responsive with a loading flag.\nError Handling\nAlways show a helpful message and allow retry.\nCheck status codes to decide retry vs fail fast.\nKeep the UI responsive with a loading flag.\nExample\nRun Example »\nExample explained\nError message: Build a helpful message from err.status; keep the UI responsive with loading.\nRetry: Store the lastAction and wire a retry() button to re-run the last request.\nOK vs Fail: Separate methods help demonstrate success and failure flows.\nNotes:\nDon't swallow errors: Surface a helpful message to users and log details for debugging.\nRetry strategy: Only retry on transient errors (e.g., 5xx); avoid retrying 4xx client errors.\nFeedback: Show a clear error message and let the user retry; keep the UI responsive with a loading flag.\nCancel stale requests: On rapid input, switch to the latest stream (e.g., switchMap) to avoid races.\nInterceptors: Centralize auth headers, logging, and retry to keep components slim.\nHTTP Interceptors\nRun cross-cutting logic on every request/response (e.g., auth headers, logging).\nRegister once at bootstrap with provideHttpClient(...).\nExample\nRun Example »\nExample explained\nwithInterceptors([...]): Registers interceptor functions for all requests.\nInterceptor: A function (req, next) that can req.clone(...) to modify the request, then calls next(req).\nprovideHttpClient(): Enables HttpClient and composes interceptors at bootstrap.",
      "examples": [
        "import { provideHttpClient, HttpClient } from '@angular/common/http'; // Bootstrap // bootstrapApplication(App, { providers: [provideHttpClient()] }); // Use in a component // http.get<User[]>('/api/users').subscribe({ next: d => users = d });",
        "loading = true; error = ''; http.get<User[]>('/api/users').subscribe({ next: d => { users = d; loading = false; }, error: () => { error = 'Failed to load'; loading = false; } });",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, inject } from '@angular/core'; import { CommonModule } from '@angular/common'; import { provideHttpClient, HttpClient } from '@angular/common/http'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>HttpClient</h3> <button (click)=\"load()\">Load Users</button> <p *ngIf=\"loading\">Loading...</p> <p *ngIf=\"error\" style=\"color:crimson\">{{ error }}</p> <ul> <li *ngFor=\"let u of users\">{{ u.name }} ({{ u.email }})</li> </ul> ` }) export class App { http = inject(HttpClient); users: any[] = []; loading = false; error = ''; load() { this.loading = true; this.error = ''; this.http.get<any[]>('https://jsonplaceholder.typicode.com/users') .subscribe({ next: (data) => { this.users = data; this.loading = false; }, error: () => { this.error = 'Failed to load users'; this.loading = false; } }); } } bootstrapApplication(App, { providers: [provideHttpClient()] });",
        "<app-root></app-root>",
        "loading = true; error = ''; result = null; http.post<Post>('/api/posts', { title, body }).subscribe({ next: r => { result = r; loading = false; }, error: () => { error = 'Failed to create'; loading = false; } });",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, inject } from '@angular/core'; import { CommonModule } from '@angular/common'; import { provideHttpClient, HttpClient } from '@angular/common/http'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>HttpClient POST</h3> <button (click)=\"createPost()\" [disabled]=\"loading\">Create Post</button> <p *ngIf=\"loading\">Sending...</p> <p *ngIf=\"error\" style=\"color:crimson\">{{ error }}</p> <div *ngIf=\"result\"> <p>Created Post ID: {{ result.id }}</p> <p>Title: {{ result.title }}</p> </div> ` }) export class App { http = inject(HttpClient); loading = false; error = ''; result: any = null; createPost() { this.loading = true; this.error = ''; this.result = null; this.http.post<any>('https://jsonplaceholder.typicode.com/posts', { title: 'foo', body: 'bar', userId: 1 }).subscribe({ next: (res) => { this.result = res; this.loading = false; }, error: () => { this.error = 'Failed to create post'; this.loading = false; } }); } } bootstrapApplication(App, { providers: [provideHttpClient()] });",
        "error = ''; loading = true; http.get('/api/data').subscribe({ next: r => { data = r; loading = false; }, error: err => { error = `Request failed (status ${'{'}err?.status ?? 'unknown'{}})`; loading = false; } });",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, inject } from '@angular/core'; import { CommonModule } from '@angular/common'; import { provideHttpClient, HttpClient, withInterceptors, HttpResponse, HttpErrorResponse, HttpRequest, HttpHandlerFn } from '@angular/common/http'; import { of, throwError } from 'rxjs'; // Fake HTTP interceptor so the demo works without external network calls function mockHttp(req: HttpRequest<any>, next: HttpHandlerFn) { if (req.method === 'GET' && req.url.includes('jsonplaceholder.typicode.com/usersx')) { return throwError(() => new HttpErrorResponse({ status: 404, statusText: 'Not Found', url: req.url })); } if (req.method === 'GET' && req.url.includes('jsonplaceholder.typicode.com/users')) { const body = [ { id: 1, name: 'Leanne Graham', email: 'leanne@example.com' }, { id: 2, name: 'Ervin Howell', email: 'ervin@example.com' } ]; return of(new HttpResponse({ status: 200, body })); } return next(req); } @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], styles: [` button { margin-right: 8px; } .error { color: crimson; } .ok { color: seagreen; } `], template: ` <h3>HTTP Error Handling</h3> <div> <button (click)=\"loadOk()\" [disabled]=\"loading\">Load OK</button> <button (click)=\"loadFail()\" [disabled]=\"loading\">Load Fail</button> <button (click)=\"retry()\" [disabled]=\"!lastAction || loading\">Retry</button> </div> <p *ngIf=\"loading\">Loading...</p> <p *ngIf=\"error\" class=\"error\">{{ error }}</p> <p *ngIf=\"!error && data\" class=\"ok\">Loaded {{ isArray(data) ? data.length + ' items' : '1 item' }}</p> <ul *ngIf=\"isArray(data)\"> <li *ngFor=\"let u of data\">{{ u.name }} ({{ u.email }})</li> </ul> ` }) export class App { http = inject(HttpClient); loading = false; error = ''; data: any[] | null = null; lastAction = ''; isArray(value: unknown): value is any[] { return Array.isArray(value as any); } fetch(url: string): void { this.loading = true; this.error = ''; this.data = null; this.http.get<any[]>(url).subscribe({ next: (res) => { this.data = res; this.loading = false; }, error: (err) => { const status = err?.status ?? 'unknown'; this.error = `Request failed (status ${status}). Please try again.`; this.loading = false; } }); } loadOk() { this.lastAction = 'ok'; this.fetch('https://jsonplaceholder.typicode.com/users'); } loadFail() { this.lastAction = 'fail'; this.fetch('https://jsonplaceholder.typicode.com/usersx'); } retry() { if (this.lastAction === 'ok') this.loadOk(); else if (this.lastAction === 'fail') this.loadFail(); } } bootstrapApplication(App, { providers: [provideHttpClient(withInterceptors([mockHttp]))] });",
        "import { HttpInterceptorFn, provideHttpClient, withInterceptors } from '@angular/common/http'; export const authInterceptor: HttpInterceptorFn = (req, next) => { const cloned = req.clone({ setHeaders: { Authorization: 'Bearer TOKEN' } }); return next(cloned); }; bootstrapApplication(App, { providers: [provideHttpClient(withInterceptors([authInterceptor]))] });",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { provideHttpClient, withInterceptors } from '@angular/common/http'; @Component({ selector: 'app-root', standalone: true, template: `<p>Interceptors demo</p>` }) export class App {} bootstrapApplication(App, { providers: [provideHttpClient(withInterceptors([]))] });",
        "HttpClient",
        "subscribe()",
        "async",
        "provideHttpClient()",
        "http.get<T>()",
        "loading",
        "error",
        "inject(HttpClient)",
        "http.get<any[]>(url)",
        "users",
        "HttpClientModule",
        "get<MyType>()",
        "HttpParams",
        "HttpHeaders",
        "http.post<T>()",
        "http.post<T>(url, body)",
        "result",
        "status",
        "err.status",
        "lastAction",
        "retry()",
        "switchMap",
        "provideHttpClient(...)",
        "withInterceptors([...])",
        "(req, next)",
        "req.clone(...)",
        "next(req)"
      ]
    },
    {
      "title": "Angular Pipes",
      "summary": "Pipes format values in templates with | (e.g., date, currency, percent).\nPipes Essentials\nWhat: Pipes format values in templates using | (e.g., date, currency, percent).\nAsync: The async pipe subscribes to Observables and renders the latest value, unsubscribing automatically.\nPresentation-only: Pipes change how a value is displayed, not the underlying data.\nPure by default: Pure pipes run when input references change; avoid in-place mutation of arrays/objects.\nNotes:\nRelated: See Templates for displaying values, Data Binding for interpolation and inputs, and HTTP for streams of data with async.\nImport CommonModule for built-in pipes in standalone components.\nFor custom pipes, use @Pipe({ standalone: true }) and add the pipe to the component imports.\nBasic Pipes\nFormat strings, numbers, dates, and more with built-in pipes.\nMany accept options (e.g., currency:'USD', date:'short').\nKeep business logic in components/services; pipes are for presentation.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nuppercase/currency/date/percent: Built-in pipes format strings, numbers, and dates.\nOptions: Many pipes accept parameters (e.g., currency:'USD', date:'mediumDate', percent:'1.0-2').\nPure by default: Pure pipes recompute when the input reference changes; avoid in-place mutation.\nNotes:\nPerformance: Avoid heavy computation in pipes; Use precomputing in components/services.\nPure pipes and mutations: Pure pipes run when the input reference changes. If you mutate arrays/objects in place, the pipe will not re-run—create a new reference instead.\nREMOVE ADS\nAsync Pipe\nRender the latest value from an Observable.\nUnsubscribes automatically when the view is destroyed.\nUse value$ | async as value to subscribe once and reuse.\nExample\nRun Example »\nExample explained\ntime$ | async: Subscribes in the template and renders the latest time value.\n*ngIf=\"users$ | async as users; else loading\": Creates a single subscription, assigns to users, and shows a fallback template while loading.\nAuto-unsubscribe: The async pipe cleans up when the view is destroyed.\nNotes:\nSingle subscription: Avoid using | async multiple times on the same Observable in the same template area; use | async as value once and reuse value.\nLoading placeholders: Combine with *ngIf and an else template for a friendly loading state.\nLists: When iterating streamed arrays, add trackBy to *ngFor for stable identity and better performance.\nCustom Pipe\nBuild small, reusable formatters with @Pipe.\nMark as standalone and import into components.\nPure by default; avoid impure pipes unless necessary.\nExample\nRun Example »\nExample explained\n@Pipe({ standalone: true }): Declares a reusable, importable pipe.\ntransform(value: string): Implements the formatting logic and returns a string.\nUsage: In the template, apply with {{ text | titlecase2 }}.\nNotes:\nImpure pipes: They run on every change detection and can hurt performance. Use pure pipes; only mark impure when strictly necessary.\nNo side effects: Keep pipes deterministic and free of side effects (no logging, no service calls).\nNull safety: Handle null/undefined inputs gracefully to avoid template errors.",
      "examples": [
        "{{ title | uppercase }} {{ price | currency:'USD' }} {{ today | date:'short' }}",
        "{{ title | uppercase }} {{ price | currency:'USD' }} {{ today | date:'mediumDate' }} {{ percent | percent:'1.0-2' }}",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>Pipes</h3> <p>{{ title | uppercase }}</p> <p>{{ price | currency:'USD' }}</p> <p>{{ today | date:'mediumDate' }}</p> <p>{{ percent | percent:'1.0-2' }}</p> ` }) export class App { title = 'Angular'; price = 1234.5; today = new Date(); percent = 0.3495; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<ng-container *ngIf=\"users$ | async as users; else loading\"> <li *ngFor=\"let u of users\">{{ u.name }}</li> </ng-container> <ng-template #loading>Loading...</ng-template>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; import { interval, of } from 'rxjs'; import { map, delay } from 'rxjs/operators'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], template: ` <h3>Async Pipe</h3> <p>Time: {{ time$ | async | date:'mediumTime' }}</p> <h4>Users (delayed)</h4> <ng-container *ngIf=\"users$ | async as users; else loading\"> <ul> <li *ngFor=\"let u of users\">{{ u.name }}</li> </ul> </ng-container> <ng-template #loading>Loading...</ng-template> ` }) export class App { time$ = interval(1000).pipe(map(() => new Date())); users$ = of([{ name: 'Alice' }, { name: 'Bob' }, { name: 'Carol' }]).pipe(delay(1200)); } bootstrapApplication(App);",
        "import { Pipe, PipeTransform } from '@angular/core'; @Pipe({ name: 'titlecase2', standalone: true }) export class TitleCase2Pipe implements PipeTransform { transform(v: string): string { /* ...format... */ return v; } }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Pipe, PipeTransform } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; @Pipe({ name: 'titlecase2', standalone: true }) export class TitleCase2Pipe implements PipeTransform { transform(value: string): string { if (!value) return ''; return value .split(/\\s+/) .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()) .join(' '); } } @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, FormsModule, TitleCase2Pipe], template: ` <h3>Custom Pipe</h3> <label> Text: <input [(ngModel)]=\"text\" placeholder=\"type here\" /> </label> <p>Original: {{ text }}</p> <p>TitleCase2: {{ text | titlecase2 }}</p> ` }) export class App { text = 'hello angular pipes'; } bootstrapApplication(App);",
        "|",
        "async",
        "CommonModule",
        "@Pipe({ standalone: true })",
        "imports",
        "currency:'USD'",
        "date:'short'",
        "uppercase",
        "currency",
        "date",
        "percent",
        "date:'mediumDate'",
        "percent:'1.0-2'",
        "value$ | async as value",
        "time$ | async",
        "*ngIf=\"users$ | async as users; else loading\"",
        "users",
        "| async",
        "| async as value",
        "value",
        "*ngIf",
        "else",
        "trackBy",
        "*ngFor",
        "@Pipe",
        "standalone",
        "transform(value: string)",
        "{{ text | titlecase2 }}",
        "null",
        "undefined"
      ]
    },
    {
      "title": "Angular Lifecycle Hooks",
      "summary": "Lifecycle hooks are methods Angular calls at key moments (create, input changes, view init, destroy) so you can set up, react to changes, access template refs, and clean up.\nLifecycle Essentials\nWhat: Lifecycle hooks are methods Angular calls at key moments (init, input changes, view init, destroy).\nSetup: Use ngOnInit after inputs are set.\nReact: Handle input changes in ngOnChanges.\nDOM ready: Use ngAfterViewInit to access @ViewChild refs.\nCleanup: Release timers/subscriptions/listeners in ngOnDestroy.\nExample explained\nngOnInit: Run setup that needs inputs already bound.\n@ViewChild + ngAfterViewInit: Access and focus the input only after the view is initialized.\nngOnDestroy: Clean up timers/listeners to prevent leaks.\nNotes:\nRelated: See Components for creating views, Templates for markup and refs, and Directives for structural rendering like *ngIf used in examples.\nAvoid DOM access in constructors.\nREMOVE ADS\nLifecycle Hooks\nToggle lifecycle: Showing a component (e.g., with *ngIf) runs ngOnInit; hiding it runs ngOnDestroy.\nDo/undo work: Start timers/subscriptions on init, clear/unsubscribe on destroy.\nExample explained\nngOnInit: Starts a timer when the component is created.\nngOnDestroy: Clears the timer when the component is removed.\n*ngIf: Toggling the condition creates/destroys the child, invoking the hooks.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nToggle: The button flips show to add/remove the child.\nHooks in action: Creating the child runs ngOnInit; removing it runs ngOnDestroy.\nCleanup: Clearing the interval prevents background work after destroy.\nNotes:\nCleanup required: Clear intervals/timeouts and unsubscribe in ngOnDestroy; Use the async pipe when possible.\nHeavy work in hooks: Avoid expensive work in frequently called hooks (e.g., ngOnChanges); debounce/throttle or defer to services.\nManual listeners: Remove event listeners you add manually on destroy, or keep the cleanup function returned by Renderer2.\nExample\nRun Example »\nExample explained\nParent → Child: The input box updates text in the parent; the child receives it via [text].\nChange record: The child stores the last prev and curr values from SimpleChanges for display.\nEdge cases: Handles transitions like undefined → value or value → ''.\nNotes:\nImmutable inputs: Replace arrays/objects instead of mutating to ensure OnChanges runs.\nWith OnPush: Input reference changes trigger checks; in-place mutation may not—emit new references from parents.\nInspect changes: Use SimpleChanges to handle edge cases (e.g., undefined → value).\nExample explained\n@Input(): The child declares an input text that parents can bind to.\nngOnChanges(changes): Receives SimpleChanges with previousValue and currentValue for each changed input.\nImmutable updates: Prefer replacing references over mutating in place to trigger change detection.\nExample\nRun Example »\nExample explained\nMultiple refs: Reads both the input box and the panel container via @ViewChild.\nDefer DOM work: Uses setTimeout in ngAfterViewInit to let the view settle before measuring.\nmeasure(): Reads bounding box and formats a size string.\nNotes:\nDon't use DOM in constructor: The view isn't ready; do DOM operations after ngAfterViewInit.\nReading too early: @ViewChild is undefined before ngAfterViewInit—check for existence or defer work.\nAfterViewInit & Cleanup\nAccess template refs after the view initializes and clean up resources when the component is destroyed.\nExample explained\nTeardown: Unsubscribe, clear intervals, and remove listeners in ngOnDestroy.\nSafety: Optional chaining (?.) guards against missing handles.\nNotes:\nFocus and measure safely: Run DOM reads/writes after ngAfterViewInit (or inside setTimeout to let the view settle).\nObservers & listeners: Disconnect ResizeObserver/MutationObserver and remove manual event listeners in ngOnDestroy.\nSubscriptions: Use the async pipe; if you subscribe manually, unsubscribe on destroy (e.g., takeUntilDestroyed).",
      "examples": [
        "import { OnInit, OnDestroy, AfterViewInit, ViewChild, ElementRef } from '@angular/core'; export class Demo implements OnInit, AfterViewInit, OnDestroy { @ViewChild('box') box!: ElementRef<HTMLInputElement>; intervalId: any; ngOnInit() { /* setup after inputs */ } ngAfterViewInit() { this.box.nativeElement.focus(); } ngOnDestroy() { clearInterval(this.intervalId); } } // Template: <input #box>",
        "export class Child implements OnInit, OnDestroy { intervalId: any; ngOnInit() { this.intervalId = setInterval(() => {/* ... */}, 1000); } ngOnDestroy() { clearInterval(this.intervalId); } // <child-cmp *ngIf=\"show\"></child-cmp>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, OnInit, OnDestroy } from '@angular/core'; import { CommonModule } from '@angular/common'; {{ ... }} show = true; toggle() { this.show = !this.show; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, OnInit, OnDestroy } from '@angular/core'; import { CommonModule } from '@angular/common'; {{ ... }} export class App { text = ''; } bootstrapApplication(App);",
        "@ViewChild('box') box!: ElementRef<HTMLInputElement>; ngAfterViewInit() { this.box.nativeElement.focus(); }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, ViewChild, ElementRef, AfterViewInit } from '@angular/core'; import { CommonModule } from '@angular/common'; {{ ... }} bootstrapApplication(App);",
        "// Example teardown pattern sub?.unsubscribe?.(); clearInterval(intervalId); removeListener?.();",
        "ngOnInit",
        "ngOnChanges",
        "ngAfterViewInit",
        "@ViewChild",
        "ngOnDestroy",
        "*ngIf",
        "show",
        "async",
        "Renderer2",
        "text",
        "[text]",
        "SimpleChanges",
        "undefined → value",
        "value → ''",
        "OnChanges",
        "@Input()",
        "ngOnChanges(changes)",
        "previousValue",
        "currentValue",
        "box",
        "panel",
        "setTimeout",
        "undefined",
        "?.",
        "ResizeObserver",
        "MutationObserver",
        "takeUntilDestroyed"
      ]
    },
    {
      "title": "Angular Styling",
      "summary": "Styling in Angular uses class/style bindings in templates and component-scoped CSS for maintainable, theme-friendly UIs.\nStyling Essentials\nBindings: Use [class.foo]/[ngClass] for classes and [style.prop]/[ngStyle] for styles.\nThemes: Toggle CSS variables to switch light/dark or accents.\nEncapsulation: Component styles are scoped by default; use :host and :host-context() for host/theme styling.\nRelated: See Data Binding for property/class/style bindings, Templates for applying directives, and Components for component-scoped styles.\nTip: Use class bindings over inline styles for maintainability.\nImport CommonModule for ngClass/ngStyle in standalone components.\nUse CSS variables to implement theme toggles efficiently.\nEncapsulation: Component styles are scoped by default.\nUse :host to style the component root and :host-context(.theme-dark) to react to a parent theme.\nBasic Styling\nUse [class.foo] for single boolean toggles and [ngClass] when applying multiple classes.\nUse classes for reusable look-and-feel.\nUse [style.prop] for one-off numeric or dynamic values (like color, width, padding).\nKeep complex styling in CSS classes.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n[class.highlight]: Toggles the highlight class with a boolean.\n[ngClass]: Applies multiple classes from an object (e.g., { big: big }).\n[style.color]/[style.borderColor]: Bind style properties to the current color.\nToolbar: Buttons update component state to demonstrate the bindings.\nBindings over literal class=: Using class=\"...\" together with [ngClass] can overwrite classes.\nUse [class.foo]/[ngClass] for predictable toggles.\nBoolean values: Avoid string booleans like [class.active]=\"'false'\".\nBind real booleans: [class.active]=\"isActive\".\nImport CommonModule: ngClass/ngStyle live in CommonModule for standalone components.\nREMOVE ADS\nDynamic Styling\nTwo-way binding with controls lets you change styles live.\n[ngClass] toggles classes based on booleans, and [ngStyle] sets several style properties at once.\nTip: For performance and clarity, keep style objects small and focused.\nFavor classes for larger visual changes.\nExample\nRun Example »\nExample explained\n[(ngModel)]: Two-way binds form controls to component fields.\n[ngClass]: Toggles fancy/rounded based on booleans.\n[ngStyle]: Sets several style properties at once from component state.\nKeep ngStyle small: Large inline style objects become hard to maintain.\nMove most styling into CSS classes and bind only dynamic bits.\nEncapsulation\nComponent styles are scoped by default to their host element.\nUse :host and :host-context() for host and theme-aware styling.\nModes: Default is Emulated.\nUse None sparingly for global styles (e.g., third‑party overrides).\nShadowDom isolates styles fully.\nHost styling: Use :host over selecting wrapper tags.\nCombine with classes on the host for variants (e.g., :host(.dense)).\nTheme context: Use :host-context(.theme-dark) to adapt to parent themes without leaking global CSS.\nAvoid deep selectors: Don't rely on .parent .child chains inside components.\nExpose tokens via CSS variables instead.\nTheme with CSS Variables\nCSS variables are named paint buckets you can swap at runtime.\nToggle a class to switch buckets (light/dark) and bind the accent variable for instant theme changes.\nUse variables for colors, spacing, and shadows so components can respond to theme changes without code changes.\nExample\nRun Example »\nExample explained\nTheme tokens: CSS variables (e.g., --bg, --fg, --accent) define the theme.\nToggle: Adding theme-dark on the toolbar swaps variable values.\n[style.--accent]: Binds a custom CSS property; the box reads it via var(--accent).\nDon't hard-code colors: Binding literal colors (e.g., [style.color]=\"'red'\") fights theming.\nUse CSS variables and classes.\nScope variables carefully: Keep theme variables at the component host or a top-level theme wrapper to avoid conflicts.\nRespect user preference: Use @media (prefers-color-scheme: dark) to set a sensible default, then allow toggling.\nDesign tokens: Define semantic tokens (e.g., --surface, --text, --accent) and reference them in components for consistent theming.",
      "examples": [
        "<div [class.active]=\"isActive\" [ngClass]=\"{ big: big }\" [style.color]=\"color\" [ngStyle]=\"{ padding: pad + 'px' }\">...</div>",
        "<div class=\"box\" [class.highlight]=\"highlight\" [ngClass]=\"{ big: big }\" [style.color]=\"color\" [style.borderColor]=\"color\">...</div>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], styles: [` .box { padding: 12px; border: 2px solid #ccc; margin-top: 8px; border-radius: 6px; } .highlight { background: #fffa8b; } .big { font-size: 24px; } .toolbar button { margin-right: 6px; } `], template: ` <h3>Styling</h3> <div class=\"toolbar\"> <button (click)=\"toggleHighlight()\">Toggle Highlight</button> <button (click)=\"toggleBig()\">Toggle Big</button> <button (click)=\"setColor('crimson')\">Crimson</button> <button (click)=\"setColor('seagreen')\">Green</button> <button (click)=\"setColor('royalblue')\">Blue</button> </div> <div class=\"box\" [class.highlight]=\"highlight\" [ngClass]=\"{ big: big }\" [style.color]=\"color\" [style.borderColor]=\"color\"> Styled box </div> ` }) export class App { highlight = false; big = false; color = 'royalblue'; toggleHighlight() { this.highlight = !this.highlight; } toggleBig() { this.big = !this.big; } setColor(c: string) { this.color = c; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "<div [ngClass]=\"{ fancy: fancy, rounded: rounded }\" [ngStyle]=\"{ color: color, padding: pad + 'px' }\">...</div>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, FormsModule], styles: [` .box { border: 2px solid #ccc; margin-top: 12px; border-radius: 6px; transition: all .15s ease-in-out; } .fancy { box-shadow: 0 2px 8px rgba(0,0,0,.15); background: #f9fbff; } .rounded { border-radius: 14px; } .toolbar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; } .toolbar label { display: inline-flex; align-items: center; gap: 6px; } `], template: ` <h3>Dynamic Styling</h3> <div class=\"toolbar\"> <label><input type=\"checkbox\" [(ngModel)]=\"fancy\"> Fancy</label> <label><input type=\"checkbox\" [(ngModel)]=\"rounded\"> Rounded</label> <label>Color <input type=\"color\" [(ngModel)]=\"color\"></label> <label>Padding <input type=\"range\" min=\"0\" max=\"40\" [(ngModel)]=\"padding\"> {{ padding }}px</label> <label>Font Size <input type=\"range\" min=\"12\" max=\"36\" [(ngModel)]=\"fontSize\"> {{ fontSize }}px</label> </div> <div class=\"box\" [ngClass]=\"{ fancy: fancy, rounded: rounded }\" [ngStyle]=\"{ color: color, borderColor: color, padding: padding + 'px', fontSize: fontSize + 'px' }\"> Styled box </div> ` }) export class App { fancy = true; rounded = false; color = '#4169e1'; padding = 12; fontSize = 18; } bootstrapApplication(App);",
        "<div [class.theme-dark]=\"dark\" class=\"toolbar\"> <button (click)=\"dark = !dark\">Toggle {{ dark ? 'Light' : 'Dark' }}</button> <button (click)=\"setAccent('#e91e63')\">Pink</button> <button (click)=\"setAccent('#00b894')\">Green</button> <button (click)=\"setAccent('#ff9800')\">Orange</button> <span class=\"swatch\" [style.background]=\"accent\"></span> </div> <div class=\"box\" [style.--accent]=\"accent\"> This box follows the current theme and accent color. </div>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule], styles: [` :host { --bg: #ffffff; --fg: #222; --accent: #4169e1; } .theme-dark { --bg: #121212; --fg: #eaeaea; --accent: #4f8cff; } .toolbar { display: flex; gap: 8px; align-items: center; } .swatch { width: 18px; height: 18px; border-radius: 50%; border: 1px solid #ccc; display: inline-block; vertical-align: middle; } .box { margin-top: 10px; padding: 14px; border-radius: 8px; border: 2px solid var(--accent); background: var(--bg); color: var(--fg); transition: all .15s ease-in-out; } button { padding: 6px 10px; } `], template: ` <h3>Theme with CSS Variables</h3> <div [class.theme-dark]=\"dark\" class=\"toolbar\"> <button (click)=\"dark = !dark\">Toggle {{ dark ? 'Light' : 'Dark' }}</button> <button (click)=\"setAccent('#e91e63')\">Pink</button> <button (click)=\"setAccent('#00b894')\">Green</button> <button (click)=\"setAccent('#ff9800')\">Orange</button> <span class=\"swatch\" [style.background]=\"accent\"></span> </div> <div class=\"box\" [style.--accent]=\"accent\"> This box follows the current theme and accent color. </div> ` }) export class App { dark = false; accent = '#4169e1'; setAccent(c: string) { this.accent = c; } } bootstrapApplication(App);",
        ":host { display: block; } :host(.dense) { padding: 8px; } :host-context(.theme-dark) { color: #eee; }",
        "[class.foo]",
        "[ngClass]",
        "[style.prop]",
        "[ngStyle]",
        ":host",
        ":host-context()",
        "CommonModule",
        "ngClass",
        "ngStyle",
        ":host-context(.theme-dark)",
        "[class.highlight]",
        "highlight",
        "{ big: big }",
        "[style.color]",
        "[style.borderColor]",
        "color",
        "class=\"...\"",
        "[class.active]=\"'false'\"",
        "[class.active]=\"isActive\"",
        "[(ngModel)]",
        "fancy",
        "rounded",
        "Emulated",
        "None",
        "ShadowDom",
        ":host(.dense)",
        ".parent .child",
        "--bg",
        "--fg",
        "--accent",
        "theme-dark",
        "[style.--accent]",
        "var(--accent)",
        "[style.color]=\"'red'\"",
        "@media (prefers-color-scheme: dark)",
        "--surface",
        "--text"
      ]
    },
    {
      "title": "Angular App Bootstrap & Providers",
      "summary": "Bootstrap starts your app with a standalone root component and registers providers (Router, HttpClient, etc.) at the right scope for performance and testability.\nApp Bootstrap Essentials\nStart: Use bootstrapApplication() to launch a standalone root component.\nProvide features: Add provideRouter(), provideHttpClient(), etc. at bootstrap.\nDI: A provider tells dependency injection how to create or supply a value for a token.\nScope: Register at the smallest useful scope (feature/route) for performance and testability.\nNotes:\nRelated: See Router, HttpClient, and Services & DI.\nRegister providers at the smallest useful scope (feature or route) to improve performance and testability.\nUse provideRouter() with lazy routes for faster startup.\nBasic Bootstrap and Global Providers\nBootstrap with Router and HttpClient for app-wide availability.\nKeep the root component minimal; configure providers at bootstrap.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nbootstrapApplication(App): Starts the app with a standalone root component.\nprovideRouter(routes): Registers the Router and routes.\nprovideHttpClient(): Enables HttpClient app-wide.\nRouterOutlet: Renders the active route's component.\nNotes:\nRoot stays light: Keep the root component minimal; configure providers in bootstrapApplication().\nUse functions: Use provideRouter() and provideHttpClient() instead of legacy modules.\nLazy first: Favor lazy routes to reduce initial bundle and speed up startup.\nREMOVE ADS\nFeature-Scoped Providers\nProvide services only where needed to avoid unnecessary globals.\nFeature/route providers can improve startup and testability.\nExample\nOnly the admin area gets the extra providers.\nThe rest of the app stays lean.\nExample explained\nproviders on route: Attaches provideHttpClient() only to /admin.\nloadComponent: Lazy loads the admin component on navigation.\nScope: Other routes do not receive these providers, keeping the root light.\nNotes:\nScope carefully: Add providers only to features that need them to avoid unnecessary global singletons.\nAvoid duplication: Be aware that scoping providers can create new instances; ensure this is intended.\nHttpClient Setup\nAdd provideHttpClient() once at the desired scope.\nEnables HttpClient for that scope; add interceptors as needed.\nKeep interceptors small and focused.\nExample\nNotes:\nStandalone-friendly: In standalone apps, Use provideHttpClient() over importing HttpClientModule.\nCross-cutting: Use interceptors for auth/logging; register them once at the appropriate scope.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { provideRouter } from '@angular/router'; import { provideHttpClient } from '@angular/common/http'; bootstrapApplication(App, { providers: [ provideRouter(routes), provideHttpClient() ] });",
        "bootstrapApplication(App, { providers: [ provideRouter(routes), provideHttpClient() ] });",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { Routes, provideRouter, RouterOutlet } from '@angular/router'; import { provideHttpClient } from '@angular/common/http'; @Component({ selector: 'home-page', standalone: true, template: `<p>Home works</p>` }) class Home {} const routes: Routes = [ { path: '', component: Home } ]; @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet], template: `<router-outlet></router-outlet>` }) class App {} bootstrapApplication(App, { providers: [ provideRouter(routes), provideHttpClient() ] });",
        "<app-root></app-root>",
        "const routes = [ { path: 'admin', providers: [provideHttpClient()], loadComponent: () => import('./admin').then(m => m.Admin) } ]; bootstrapApplication(App, { providers: [provideRouter(routes)] });",
        "import { Routes, provideRouter } from '@angular/router'; import { provideHttpClient } from '@angular/common/http'; const routes: Routes = [ { path: 'admin', providers: [provideHttpClient()], loadComponent: () => import('./admin.component').then(m => m.AdminComponent) } ]; bootstrapApplication(App, { providers: [provideRouter(routes)] });",
        "bootstrapApplication(App, { providers: [provideHttpClient()] });",
        "import { provideHttpClient } from '@angular/common/http'; bootstrapApplication(App, { providers: [provideHttpClient()] });",
        "bootstrapApplication()",
        "provideRouter()",
        "provideHttpClient()",
        "HttpClient",
        "/admin",
        "HttpClientModule"
      ]
    },
    {
      "title": "Angular Control Flow",
      "summary": "Control flow directives (@if, @for, @switch) render branches, lists, and cases in templates and replace the legacy *ngIf/*ngFor/[ngSwitch] for new code.\nControl Flow Essentials\n@if: Conditional blocks with optional else if/else.\n@for: Loops with track for stable identity and optional @empty for empty states.\n@switch: Selects and renders a matching case.\nPreferred for new code in Angular 17+; legacy *ngIf/*ngFor/[ngSwitch] remain supported.\nCode explained\n@if ... @else: Branches to render different blocks based on a condition.\n@for (...; track ...): Iterates and uses track to keep stable identities for DOM reuse.\n@switch/@case/@default: Selects and renders a matching case.\nNotes:\nRelated: See Templates, Directives, and Lists.\nUse @for with track for stable list rendering.\nUse @if ...; else for readable branches.\nControl Flow Basics\nToggle content with @if ...; else.\nIterate with @for and add a track expression for stable DOM updates.\nREMOVE ADS\nExample\nToggle content with @if, and render lists with @for using a track expression:\nExampleGet your own Angular Server\nRun Example »\nExample explained\n@if ... @else: Toggles the paragraph based on the show() signal.\n@for ... track item: Renders the list from the items() signal and preserves DOM with track.\n@empty: Displays a fallback when the list is empty.\nSignals: Buttons update show and items, which re-render the view.\nNotes:\nUse track: Prefer tracking by a stable key (e.g., track it.id) for lists of objects; for primitives, track item is fine.\nSignals: Read signals with sig() in templates (e.g., @if (flag()), @for (x of list())).\nLegacy equivalence: In *ngFor, use trackBy to match track in @for.\nLegacy syntax: *ngIf/*ngFor/[ngSwitch] remain supported; prefer @if/@for/@switch for new code.\nKeep logic in TS: Compute flags and derived arrays in the component; keep templates simple.\nNo side effects: Avoid side effects inside control-flow blocks; update state in handlers/services.",
      "examples": [
        "@if (score > 90) { <p>A</p> } @else if (score > 75) { <p>B</p> } @else { <p>C</p> } <ul> @for (it of items; track it.id) { <li>{{ it.label }}</li> } @empty { <li>No items</li> } </ul> @switch (status) { @case ('pending') { <p>Pending</p> } @case ('done') { <p>Done</p> } @default { <p>Unknown</p> } }",
        "@if (show) { <p>Visible</p> } @else { <p>Hidden</p> } @for (item of items; track item) { <li>{{ item }}</li> }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Control Flow</h3> <button (click)=\"show.set(!show())\">Toggle</button> <button (click)=\"items.set([])\">Clear</button> <button (click)=\"reset()\">Reset</button> @if (show()) { <p>Visible</p> } @else { <p>Hidden</p> } <ul> @for (item of items(); track item) { <li>{{ item }}</li> } @empty { <li>No items</li> } </ul> ` }) export class App { show = signal(true); items = signal(['One','Two','Three']); reset() { this.items.set(['One','Two','Three']); } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "@if",
        "@for",
        "@switch",
        "*ngIf/*ngFor/[ngSwitch]",
        "else if",
        "else",
        "track",
        "@empty",
        "*ngIf",
        "*ngFor",
        "[ngSwitch]",
        "@if ... @else",
        "@for (...; track ...)",
        "@switch/@case/@default",
        "@if ...; else",
        "show()",
        "@for ... track item",
        "items()",
        "show",
        "items",
        "track it.id",
        "track item",
        "sig()",
        "@if (flag())",
        "@for (x of list())",
        "trackBy"
      ]
    },
    {
      "title": "Angular Signals",
      "summary": "Signals are reactive state: read by calling (e.g., count()), update with set()/update(), derive with computed(), and run side effects with effect().\nSignals Essentials\nSignal: A value you read by calling it (e.g., count()). Updating it notifies dependents.\nState: Use signal() for local component state.\nDerived: Use computed() for read-only formulas.\nEffects: Use effect() to run side effects when dependencies change.\nNotes:\nRelated: See Data Binding, Services & DI, and Change Detection.\nUse signals for local component state.\nBridge RxJS with toSignal()/toObservable() when needed.\nLegacy equivalence: For lists, prefer @for with track; with *ngFor, use trackBy for the same effect.\nWorking with Signals\nUpdate a signal with .set() or .update().\nRead a signal by calling it like a function.\nExample\nUse a signal, derive with computed(), react with effect(), and update with update():\nExampleGet your own Angular Server\nRun Example »\nExample explained\nsignal(0): Creates reactive state you read by calling (e.g., count()).\ncomputed(() => ...): Derives a read‑only value (double()) from other signals.\neffect(() => ...): Runs whenever dependencies change (logs on count() updates).\nupdate(n => n + 1): Writes to the signal and notifies dependents.\nTips:\nImmutable-friendly: Use creating new objects/arrays in set/update instead of mutating in place.\nKeep effects small: Avoid writing to signals inside effect() to prevent feedback loops.\nCompute cheaply: Keep computed() pure and cheap; derive from other signals only.\nREMOVE ADS\nDerived Values and Effects\nWrap read-only formulas in computed(); it recalculates when dependencies change.\nUse effect() for side effects such as logging or syncing.\nKeep effects idempotent and light.\nExample\nCompute a derived value with computed() and observe it with effect():\nExample\nExample explained\ncomputed: sum() recalculates when a() or b() change.\neffect: Reacts to sum() updates (logs on each change).\nincA()/incB(): Use update to increment signals, driving recomputation.\nNotes:\nAvoid side-effecty computed: Keep computed() pure (no async/mutations).\nEffect lifecycles: Clean up inside effect() and avoid unnecessary work on each run.\nInterop: Bridge with RxJS using toSignal()/toObservable() when integrating streams.\nRxJS Interop\nConvert an Observable to a signal with toSignal() for template-friendly reads.\nConvert a signal to an Observable with toObservable() to integrate with stream APIs.\nNotes:\nInitial values: Always provide initialValue to toSignal() for SSR and first render.\nOwnership: Manage subscriptions on the Observable side; toSignal() handles teardown automatically.\nSignals Quick Reference\nCreate: signal(initial)\nRead: call the signal (e.g., count())\nWrite: set(value), update(fn)\nDerived: computed(fn)\nEffects: effect(fn)\nRxJS interop: toSignal(observable, { initialValue }), toObservable(signal)",
      "examples": [
        "import { signal, computed, effect } from '@angular/core'; const count = signal(0); const double = computed(() => count() * 2); effect(() => console.log('count =', count())); count.update(n => n + 1);",
        "const count = signal(0); count.set(1); count.update(n => n + 1); console.log(count());",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal, computed, effect } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Signals</h3> <p>Count: {{ count() }}</p> <p>Double: {{ double() }}</p> <button (click)=\"inc()\">Increment</button> ` }) export class App { count = signal(0); double = computed(() => this.count() * 2); constructor() { effect(() => console.log('count changed', this.count())); } inc() { this.count.update(n => n + 1); } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "const a = signal(2); const b = signal(3); const sum = computed(() => a() + b()); effect(() => console.log('sum =', sum()));",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal, computed, effect } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Derived & Effects</h3> <p>a: {{ a() }} | b: {{ b() }} | sum: {{ sum() }}</p> <button (click)=\"incA()\">inc a</button> <button (click)=\"incB()\">inc b</button> ` }) export class App { a = signal(2); b = signal(3); sum = computed(() => this.a() + this.b()); constructor() { effect(() => console.log('sum =', this.sum())); } incA() { this.a.update(n => n + 1); } incB() { this.b.update(n => n + 1); } } bootstrapApplication(App);",
        "import { signal, computed, effect, toSignal, toObservable } from '@angular/core'; import { interval, map } from 'rxjs'; // Observable -> Signal const seconds$ = interval(1000).pipe(map(n => n + 1)); const seconds = toSignal(seconds$, { initialValue: 0 }); // Signal -> Observable const count = signal(0); const count$ = toObservable(count);",
        "count()",
        "set()",
        "update()",
        "computed()",
        "effect()",
        "signal()",
        "toSignal()",
        "toObservable()",
        "@for",
        "track",
        "*ngFor",
        "trackBy",
        ".set()",
        ".update()",
        "signal(0)",
        "computed(() => ...)",
        "double()",
        "effect(() => ...)",
        "update(n => n + 1)",
        "set",
        "update",
        "computed",
        "sum()",
        "a()",
        "b()",
        "effect",
        "incA()",
        "incB()",
        "Observable",
        "initialValue",
        "signal(initial)",
        "set(value)",
        "update(fn)",
        "computed(fn)",
        "effect(fn)",
        "toSignal(observable, { initialValue })",
        "toObservable(signal)"
      ]
    },
    {
      "title": "Angular Change Detection & Performance",
      "summary": "Change detection updates the view when state changes\nChange Detection Essentials\nOnPush: Checks only on inputs, events/async tasks, and signal updates.\nSignals: Push updates explicitly via state changes for predictable renders.\nStable lists: Use track/trackBy for identity to avoid DOM churn.\nExample explained\nOnPush: The component uses ChangeDetectionStrategy.OnPush for predictable checks.\nSignals: items is a signal; update() replaces the array immutably to trigger re-render.\nList identity: The template loops with @for and track it.id to preserve DOM nodes.\nNotes:\nRelated: See Lists, Signals, and Components.\nWith signals, OnPush updates automatically.\nUse trackBy (or track with @for) to prevent DOM churn.\nREMOVE ADS\nOnPush and Signals\nCombine OnPush with signals for predictable updates.\nKeep templates simple and push changes through state updates.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nOnPush + signals: Updating the count signal triggers an update under OnPush.\nIncrement: inc() sets a new value (this.count.set(...)), causing the view to refresh.\nStable list: The list uses @for ... track it.id to minimize DOM churn.\nTips:\nImmutable updates: Create new object/array references so OnPush detects changes.\nAvoid deep mutation: Changing nested fields without replacing the reference may not re-render.\nWhen it runs: OnPush checks on input changes, events/async tasks, and signal updates.\nSignals Patterns\nUse computed() for derived values; recomputes only when dependencies change.\nUse effect() for side effects (logging, syncing); keep effects light and idempotent.\nRead signals in templates by calling them (e.g., {{ count() }}).\nExample explained\nsignal(): Holds state; read by calling it (count()).\ncomputed(): Derives double from count and re-computes when dependencies change.\neffect(): Runs side effects (here logging) whenever its dependencies update.\nStable Lists with track\nUse track with a unique key to prevent DOM churn (same idea as trackBy for *ngFor).\nKeeps list rendering fast and predictable.\nKey selection: Use stable unique IDs; avoid array index if items can reorder.\nControl flow syntax: With @for, track like @for (it of items(); track it.id).\nState preservation: Tracking prevents destroying/recreating DOM and component state unnecessarily.",
      "examples": [
        "import { ChangeDetectionStrategy, signal } from '@angular/core'; @Component({ changeDetection: ChangeDetectionStrategy.OnPush }) class Demo { items = signal([{ id: 1, label: 'A' }]); add() { this.items.update(a => [...a, { id: Date.now(), label: 'N' }]); } } // Template: @for (it of items(); track it.id) { ... }",
        "@Component({ changeDetection: ChangeDetectionStrategy.OnPush }) export class App { count = signal(0); inc() { this.count.set(this.count() + 1); } }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal, ChangeDetectionStrategy } from '@angular/core'; import { CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, changeDetection: ChangeDetectionStrategy.OnPush, imports: [CommonModule], template: ` <h3>OnPush + Signals</h3> <p>Count: {{ count() }}</p> <button (click)=\"inc()\">Increment</button> <ul> @for (it of items(); track it.id) { <li>{{ it.label }}</li> } </ul> ` }) export class App { count = signal(0); items = signal([{ id: 1, label: 'A' }, { id: 2, label: 'B' }]); inc() { this.count.set(this.count() + 1); } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { signal, computed, effect } from '@angular/core'; const count = signal(0); const double = computed(() => count() * 2); effect(() => console.log('double =', double()));",
        "@for (it of items(); track it.id) { <li>{{ it.label }}</li> }",
        "track",
        "trackBy",
        "ChangeDetectionStrategy.OnPush",
        "items",
        "update()",
        "@for",
        "track it.id",
        "OnPush",
        "count",
        "inc()",
        "this.count.set(...)",
        "@for ... track it.id",
        "computed()",
        "effect()",
        "{{ count() }}",
        "count()",
        "double",
        "*ngFor",
        "@for (it of items(); track it.id)"
      ]
    },
    {
      "title": "Angular Dynamic Components",
      "summary": "Create components at runtime with createComponent(), or render selectorless standalone components with *ngComponentOutlet.\nDynamic Components Essentials\ncreateComponent(): Create components at runtime and pass inputs, outputs, and directives directly.\nSelectorless components: Standalone components can be used without a selector via *ngComponentOutlet.\nSignals: Drive dynamic state from signal() and read in templates by calling the signal.\nNotes:\nRelated: See Control Flow for @if/@for, and Signals for state and effects.\nPrefer selectorless + *ngComponentOutlet for simple outlets; use createComponent() for fine-grained control (host element, directives, lifecycle).\ncreateComponent() with inputs & outputs\nProvide inputs/outputs and an optional hostElement to attach into the DOM.\nUse EnvironmentInjector (or inject()) so the component can resolve providers.\nExampleGet your own Angular Server\nRun Example »\nExample explained\ncreateComponent(Card, ...): Creates the Card component at runtime and returns a component ref.\nenvironmentInjector: Supplies DI so the dynamic component can resolve providers.\nhostElement: Attaches the component's host into the given DOM element (#host).\ninputs/outputs: Sets initial inputs and wires output callbacks (e.g., clicked).\nsetInput / destroy: Update inputs later with ref.setInput(...) and clean up via ref.destroy().\nNotes:\nCleanup: Always call destroy() on the component ref when removing it.\nUpdating inputs: Use setInput(name, value) on the component ref to push new input values.\nREMOVE ADS\nSelectorless via *ngComponentOutlet\nRender a standalone component without a selector using *ngComponentOutlet.\nPass inputs and outputs inline in the outlet micro-syntax.\nExample\nRun Example »\nExample explained\n*ngComponentOutlet=\"ActionButton\": Renders the standalone component class referenced by ActionButton.\ninputs / outputs: Pass values and event handlers directly in the outlet micro-syntax.\nSignals for state: The clicks signal holds state and updates the UI when onClick increments it.\nNotes:\nInputs/Outputs: The outlet micro-syntax supports inputs and outputs bags for easy wiring.\nComposition: Use outlets inside @if/@for for conditional or repeated dynamic UIs.",
      "examples": [
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, EventEmitter, Output, Input, ElementRef, ViewChild, inject, EnvironmentInjector, ComponentRef } from '@angular/core'; import { createComponent } from '@angular/core'; @Component({ standalone: true, template: ` <div style=\"padding:8px;border:1px solid #ddd;border-radius:6px;\"> <h4 style=\"margin:0 0 8px 0;\">{{ title }}</h4> <button (click)=\"clicked.emit()\">Click</button> </div> ` }) export class Card { @Input() title = 'Card'; @Output() clicked = new EventEmitter<void>(); } @Component({ selector: 'app-root', standalone: true, template: ` <h3>Dynamic createComponent()</h3> <div #host style=\"min-height:60px;border:1px dashed #aaa;padding:8px;border-radius:6px;\"></div> <div style=\"margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;\"> <button (click)=\"mount()\">Mount</button> <button (click)=\"update()\">Update input</button> <button (click)=\"unmount()\">Unmount</button> </div> ` }) export class App { @ViewChild('host', { read: ElementRef }) host!: ElementRef<HTMLElement>; env: EnvironmentInjector = inject(EnvironmentInjector); ref: ComponentRef<Card> | null = null; mount() { if (this.ref) return; this.ref = createComponent(Card, { environmentInjector: this.env, hostElement: this.host.nativeElement }); this.ref.setInput?.('title', 'Hello from Dynamic'); this.ref.instance.clicked.subscribe(() => alert('Card clicked')); } update() { if (!this.ref) return; this.ref.setInput?.('title', 'Updated Title ' + new Date().toLocaleTimeString()); } unmount() { this.ref?.destroy(); this.ref = null; } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, EventEmitter, Output, Input, signal } from '@angular/core'; import { NgComponentOutlet } from '@angular/common'; @Component({ standalone: true, template: `<button (click)=\"clicked.emit()\">{{ label }}</button>` }) export class ActionButton { @Input() label = 'Do it'; @Output() clicked = new EventEmitter<void>(); } @Component({ selector: 'app-root', standalone: true, imports: [NgComponentOutlet], template: ` <h3>Selectorless via *ngComponentOutlet</h3> <p>Clicks: {{ clicks() }}</p> <ng-container *ngComponentOutlet=\"ActionButton; inputs: { label: 'Launch' }; outputs: { clicked: onClick }\"></ng-container> ` }) export class App { ActionButton = ActionButton; clicks = signal(0); onClick = () => this.clicks.update(n => n + 1); } bootstrapApplication(App);",
        "createComponent()",
        "*ngComponentOutlet",
        "inputs",
        "outputs",
        "directives",
        "signal()",
        "@if",
        "@for",
        "hostElement",
        "EnvironmentInjector",
        "inject()",
        "Card",
        "#host",
        "clicked",
        "ref.setInput(...)",
        "ref.destroy()",
        "destroy()",
        "setInput(name, value)",
        "ActionButton",
        "clicks",
        "onClick"
      ]
    },
    {
      "title": "Angular Advanced DI",
      "summary": "Advanced DI uses hierarchical injectors, custom InjectionToken, optional and multi providers, and function-style inject() to compose flexible configurations.\nAdvanced DI Essentials\nScope: Hierarchical injectors mean providers at app/route/component levels define where instances live.\nTokens: Use InjectionToken for non-class values and configuration.\nFunction inject: Use inject() in constructors or utility functions.\nOptional & Multi: Optional dependencies and multi providers enable flexible composition.\nCode explained\nInjectionToken: Defines a typed token for non-class values and configuration.\ninject(TOKEN, { optional: true }): Retrieves a dependency and returns null/undefined when missing.\nmulti: true: Collects multiple provider values into an array for the same token.\nNotes:\nRelated: See Services & DI, Router, and App Bootstrap.\nUse InjectionToken for configuration, Use function-style inject() in utilities, and scope providers to routes/components when possible.\nREMOVE ADS\nAdvanced DI Example\nExampleGet your own Angular Server\nRun Example »\nExample explained\nFEATURES token: A multi provider token that aggregates strings contributed by providers.\ninject(FEATURES): Reads the aggregated array at runtime.\nDisplay: The template joins the features into a comma-separated list.\nNotes:\nTokens over types: Use InjectionToken for values and interfaces, not classes.\nMulti providers: Add multi: true to collect many contributions under one token.\nScope providers: Use providing at routes/components instead of root when you need isolation.\nOptional and Multi Providers\nUse @Optional() or inject(TOKEN, { optional: true }) when a dependency is not required.\nMulti providers let many values contribute to the same token.\nExample\nExample explained\nOptional inject: inject(USER_NAME, { optional: true }) returns a value when provided or null/undefined when absent.\nMulti providers: Multiple FEATURES entries are combined into an array.\nFallbacks: The template shows defaults when optional values are missing.\nNotes:\nOptional deps: Always handle null when a dependency is optional.\nAvoid collisions: Name tokens clearly to prevent accidental reuse across features.\nConfig pattern: Model global settings with tokens and override per route/component as needed.",
      "examples": [
        "import { InjectionToken, inject, Optional } from '@angular/core'; // Tokens export const CONFIG = new InjectionToken<{ api: string }>('CONFIG'); export const FEATURES = new InjectionToken<string[]>('FEATURES'); // Optional inject const cfg = inject(CONFIG, { optional: true }); // Multi providers bootstrapApplication(App, { providers: [ { provide: CONFIG, useValue: { api: '/api' } }, { provide: FEATURES, useValue: 'search', multi: true }, { provide: FEATURES, useValue: 'share', multi: true }, ] });",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, InjectionToken, inject } from '@angular/core'; const FEATURES = new InjectionToken<string[]>('FEATURES'); @Component({ selector: 'app-root', standalone: true, template: ` <h3>DI: Multi Providers</h3> <p>Features: {{ features.join(', ') }}</p> ` }) class App { features = inject(FEATURES); } bootstrapApplication(App, { providers: [ { provide: FEATURES, useValue: 'search', multi: true }, { provide: FEATURES, useValue: 'share', multi: true }, { provide: FEATURES, useValue: 'ai', multi: true } ] });",
        "<app-root></app-root>",
        "import { InjectionToken, inject, Optional } from '@angular/core'; export const USER_NAME = new InjectionToken<string>('USER_NAME'); // Constructor optional constructor(@Optional() public maybeName?: string) {} // Function optional const name = inject(USER_NAME, { optional: true });",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, InjectionToken, inject } from '@angular/core'; const USER_NAME = new InjectionToken<string>('USER_NAME'); const FEATURES = new InjectionToken<string[]>('FEATURES'); @Component({ selector: 'app-root', standalone: true, template: ` <h3>Optional & Multi</h3> <p>Hello: {{ name || 'Anonymous' }}</p> <p>Features: {{ features?.join(', ') || '∅' }}</p> ` }) class App { name = inject(USER_NAME, { optional: true }); features = inject(FEATURES, { optional: true }); } bootstrapApplication(App, { providers: [ // Try commenting USER_NAME to see optional behavior { provide: USER_NAME, useValue: 'Dana' }, { provide: FEATURES, useValue: 'search', multi: true }, { provide: FEATURES, useValue: 'share', multi: true }, ] });",
        "InjectionToken",
        "inject()",
        "null",
        "undefined",
        "multi: true",
        "@Optional()",
        "inject(TOKEN, { optional: true })",
        "inject(USER_NAME, { optional: true })",
        "null/undefined",
        "FEATURES"
      ]
    },
    {
      "title": "Angular Router Advanced",
      "summary": "Advanced routing covers functional guards/resolvers with inject(), auxiliary outlets for multiple views, and preloading strategies; return a UrlTree to redirect.\nRouter Advanced Essentials\nFunctional guards/resolvers: Use functions with inject() for type-safe navigation.\nAux outlets: Named RouterOutlets render multiple views (e.g., /inbox(compose:modal)).\nPreloading & data: Use data for static flags and preloading strategies to optimize navigation.\nCode explained\ninject(Router): Accesses the Router inside a guard function.\nUrlTree redirect: Return router.createUrlTree(['/']) to redirect instead of navigating imperatively.\nAux outlet: A route with outlet: 'modal' targets a named RouterOutlet.\nNotes:\nRelated: See Router, Services, and App Bootstrap.\nUse functional guards with inject().\nGuard types: canActivate, canDeactivate, canMatch (decide if a route config matches), canLoad (block loading lazy content).\nReturn a UrlTree for redirects.\nCode explained\nCanDeactivateFn: Decide if navigation away is allowed (e.g., confirm dialog).\nCanMatchFn: Decide if a route definition should match the current URL segments.\nREMOVE ADS\nFunctional Guards with inject()\nExampleGet your own Angular Server\nRun Example »\nExample explained\nFunctional guard: canActivate() uses inject(Router) and returns a UrlTree when blocked.\nSignal state: The isLoggedIn signal drives the guard's allow/deny result.\nLinks + outlet: Navigation uses routerLink and <router-outlet> renders the active route.\nNotes:\nUse functions: Write guards as pure functions and use inject() to access services.\nRedirects: Return a UrlTree instead of navigating imperatively.\nKeep them fast: Avoid heavy work in guards; delegate to services and cache where possible.\nPreloading and Route Data\nUse route data for static flags (titles, permissions).\nLazy load features and enable preloading to optimize navigation.\nCode explained\nwithPreloading(PreloadAllModules): Preloads lazy routes in the background after initial load.\ndata: Static route data holds metadata like titles/flags for reuse.\nNotes:\nRoute data: Use data for static flags (titles, permissions) over hardcoding in components.\nPreloading: Use strategies to fetch likely-next modules in the background.\nMeasure: Profile bundle sizes and navigation timing before/after enabling preloading.",
      "examples": [
        "import { inject } from '@angular/core'; import { Router, Routes, provideRouter, withPreloading, PreloadAllModules } from '@angular/router'; function canActivate() { const router = inject(Router); return /* condition */ true || router.createUrlTree(['/']); } const routes: Routes = [ { path: 'feature', loadComponent: () => import('./feature').then(m => m.Feature), data: { title: 'Feature' }, canActivate: [canActivate] }, { path: 'inbox', loadComponent: () => import('./inbox').then(m => m.Inbox) }, { path: 'compose', outlet: 'modal', loadComponent: () => import('./compose').then(m => m.Compose) } ]; provideRouter(routes, withPreloading(PreloadAllModules));",
        "import { CanDeactivateFn, CanMatchFn } from '@angular/router'; // canDeactivate: confirm navigation away const canDeactivate: CanDeactivateFn<any> = (component, curr, currState, nextState) => confirm('Leave this page?'); // canMatch: decide if a route config should match current URL const canMatch: CanMatchFn = (route, segments) => segments[0]?.path === 'secret';",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, signal, inject } from '@angular/core'; import { Routes, provideRouter, Router, RouterOutlet } from '@angular/router'; const isLoggedIn = signal(false); function canActivate() { const router = inject(Router); return isLoggedIn() || router.createUrlTree(['/']); } @Component({ selector: 'home-page', standalone: true, template: `<p>Home</p> <button (click)=\"login()\">Login</button>` }) class Home { login() { isLoggedIn.set(true); } } @Component({ selector: 'secret-page', standalone: true, template: `<p>Top Secret</p>` }) class Secret {} const routes: Routes = [ { path: '', component: Home }, { path: 'secret', component: Secret, canActivate: [canActivate] } ]; @Component({ selector: 'app-root', standalone: true, imports: [RouterOutlet], template: `<a [routerLink]=\"['/']\">Home</a> | <a [routerLink]=\"['/secret']\">Secret</a> <router-outlet></router-outlet>` }) class App {} bootstrapApplication(App, { providers: [provideRouter(routes)] });",
        "<app-root></app-root>",
        "provideRouter(routes, withPreloading(PreloadAllModules)); // Route with data { path: 'feature', loadComponent: () => import('./feature').then(m => m.Feature), data: { title: 'Feature' } }",
        "inject()",
        "UrlTree",
        "RouterOutlet",
        "/inbox(compose:modal)",
        "data",
        "router.createUrlTree(['/'])",
        "outlet: 'modal'",
        "canActivate",
        "canDeactivate",
        "canMatch",
        "canLoad",
        "canActivate()",
        "inject(Router)",
        "isLoggedIn",
        "routerLink",
        "<router-outlet>"
      ]
    },
    {
      "title": "Angular HTTP Interceptors",
      "summary": "HTTP interceptors are functions in the HttpClient pipeline that let you add headers, log, handle errors, and retry in one place.\nHTTP Interceptors Essentials\nInspect or transform requests and responses globally.\nAn interceptor is a function in the HttpClient pipeline that runs for every request/response.\nCommon uses: auth headers, error handling, retries, logging.\nNotes:\nRelated: See HttpClient and Services.\nChain small, single-purpose interceptors.\nHandle errors centrally to keep components slim.\nWriting an Interceptor\nExampleGet your own Angular Server\nRun Example »\nExample explained\nwithInterceptors([fn]): Registers one or more interceptor functions that run for every request and response.\nInterceptor fn (req, next): Optionally req.clone(...) to modify the request, then call next(req) to continue.\nprovideHttpClient(...): Enables HttpClient and composes interceptors at bootstrap.\nNotes:\nOrder: Requests flow in provided order; responses unwind in reverse.\nImmutable: Use req.clone({...}) to modify HttpRequest.\nSingle-purpose: Compose focused interceptors with withInterceptors([...]).\nREMOVE ADS\nError Handling and Retries\nCentralize HTTP error handling in an interceptor.\nKeep components simpler by mapping errors to user-friendly messages.\nAdd retry logic carefully with backoff; avoid retrying non‑retryable errors (e.g., 4xx).\nGuidelines:\nUse catchError in the interceptor to map errors to user-friendly messages.\nRetry idempotent requests with retry or backoff using retryWhen; avoid retrying 4xx errors.\nHandle auth (401) by refreshing tokens or redirecting; avoid doing navigation from many places-keep it centralized.\nOrdering & Composition\nCompose small interceptors and mind the order they run in.\nRequests flow in the order provided; responses unwind in reverse.\nOrder: Requests flow through interceptors in the order provided; responses unwind in reverse.\nSingle-purpose: Keep interceptors focused (auth, logging, error handling) and compose with withInterceptors([...]).\nStateless: Avoid storing mutable state inside interceptors; Use pure functions and injected services.\nRetry safety: Retry only idempotent methods (e.g., GET/HEAD).\nAvoid retrying non-idempotent methods unless you use idempotency keys.",
      "examples": [
        "import { provideHttpClient, withInterceptors } from '@angular/common/http'; const authInterceptor = (req, next) => { const cloned = req.clone({ setHeaders: { Authorization: 'Bearer token' } }); return next(cloned); }; bootstrapApplication(App, { providers: [provideHttpClient(withInterceptors([authInterceptor]))] });",
        "const logInterceptor = (req, next) => { console.log(req.method, req.url); return next(req); }; provideHttpClient(withInterceptors([logInterceptor]));",
        "import { HttpInterceptorFn } from '@angular/common/http'; const typedInterceptor: HttpInterceptorFn = (req, next) => { // Example: add a header return next(req.clone({ setHeaders: { 'X-Trace': 'demo' } })); }; provideHttpClient(withInterceptors([typedInterceptor]));",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, inject } from '@angular/core'; import { HttpClient, provideHttpClient, withInterceptors, HttpResponse, HttpRequest, HttpHandlerFn } from '@angular/common/http'; import { of } from 'rxjs'; import { JsonPipe } from '@angular/common'; const logInterceptor = (req: HttpRequest<any>, next: HttpHandlerFn) => { console.log('Request', req.method, req.url); return next(req); }; // Mock interceptor so the demo runs without external network const mockInterceptor = (req: HttpRequest<any>, next: HttpHandlerFn) => { if (req.method === 'GET' && req.url.includes('jsonplaceholder.typicode.com/todos/1')) { const body = { id: 1, title: 'Mocked todo', completed: false }; return of(new HttpResponse({ status: 200, body })); } return next(req); }; @Component({ selector: 'app-root', standalone: true, imports: [JsonPipe], template: ` <h3>HTTP Interceptor</h3> <button (click)=\"load()\">Load</button> <pre>{{ data | json }}</pre> ` }) class App { #http = inject(HttpClient); data: any; load() { this.#http.get('https://jsonplaceholder.typicode.com/todos/1').subscribe(r => this.data = r); } } bootstrapApplication(App, { providers: [provideHttpClient(withInterceptors([mockInterceptor, logInterceptor]))] });",
        "<app-root></app-root>",
        "import { catchError } from 'rxjs/operators'; import { throwError } from 'rxjs'; const errorInterceptor = (req, next) => next(req).pipe( catchError(err => { // map/log/notify return throwError(() => err); }) ); provideHttpClient(withInterceptors([errorInterceptor]));",
        "const auth = (req, next) => next(req.clone({ setHeaders: { Authorization: '...' } })); const log = (req, next) => { console.log(req.url); return next(req); }; // Request order: auth -> log // Response order: log -> auth provideHttpClient(withInterceptors([auth, log]));",
        "req.clone(...)",
        "next(req)",
        "req.clone({...})",
        "HttpRequest",
        "withInterceptors([...])",
        "catchError",
        "retry",
        "retryWhen"
      ]
    },
    {
      "title": "Angular Reactive Forms Advanced",
      "summary": "Advanced reactive forms model complex data with FormGroup/FormArray, combine sync/async validators, and update efficiently with patchValue and updateOn; observe valueChanges/statusChanges for reactive logic.\nReactive Forms Advanced Essentials\nStructure: Use FormGroup and FormArray to model complex forms.\nValidation: Combine sync and async validators at control and group levels.\nUpdates: Use patchValue for partial updates; setValue requires the full shape.\nExample explained\nfb.group({...}): Creates a FormGroup with controls and validators.\nFormArray: Holds an ordered list of controls/groups for dynamic rows.\nPush a row: (form.get('tags') as FormArray).push(fb.group({ label: [''] })) adds a new group.\nNotes:\nRelated: See Forms and Services & DI.\nKeep form state in a service for reuse across routes.\nsetValue vs patchValue: setValue requires the full shape; patchValue updates a subset.\nValidate at the control and group levels.\nREMOVE ADS\nNested Groups and Arrays\nGroup related controls for structure and reuse.\nUse FormArray for dynamic lists like tags or items. A FormArray is an ordered list of controls whose length can change at runtime.\nExample explained\nfb.array([...]): Initializes a FormArray with one FormGroup row.\nAdd row: tags.push(fb.group({ label: [''] })) appends another tag group.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n[formGroup]: Binds the form model to the template.\nformArrayName: Points to the tags array; each row uses [formGroupName]=\"i\".\nGetter + push: The tags getter returns the FormArray; addTag() pushes a new group.\nSubmit: Reads form.value, which reflects the nested group/array structure.\nBinding tips: Use formArrayName and [formGroupName] for each row to keep bindings aligned.\nConsistent shapes: Push groups with the same control shape to a FormArray; avoid mixing primitives and groups.\nDynamic lists: When rendering with *ngFor, use trackBy to keep inputs stable while adding/removing rows.\nValidation Strategies\nUse synchronous validators for most rules; they are fast and simple.\nUse async validators for server checks/uniqueness; they run after sync validators.\nKeep validation lean and debounce inputs before async checks.\nExample explained\nValidator factory: banned([...]) returns a function (c: AbstractControl) => ValidationErrors | null.\nControl-level: Attach sync validators like Validators.required and custom rules to a control.\nGuidelines:\nUse group-level validators for cross-field rules (e.g., password match).\nReduce churn with updateOn: 'blur' | 'submit' (delay validation/value changes until that event) when appropriate.\nShow errors based on touched/dirty to avoid noisy UX.\nAsync validators should be fast and cancelable; debounce inputs before triggering server checks.",
      "examples": [
        "import { FormBuilder, Validators, FormArray } from '@angular/forms'; fb.group({ name: ['', Validators.required], tags: fb.array([ fb.group({ label: ['Angular'] }) ]) }); // Add row (form.get('tags') as FormArray).push(fb.group({ label: [''] }));",
        "const tags = fb.array([ fb.group({ label: ['Angular'] }) ]); tags.push(fb.group({ label: [''] }));",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { ReactiveFormsModule, FormBuilder, Validators, FormArray } from '@angular/forms'; import { JsonPipe, CommonModule } from '@angular/common'; @Component({ selector: 'app-root', standalone: true, imports: [CommonModule, ReactiveFormsModule, JsonPipe], template: ` <h3>Advanced Reactive Form</h3> <form [formGroup]=\"form\" (ngSubmit)=\"submit()\"> <input placeholder=\"Name\" formControlName=\"name\"> <div formArrayName=\"tags\"> <div *ngFor=\"let t of tags.controls; let i = index\" [formGroupName]=\"i\"> <input placeholder=\"Tag\" formControlName=\"label\"> </div> </div> <button type=\"button\" (click)=\"addTag()\">Add Tag</button> <button type=\"submit\">Submit</button> </form> <pre>{{ form.value | json }}</pre> ` }) class App { fb = new FormBuilder(); form = this.fb.group({ name: ['', Validators.required], tags: this.fb.array([this.fb.group({ label: ['Angular'] })]) }); get tags(): FormArray { return this.form.get('tags') as FormArray; } addTag() { this.tags.push(this.fb.group({ label: [''] })); } submit() { alert(JSON.stringify(this.form.value)); } } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { AbstractControl, ValidationErrors } from '@angular/forms'; function banned(value: string[]): (c: AbstractControl): ValidationErrors | null { return (c) => value.includes(c.value) ? { banned: true } : null; } fb.control('', [Validators.required, banned(['admin'])]);",
        "// Group-level validator and updateOn: 'blur' import { AbstractControl, ValidationErrors } from '@angular/forms'; function samePassword(group: AbstractControl): ValidationErrors | null { const pass = group.get('pass')?.value; const confirm = group.get('confirm')?.value; return pass === confirm ? null : { mismatch: true }; } const form = fb.group( { pass: [''], confirm: [''] }, { validators: samePassword, updateOn: 'blur' } );",
        "FormGroup",
        "FormArray",
        "patchValue",
        "updateOn",
        "valueChanges",
        "statusChanges",
        "setValue",
        "(form.get('tags') as FormArray).push(fb.group({ label: [''] }))",
        "tags.push(fb.group({ label: [''] }))",
        "tags",
        "[formGroupName]=\"i\"",
        "addTag()",
        "form.value",
        "formArrayName",
        "[formGroupName]",
        "*ngFor",
        "trackBy",
        "banned([...])",
        "(c: AbstractControl) => ValidationErrors | null",
        "Validators.required",
        "updateOn: 'blur' | 'submit'",
        "touched",
        "dirty"
      ]
    },
    {
      "title": "Angular State Management",
      "summary": "State management organizes how data changes over time.\nState Management Essentials\nLocal first: Start with component signals; promote to a service (store) only when sharing is needed.\nSignals: Use signal() for local and service-backed state; derive with computed().\nInterop: Use RxJS only when stream semantics are required; keep global state minimal.\nNotes:\nRelated: See Signals, Services, and Change Detection.\nStart with a simple service + signals; reach for libraries only when complexity demands it.\nService-backed Signals (Store)\nLift state into a service to share across components.\nIt improves reuse.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nCounterStore: A service holding a signal and an update method (inc()).\ninject(CounterStore): Retrieves the store in the component (no constructor required).\nstore.count(): Read the current value in the template; clicking the button calls store.inc().\nDesign tips:\nKeep a single source of truth per feature in a service; inject where needed.\nExpose methods for updates; avoid mutating state from components directly.\nDerive values with computed signals; keep side effects (like persistence) in the service.\nBridge to streams only when needed (e.g., to interop with RxJS-based APIs).\nREMOVE ADS\nLocal vs Global State\nKeep most state local to components to reduce coupling.\nPromote to a shared service only when multiple features need it.\nScope providers at the feature/route level when isolation is desired.\nGuidelines:\nPromote state when multiple routes/components need the same data or when caching improves UX.\nSeparate UI state (filters, dialogs) from server/cache state; manage them independently.\nInitialize lazily on first use and consider reset points (e.g., on logout).",
      "examples": [
        "import { Injectable, signal, computed, inject } from '@angular/core'; @Injectable({ providedIn: 'root' }) class CounterStore { count = signal(0); double = computed(() => this.count() * 2); inc() { this.count.update(n => n + 1); } } // Component: const store = inject(CounterStore);",
        "import { Injectable, signal, inject } from '@angular/core'; @Injectable({ providedIn: 'root' }) class CounterStore { count = signal(0); inc() { this.count.update(n => n + 1); } } // Component usage class App { store = inject(CounterStore); }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component, Injectable, signal, inject } from '@angular/core'; @Injectable({ providedIn: 'root' }) class CounterStore { count = signal(0); inc() { this.count.update(n => n + 1); } } @Component({ selector: 'app-root', standalone: true, template: ` <h3>Service with Signals</h3> <p>Count: {{ store.count() }}</p> <button (click)=\"store.inc()\">Increment</button> ` }) class App { store = inject(CounterStore); } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { provideRouter, Routes } from '@angular/router'; const routes: Routes = [ { path: '', component: Home, providers: [CounterStore] } ]; bootstrapApplication(App, { providers: [provideRouter(routes)] });",
        "signal()",
        "computed()",
        "CounterStore",
        "signal",
        "inc()",
        "inject(CounterStore)",
        "store.count()",
        "store.inc()"
      ]
    },
    {
      "title": "Angular Animations",
      "summary": "Animations in Angular are declarative: define trigger/transition/animate in the component and toggle state from data; enable app‑wide with provideAnimations().\nAnimations Essentials\ntrigger: Define a named animation bound in the template (e.g., [@openClose]).\ntransition: Declare when it runs (state changes or wildcards like * <=> *).\nanimate: Set duration/easing and final styles via style().\nSetup:\nInstall: npm install @angular/animations\nEnable: Provide animations app-wide with provideAnimations() from @angular/platform-browser/animations.\nOpt-out: Use provideNoopAnimations() to disable motion (e.g., in tests).\nExample explained\ntrigger('openClose'): Defines a named animation used in the template with [@openClose].\nstate(): Declares end styles for each state (e.g., open and closed).\ntransition('open <=> closed'): Runs when switching between states; animate('200ms ease-in-out') sets duration/easing.\nNotes:\nRelated: See Components and Templates.\nKeep animations declarative in the component and toggle via state.\nREMOVE ADS\nComponent Animations\nDefine triggers on the component.\nToggle state through data to keep templates simple.\nExampleGet your own Angular Server\nRun Example »\nExample explained\n[@openClose]: Binds the element to the openClose trigger and uses the component's state as 'open' or 'closed'.\nToggling: Clicking the button flips open to run the open <=> closed transition.\nprovideAnimations(): Enables Angular animations app‑wide so transitions run.\nPerformance: Use animating opacity/transform for smoother motion; layout properties (like width/height) can be more expensive.\nState-driven: Keep animations declarative and driven by component state.\nAvoid imperative DOM calls.\nAccessibility: Respect prefers-reduced-motion with shorter or disabled animations when appropriate.\nProviding Animations\nUse provideAnimations() to enable animations across the app.\nUse provideNoopAnimations() in tests or when you want to disable motion.\nNotes:\nTesting: Disable animations in tests for stable timing using provideNoopAnimations().\nConditional enablement: Feature-flag or disable heavy animations on low-power devices.",
      "examples": [
        "import { trigger, state, style, transition, animate } from '@angular/animations'; @Component({ animations: [ trigger('openClose', [ state('open', style({ opacity: 1 })), state('closed', style({ opacity: 0 })), transition('open <=> closed', [animate('200ms ease-in-out')]) ]) ] }) class App {}",
        "<div [@openClose]=\"open ? 'open' : 'closed'\">...</div> toggle() { this.open = !this.open; }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; import { trigger, state, style, transition, animate } from '@angular/animations'; import { provideAnimations } from '@angular/platform-browser/animations'; @Component({ selector: 'app-root', standalone: true, animations: [ trigger('openClose', [ state('open', style({ height: '80px', opacity: 1 })), state('closed', style({ height: '0px', opacity: 0 })), transition('open <=> closed', [animate('200ms ease-in-out')]) ]) ], template: ` <h3>Animations</h3> <button (click)=\"open = !open\">Toggle</button> <div [@openClose]=\"open ? 'open' : 'closed'\" style=\"overflow:hidden;background:#e3f2fd;margin-top:8px\">Panel</div> ` }) class App { open = true; } bootstrapApplication(App, { providers: [provideAnimations()] });",
        "<app-root></app-root>",
        "import { animation, style, animate, useAnimation } from '@angular/animations'; // Reusable animation definition export const fadeIn = animation([ style({ opacity: 0 }), animate('{{time}} ease-out', style({ opacity: 1 })) ]); // In component trigger: // transition(':enter', [ useAnimation(fadeIn, { params: { time: '200ms' } }) ])",
        "import { provideAnimations, provideNoopAnimations } from '@angular/platform-browser/animations'; bootstrapApplication(App, { providers: [provideAnimations()] }); // Tests or opt-out: // bootstrapApplication(App, { providers: [provideNoopAnimations()] });",
        "trigger",
        "transition",
        "animate",
        "provideAnimations()",
        "[@openClose]",
        "* <=> *",
        "style()",
        "npm install @angular/animations",
        "@angular/platform-browser/animations",
        "provideNoopAnimations()",
        "open",
        "closed",
        "animate('200ms ease-in-out')",
        "openClose",
        "'open'",
        "'closed'",
        "open <=> closed",
        "opacity",
        "transform",
        "prefers-reduced-motion"
      ]
    },
    {
      "title": "Angular Testing",
      "summary": "Testing verifies components and services with lightweight setups.\nTesting Essentials\nComponent & services: Test with DOM-style checks and lightweight setups (no NgModules needed).\nTestBed (lite): Create components with their providers efficiently.\nPure logic: Keep logic in pure functions for easy testing.\nMocks: Mock HTTP and the router as needed.\nNotes:\nRelated: See Components and Services.\nUse small, deterministic tests.\nMock HTTP and router in unit tests.\nComponent Smoke Test\nExampleGet your own Angular Server\nRun Example »\nExample explained\nInterpolation {{ expression }}: Angular evaluates the expression against the component and inserts the result as text in the DOM.\n“expect 5”: The phrase in the template is explanatory text for the reader, not a test assertion.\nReal assertions: In unit tests, use expect(actual).toBe(expected) (or toEqual(expected)) to verify results.\nTips:\nDisable animations in tests with provideNoopAnimations() for stable timing.\nDrive the DOM via component state; avoid manual DOM calls.\nTrigger change detection only when needed (e.g., after updating inputs).\nREMOVE ADS\nTest Strategies\nUnit test pure functions directly for fast feedback.\nUse shallow component tests for template behavior.\nAdd integration tests where behavior spans components.\nAsync testing example\nExample explained\nexpect(actual): Creates an assertion with the actual value under test. Use toBe(expected) for strict equality (===), toEqual(expected) for deep structural equality, and toBeTrue()/toBeFalse() for boolean checks.\nfakeAsync(testFn): Runs testFn in a fake async zone so time can be advanced deterministically.\ntick(ms): Advances the virtual clock by ms milliseconds to flush pending timers and microtasks.\nAlternatives: waitForAsync(testFn) completes the test after pending async work; whenStable() resolves when no tasks remain.\nHTTP testing (conceptual)\nExample explained\nHttpClientTestingModule: Provides a mock backend for HttpClient so no real network calls are made.\nHttpTestingController: Lets you inspect, match, and respond to HTTP requests made by HttpClient.\nexpectOne(match): Asserts there is exactly one pending request matching match (URL string, RegExp, or predicate) and returns a TestRequest.\nflush(body, options?): Sends a mock response for the matched request with the given body and optional options (e.g., status, statusText, headers).\nverify(): Fails the test if there are unmatched or outstanding requests at the end.\nGuidelines:\nHTTP: Use HttpClientTestingModule and HttpTestingController to mock requests.\nRouter: Use the router testing utilities to avoid real navigation.\nAsync: Use fakeAsync/tick or waitForAsync/whenStable instead of timers.\nQueries: Use stable selectors and role/text queries over brittle CSS when possible.",
      "examples": [
        "// Disable animations in tests for stability import { provideNoopAnimations } from '@angular/platform-browser/animations'; bootstrapApplication(App, { providers: [provideNoopAnimations()] });",
        "@Component({ standalone: true, template: `<p>{{ add(2,3) }}</p>` }) class App { add(a:number,b:number){ return a+b; } }",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; function add(a: number, b: number) { return a + b; } @Component({ selector: 'app-root', standalone: true, template: ` <h3>Testing Smoke</h3> <p>2 + 3 = {{ add(2,3) }} (expect 5)</p> ` }) class App { add = add; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { fakeAsync, tick } from '@angular/core/testing'; it('waits for async work', fakeAsync(() => { let done = false; setTimeout(() => done = true, 10); tick(10); expect(done).toBeTrue(); }));",
        "// HTTP testing (conceptual) import { TestBed } from '@angular/core/testing'; import { HttpClient } from '@angular/common/http'; import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing'; TestBed.configureTestingModule({ imports: [HttpClientTestingModule] }); const http = TestBed.inject(HttpClient); const httpMock = TestBed.inject(HttpTestingController); http.get('/api/todos/1').subscribe(data => expect(data).toBeTruthy()); httpMock.expectOne('/api/todos/1').flush({ id: 1, title: 'Test' }); httpMock.verify();",
        "expect(actual).toBe(expected)",
        "toEqual(expected)",
        "provideNoopAnimations()",
        "toBe(expected)",
        "toBeTrue()",
        "toBeFalse()",
        "testFn",
        "ms",
        "waitForAsync(testFn)",
        "whenStable()",
        "HttpClient",
        "RegExp",
        "TestRequest",
        "status",
        "statusText",
        "headers",
        "HttpClientTestingModule",
        "HttpTestingController",
        "fakeAsync",
        "tick",
        "waitForAsync",
        "whenStable"
      ]
    },
    {
      "title": "Angular Security",
      "summary": "Angular defends against XSS by sanitizing template bindings.\nSecurity Essentials\nXSS protection: Angular sanitizes template bindings to block script injection.\nSanitization: Dangerous values are stripped or transformed before writing to the DOM.\nBind properties: Use property bindings over string concatenation for URLs/HTML.\nAvoid bypass: Only use DomSanitizer in audited, rare cases.\nRelated: See HTTP and Templates.\nTip: Bind with [href]/[src]/[innerHTML] and let Angular sanitize.\nOnly use DomSanitizer in rare, audited cases.\nSanitization Basics\nExampleGet your own Angular Server\nRun Example »\nExample explained\n[innerHTML]: Angular sanitizes bound HTML, removing dangerous content (e.g., scripts).\nProperty bindings: Use [innerHTML]/[href]/[src] so the sanitizer runs.\nInterpolation: {{ ... }} escapes HTML by default; use bindings for safe HTML insertion.\nKey points:\nAngular sanitizes values bound to [innerHTML], [src], and [href].\nAvoid string concatenation for HTML/URLs.\nUse property bindings so the sanitizer runs.\nAvoid bypassing sanitizer; Use safe data flow and templates.\nREMOVE ADS\nSafe DOM APIs\nUse property bindings for URLs and HTML to ensure the sanitizer runs.\nAudit any use of DomSanitizer.bypassSecurityTrust*; document scope and rationale.\nLimit bypass to vetted, static content paths encapsulated in small utilities.\nGuidelines:\nDo not pass untrusted/user input to bypassSecurityTrust*.\nOnly bypass for vetted, static sources; encapsulate in a small utility with comments.\nEnable Content Security Policy (CSP); consider Trusted Types for stronger XSS defenses.",
      "examples": [
        "// Angular sanitizes [innerHTML], [href], [src] @Component({ template: `<div [innerHTML]=\"html\"></div>` }) class C { html = '<b>Hello</b> <script>alert(1)</script>'; }",
        "// Property binding runs the sanitizer <img [src]=\"photoUrl\" alt=\"...\"> <a [href]=\"profileUrl\">Profile</a>",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>Sanitized HTML</h3> <div [innerHTML]=\"html\"></div> ` }) class App { html = `Hello <script>alert('xss')</script>`; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { DomSanitizer } from '@angular/platform-browser'; // Use: [href]=\"safeUrl\" with validated values // Avoid bypass unless strictly necessary and audited: // const safe = sanitizer.bypassSecurityTrustUrl(untrusted);",
        "DomSanitizer",
        "[href]",
        "[src]",
        "[innerHTML]",
        "{{ ... }}",
        "DomSanitizer.bypassSecurityTrust*",
        "bypassSecurityTrust*"
      ]
    },
    {
      "title": "Angular SSR & Hydration",
      "summary": "SSR renders HTML on the server, and hydration reuses that HTML on the client by attaching state and listeners.\nSSR & Hydration Essentials\nSSR: Pre-renders HTML on the server for faster first paint and SEO.\nHydration: Reuses server HTML on the client by wiring up state and listeners (no full re-render).\nDeterminism: Keep render output predictable; make effects idempotent.\nRelated: See App Bootstrap, Router, and HTTP.\nTip: Keep effects idempotent and avoid non-deterministic rendering to ensure smooth hydration.\nHydration-safe Checks\nOnly call browser-only APIs when running in the browser.\nGuard with feature detection or platform checks.\nExampleGet your own Angular Server\nRun Example »\nExample explained\nisBrowser: Uses typeof window !== 'undefined' to check if code runs in the browser.\nHydration-safe: Avoids accessing browser-only APIs during server render; reads them only after hydration on the client.\nSSR → Hydration: Server renders initial HTML; the client attaches listeners/state without re-rendering the whole view.\nGuidelines:\nAvoid accessing window/document during SSR.\nCheck availability first.\nDefer side effects (e.g., event listeners, measurements) until after hydration.\nUse feature detection over user-agent checks.\nREMOVE ADS\nSSR Tips\nUse pure, deterministic templates (avoid random values during render).\nDefer heavy work to effects that run post-hydration.\nUse TransferState to reuse SSR-fetched data on the client.\nBest practices:\nStabilize IDs across server and client to avoid mismatch.\nAvoid time-based randomness during render; compute after hydration where needed.\nCache SSR-fetched data via TransferState to prevent double-fetch.",
      "examples": [
        "// Deterministic render (no random IDs during render) @Component({ template: `<div>Hello</div>` }) class App {}",
        "// Simple feature detection const isBrowser = typeof window !== 'undefined'; // Angular platform check import { PLATFORM_ID, inject } from '@angular/core'; import { isPlatformBrowser } from '@angular/common'; const platformId = inject(PLATFORM_ID); const onBrowser = isPlatformBrowser(platformId);",
        "import { bootstrapApplication } from '@angular/platform-browser'; import { Component } from '@angular/core'; @Component({ selector: 'app-root', standalone: true, template: ` <h3>SSR & Hydration</h3> <p>Is Browser: {{ isBrowser }}</p> ` }) class App { isBrowser = typeof window !== 'undefined'; } bootstrapApplication(App);",
        "<app-root></app-root>",
        "import { TransferState, makeStateKey } from '@angular/platform-browser'; const DATA_KEY = makeStateKey\n('initial-data'); // Server: state.set(DATA_KEY, data) // Client: const cached = state.get(DATA_KEY, null);",
        "typeof window !== 'undefined'",
        "window",
        "document"
      ]
    },
    {
      "title": "Angular Online Compiler",
      "summary": "Angular Compiler (Editor)\nCreate, edit, and run Angular-friendly projects in W3Schools Spaces.\nSpaces lets you build and host web apps using a Node.js environment with zero setup.\nEdit your code directly in the browser and share your projects easily.\nThe code editor includes:\nTemplates: Start from scratch or use a template\nCloud-based: No installations. Just your browser\nTerminal & Log: Debug and troubleshoot your code\nFile Navigator: Switch between files quickly\nPractice Faster\nUse W3Schools Spaces to build, test, and deploy Angular examples.\nNew languages and templates are added regularly.",
      "examples": []
    },
    {
      "title": "Angular Exercises",
      "summary": "Exercises\nTest your Angular skills with exercises from core topics:\nIntro\nGet Started\nFirst App\nTemplates\nInterpolation\nReference Variables\nNull-Safe Navigation (?.)\nStructural Directives\nngTemplateOutlet\nStatements and $event\nAlias\nPipes (|)\nAttribute Binding\nTrackBy\nComponents\nData Binding\nDirectives\nEvents\nConditional Rendering\nLists\nForms\nRouter\nServices\nHTTP\nPipes\nLifecycle\nCSS Styling\nApp Bootstrap\nControl Flow\nSignals\nChange Detection\nAdvanced DI\nRouter Advanced\nHTTP Interceptors\nReactive Forms Advanced\nState Management\nAnimations\nTesting\nSecurity\nSSR & Hydration\nDynamic Components\nREMOVE ADS\nLog in to track your progress\nIf you haven't already, sign up to become a W3Schooler, and get points for every exercise you complete.\nAs a logged on W3Schools user you will have access to many features like having your own web page, track your learning progress, receive personal guided paths, and more.\nThe Exercise\nWe have gathered a variety of Angular exercises from our Angular Tutorial.\nThe exercises are a mix of \"multiple choice\" and \"fill in the blanks\" questions.\nIf you're stuck, you can try again or hit the \"Show Answer\" button.",
      "examples": []
    },
    {
      "title": "Angular Quiz",
      "summary": "You can test your Angular skills with W3Schools' Quiz.\nThe Test\nThe test contains 25 questions and there is no time limit.\nThe test is not official; it's a nice way to see how much you know (or don't know) about Angular.\nCount Your Score\nYou will get 1 point for each correct answer. At the end of the Quiz your total score will be displayed. Maximum score is 25 points.\nStart the Quiz\nGood luck!\nStart the Angular Quiz ❯\nIf you don't know Angular, we suggest that you read our Angular Tutorial from scratch.",
      "examples": []
    },
    {
      "title": "Angular Server Create Angular Server Powerful Code Editor Practice Makes Perfect kAI",
      "summary": "Coding Skills\nAI Tutor\nProjects\nSecurely\nChoose your Plan\nBy subscribing to a plan you support the W3Schools mission to make\nlearning available to everyone - no matter their background.\n$0 /Forever\nThis is for you that are beginning to explore coding and web development\nTrack your progress\nSet your goals\nBuild and host 1 static website\n100 credits/month\nAccess various AI features like W3Schools kAI coding tutor and interview preparation.\nNo support\n$14.99 /Month\nThis is for you that want to learn and reach your goals faster. Build fullstack projects, ad free experience.\nAd-free experience\nUnlimited challenges\nUnlimited practice tests\nBuild and host 15 static websites\nBuild and host 1 full stack server\nChoose from 75+ templates\n10000 credits/month\nAccess various AI features like W3Schools kAI coding tutor and interview preparation.\nCancel anytime\nFor teachers\nSpend less time on admin tasks while engaging your students. Help them learn, practice and collaborate. All in one place.\nAd-free for focused learning\nDashboard to manage your classroom\nStudy plans for structured learning\nTrack progress with insights\nInteractive code challenges and projects\nAccess to all courses and certification exams\nSpaces for building and publishing projects\n25% OFF\nYou can also buy a domain or connect an existing one.\nSave Time with Templates\nJust landed in Spaces\nLearn to code more effectively\nand intelligently with kAI - AI tutor\nHi! I'm kAI, W3Schools AI Tutor...\nFeel free to ask me any coding-related questions, and I'll do my best to assist you.\nI can help you checking your code for errors, improving your code's structure, explaining coding concepts in a clear and understandable way, and more...\nI can even create complete websites for you based on your input, so what are you waiting for?\nSuper Simple to Share\nIncluded for free in all plans\nWant custom domains?\nHow it works\nCoding Made Easy\nCloud-based\nTerminal & Log\nHow To Libraries\nDatabase\nFile Navigator\nPackage Manager\nAnalytics\nEnvironment Manager\nSave Time & Money.\nAll Your Files in One Place.\nFix Your Code Faster.\nGet Full Data Visibility.\nIncreased Control and Security.\nFind What You Need Quicker.\nGet Traffic Insights.\nGet Inspired\nFrequently Asked Questions\nWith Basic Spaces, you can build frontend websites. Whereas with Fullstack Spaces, you can build frontend and backend websites.\nBasic Spaces include HTML, CSS, and Javascript. Full Stack Spaces include everything in Basic Spaces plus PHP, Python, React.js, Vue.js, Node.js, Handlebars, and Django.\nYour subscription will be automatically renewed every month.\nYour access to all the benefits for the paid period of time will continue. However, the subscription will not be renewed automatically.\nTo subscribe W3Schools accounts for multiple users, you can contact sales@w3schools.com",
      "examples": []
    }
  ],
  "glossary": [
    "advanced angular",
    "alias",
    "angular animations",
    "angular compiler",
    "angular components",
    "angular conditional",
    "angular directives",
    "angular events",
    "angular exercises",
    "angular forms",
    "angular home",
    "angular intro",
    "angular lists",
    "angular pipes",
    "angular quiz",
    "angular router",
    "angular security",
    "angular server",
    "angular signals",
    "angular styling",
    "angular templates",
    "angular testing",
    "attribute binding",
    "backend",
    "exercises",
    "free",
    "interpolation",
    "javascript",
    "ngtemplateoutlet",
    "note",
    "overview   prerequisites",
    "pipes",
    "prerequisites",
    "programs",
    "reference variables",
    "references",
    "report error",
    "structural directives",
    "trackby",
    "w3schools spaces"
  ],
  "objectives": [
    "Basic HTML, CSS, and JavaScript.",
    "Some TypeScript helps but is not required."
  ]
}