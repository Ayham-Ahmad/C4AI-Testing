{
  "course_name": "Xml",
  "description": "XML stands for eXtensible Markup Language. XML was designed to store and transport data. XML was designed to be both human- and machine-readable. Display the XML File » Display the XML File as a Note » Display the XML File » Display with XSLT » REMOVE ADS XML plays an important role in many different IT systems. XML is often used for distributing data over the Internet. It is important (for all types of software developers!) to have a good understanding of XML. This tutorial will give you a solid understanding of: This tutorial will also dig deep into the following important XML standards: We recommend reading this tutorial, in the sequence listed in the left menu. Examples are better than 1000 words. Examples are often easier to understand than text explanations. This tutorial supplements all explanations with clarifying \"Try it Yourself\" examples. Test your XML skills at W3Schools! Sign Up for Free",
  "course_summary": [
    {
      "title": "Introduction to XML",
      "summary": "XML is a software- and hardware-independent tool for storing and transporting data.\nWhat is XML?\nXML stands for eXtensible Markup Language\nXML is a markup language much like HTML\nXML was designed to store and transport data\nXML was designed to be self-descriptive\nXML is a W3C Recommendation\nXML Does Not DO Anything\nMaybe it is a little hard to understand, but XML does not DO anything.\nThis note is a note to Tove from Jani, stored as XML:\nThe XML above is quite self-descriptive:\nIt has sender information\nIt has receiver information\nIt has a heading\nIt has a message body\nBut still, the XML above does not DO anything. XML is just information wrapped in tags.\nSomeone must write a piece of software to send, receive, store, or display it:\nNote\nTo: Tove\nFrom: Jani\nReminder\nDon't forget me this weekend!\nThe Difference Between XML and HTML\nXML and HTML were designed with different goals:\nXML was designed to carry data - with focus on what data is\nHTML was designed to display data - with focus on how data looks\nXML tags are not predefined like HTML tags are\nREMOVE ADS\nXML Does Not Use Predefined Tags\nThe XML language has no predefined tags.\nThe tags in the example above (like <to> and <from>) are not defined in any XML standard. These tags are \"invented\" by the author of the XML document.\nHTML works with predefined tags like <p>, <h1>, <table>, etc.\nWith XML, the author must define both the tags and the document structure.\nXML is Extensible\nMost XML applications will work as expected even if new data is added (or removed).\nImagine an application designed to display the original version of note.xml (<to> <from> <heading> <body>).\nThen imagine a newer version of note.xml with added <date> and <hour> elements, and a removed <heading>.\nThe way XML is constructed, older version of the application can still work:\nOld Version\nNote\nTo: Tove\nFrom: Jani\nReminder\nDon't forget me this weekend!\nNew Version\nNote\nTo: Tove\nFrom: Jani\nDate: 2015-09-01 08:30\nDon't forget me this weekend!\nXML Simplifies Things\nXML simplifies data sharing\nXML simplifies data transport\nXML simplifies platform changes\nXML simplifies data availability\nMany computer systems contain data in incompatible formats. Exchanging data between incompatible systems (or upgraded systems) is a time-consuming task for web developers. Large amounts of data must be converted, and incompatible data is often lost.\nXML stores data in plain text format. This provides a software- and hardware-independent way of storing, transporting, and sharing data.\nXML also makes it easier to expand or upgrade to new operating systems, new applications, or new browsers, without losing data.\nWith XML, data can be available to all kinds of \"reading machines\" like people, computers, voice machines, news feeds, etc.\nXML is a W3C Recommendation\nXML became a W3C Recommendation as early as in February 1998.",
      "examples": [
        "<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<note>\n<date>2015-09-01</date>\n<hour>08:30</hour>\n<to>Tove</to>\n<from>Jani</from>\n<body>Don't forget me this weekend!</body>\n</note>"
      ]
    },
    {
      "title": "How Can XML be Used?",
      "summary": "XML is used in many aspects of web development.\nXML is often used to separate data from presentation.\nXML Separates Data from Presentation\nXML does not carry any information about how to be displayed.\nThe same XML data can be used in many different presentation scenarios.\nBecause of this, with XML, there is a full separation between data and presentation.\nXML is Often a Complement to HTML\nIn many HTML applications, XML is used to store or transport data, while HTML is used to format and display the same data.\nXML Separates Data from HTML\nWhen displaying data in HTML, you should not have to edit the HTML file when the data changes.\nWith XML, the data can be stored in separate XML files.\nWith a few lines of JavaScript code, you can read an XML file and update the data content of any HTML page.\nBooks.xml\nYou will learn a lot more about using XML and JavaScript in the DOM section of this tutorial.\nREMOVE ADS\nTransaction Data\nThousands of XML formats exist, in many different industries, to describe day-to-day data transactions:\nStocks and Shares\nFinancial transactions\nMedical data\nMathematical data\nScientific measurements\nNews information\nWeather services\nExample: XML News\nXMLNews is a specification for exchanging news and other information.\nUsing a standard makes it easier for both news producers and news consumers to produce, receive, and archive any kind of news information across different hardware, software, and programming languages.\nAn example XMLNews document:\nExample: XML Weather Service\nAn XML national weather service from NOAA (National Oceanic and Atmospheric Administration):",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\n<book category=\"cooking\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n\n<book category=\"children\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n<book category=\"web\">\n<title lang=\"en\">XQuery Kick Start</title>\n<author>James McGovern</author>\n<author>Per Bothner</author>\n<author>Kurt Cagle</author>\n<author>James Linn</author>\n<author>Vaidyanathan Nagarajan</author>\n<year>2003</year>\n<price>49.99</price>\n</book>\n\n<book category=\"web\" cover=\"paperback\">\n<title lang=\"en\">Learning XML</title>\n<author>Erik T. Ray</author>\n<year>2003</year>\n<price>39.95</price>\n</book>\n\n</bookstore>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<nitf>\n<head>\n<title>Colombia Earthquake</title>\n</head>\n<body>\n<headline>\n<hl1>143 Dead in Colombia Earthquake</hl1>\n</headline>\n<byline>\n<bytag>By Jared Kotler, Associated Press Writer</bytag>\n</byline>\n<dateline>\n<location>Bogota, Colombia</location>\n<date>Monday January 25 1999 7:28 ET</date>\n</dateline>\n</body>\n</nitf>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<current_observation>\n\n<credit>NOAA's National Weather Service</credit>\n<credit_URL>http://weather.gov/</credit_URL>\n\n<image>\n<url>http://weather.gov/images/xml_logo.gif</url>\n<title>NOAA's National Weather Service</title>\n<link>http://weather.gov</link>\n</image>\n\n<location>New York/John F. Kennedy Intl Airport, NY</location>\n<station_id>KJFK</station_id>\n<latitude>40.66</latitude>\n<longitude>-73.78</longitude>\n<observation_time_rfc822>Mon, 11 Feb 2008 06:51:00 -0500 EST\n</observation_time_rfc822>\n\n<weather>A Few Clouds</weather>\n<temp_f>11</temp_f>\n<temp_c>-12</temp_c>\n<relative_humidity>36</relative_humidity>\n<wind_dir>West</wind_dir>\n<wind_degrees>280</wind_degrees>\n<wind_mph>18.4</wind_mph>\n<wind_gust_mph>29</wind_gust_mph>\n<pressure_mb>1023.6</pressure_mb>\n<pressure_in>30.23</pressure_in>\n<dewpoint_f>-11</dewpoint_f>\n<dewpoint_c>-24</dewpoint_c>\n<windchill_f>-7</windchill_f>\n<windchill_c>-22</windchill_c>\n<visibility_mi>10.00</visibility_mi>\n\n<icon_url_base>http://weather.gov/weather/images/fcicons/</icon_url_base>\n<icon_url_name>nfew.jpg</icon_url_name>\n<disclaimer_url>http://weather.gov/disclaimer.html</disclaimer_url>\n<copyright_url>http://weather.gov/disclaimer.html</copyright_url>\n\n</current_observation>"
      ]
    },
    {
      "title": "XML Tree",
      "summary": "XML documents form a tree structure that starts at \"the root\" and branches to \"the leaves\".\nThe XML Tree Structure\nAn Example XML Document\nThe image above represents books in this XML:\nREMOVE ADS\nXML Tree Structure\nXML documents are formed as element trees.\nAn XML tree starts at a root element and branches from the root to child elements.\nAll elements can have sub elements (child elements):\nThe terms parent, child, and sibling are used to describe the relationships between elements.\nParents have children. Children have parents. Siblings are children on the same level (brothers and sisters).\nAll elements can have text content (Harry Potter) and attributes (category=\"cooking\").\nSelf-Describing Syntax\nXML uses a much self-describing syntax.\nA prolog defines the XML version and the character encoding:\nThe next line is the root element of the document:\nThe next line starts a <book> element:\nThe <book> elements have 4 child elements: <title>, <author>, <year>, <price>.\nThe next line ends the book element:\nYou can assume, from this example, that the XML document contains information about books in a bookstore.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n<book category=\"cooking\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n<book category=\"children\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n<book category=\"web\">\n<title lang=\"en\">Learning XML</title>\n<author>Erik T. Ray</author>\n<year>2003</year>\n<price>39.95</price>\n</book>\n</bookstore>",
        "<root>\n<child>\n<subchild>.....</subchild>\n</child>\n</root>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<bookstore>",
        "<book category=\"cooking\">",
        "<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>",
        "</book>"
      ]
    },
    {
      "title": "XML Syntax Rules",
      "summary": "The syntax rules of XML are very simple and logical. The rules are easy to learn, and easy to use.\nXML Documents Must Have a Root Element\nXML documents must contain one root element that is the parent of all other elements:\nIn this example <note> is the root element:\nThe XML Prolog\nThis line is called the XML prolog:\nThe XML prolog is optional. If it exists, it must come first in the document.\nXML documents can contain international characters, like Norwegian øæå or French êèé.\nTo avoid errors, you should specify the encoding used, or save your XML files as UTF-8.\nUTF-8 is the default character encoding for XML documents.\nCharacter encoding can be studied in our Character Set Tutorial.\nUTF-8 is also the default encoding for HTML5, CSS, JavaScript, PHP, and SQL.\nREMOVE ADS\nAll XML Elements Must Have a Closing Tag\nIn XML, it is illegal to omit the closing tag. All elements must have a closing tag:\nNote: The XML prolog does not have a closing tag! This is not an error. The prolog is not a part of the XML document.\nXML Tags are Case Sensitive\nXML tags are case sensitive. The tag <Letter> is different from the tag <letter>.\nOpening and closing tags must be written with the same case:\n\"Opening and closing tags\" are often referred to as \"Start and end tags\". Use whatever you prefer. It is exactly the same thing.\nXML Elements Must be Properly Nested\nIn HTML, you might see improperly nested elements:\nIn XML, all elements must be properly nested within each other:\nIn the example above, \"Properly nested\" simply means that since the <i> element is opened inside the <b> element, it must be closed inside the <b> element.\nXML Attribute Values Must Always be Quoted\nXML elements can have attributes in name/value pairs just like in HTML.\nIn XML, the attribute values must always be quoted:\nEntity References\nSome characters have a special meaning in XML.\nIf you place a character like \"<\" inside an XML element, it will generate an error because the parser interprets it as the start of a new element.\nThis will generate an XML error:\nTo avoid this error, replace the \"<\" character with an entity reference:\nThere are 5 pre-defined entity references in XML:\nOnly < and & are strictly illegal in XML, but it is a good habit to replace > with &gt; as well.\nComments in XML\nThe syntax for writing comments in XML is similar to that of HTML:\nTwo dashes in the middle of a comment are not allowed:\nWhite-space is Preserved in XML\nXML does not truncate multiple white-spaces (HTML truncates multiple white-spaces to one single white-space):\nXML Stores New Line as LF\nWindows applications store a new line as: carriage return and line feed (CR+LF).\nUnix and Mac OSX use LF.\nOld Mac systems use CR.\nXML stores a new line as LF.\nWell Formed XML\nXML documents that conform to the syntax rules above are said to be \"Well Formed\" XML documents.",
      "examples": [
        "<root>\n<child>\n<subchild>.....</subchild>\n</child>\n</root>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "<p>This is a paragraph.</p>\n<br />",
        "<message>This is correct</message>",
        "<b><i>This text is bold and italic</b></i>",
        "<b><i>This text is bold and italic</i></b>",
        "<note date=\"12/11/2007\">\n<to>Tove</to>\n<from>Jani</from>\n</note>",
        "<message>salary < 1000</message>",
        "<message>salary &lt; 1000</message>",
        "<!-- This is a comment -->",
        "<!-- This is an invalid -- comment -->"
      ]
    },
    {
      "title": "XML Elements",
      "summary": "An XML document contains XML Elements.\nWhat is an XML Element?\nAn XML element is everything from (including) the element's start tag to (including) the element's end tag.\nAn element can contain:\ntext\nattributes\nother elements\nor a mix of the above\nIn the example above:\n<title>, <author>, <year>, and <price> have text content because they contain text (like 29.99).\n<bookstore> and <book> have element contents, because they contain elements.\n<book> has an attribute (category=\"children\").\nEmpty XML Elements\nAn element with no content is said to be empty.\nIn XML, you can indicate an empty element like this:\nYou can also use a so called self-closing tag:\nThe two forms produce identical results in XML software (Readers, Parsers, Browsers).\nEmpty elements can have attributes.\nREMOVE ADS\nXML Naming Rules\nXML elements must follow these naming rules:\nElement names are case-sensitive\nElement names must start with a letter or underscore\nElement names cannot start with the letters xml (or XML, or Xml, etc)\nElement names can contain letters, digits, hyphens, underscores, and periods\nElement names cannot contain spaces\nAny name can be used, no words are reserved (except xml).\nBest Naming Practices\nCreate descriptive names, like this: <person>, <firstname>, <lastname>.\nCreate short and simple names, like this: <book_title> not like this: <the_title_of_the_book>.\nAvoid \"-\". If you name something \"first-name\", some software may think you want to subtract \"name\" from \"first\".\nAvoid \".\". If you name something \"first.name\", some software may think that \"name\" is a property of the object \"first\".\nAvoid \":\". Colons are reserved for namespaces (more later).\nNon-English letters like éòá are perfectly legal in XML, but watch out for problems if your software doesn't support them!\nNaming Conventions\nSome commonly used naming conventions for XML elements:\nTip! Choose your naming style, and be consistent about it!\nXML documents often have a corresponding database. A common practice is to use the naming rules of the database for the XML elements.\nXML Elements are Extensible\nXML elements can be extended to carry more information.\nLook at the following XML example:\nLet's imagine that we created an application that extracted the <to>, <from>, and <body> elements from the XML document to produce this output:\nTo: Tove\nFrom: Jani\nDon't forget me this weekend!\nImagine that the author of the XML document added some extra information to it:\nShould the application break or crash?\nNo. The application should still be able to find the <to>, <from>, and <body> elements in the XML document and produce the same output.\nThis is one of the beauties of XML. It can be extended without breaking applications.",
      "examples": [
        "<price>29.99</price>",
        "<bookstore>\n<book category=\"children\">\n<title>Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n<book category=\"web\">\n<title>Learning XML</title>\n<author>Erik T. Ray</author>\n<year>2003</year>\n<price>39.95</price>\n</book>\n</bookstore>",
        "<element></element>",
        "<element />",
        "<note>\n<to>Tove</to>\n<from>Jani</from>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<note>\n<date>2008-01-10</date>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>"
      ]
    },
    {
      "title": "XML Attributes",
      "summary": "XML elements can have attributes, just like HTML.\nAttributes are designed to contain data related to a specific element.\nXML Attributes Must be Quoted\nAttribute values must always be quoted. Either single or double quotes can be used.\nFor a person's gender, the <person> element can be written like this:\nor like this:\nIf the attribute value itself contains double quotes you can use single quotes, like in this example:\nor you can use character entities:\nXML Elements vs. Attributes\nTake a look at these two examples:\nIn the first example, gender is an attribute. In the last example, gender is an element. Both examples provide the same information.\nThere are no rules about when to use attributes or when to use elements in XML.\nREMOVE ADS\nMy Favorite Way\nThe following three XML documents contain exactly the same information:\nA date attribute is used in the first example:\nA <date> element is used in the second example:\nAn expanded <date> element is used in the third example: (THIS IS MY FAVORITE):\nAvoid XML Attributes?\nSome things to consider when using attributes are:\nattributes cannot contain multiple values (elements can)\nattributes cannot contain tree structures (elements can)\nattributes are not easily expandable (for future changes)\nDon't end up like this:\nXML Attributes for Metadata\nSometimes ID references are assigned to elements. These IDs can be used to identify XML elements in much the same way as the id attribute in HTML. This example demonstrates this:\nThe id attributes above are for identifying the different notes. It is not a part of the note itself.\nWhat I'm trying to say here is that metadata (data about data) should be stored as attributes, and the data itself should be stored as elements.",
      "examples": [
        "<person gender=\"female\">",
        "<person gender='female'>",
        "<gangster name='George \"Shotgun\" Ziegler'>",
        "<gangster name=\"George &quot;Shotgun&quot; Ziegler\">",
        "<person gender=\"female\">\n<firstname>Anna</firstname>\n<lastname>Smith</lastname>\n</person>",
        "<person>\n<gender>female</gender>\n<firstname>Anna</firstname>\n<lastname>Smith</lastname>\n</person>",
        "<note date=\"2008-01-10\">\n<to>Tove</to>\n<from>Jani</from>\n</note>",
        "<note>\n<date>2008-01-10</date>\n<to>Tove</to>\n<from>Jani</from>\n</note>",
        "<note>\n<date>\n<year>2008</year>\n<month>01</month>\n<day>10</day>\n</date>\n<to>Tove</to>\n<from>Jani</from>\n</note>",
        "<note day=\"10\" month=\"01\" year=\"2008\"\nto=\"Tove\" from=\"Jani\" heading=\"Reminder\"\nbody=\"Don't forget me this weekend!\">\n</note>",
        "<messages>\n<note id=\"501\">\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>\n<note id=\"502\">\n<to>Jani</to>\n<from>Tove</from>\n<heading>Re: Reminder</heading>\n<body>I will not</body>\n</note>\n</messages>"
      ]
    },
    {
      "title": "XML Namespaces",
      "summary": "XML Namespaces provide a method to avoid element name conflicts.\nName Conflicts\nIn XML, element names are defined by the developer. This often results in a conflict when trying to mix XML documents from different XML applications.\nThis XML carries HTML table information:\nThis XML carries information about a table (a piece of furniture):\nIf these XML fragments were added together, there would be a name conflict. Both contain a <table> element, but the elements have different content and meaning.\nA user or an XML application will not know how to handle these differences.\nSolving the Name Conflict Using a Prefix\nName conflicts in XML can easily be avoided using a name prefix.\nThis XML carries information about an HTML table, and a piece of furniture:\nIn the example above, there will be no conflict because the two <table> elements have different names.\nREMOVE ADS\nXML Namespaces - The xmlns Attribute\nWhen using prefixes in XML, a namespace for the prefix must be defined.\nThe namespace can be defined by an xmlns attribute in the start tag of an element.\nThe namespace declaration has the following syntax. xmlns:prefix=\"URI\".\nIn the example above:\nThe xmlns attribute in the first <table> element gives the h: prefix a qualified namespace.\nThe xmlns attribute in the second <table> element gives the f: prefix a qualified namespace.\nWhen a namespace is defined for an element, all child elements with the same prefix are associated with the same namespace.\nNamespaces can also be declared in the XML root element:\nNote: The namespace URI is not used by the parser to look up information.\nThe purpose of using an URI is to give the namespace a unique name.\nHowever, companies often use the namespace as a pointer to a web page containing namespace information.\nUniform Resource Identifier (URI)\nA Uniform Resource Identifier (URI) is a string of characters which identifies an Internet Resource.\nThe most common URI is the Uniform Resource Locator (URL) which identifies an Internet domain address. Another, not so common type of URI is the Uniform Resource Name (URN).\nDefault Namespaces\nDefining a default namespace for an element saves us from using prefixes in all the child elements. It has the following syntax:\nThis XML carries HTML table information:\nThis XML carries information about a piece of furniture:\nNamespaces in Real Use\nXSLT is a language that can be used to transform XML documents into other formats.\nThe XML document below, is a document used to transform XML into HTML.\nThe namespace \"http://www.w3.org/1999/XSL/Transform\" identifies XSLT elements inside an HTML document:\nIf you want to learn more about XSLT, please read our XSLT Tutorial.",
      "examples": [
        "<table>\n<tr>\n<td>Apples</td>\n<td>Bananas</td>\n</tr>\n</table>",
        "<table>\n<name>African Coffee Table</name>\n<width>80</width>\n<length>120</length>\n</table>",
        "<h:table>\n<h:tr>\n<h:td>Apples</h:td>\n<h:td>Bananas</h:td>\n</h:tr>\n</h:table>\n\n<f:table>\n<f:name>African Coffee Table</f:name>\n<f:width>80</f:width>\n<f:length>120</f:length>\n</f:table>",
        "<root>\n\n<h:table xmlns:h=\"http://www.w3.org/TR/html4/\">\n<h:tr>\n<h:td>Apples</h:td>\n<h:td>Bananas</h:td>\n</h:tr>\n</h:table>\n\n<f:table xmlns:f=\"https://www.w3schools.com/furniture\">\n<f:name>African Coffee Table</f:name>\n<f:width>80</f:width>\n<f:length>120</f:length>\n</f:table>\n\n</root>",
        "<root xmlns:h=\"http://www.w3.org/TR/html4/\"\nxmlns:f=\"https://www.w3schools.com/furniture\">\n\n<h:table>\n<h:tr>\n<h:td>Apples</h:td>\n<h:td>Bananas</h:td>\n</h:tr>\n</h:table>\n\n<f:table>\n<f:name>African Coffee Table</f:name>\n<f:width>80</f:width>\n<f:length>120</f:length>\n</f:table>\n\n</root>",
        "xmlns=\"namespaceURI\"",
        "<table xmlns=\"http://www.w3.org/TR/html4/\">\n<tr>\n<td>Apples</td>\n<td>Bananas</td>\n</tr>\n</table>",
        "<table xmlns=\"https://www.w3schools.com/furniture\">\n<name>African Coffee Table</name>\n<width>80</width>\n<length>120</length>\n</table>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr>\n<th style=\"text-align:left\">Title</th>\n<th style=\"text-align:left\">Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<td><xsl:value-of select=\"artist\"/></td>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "Displaying XML",
      "summary": "Raw XML files can be viewed in all major browsers.\nDon't expect XML files to be displayed as HTML pages.\nViewing XML Files\nLook at the XML file above in your browser: note.xml\nMost browsers will display an XML document with color-coded elements.\nOften a plus (+) or minus sign (-) to the left of the elements can be clicked to expand or collapse the element structure.\nTo view raw XML source, try to select \"View Page Source\" or \"View Source\" from the browser menu.\nNote: In Safari 5 (and earlier), only the element text will be displayed. To view the raw XML, you must right click the page and select \"View Source\".\nViewing an Invalid XML File\nIf an erroneous XML file is opened, some browsers will report the error, and some will display it, or display it incorrectly.\nTry to open the following XML file: note_error.xml\nOther XML Examples\nViewing some XML documents will help you get the XML feeling:\nAn XML breakfast menu\nThis is a breakfast food menu from a restaurant, stored as XML.\nAn XML CD catalog\nThis is a CD collection, stored as XML.\nAn XML plant catalog\nThis is a plant catalog from a plant shop, stored as XML.\nREMOVE ADS\nWhy Does XML Display Like This?\nXML documents do not carry information about how to display the data.\nSince XML tags are \"invented\" by the author of the XML document, browsers do not know if a tag like <table> describes an HTML table or a dining table.\nWithout any information about how to display the data, the browsers can just display the XML document as it is.\nTip: If you want to style an XML document, use XSLT.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n- <note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>"
      ]
    },
    {
      "title": "XML HttpRequest",
      "summary": "All modern browsers have a built-in XMLHttpRequest object to request data from a server.\nThe XMLHttpRequest Object\nThe XMLHttpRequest object can be used to request data from a web server.\nThe XMLHttpRequest object is a developers dream, because you can:\nUpdate a web page without reloading the page\nRequest data from a server - after the page has loaded\nReceive data from a server  - after the page has loaded\nSend data to a server - in the background\nXMLHttpRequest Example\nWhen you type a character in the input field below, an XMLHttpRequest is sent to the server, and some name suggestions are returned (from the server):\nExample\nStart typing a name in the input field below:\nName:   Suggestions:\nThe example above is explained in the AJAX chapters of this tutorial.\nSending an XMLHttpRequest\nA common JavaScript syntax for using the XMLHttpRequest object looks much like this:\nExample\nREMOVE ADS\nExample Explained\nThe first line in the example above creates an XMLHttpRequest object:\nThe onreadystatechange property specifies a function to be executed every time the status of the XMLHttpRequest object changes:\nWhen readyState property is 4 and the status property is 200, the response is ready:\nThe responseText property returns the server response as a text string.\nThe text string can be used to update a web page:\nYou will learn a lot more about the XMLHttpRequest object in the AJAX chapters of this tutorial.",
      "examples": [
        "var xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\n// Typical action to be performed when the document is ready:\ndocument.getElementById(\"demo\").innerHTML = xhttp.responseText;\n}\n};\nxhttp.open(\"GET\", \"filename\", true);\nxhttp.send();",
        "var xhttp = new XMLHttpRequest();",
        "xhttp.onreadystatechange = function()",
        "if (this.readyState == 4 && this.status == 200)",
        "document.getElementById(\"demo\").innerHTML = xhttp.responseText;"
      ]
    },
    {
      "title": "XML Parser",
      "summary": "All major browsers have a built-in XML parser to access and manipulate XML.\nXML Parser\nThe XML DOM (Document Object Model) defines the properties and methods for accessing and editing XML.\nHowever, before an XML document can be accessed, it must be loaded into an XML DOM object.\nAll modern browsers have a built-in XML parser that can convert text into an XML DOM object.\nParsing a Text String\nThis example parses a text string into an XML DOM object, and extracts the info from it with JavaScript:\nExample\nREMOVE ADS\nExample Explained\nA text string is defined:\nAn XML DOM parser is created:\nThe parser creates a new XML DOM object using the text string:\nThe XMLHttpRequest Object\nThe XMLHttpRequest Object has a built in XML Parser.\nThe responseText property returns the response as a string.\nThe responseXML property returns the response as an XML DOM object.\nIf you want to use the response as an XML DOM object, you can use the responseXML property.\nExample\nRequest the file cd_catalog.xml and use the response as an XML DOM object:",
      "examples": [
        "<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar text, parser, xmlDoc;\n\ntext = \"<bookstore><book>\" +\n\"<title>Everyday Italian</title>\" +\n\"<author>Giada De Laurentiis</author>\" +\n\"<year>2005</year>\" +\n\"</book></bookstore>\";\n\nparser = new DOMParser();\nxmlDoc = parser.parseFromString(text,\"text/xml\");\n\ndocument.getElementById(\"demo\").innerHTML =\nxmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue;\n</script>\n\n</body>\n</html>",
        "text = \"<bookstore><book>\" +\n\"<title>Everyday Italian</title>\" +\n\"<author>Giada De Laurentiis</author>\" +\n\"<year>2005</year>\" +\n\"</book></bookstore>\";",
        "parser = new DOMParser();",
        "xmlDoc = parser.parseFromString(text,\"text/xml\");",
        "xmlDoc = xmlhttp.responseXML;\ntxt = \"\";\nx = xmlDoc.getElementsByTagName(\"ARTIST\");\nfor (i = 0; i < x.length; i++) {\ntxt += x[i].childNodes[0].nodeValue + \"<br>\";\n}\ndocument.getElementById(\"demo\").innerHTML = txt;"
      ]
    },
    {
      "title": "XML DOM",
      "summary": "What is the DOM?\nThe Document Object Model (DOM) defines a standard for accessing and manipulating documents:\n\"The W3C Document Object Model (DOM) is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a document.\"\nThe HTML DOM defines a standard way for accessing and manipulating HTML documents. It presents an HTML document as a tree-structure.\nThe XML DOM defines a standard way for accessing and manipulating XML documents. It presents an XML document as a tree-structure.\nUnderstanding the DOM is a must for anyone working with HTML or XML.\nThe HTML DOM\nAll HTML elements can be accessed through the HTML DOM.\nThis example changes the value of an HTML element with id=\"demo\":\nExample\nYou can learn a lot more about the HTML DOM in our JavaScript tutorial.\nREMOVE ADS\nThe XML DOM\nAll XML elements can be accessed through the XML DOM.\nBooks.xml\nThis code retrieves the text value of the first <title> element in an XML document:\nExample\nThe XML DOM is a standard for how to get, change, add, and delete XML elements.\nThis example loads a text string into an XML DOM object, and extracts the info from it with JavaScript:\nExample\nYou will learn a lot more about the XML DOM in our XML DOM Tutorial.",
      "examples": [
        "<h1 id=\"demo\">This is a Heading</h1>\n\n<button type=\"button\"\nonclick=\"document.getElementById('demo').innerHTML = 'Hello World!'\">Click Me!\n</button>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n\n<book category=\"cooking\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n\n<book category=\"children\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n</bookstore>",
        "txt = xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue;",
        "<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar text, parser, xmlDoc;\n\ntext = \"<bookstore><book>\" +\n\"<title>Everyday Italian</title>\" +\n\"<author>Giada De Laurentiis</author>\" +\n\"<year>2005</year>\" +\n\"</book></bookstore>\";\n\nparser = new DOMParser();\nxmlDoc = parser.parseFromString(text,\"text/xml\");\n\ndocument.getElementById(\"demo\").innerHTML =\nxmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue;\n</script>\n\n</body>\n</html>"
      ]
    },
    {
      "title": "XML and XPath",
      "summary": "What is XPath?\nXPath is a major element in the XSLT standard.\nXPath can be used to navigate through elements and attributes in an XML document.\nXPath is a syntax for defining parts of an XML document\nXPath uses path expressions to navigate in XML documents\nXPath contains a library of standard functions\nXPath is a major element in XSLT and in XQuery\nXPath is a W3C recommendation\nXPath Path Expressions\nXPath uses path expressions to select nodes or node-sets in an XML document. These path expressions look very much like the expressions you see when you work with a traditional computer file system.\nXPath expressions can be used in JavaScript, Java, XML Schema, PHP, Python, C and C++, and lots of other languages.\nXPath is Used in XSLT\nXPath is a major element in the XSLT standard.\nWith XPath knowledge you will be able to take great advantage of XSL.\nREMOVE ADS\nXPath Example\nWe will use the following XML document:\nIn the table below we have listed some XPath expressions and the result of the expressions:\nXPath Tutorial\nYou will learn a lot more about XPath in our XPath Tutorial.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore>\n\n<book category=\"cooking\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n\n<book category=\"children\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n<book category=\"web\">\n<title lang=\"en\">XQuery Kick Start</title>\n<author>James McGovern</author>\n<author>Per Bothner</author>\n<author>Kurt Cagle</author>\n<author>James Linn</author>\n<author>Vaidyanathan Nagarajan</author>\n<year>2003</year>\n<price>49.99</price>\n</book>\n\n<book category=\"web\">\n<title lang=\"en\">Learning XML</title>\n<author>Erik T. Ray</author>\n<year>2003</year>\n<price>39.95</price>\n</book>\n\n</bookstore>"
      ]
    },
    {
      "title": "XML and XSLT",
      "summary": "With XSLT you can transform an XML document into HTML.\nDisplaying XML with XSLT\nXSLT (eXtensible Stylesheet Language Transformations) is the recommended style sheet language for XML.\nXSLT is far more sophisticated than CSS. With XSLT you can add/remove elements and attributes to or from the output file. You can also rearrange and sort elements, perform tests and make decisions about which elements to hide and display, and a lot more.\nXSLT uses XPath to find information in an XML document.\nXSLT Example\nWe will use the following XML document:\nREMOVE ADS\nUse XSLT to transform XML into HTML, before it is displayed in a browser:\nExample XSLT Stylesheet:\nXSLT Tutorial\nIf you want to learn more about XSLT, go to our XSLT Tutorial.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<breakfast_menu>\n\n<food>\n<name>Belgian Waffles</name>\n<price>$5.95</price>\n<description>Two of our famous Belgian Waffles with plenty of real maple syrup</description>\n<calories>650</calories>\n</food>\n\n<food>\n<name>Strawberry Belgian Waffles</name>\n<price>$7.95</price>\n<description>Light Belgian waffles covered with strawberries and whipped cream</description>\n<calories>900</calories>\n</food>\n\n<food>\n<name>Berry-Berry Belgian Waffles</name>\n<price>$8.95</price>\n<description>Light Belgian waffles covered with an assortment of fresh berries and whipped cream</description>\n<calories>900</calories>\n</food>\n\n<food>\n<name>French Toast</name>\n<price>$4.50</price>\n<description>Thick slices made from our homemade sourdough bread</description>\n<calories>600</calories>\n</food>\n\n<food>\n<name>Homestyle Breakfast</name>\n<price>$6.95</price>\n<description>Two eggs, bacon or sausage, toast, and our ever-popular hash browns</description>\n<calories>950</calories>\n</food>\n\n</breakfast_menu>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<html xsl:version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n<body style=\"font-family:Arial;font-size:12pt;background-color:#EEEEEE\">\n<xsl:for-each select=\"breakfast_menu/food\">\n<div style=\"background-color:teal;color:white;padding:4px\">\n<span style=\"font-weight:bold\"><xsl:value-of select=\"name\"/> - </span>\n<xsl:value-of select=\"price\"/>\n</div>\n<div style=\"margin-left:20px;margin-bottom:1em;font-size:10pt\">\n<p>\n<xsl:value-of select=\"description\"/>\n<span style=\"font-style:italic\"> (<xsl:value-of select=\"calories\"/> calories per serving)</span>\n</p>\n</div>\n</xsl:for-each>\n</body>\n</html>"
      ]
    },
    {
      "title": "XML and XQuery",
      "summary": "What is XQuery?\nXQuery is to XML what SQL is to databases.\nXQuery was designed to query XML data.\nXQuery Example\nWhat is XQuery?\nXQuery is the language for querying XML data\nXQuery for XML is like SQL for databases\nXQuery is built on XPath expressions\nXQuery is supported by all major databases\nXQuery is a W3C Recommendation\nXQuery is About Querying XML\nXQuery is a language for finding and extracting elements and attributes from XML documents.\nHere is an example of what XQuery could solve:\n\"Select all CD records with a price less than $10 from the CD collection stored in cd_catalog.xml\"\nXQuery and XPath\nXQuery 1.0 and XPath 2.0 share the same data model and support the same functions and operators. If you have already studied XPath you will have no problems with understanding XQuery.\nXQuery - Examples of Use\nXQuery can be used to:\nExtract information to use in a Web Service\nGenerate summary reports\nTransform XML data to XHTML\nSearch Web documents for relevant information\nXQuery is a W3C Recommendation\nXQuery is compatible with several W3C standards, such as XML, Namespaces, XSLT, XPath, and XML Schema.\nXQuery 1.0 became a W3C Recommendation in 2007.\nXQuery Tutorial\nYou will learn a lot more about XQuery in our XQuery Tutorial.",
      "examples": [
        "for $x in doc(\"books.xml\")/bookstore/book\nwhere $x/price>30\norder by $x/title\nreturn $x/title"
      ]
    },
    {
      "title": "XML, XLink and XPointer",
      "summary": "XLink is used to create hyperlinks in XML documents.\nXLink is used to create hyperlinks within XML documents\nAny element in an XML document can behave as a link\nWith XLink, the links can be defined outside the linked files\nXLink is a W3C Recommendation\nXLink Browser Support\nThere is no browser support for XLink in XML documents.\nHowever, all major browsers support XLinks in SVG.\nXLink Syntax\nIn HTML, the <a> element defines a hyperlink. However, this is not how it works in XML. In XML documents, you can use whatever element names you want - therefore it is impossible for browsers to predict what link elements will be called in XML documents.\nBelow is a simple example of how to use XLink to create links in an XML document:\nTo get access to the XLink features we must declare the XLink namespace. The XLink namespace is: \"http://www.w3.org/1999/xlink\".\nThe xlink:type and the xlink:href attributes in the <homepage> elements come from the XLink namespace.\nThe xlink:type=\"simple\" creates a simple \"HTML-like\" link (means \"click here to go there\").\nThe xlink:href attribute specifies the URL to link to.\nXLink Example\nThe following XML document contains XLink features:\nExample explained:\nThe XLink namespace is declared at the top of the document (xmlns:xlink=\"http://www.w3.org/1999/xlink\")\nThe xlink:type=\"simple\" creates a simple \"HTML-like\" link\nThe xlink:href attribute specifies the URL to link to (in this case - an image)\nThe xlink:show=\"new\" specifies that the link should open in a new window\nREMOVE ADS\nXLink - Going Further\nIn the example above we have demonstrated simple XLinks. XLink is getting more interesting when accessing remote locations as resources, instead of standalone pages.\nIf we set the value of the xlink:show attribute to \"embed\", the linked resource should be processed inline within the page. When you consider that this could be another XML document you could, for example, build a hierarchy of XML documents.\nYou can also specify WHEN the resource should appear, with the xlink:actuate attribute.\nXLink Attribute Reference\nonLoad - the resource should be loaded and shown when the document loads\nonRequest - the resource is not read or shown before the link is clicked\nXPointer\nXPointer allows links to point to specific parts of an XML document\nXPointer uses XPath expressions to navigate in the XML document\nXPointer is a W3C Recommendation\nXPointer Browser Support\nThere is no browser support for XPointer. But XPointer is used in other XML languages.\nXPointer Example\nIn this example, we will use XPointer in conjunction with XLink to point to a specific part of another document.\nWe will start by looking at the target XML document (the document we are linking to):\nNote that the XML document above uses id attributes on each element!\nSo, instead of linking to the entire document (as with XLink), XPointer allows you to link to specific parts of the document. To link to a specific part of a page, add a number sign (#) and an XPointer expression after the URL in the xlink:href attribute, like this: xlink:href=\"https://dog.com/dogbreeds.xml#xpointer(id('Rottweiler'))\". The expression refers to the element in the target document, with the id value of \"Rottweiler\".\nXPointer also allows a shorthand method for linking to an element with an id. You can use the value of the id directly, like this: xlink:href=\"https://dog.com/dogbreeds.xml#Rottweiler\".\nThe following XML document contains links to more information of the dog breed for each of my dogs:",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<homepages xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<homepage xlink:type=\"simple\" xlink:href=\"https://www.w3schools.com\">Visit W3Schools</homepage>\n<homepage xlink:type=\"simple\" xlink:href=\"http://www.w3.org\">Visit W3C</homepage>\n</homepages>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n\n<book title=\"Harry Potter\">\n<description\nxlink:type=\"simple\"\nxlink:href=\"/images/HPotter.gif\"\nxlink:show=\"new\">\nAs his fifth year at Hogwarts School of Witchcraft and\nWizardry approaches, 15-year-old Harry Potter is.......\n</description>\n</book>\n\n<book title=\"XQuery Kick Start\">\n<description\nxlink:type=\"simple\"\nxlink:href=\"/images/XQuery.gif\"\nxlink:show=\"new\">\nXQuery Kick Start delivers a concise introduction\nto the XQuery standard.......\n</description>\n</book>\n\n</bookstore>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<dogbreeds>\n\n<dog breed=\"Rottweiler\" id=\"Rottweiler\">\n<picture url=\"https://dog.com/rottweiler.gif\" />\n<history>The Rottweiler's ancestors were probably Roman\ndrover dogs.....</history>\n<temperament>Confident, bold, alert and imposing, the Rottweiler\nis a popular choice for its ability to protect....</temperament>\n</dog>\n\n<dog breed=\"FCRetriever\" id=\"FCRetriever\">\n<picture url=\"https://dog.com/fcretriever.gif\" />\n<history>One of the earliest uses of retrieving dogs was to\nhelp fishermen retrieve fish from the water....</history>\n<temperament>The flat-coated retriever is a sweet, exuberant,\nlively dog that loves to play and retrieve....</temperament>\n</dog>\n\n</dogbreeds>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<mydogs xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n\n<mydog>\n<description>\nAnton is my favorite dog. He has won a lot of.....\n</description>\n<fact xlink:type=\"simple\" xlink:href=\"https://dog.com/dogbreeds.xml#Rottweiler\">\nFact about Rottweiler\n</fact>\n</mydog>\n\n<mydog>\n<description>\nPluto is the sweetest dog on earth......\n</description>\n<fact xlink:type=\"simple\" xlink:href=\"https://dog.com/dogbreeds.xml#FCRetriever\">\nFact about flat-coated Retriever\n</fact>\n</mydog>\n\n</mydogs>"
      ]
    },
    {
      "title": "XML Validator",
      "summary": "Use our XML validator to syntax-check your XML.\nWell Formed XML Documents\nAn XML document with correct syntax is called \"Well Formed\".\nThe syntax rules were described in the previous chapters:\nXML documents must have a root element\nXML elements must have a closing tag\nXML tags are case sensitive\nXML elements must be properly nested\nXML attribute values must be quoted\nXML Errors Will Stop You\nErrors in XML documents will stop your XML applications.\nThe W3C XML specification states that a program should stop processing an XML document if it finds an error. The reason is that XML software should be small, fast, and compatible.\nHTML browsers are allowed to display HTML documents with errors (like missing end tags).\nWith XML, errors are not allowed.\nREMOVE ADS\nSyntax-Check Your XML\nTo help you syntax-check your XML, we have created an XML validator.\nTry to syntax-check correct XML :\nTry to syntax-check incorrect XML :\nTry to syntax-check your own XML :\nValid XML Documents\nA \"well formed\" XML document is not the same as a \"valid\" XML document.\nA \"valid\" XML document must be well formed. In addition, it must conform to a document type definition.\nThere are two different document type definitions that can be used with XML:\nDTD - The original Document Type Definition\nXML Schema - An XML-based alternative to DTD\nA document type definition defines the rules and the legal elements and attributes for an XML document.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>"
      ]
    },
    {
      "title": "XML DTD",
      "summary": "An XML document with correct syntax is called \"Well Formed\".\nAn XML document validated against a DTD is both \"Well Formed\" and \"Valid\".\nWhat is a DTD?\nDTD stands for Document Type Definition.\nA DTD defines the structure and the legal elements and attributes of an XML document.\nValid XML Documents\nA \"Valid\" XML document is \"Well Formed\", as well as it conforms to the rules of a DTD:\nThe DOCTYPE declaration above contains a reference to a DTD file. The content of the DTD file is shown and explained below.\nXML DTD\nThe purpose of a DTD is to define the structure and the legal elements and attributes of an XML document:\nNote.dtd:\nThe DTD above is interpreted like this:\n!DOCTYPE note -  Defines that the root element of the document is note\n!ELEMENT note - Defines that the note element must contain the elements: \"to, from, heading, body\"\n!ELEMENT to - Defines the to element to be of type \"#PCDATA\"\n!ELEMENT from - Defines the from element to be of type \"#PCDATA\"\n!ELEMENT heading  - Defines the heading element to be of type \"#PCDATA\"\n!ELEMENT body - Defines the body element to be of type \"#PCDATA\"\nTip: #PCDATA means parseable character data.\nREMOVE ADS\nUsing DTD for Entity Declaration\nA DOCTYPE declaration can also be used to define special characters or strings, used in the document:\nExample\nTip: An entity has three parts: it starts with an ampersand (&), then comes the entity name, and it ends with a semicolon (;).\nWhen to Use a DTD?\nWith a DTD, independent groups of people can agree to use a standard DTD for interchanging data.\nWith a DTD, you can verify that the data you receive from the outside world is valid.\nYou can also use a DTD to verify your own data.\nIf you want to study DTD, please read our DTD Tutorial.\nWhen NOT to Use a DTD?\nXML does not require a DTD.\nWhen you are experimenting with XML, or when you are working with small XML files, creating DTDs may be a waste of time.\nIf you develop applications, wait until the specification is stable before you add a DTD. Otherwise, your software might stop working because of validation errors.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE note SYSTEM \"Note.dtd\">\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<!DOCTYPE note\n[\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n]>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!DOCTYPE note [\n<!ENTITY nbsp \"&#xA0;\">\n<!ENTITY writer \"Writer: Donald Duck.\">\n<!ENTITY copyright \"Copyright: W3Schools.\">\n]>\n\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n<footer>&writer;&nbsp;&copyright;</footer>\n</note>"
      ]
    },
    {
      "title": "XML Schema",
      "summary": "An XML Schema describes the structure of an XML document, just like a DTD.\nAn XML document with correct syntax is called \"Well Formed\".\nAn XML document validated against an XML Schema is both \"Well Formed\" and \"Valid\".\nXML Schema\nXML Schema is an XML-based alternative to DTD:\nThe Schema above is interpreted like this:\n<xs:element name=\"note\"> defines the element called \"note\"\n<xs:complexType> the \"note\" element is a complex type\n<xs:sequence> the complex type is a sequence of elements\n<xs:element name=\"to\" type=\"xs:string\"> the element \"to\" is of type string (text)\n<xs:element name=\"from\" type=\"xs:string\"> the element \"from\" is of type string\n<xs:element name=\"heading\" type=\"xs:string\"> the element \"heading\" is of type string\n<xs:element name=\"body\" type=\"xs:string\"> the element \"body\" is of type string\nXML Schemas are More Powerful than DTD\nXML Schemas are written in XML\nXML Schemas are extensible to additions\nXML Schemas support data types\nXML Schemas support namespaces\nREMOVE ADS\nWhy Use an XML Schema?\nWith XML Schema, your XML files can carry a description of its own format.\nWith XML Schema, independent groups of people can agree on a standard for interchanging data.\nWith XML Schema, you can verify data.\nXML Schemas Support Data Types\nOne of the greatest strengths of XML Schemas is the support for data types:\nIt is easier to describe document content\nIt is easier to define restrictions on data\nIt is easier to validate the correctness of data\nIt is easier to convert data between different data types\nXML Schemas use XML Syntax\nAnother great strength about XML Schemas is that they are written in XML:\nYou don't have to learn a new language\nYou can use your XML editor to edit your Schema files\nYou can use your XML parser to parse your Schema files\nYou can manipulate your Schemas with the XML DOM\nYou can transform your Schemas with XSLT\nIf you want to study XML Schema, please read our XML Schema Tutorial.",
      "examples": [
        "<xs:element name=\"note\">\n\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"to\" type=\"xs:string\"/>\n<xs:element name=\"from\" type=\"xs:string\"/>\n<xs:element name=\"heading\" type=\"xs:string\"/>\n<xs:element name=\"body\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n\n</xs:element>"
      ]
    },
    {
      "title": "XML on the Server",
      "summary": "XML files are plain text files just like HTML files.\nXML can easily be stored and generated by a standard web server.\nStoring XML Files on the Server\nXML files can be stored on an Internet server exactly the same way as HTML files.\nStart Windows Notepad and write the following lines:\nSave the file on your web server with a proper name like \"note.xml\".\nGenerating XML with PHP\nXML can be generated on a server without any installed XML software.\nTo generate an XML response from the server using PHP, use following code:\nNote that the content type of the response header must be set to \"text/xml\".\nSee how the PHP file will be returned from the server.\nIf you want to study PHP, you will find our PHP tutorial on our homepage.\nREMOVE ADS\nGenerating XML with ASP\nTo generate an XML response from the server - simply write the following code and save it as an ASP file on the web server:\nNote that the content type of the response must be set to \"text/xml\".\nSee how the ASP file will be returned from the server.\nIf you want to study ASP, you will find our ASP tutorial on our homepage.\nGenerating XML From a Database\nXML can be generated from a database without any installed XML software.\nTo generate an XML database response from the server, simply write the following code and save it as an ASP file on the web server:\nSee the real life database output from the ASP file above.\nThe example above uses ASP with ADO.\nIf you want to study ASP and ADO, you will find the tutorials on our homepage.\nTransforming XML with XSLT on the Server\nThis ASP transforms an XML file to XHTML on the server:\nExample explained\nThe first block of code creates an instance of the Microsoft XML parser (XMLDOM), and loads the XML file into memory.\nThe second block of code creates another instance of the parser and loads the XSL file into memory.\nThe last line of code transforms the XML document using the XSL document, and sends the result as XHTML to your browser. Nice!\nSee how it works.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<from>Jani</from>\n<to>Tove</to>\n<message>Remember me this weekend</message>\n</note>",
        "<?php\nheader(\"Content-type: text/xml\");\necho \"<?xml version='1.0' encoding='UTF-8'?>\";\necho \"<note>\";\necho \"<from>Jani</from>\";\necho \"<to>Tove</to>\";\necho \"<message>Remember me this weekend</message>\";\necho \"</note>\";\n?>",
        "<%\nresponse.ContentType=\"text/xml\"\nresponse.Write(\"<?xml version='1.0' encoding='UTF-8'?>\")\nresponse.Write(\"<note>\")\nresponse.Write(\"<from>Jani</from>\")\nresponse.Write(\"<to>Tove</to>\")\nresponse.Write(\"<message>Remember me this weekend</message>\")\nresponse.Write(\"</note>\")\n%>",
        "<%\nresponse.ContentType = \"text/xml\"\nset conn=Server.CreateObject(\"ADODB.Connection\")\nconn.provider=\"Microsoft.Jet.OLEDB.4.0;\"\nconn.open server.mappath(\"/datafolder/database.mdb\")\n\nsql=\"select fname,lname from tblGuestBook\"\nset rs=Conn.Execute(sql)\n\nresponse.write(\"<?xml version='1.0' encoding='UTF-8'?>\")\nresponse.write(\"<guestbook>\")\nwhile (not rs.EOF)\nresponse.write(\"<guest>\")\nresponse.write(\"<fname>\" & rs(\"fname\") & \"</fname>\")\nresponse.write(\"<lname>\" & rs(\"lname\") & \"</lname>\")\nresponse.write(\"</guest>\")\nrs.MoveNext()\nwend\n\nrs.close()\nconn.close()\nresponse.write(\"</guestbook>\")\n%>",
        "<%\n'Load XML\nset xml = Server.CreateObject(\"Microsoft.XMLDOM\")\nxml.async = false\nxml.load(Server.MapPath(\"simple.xml\"))\n\n'Load XSL\nset xsl = Server.CreateObject(\"Microsoft.XMLDOM\")\nxsl.async = false\nxsl.load(Server.MapPath(\"simple.xsl\"))\n\n'Transform file\nResponse.Write(xml.transformNode(xsl))\n%>"
      ]
    },
    {
      "title": "AJAX Introduction",
      "summary": "AJAX is a developer's dream, because you can:\nUpdate a web page without reloading the page\nRequest data from a server - after the page has loaded\nReceive data from a server - after the page has loaded\nSend data to a server - in the background\nTry it Yourself Examples in Every Chapter\nIn every chapter, you can edit the examples online, and click on a button to view the result.\nAJAX Example\nLet AJAX change this text\nTry it Yourself »\nAJAX Example Explained\nHTML Page\nThe HTML page contains a <div> section and a <button>.\nThe <div> section is used to display information from a server.\nThe <button> calls a function (if it is clicked).\nThe function requests data from a web server and displays it:\nFunction loadDoc()\nThe \"ajax_info.txt\" file used in the example above, is a simple text file and looks like this:\nREMOVE ADS\nWhat is AJAX?\nAJAX = Asynchronous JavaScript And XML.\nAJAX is not a programming language.\nAJAX just uses a combination of:\nA browser built-in XMLHttpRequest object (to request data from a web server)\nJavaScript and HTML DOM (to display or use the data)\nAJAX is a misleading name. AJAX applications might use XML to transport data, but it is equally common to transport data as plain text or JSON text.\nAJAX allows web pages to be updated asynchronously by exchanging data with a web server behind the scenes. This means that it is possible to update parts of a web page, without reloading the whole page.\nHow AJAX Works\n1. An event occurs in a web page (the page is loaded, a button is clicked)\n2. An XMLHttpRequest object is created by JavaScript\n3. The XMLHttpRequest object sends a request to a web server\n4. The server processes the request\n5. The server sends a response back to the web page\n6. The response is read by JavaScript\n7. Proper action (like page update) is performed by JavaScript",
      "examples": [
        "<!DOCTYPE html>\n<html>\n<body>\n\n<div id=\"demo\">\n<h2>Let AJAX change this text</h2>\n<button type=\"button\" onclick=\"loadDoc()\">Change Content</button>\n</div>\n\n</body>\n</html>",
        "function loadDoc() {\nvar xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"demo\").innerHTML = this.responseText;\n}\n};\nxhttp.open(\"GET\", \"ajax_info.txt\", true);\nxhttp.send();\n}",
        "<h1>AJAX</h1>\n<p>AJAX is not a programming language.</p>\n<p>AJAX is a technique for accessing web servers from a web page.</p>\n<p>AJAX stands for Asynchronous JavaScript And XML.</p>"
      ]
    },
    {
      "title": "AJAX - The XMLHttpRequest Object",
      "summary": "The keystone of AJAX is the XMLHttpRequest object.\nThe XMLHttpRequest Object\nAll modern browsers support the XMLHttpRequest object.\nThe XMLHttpRequest object can be used to exchange data with a server behind the scenes. This means that it is possible to update parts of a web page, without reloading the whole page.\nCreate an XMLHttpRequest Object\nAll modern browsers (Chrome, Firefox, Edge (and IE7+), Safari, Opera) have a built-in XMLHttpRequest object.\nSyntax for creating an XMLHttpRequest object:\nExample\nThe \"ajax_info.txt\" file used in the example above, is a simple text file and looks like this:\nAccess Across Domains\nFor security reasons, modern browsers do not allow access across domains.\nThis means that both the web page and the XML file it tries to load, must be located on the same server.\nThe examples on W3Schools all open XML files located on the W3Schools domain.\nIf you want to use the example above on one of your own web pages, the XML files you load must be located on your own server.\nREMOVE ADS\nXMLHttpRequest Object Methods\nXMLHttpRequest Object Properties",
      "examples": [
        "variable = new XMLHttpRequest();",
        "var xhttp = new XMLHttpRequest();",
        "<h1>AJAX</h1>\n<p>AJAX is not a programming language.</p>\n<p>AJAX is a technique for accessing web servers from a web page.</p>\n<p>AJAX stands for Asynchronous JavaScript And XML.</p>"
      ]
    },
    {
      "title": "AJAX - Send a Request To a Server",
      "summary": "The XMLHttpRequest object is used to exchange data with a server.\nSend a Request To a Server\nTo send a request to a server, we use the open() and send() methods of the XMLHttpRequest object:\nGET or POST?\nGET is simpler and faster than POST, and can be used in most cases.\nHowever, always use POST requests when:\nA cached file is not an option (update a file or database on the server).\nSending a large amount of data to the server (POST has no size limitations).\nSending user input (which can contain unknown characters), POST is more robust and secure than GET.\nGET Requests\nA simple GET request:\nExample\nIn the example above, you may get a cached result. To avoid this, add a unique ID to the URL:\nExample\nIf you want to send information with the GET method, add the information to the URL:\nExample\nREMOVE ADS\nPOST Requests\nA simple POST request:\nExample\nTo POST data like an HTML form, add an HTTP header with setRequestHeader(). Specify the data you want to send in the send() method:\nExample\nThe url - A File On a Server\nThe url parameter of the open() method, is an address to a file on a server:\nThe file can be any kind of file, like .txt and .xml, or server scripting files like .asp and .php (which can perform actions on the server before sending the response back).\nAsynchronous - True or False?\nServer requests should be sent asynchronously.\nThe async parameter of the open() method should be set to true:\nBy sending asynchronously, the JavaScript does not have to wait for the server response, but can instead:\nexecute other scripts while waiting for server response\ndeal with the response after the response is ready\nThe onreadystatechange Property\nWith the XMLHttpRequest object you can define a function to be executed when the request receives an answer.\nThe function is defined in the onreadystatechange property of the XMLHttpRequest object:\nExample\nThe \"ajax_info.txt\" file used in the example above, is a simple text file and looks like this:\nYou will learn more about onreadystatechange in a later chapter.\nSynchronous Request\nTo execute a synchronous request, change the third parameter in the open() method to false:\nSometimes async = false are used for quick testing. You will also find synchronous requests in older JavaScript code.\nSince the code will wait for server completion, there is no need for an onreadystatechange function:\nExample\nSynchronous XMLHttpRequest (async = false) is not recommended because the JavaScript will stop executing until the server response is ready. If the server is busy or slow, the application will hang or stop.\nSynchronous XMLHttpRequest is in the process of being removed from the web standard, but this process can take many years.\nModern developer tools are encouraged to warn about using synchronous requests and may throw an InvalidAccessError exception when it occurs.",
      "examples": [
        "xhttp.open(\"GET\", \"ajax_info.txt\", true);\nxhttp.send();",
        "xhttp.open(\"GET\", \"demo_get.asp\", true);\nxhttp.send();",
        "xhttp.open(\"GET\", \"demo_get.asp?t=\" + Math.random(), true);\nxhttp.send();",
        "xhttp.open(\"GET\", \"demo_get2.asp?fname=Henry&lname=Ford\", true);\nxhttp.send();",
        "xhttp.open(\"POST\", \"demo_post.asp\", true);\nxhttp.send();",
        "xhttp.open(\"POST\", \"demo_post2.asp\", true);\nxhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\nxhttp.send(\"fname=Henry&lname=Ford\");",
        "xhttp.open(\"GET\", \"ajax_test.asp\", true);",
        "xhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"demo\").innerHTML = this.responseText;\n}\n};\nxhttp.open(\"GET\", \"ajax_info.txt\", true);\nxhttp.send();",
        "<h1>AJAX</h1>\n<p>AJAX is not a programming language.</p>\n<p>AJAX is a technique for accessing web servers from a web page.</p>\n<p>AJAX stands for Asynchronous JavaScript And XML.</p>",
        "xhttp.open(\"GET\", \"ajax_info.txt\", false);",
        "xhttp.open(\"GET\", \"ajax_info.txt\", false);\nxhttp.send();\ndocument.getElementById(\"demo\").innerHTML = xhttp.responseText;"
      ]
    },
    {
      "title": "AJAX - Server Response",
      "summary": "The onreadystatechange Property\nThe readyState property holds the status of the XMLHttpRequest.\nThe onreadystatechange property defines a function to be executed when the readyState changes.\nThe status property and the statusText property holds the status of the XMLHttpRequest object.\nThe onreadystatechange function is called every time the readyState changes.\nWhen readyState is 4 and status is 200, the response is ready:\nExample\nThe \"ajax_info.txt\" file used in the example above, is a simple text file and looks like this:\nThe onreadystatechange event is triggered four times (1-4), one time for each change in the readyState.\nREMOVE ADS\nUsing a Callback Function\nA callback function is a function passed as a parameter to another function.\nIf you have more than one AJAX task in a website, you should create one function for executing the XMLHttpRequest object, and one callback function for each AJAX task.\nThe function call should contain the URL and what function to call when the response is ready.\nExample\nServer Response Properties\nServer Response Methods\nThe responseText Property\nThe responseText property returns the server response as a JavaScript string, and you can use it accordingly:\nExample\nThe responseXML Property\nThe XML HttpRequest object has an in-built XML parser.\nThe responseXML property returns the server response as an XML DOM object.\nUsing this property you can parse the response as an XML DOM object:\nExample\nRequest the file cd_catalog.xml and parse the response:\nYou will learn a lot more about XML DOM in the DOM chapters of this tutorial.\nThe getAllResponseHeaders() Method\nThe getAllResponseHeaders() method returns all header information from the server response.\nExample\nThe getResponseHeader() Method\nThe getResponseHeader() method returns specific header information from the server response.\nExample",
      "examples": [
        "function loadDoc() {\nvar xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"demo\").innerHTML =\nthis.responseText;\n}\n};\nxhttp.open(\"GET\", \"ajax_info.txt\", true);\nxhttp.send();\n}",
        "<h1>AJAX</h1>\n<p>AJAX is not a programming language.</p>\n<p>AJAX is a technique for accessing web servers from a web page.</p>\n<p>AJAX stands for Asynchronous JavaScript And XML.</p>",
        "loadDoc(\"url-1\", myFunction1);\n\nloadDoc(\"url-2\", myFunction2);\n\nfunction loadDoc(url, cFunction) {\nvar xhttp;\nxhttp=new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ncFunction(this);\n}\n};\nxhttp.open(\"GET\", url, true);\nxhttp.send();\n}\n\nfunction myFunction1(xhttp) {\n// action goes here\n}\nfunction myFunction2(xhttp) {\n// action goes here\n}",
        "document.getElementById(\"demo\").innerHTML = xhttp.responseText;",
        "xmlDoc = xhttp.responseXML;\ntxt = \"\";\nx = xmlDoc.getElementsByTagName(\"ARTIST\");\nfor (i = 0; i < x.length; i++) {\ntxt += x[i].childNodes[0].nodeValue + \"<br>\";\n}\ndocument.getElementById(\"demo\").innerHTML = txt;\nxhttp.open(\"GET\", \"cd_catalog.xml\", true);\nxhttp.send();",
        "var xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"demo\").innerHTML =\nthis.getAllResponseHeaders();\n}\n};",
        "var xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"demo\").innerHTML =\nthis.getResponseHeader(\"Last-Modified\");\n}\n};\nxhttp.open(\"GET\", \"ajax_info.txt\", true);\nxhttp.send();"
      ]
    },
    {
      "title": "AJAX XML Example",
      "summary": "AJAX can be used for interactive communication with an XML file.\nAJAX XML Example\nThe following example will demonstrate how a web page can fetch information from an XML file with AJAX:\nExample\nTry it Yourself »\nExample Explained\nWhen a user clicks on the \"Get CD info\" button above, the loadDoc() function is executed.\nThe loadDoc() function creates an XMLHttpRequest object, adds the function to be executed when the server response is ready, and sends the request off to the server.\nWhen the server response is ready, an HTML table is built, nodes (elements) are extracted from the XML file, and it finally updates the element \"demo\" with the HTML table filled with XML data:\nLoadXMLDoc()\nThe XML File\nThe XML file used in the example above looks like this: \"cd_catalog.xml\".",
      "examples": [
        "function loadDoc() {\nvar xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\nmyFunction(this);\n}\n};\nxhttp.open(\"GET\", \"cd_catalog.xml\", true);\nxhttp.send();\n}\nfunction myFunction(xml) {\nvar i;\nvar xmlDoc = xml.responseXML;\nvar table=\"<tr><th>Title</th><th>Artist</th></tr>\";\nvar x = xmlDoc.getElementsByTagName(\"CD\");\nfor (i = 0; i <x.length; i++) {\ntable += \"<tr><td>\" +\nx[i].getElementsByTagName(\"TITLE\")[0].childNodes[0].nodeValue +\n\"</td><td>\" +\nx[i].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue +\n\"</td></tr>\";\n}\ndocument.getElementById(\"demo\").innerHTML = table;\n}"
      ]
    },
    {
      "title": "AJAX PHP Example",
      "summary": "AJAX is used to create more interactive applications.\nAJAX PHP Example\nThe following example demonstrates how a web page can communicate with a web server while a user types characters in an input field:\nExample\nStart typing a name in the input field below:\nExample Explained\nIn the example above, when a user types a character in the input field, a function called \"showHint()\" is executed.\nThe function is triggered by the onkeyup event.\nHere is the HTML code:\nExample\nCode explanation:\nFirst, check if the input field is empty (str.length == 0). If it is, clear the content of the txtHint placeholder and exit the function.\nHowever, if the input field is not empty, do the following:\nCreate an XMLHttpRequest object\nCreate the function to be executed when the server response is ready\nSend the request off to a PHP file (gethint.php) on the server\nNotice that q parameter is added gethint.php?q=\"+str\nThe str variable holds the content of the input field\nREMOVE ADS\nThe PHP File - \"gethint.php\"\nThe PHP file checks an array of names, and returns the corresponding name(s) to the browser:",
      "examples": [
        "<html>\n<head>\n<script>\nfunction showHint(str) {\nif (str.length == 0) {\ndocument.getElementById(\"txtHint\").innerHTML = \"\";\nreturn;\n} else {\nvar xmlhttp = new XMLHttpRequest();\nxmlhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"txtHint\").innerHTML = this.responseText;\n}\n};\nxmlhttp.open(\"GET\", \"gethint.php?q=\" + str, true);\nxmlhttp.send();\n}\n}\n</script>\n</head>\n<body>\n\n<p><b>Start typing a name in the input field below:</b></p>\n<form>\nFirst name: <input type=\"text\" onkeyup=\"showHint(this.value)\">\n</form>\n<p>Suggestions: <span id=\"txtHint\"></span></p>\n</body>\n</html>",
        "<?php\n// Array with names\n$a[] = \"Anna\";\n$a[] = \"Brittany\";\n$a[] = \"Cinderella\";\n$a[] = \"Diana\";\n$a[] = \"Eva\";\n$a[] = \"Fiona\";\n$a[] = \"Gunda\";\n$a[] = \"Hege\";\n$a[] = \"Inga\";\n$a[] = \"Johanna\";\n$a[] = \"Kitty\";\n$a[] = \"Linda\";\n$a[] = \"Nina\";\n$a[] = \"Ophelia\";\n$a[] = \"Petunia\";\n$a[] = \"Amanda\";\n$a[] = \"Raquel\";\n$a[] = \"Cindy\";\n$a[] = \"Doris\";\n$a[] = \"Eve\";\n$a[] = \"Evita\";\n$a[] = \"Sunniva\";\n$a[] = \"Tove\";\n$a[] = \"Unni\";\n$a[] = \"Violet\";\n$a[] = \"Liza\";\n$a[] = \"Elizabeth\";\n$a[] = \"Ellen\";\n$a[] = \"Wenche\";\n$a[] = \"Vicky\";\n\n// get the q parameter from URL\n$q = $_REQUEST[\"q\"];\n\n$hint = \"\";\n\n// lookup all hints from array if $q is different from \"\"\nif ($q !== \"\") {\n$q = strtolower($q);\n$len=strlen($q);\nforeach($a as $name) {\nif (stristr($q, substr($name, 0, $len))) {\nif ($hint === \"\") {\n$hint = $name;\n} else {\n$hint .= \", $name\";\n}\n}\n}\n}\n\n// Output \"no suggestion\" if no hint was found or output correct values\necho $hint === \"\" ? \"no suggestion\" : $hint;\n?>"
      ]
    },
    {
      "title": "AJAX ASP Example",
      "summary": "AJAX is used to create more interactive applications.\nAJAX ASP Example\nThe following example will demonstrate how a web page can communicate with a web server while a user type characters in an input field:\nExample\nStart typing a name in the input field below:\nExample Explained\nIn the example above, when a user types a character in the input field, a function called \"showHint()\" is executed.\nThe function is triggered by the onkeyup event.\nHere is the HTML code:\nExample\nCode explanation:\nFirst, check if the input field is empty (str.length == 0). If it is, clear the content of the txtHint placeholder and exit the function.\nHowever, if the input field is not empty, do the following:\nCreate an XMLHttpRequest object\nCreate the function to be executed when the server response is ready\nSend the request off to an ASP file (gethint.asp) on the server\nNotice that q parameter is added gethint.asp?q=\"+str\nThe str variable holds the content of the input field\nREMOVE ADS\nThe ASP File - \"gethint.asp\"\nThe ASP file checks an array of names, and returns the corresponding name(s) to the browser:",
      "examples": [
        "<html>\n<head>\n<script>\nfunction showHint(str) {\nif (str.length == 0) {\ndocument.getElementById(\"txtHint\").innerHTML = \"\";\nreturn;\n} else {\nvar xmlhttp = new XMLHttpRequest();\nxmlhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"txtHint\").innerHTML = this.responseText;\n}\n};\nxmlhttp.open(\"GET\", \"gethint.asp?q=\" + str, true);\nxmlhttp.send();\n}\n}\n</script>\n</head>\n<body>\n\n<p><b>Start typing a name in the input field below:</b></p>\n<form>\nFirst name: <input type=\"text\" onkeyup=\"showHint(this.value)\">\n</form>\n<p>Suggestions: <span id=\"txtHint\"></span></p>\n</body>\n</html>",
        "<%\nresponse.expires=-1\ndim a(30)\n'Fill up array with names\na(1)=\"Anna\"\na(2)=\"Brittany\"\na(3)=\"Cinderella\"\na(4)=\"Diana\"\na(5)=\"Eva\"\na(6)=\"Fiona\"\na(7)=\"Gunda\"\na(8)=\"Hege\"\na(9)=\"Inga\"\na(10)=\"Johanna\"\na(11)=\"Kitty\"\na(12)=\"Linda\"\na(13)=\"Nina\"\na(14)=\"Ophelia\"\na(15)=\"Petunia\"\na(16)=\"Amanda\"\na(17)=\"Raquel\"\na(18)=\"Cindy\"\na(19)=\"Doris\"\na(20)=\"Eve\"\na(21)=\"Evita\"\na(22)=\"Sunniva\"\na(23)=\"Tove\"\na(24)=\"Unni\"\na(25)=\"Violet\"\na(26)=\"Liza\"\na(27)=\"Elizabeth\"\na(28)=\"Ellen\"\na(29)=\"Wenche\"\na(30)=\"Vicky\"\n\n'get the q parameter from URL\nq=ucase(request.querystring(\"q\"))\n\n'lookup all hints from array if length of q>0\nif len(q)>0 then\nhint=\"\"\nfor i=1 to 30\nif q=ucase(mid(a(i),1,len(q))) then\nif hint=\"\" then\nhint=a(i)\nelse\nhint=hint & \" , \" & a(i)\nend if\nend if\nnext\nend if\n\n'Output \"no suggestion\" if no hint were found\n'or output the correct values\nif hint=\"\" then\nresponse.write(\"no suggestion\")\nelse\nresponse.write(hint)\nend if\n%>"
      ]
    },
    {
      "title": "AJAX Database Example",
      "summary": "AJAX can be used for interactive communication with a database.\nAJAX Database Example\nThe following example will demonstrate how a web page can fetch information from a database with AJAX:\nExample\nTry it Yourself »\nExample Explained - The showCustomer() Function\nWhen a user selects a customer in the dropdown list above, a function called \"showCustomer()\" is executed. The function is triggered by the \"onchange\" event:\nshowCustomer\nThe showCustomer() function does the following:\nCheck if a customer is selected\nCreate an XMLHttpRequest object\nCreate the function to be executed when the server response is ready\nSend the request off to a file on the server\nNotice that a parameter (q) is added to the URL (with the content of the dropdown list)\nREMOVE ADS\nThe AJAX Server Page\nThe page on the server called by the JavaScript above is an PHP file called \"getcustomer.php\".\nThe source code in \"getcustomer.php\" runs a query against a database, and returns the result in an HTML table:",
      "examples": [
        "function showCustomer(str) {\nvar xhttp;\nif (str == \"\") {\ndocument.getElementById(\"txtHint\").innerHTML = \"\";\nreturn;\n}\nxhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\ndocument.getElementById(\"txtHint\").innerHTML = this.responseText;\n}\n};\nxhttp.open(\"GET\", \"getcustomer.php?q=\"+str, true);\nxhttp.send();\n}",
        "<?php\n$mysqli = new mysqli(\"servername\", \"username\", \"password\", \"dbname\");\nif($mysqli->connect_error) {\nexit('Could not connect');\n}\n\n$sql = \"SELECT customerid, companyname, contactname, address, city, postalcode, country\nFROM customers WHERE customerid = ?\";\n\n$stmt = $mysqli->prepare($sql);\n$stmt->bind_param(\"s\", $_GET['q']);\n$stmt->execute();\n$stmt->store_result();\n$stmt->bind_result($cid, $cname, $name, $adr, $city, $pcode, $country);\n$stmt->fetch();\n$stmt->close();\n\necho \"<table>\";\necho \"<tr>\";\necho \"<th>CustomerID</th>\";\necho \"<td>\" . $cid . \"</td>\";\necho \"<th>CompanyName</th>\";\necho \"<td>\" . $cname . \"</td>\";\necho \"<th>ContactName</th>\";\necho \"<td>\" . $name . \"</td>\";\necho \"<th>Address</th>\";\necho \"<td>\" . $adr . \"</td>\";\necho \"<th>City</th>\";\necho \"<td>\" . $city . \"</td>\";\necho \"<th>PostalCode</th>\";\necho \"<td>\" . $pcode . \"</td>\";\necho \"<th>Country</th>\";\necho \"<td>\" . $country . \"</td>\";\necho \"</tr>\";\necho \"</table>\";\n?>"
      ]
    },
    {
      "title": "XML Applications",
      "summary": "This chapter demonstrates some HTML applications using XML, HTTP, DOM, and JavaScript.\nThe XML Document Used\nIn this chapter we will use the XML file called \"cd_catalog.xml\".\nDisplay XML Data in an HTML Table\nThis example loops through each <CD> element, and displays the values of the <ARTIST> and the <TITLE> elements in an HTML table:\nExample\nFor more information about using JavaScript and the XML DOM, go to DOM Intro.\nREMOVE ADS\nDisplay the First CD in an HTML div Element\nThis example uses a function to display the first CD element in an HTML element with id=\"showCD\":\nExample\nNavigate Between the CDs\nTo navigate between the CDs, in the example above, add a next() and previous() function:\nExample\nShow Album Information When Clicking On a CD\nThe last example shows how you can display album information when the user clicks on a CD:\nExample",
      "examples": [
        "<html>\n<head>\n<style>\ntable, th, td {\nborder: 1px solid black;\nborder-collapse:collapse;\n}\nth, td {\npadding: 5px;\n}\n</style>\n</head>\n<body>\n\n<button type=\"button\" onclick=\"loadXMLDoc()\">Get my CD collection</button>\n<br><br>\n<table id=\"demo\"></table>\n\n<script>\nfunction loadXMLDoc() {\nvar xmlhttp = new XMLHttpRequest();\nxmlhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\nmyFunction(this);\n}\n};\nxmlhttp.open(\"GET\", \"cd_catalog.xml\", true);\nxmlhttp.send();\n}\nfunction myFunction(xml) {\nvar i;\nvar xmlDoc = xml.responseXML;\nvar table=\"<tr><th>Artist</th><th>Title</th></tr>\";\nvar x = xmlDoc.getElementsByTagName(\"CD\");\nfor (i = 0; i <x.length; i++) {\ntable += \"<tr><td>\" +\nx[i].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue +\n\"</td><td>\" +\nx[i].getElementsByTagName(\"TITLE\")[0].childNodes[0].nodeValue +\n\"</td></tr>\";\n}\ndocument.getElementById(\"demo\").innerHTML = table;\n}\n</script>\n\n</body>\n</html>",
        "displayCD(0);\n\nfunction displayCD(i) {\nvar xmlhttp = new XMLHttpRequest();\nxmlhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\nmyFunction(this, i);\n}\n};\nxmlhttp.open(\"GET\", \"cd_catalog.xml\", true);\nxmlhttp.send();\n}\n\nfunction myFunction(xml, i) {\nvar xmlDoc = xml.responseXML;\nx = xmlDoc.getElementsByTagName(\"CD\");\ndocument.getElementById(\"showCD\").innerHTML =\n\"Artist: \" +\nx[i].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue +\n\"<br>Title: \" +\nx[i].getElementsByTagName(\"TITLE\")[0].childNodes[0].nodeValue +\n\"<br>Year: \" +\nx[i].getElementsByTagName(\"YEAR\")[0].childNodes[0].nodeValue;\n}",
        "function next() {\n// display the next CD, unless you are on the last CD\nif (i < x.length-1) {\ni++;\ndisplayCD(i);\n}\n}\n\nfunction previous() {\n// display the previous CD, unless you are on the first CD\nif (i > 0) {\ni--;\ndisplayCD(i);\n}\n}",
        "function displayCD(i) {\ndocument.getElementById(\"showCD\").innerHTML =\n\"Artist: \" +\nx[i].getElementsByTagName(\"ARTIST\")[0].childNodes[0].nodeValue +\n\"<br>Title: \" +\nx[i].getElementsByTagName(\"TITLE\")[0].childNodes[0].nodeValue +\n\"<br>Year: \" +\nx[i].getElementsByTagName(\"YEAR\")[0].childNodes[0].nodeValue;\n}"
      ]
    },
    {
      "title": "AJAX Examples",
      "summary": "Simple Examples\nA simple AJAX example\nCreate a simple XMLHttpRequest, and retrieve data from a TXT file.\nAn AJAX example with a callback function\nCreate a XMLHttpRequest with a callback function, and retrieve data from a TXT file.\nExamples explained\nRequest Header Information\nRetrieve all header information of a resource (file)\nRetrieve specific header information of a resource (file)\nExamples explained\nRequest XML Files\nLoad an XML file with AJAX\nCreate an XMLHttpRequest to retrieve data from an XML file.\nRetrieve the content of an XML file\nCreate an XMLHttpRequest to retrieve data from an XML file and display the data in an HTML table.\nExamples explained\nRetrieve Server Data with PHP and ASP\nRetrieve the content of a PHP file\nHow a web page can communicate with a web server while a user type characters in an input field.\nRetrieve the content of an ASP file\nHow a web page can communicate with a web server while a user type characters in an input field.\nExamples explained\nRetrieve Database Information\nRetrieve content from a database\nHow a web page can fetch information from a database with AJAX.\nExamples explained\nAJAX Applications\nView an XML CD catalog\nDisplay XML data in an HTML table\nShow XML data inside an HTML div element\nNavigate through XML nodes\nA simple CD catalog application\nExamples explained",
      "examples": []
    },
    {
      "title": "XML DOM Tutorial",
      "summary": "What is the DOM?\nThe DOM defines a standard for accessing and manipulating documents:\n\"The W3C Document Object Model (DOM) is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a document.\"\nThe HTML DOM defines a standard way for accessing and manipulating HTML documents. It presents an HTML document as a tree-structure.\nThe XML DOM defines a standard way for accessing and manipulating XML documents. It presents an XML document as a tree-structure.\nUnderstanding the DOM is a must for anyone working with HTML or XML.\nThe HTML DOM\nAll HTML elements can be accessed through the HTML DOM.\nThis example changes the value of an HTML element with id=\"demo\":\nExample\nThis example changes the value of the first <h1> element in an HTML document:\nExample\nNote: Even if the HTML document contains only ONE <h1> element you still have to specify the array index [0], because the getElementsByTagName() method always returns an array.\nYou can learn a lot more about the HTML DOM in our JavaScript tutorial.\nREMOVE ADS\nThe XML DOM\nAll XML elements can be accessed through the XML DOM.\nThe XML DOM is:\nA standard object model for XML\nA standard programming interface for XML\nPlatform- and language-independent\nA W3C standard\nIn other words: The XML DOM is a standard for how to get, change, add, or delete XML elements.\nGet the Value of an XML Element\nThis code retrieves the text value of the first <title> element in an XML document:\nExample\nLoading an XML File\nThe XML file used in the examples below is books.xml.\nThis example reads \"books.xml\" into xmlDoc and retrieves the text value of the first <title> element in books.xml:\nExample\nExample Explained\nxmlDoc - the XML DOM object created by the parser.\ngetElementsByTagName(\"title\")[0] - get the first <title> element\nchildNodes[0] - the first child of the <title> element (the text node)\nnodeValue - the value of the node (the text itself)\nLoading an XML String\nThis example loads a text string into an XML DOM object, and extracts the info from it with JavaScript:\nExample\nProgramming Interface\nThe DOM models XML as a set of node objects. The nodes can be accessed with JavaScript or other programming languages. In this tutorial we use JavaScript.\nThe programming interface to the DOM is defined by a set standard properties and methods.\nProperties are often referred to as something that is (i.e. nodename is \"book\").\nMethods are often referred to as something that is done (i.e. delete \"book\").\nXML DOM Properties\nThese are some typical DOM properties:\nx.nodeName - the name of x\nx.nodeValue - the value of x\nx.parentNode - the parent node of x\nx.childNodes - the child nodes of x\nx.attributes - the attributes nodes of x\nNote: In the list above, x is a node object.\nXML DOM Methods\nx.getElementsByTagName(name) - get all elements with a specified tag name\nx.appendChild(node) - insert a child node to x\nx.removeChild(node) - remove a child node from x\nNote: In the list above, x is a node object.",
      "examples": [
        "<h1 id=\"demo\">This is a Heading</h1>\n\n<script>\ndocument.getElementById(\"demo\").innerHTML = \"Hello World!\";\n</script>",
        "<h1>This is a Heading</h1>\n\n<h1>This is a Heading</h1>\n\n<script>\ndocument.getElementsByTagName(\"h1\")[0].innerHTML = \"Hello World!\";\n</script>",
        "txt = xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue;",
        "<!DOCTYPE html>\n<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\nmyFunction(this);\n}\n};\nxhttp.open(\"GET\", \"books.xml\", true);\nxhttp.send();\n\nfunction myFunction(xml) {\nvar xmlDoc = xml.responseXML;\ndocument.getElementById(\"demo\").innerHTML =\nxmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue;\n}\n</script>\n\n</body>\n</html>",
        "<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar text, parser, xmlDoc;\n\ntext = \"<bookstore><book>\" +\n\"<title>Everyday Italian</title>\" +\n\"<author>Giada De Laurentiis</author>\" +\n\"<year>2005</year>\" +\n\"</book></bookstore>\";\n\nparser = new DOMParser();\nxmlDoc = parser.parseFromString(text,\"text/xml\");\n\ndocument.getElementById(\"demo\").innerHTML =\nxmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue;\n</script>\n\n</body>\n</html>"
      ]
    },
    {
      "title": "XML DOM Nodes",
      "summary": "According to the XML DOM, everything in an XML document is a node:\nThe entire document is a document node\nEvery XML element is an element node\nThe text in the XML elements are text nodes\nEvery attribute is an attribute node\nComments are comment nodes\nDOM Example\nLook at the following XML file (books.xml):\nThe root node in the XML above is named <bookstore>.\nAll other nodes in the document are contained within <bookstore>.\nThe root node <bookstore> holds 4 <book> nodes.\nThe first <book> node holds the child nodes: <title>, <author>, <year>, and <price>.\nThe child nodes contain one text node each, \"Everyday Italian\", \"Giada De Laurentiis\", \"2005\", and \"30.00\".\nREMOVE ADS\nText is Always Stored in Text Nodes\nA common error in DOM processing is to expect an element node to contain text.\nHowever, the text of an element node is stored in a text node.\nIn this example: <year>2005</year>, the element node <year> holds a text node with the value \"2005\".\n\"2005\" is not the value of the <year> element!\nThe XML DOM Node Tree\nThe XML DOM views an XML document as a tree-structure. The tree structure is called a node-tree.\nAll nodes can be accessed through the tree. Their contents can be modified or deleted, and new elements can be created.\nThe node tree shows the set of nodes, and the connections between them. The tree starts at the root node and branches out to the text nodes at the lowest level of the tree:\nThe image above represents the XML file books.xml.\nNode Parents, Children, and Siblings\nThe nodes in the node tree have a hierarchical relationship to each other.\nThe terms parent, child, and sibling are used to describe the relationships. Parent nodes have children. Children on the same level are called siblings (brothers or sisters).\nIn a node tree, the top node is called the root\nEvery node, except the root, has exactly one parent node\nA node can have any number of children\nA leaf is a node with no children\nSiblings are nodes with the same parent\nThe following image illustrates a part of the node tree and the relationship between the nodes:\nBecause the XML data is structured in a tree form, it can be traversed without knowing the exact structure of the tree and without knowing the type of data contained within.\nYou will learn more about traversing the node tree in a later chapter of this tutorial.\nFirst Child - Last Child\nLook at the following XML fragment:\nIn the XML above, the <title> element is the first child of the <book> element, and the <price> element is the last child of the <book> element.\nFurthermore, the <book> element is the parent node of the <title>, <author>, <year>, and <price> elements.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bookstore>\n<book category=\"cooking\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n<book category=\"children\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n<book category=\"web\">\n<title lang=\"en\">XQuery Kick Start</title>\n<author>James McGovern</author>\n<author>Per Bothner</author>\n<author>Kurt Cagle</author>\n<author>James Linn</author>\n<author>Vaidyanathan Nagarajan</author>\n<year>2003</year>\n<price>49.99</price>\n</book>\n<book category=\"web\" cover=\"paperback\">\n<title lang=\"en\">Learning XML</title>\n<author>Erik T. Ray</author>\n<year>2003</year>\n<price>39.95</price>\n</book>\n</bookstore>",
        "<bookstore>\n<book category=\"cooking\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n</bookstore>"
      ]
    },
    {
      "title": "XML DOM - Accessing Nodes",
      "summary": "With the DOM, you can access every node in an XML document.\nAccessing Nodes\nYou can access a node in three ways:\nBy using the getElementsByTagName() method\nBy looping through (traversing) the nodes tree\nBy navigating the node tree, using the node relationships\nThe getElementsByTagName() Method\ngetElementsByTagName() returns all elements with a specified tag name.\nSyntax\nExample\nThe following example returns all <title> elements under the x element:\nNote that the example above only returns <title> elements under the x node. To return all <title> elements in the XML document use:\nwhere xmlDoc is the document itself (document node).\nREMOVE ADS\nDOM Node List\nThe getElementsByTagName() method returns a node list. A node list is an array of nodes.\nThe <title> elements in x can be accessed by index number. To access the third <title> you can write::\nNote: The index starts at 0.\nTry it Yourself\nDOM Node List Length\nThe length property defines the length of a node list (the number of nodes).\nYou can loop through a node list by using the length property:\nExample\nNode Types\nThe documentElement property of the XML document is the root node.\nThe nodeName property of a node is the name of the node.\nThe nodeType property of a node is the type of the node.\nYou will learn more about the node properties in the next chapter of this tutorial.\nTry it Yourself\nTraversing Nodes\nThe following code loops through the child nodes, that are also element nodes, of the root node:\nExample\nExample explained:\nSuppose you have loaded \"books.xml\" into xmlDoc\nGet the child nodes of the root element (xmlDoc)\nFor each child node, check the node type. If the node type is \"1\" it is an element node\nOutput the name of the node if it is an element node\nNavigating Node Relationships\nThe following code navigates the node tree using the node relationships:\nExample\nExample explained:\nSuppose you have loaded \"books.xml\" into xmlDoc\nGet the child nodes of the first book element\nSet the \"y\" variable to be the first child node of the first book element\nFor each child node (starting with the first child node \"y\"):\nCheck the node type. If the node type is \"1\" it is an element node\nOutput the name of the node if it is an element node\nSet the \"y\" variable to be the next sibling node, and run through the loop again",
      "examples": [
        "node.getElementsByTagName(\"tagname\");",
        "x.getElementsByTagName(\"title\");",
        "xmlDoc.getElementsByTagName(\"title\");",
        "x = xmlDoc.getElementsByTagName(\"title\");",
        "y = x[2];",
        "var x = xmlDoc.getElementsByTagName(\"title\");\n\nfor (i = 0; i <x.length; i++) {\n// do something for each node\n}",
        "txt = \"\";\nx = xmlDoc.documentElement.childNodes;\n\nfor (i = 0; i <x.length; i++) {\n// Process only element nodes (type 1)\nif (x[i].nodeType == 1) {\ntxt += x[i].nodeName + \"<br>\";\n}\n}",
        "x = xmlDoc.getElementsByTagName(\"book\")[0];\nxlen = x.childNodes.length;\ny = x.firstChild;\n\ntxt = \"\";\nfor (i = 0; i <xlen; i++) {\n// Process only element nodes (type 1)\nif (y.nodeType == 1) {\ntxt += y.nodeName + \"<br>\";\n}\ny = y.nextSibling;\n}"
      ]
    },
    {
      "title": "XML DOM Node Information",
      "summary": "The nodeName, nodeValue, and nodeType properties contain information about nodes.\nNode Properties\nIn the XML DOM, each node is an object.\nObjects have methods and properties, that can be accessed and manipulated by JavaScript.\nThree important node properties are:\nnodeName\nnodeValue\nnodeType\nThe nodeName Property\nThe nodeName property specifies the name of a node.\nnodeName is read-only\nnodeName of an element node is the same as the tag name\nnodeName of an attribute node is the attribute name\nnodeName of a text node is always #text\nnodeName of the document node is always #document\nTry it Yourself.\nThe nodeValue Property\nThe nodeValue property specifies the value of a node.\nnodeValue for element nodes is undefined\nnodeValue for text nodes is the text itself\nnodeValue for attribute nodes is the attribute value\nREMOVE ADS\nGet the Value of an Element\nThe following code retrieves the text node value of the first <title> element:\nExample\nResult: txt = \"Everyday Italian\"\nExample explained:\nSuppose you have loaded books.xml into xmlDoc\nGet text node of the first <title> element node\nSet the txt variable to be the value of the text node\nChange the Value of an Element\nThe following code changes the text node value of the first <title> element:\nExample\nExample explained:\nSuppose you have loaded books.xml into xmlDoc\nGet text node of the first <title> element node\nChange the value of the text node to \"Easy Cooking\"\nThe nodeType Property\nThe nodeType property specifies the type of node.\nnodeType is read only.\nThe most important node types are:\nTry it Yourself.",
      "examples": [
        "var x = xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0];\nvar txt = x.nodeValue;",
        "var x = xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0];\nx.nodeValue = \"Easy Cooking\";"
      ]
    },
    {
      "title": "XML DOM Node List",
      "summary": "A list of nodes is returned by the getElementsByTagName() method and the childNodes property.\nDOM Node List\nWhen using properties or methods like childNodes or getElementsByTagName(), a node list object is returned.\nA node list object represents a list of nodes, in the same order as in the XML.\nNodes in the node list are accessed with index numbers starting from 0.\nThe following image represents a node list of the <title> elements in books.xml:\nSuppose \"books.xml\" is loaded into the variable xmlDoc.\nThis code fragment returns a node list of title elements in \"books.xml\":\nAfter the execution of the statement above, x is a node list object.\nThe following code fragment returns the text from the first <title> element in the node list (x):\nExample\nAfter the execution of the statement above, txt = \"Everyday Italian\".\nREMOVE ADS\nNode List Length\nA node list object keeps itself up-to-date. If an element is deleted or added, the list is automatically updated.\nThe length property of a node list is the number of nodes in the list.\nThis code fragment returns the number of <title> elements in \"books.xml\":\nAfter the execution of the statement above, the value of x will be 4.\nThe length of the node list can be used to loop through all the elements in the list.\nThis code fragment uses the length property to loop through the list of <title> elements:\nExample\nOutput:\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nSet the x variable to hold a node list of all title elements\nCollect the text node values from <title> elements\nDOM Attribute List (Named Node Map)\nThe attributes property of an element node returns a list of attribute nodes.\nThis is called a named node map, and is similar to a node list, except for some differences in methods and properties.\nAn attribute list keeps itself up-to-date. If an attribute is deleted or added, the list is automatically updated.\nThis code fragment returns a list of attribute nodes from the first <book> element in \"books.xml\":\nAfter the execution of the code above, x.length is the number of attributes and x.getNamedItem() can be used to return an attribute node.\nThis code fragment gets the value of the \"category\" attribute, and the number of attributes, of a book:\nExample\nOutput:\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nSet the x variable to hold a list of all attributes of the first <book> element\nGet the value of the \"category\" attribute and the length of the attribute list",
      "examples": [
        "x = xmlDoc.getElementsByTagName(\"title\");",
        "var txt = x[0].childNodes[0].nodeValue;",
        "x = xmlDoc.getElementsByTagName('title').length;",
        "x = xmlDoc.getElementsByTagName('title');\nxLen = x.length;\n\nfor (i = 0; i <xLen; i++) {\ntxt += x[i].childNodes[0].nodeValue) + \" \";\n}",
        "Everyday Italian\nHarry Potter\nXQuery Kick Start\nLearning XML",
        "x = xmlDoc.getElementsByTagName('book')[0].attributes;",
        "x = xmlDoc.getElementsByTagName(\"book\")[0].attributes;\n\ntxt = x.getNamedItem(\"category\").nodeValue + \" \" + x.length;",
        "cooking 1"
      ]
    },
    {
      "title": "XML DOM Traverse Node Tree",
      "summary": "Traversing means looping through or traveling across the node tree.\nTraversing the Node Tree\nOften you want to loop an XML document, for example: when you want to extract the value of each element.\nThis is called \"Traversing the node tree\"\nThe example below loops through all child nodes of <book>, and displays their names and values:\nExample\nOutput:\nExample explained:\nLoad the XML string into xmlDoc\nGet the child nodes of the root element\nFor each child node, output the node name and the node value of the text node\nREMOVE ADS\nBrowser Differences in DOM Parsing\nAll modern browsers support the W3C DOM specification.\nHowever, there are some differences between browsers. One important difference is:\nThe way they handle white-spaces and new lines\nDOM - White Spaces and New Lines\nXML often contains new line, or white space characters, between nodes. This is often the case when the document is edited by a simple editor like Notepad.\nThe following example (edited by Notepad) contains CR/LF (new line) between each line and two spaces in front of each child node:\nInternet Explorer 9 and earlier do NOT treat empty white-spaces, or new lines as text nodes, while other browsers do.\nThe following example will output the number of child nodes the root element (of books.xml) has. IE9 and earlier will output 4 child nodes, while IE10 and later versions, and other browsers will output 9 child nodes:\nExample\nPCDATA - Parsed Character Data\nXML parsers normally parse all the text in an XML document.\nWhen an XML element is parsed, the text between the XML tags is also parsed:\nThe parser does this because XML elements can contain other elements, as in this example, where the <name> element contains two other elements (first and last):\nand the parser will break it up into sub-elements like this:\nParsed Character Data (PCDATA) is a term used about text data that will be parsed by the XML parser.\nCDATA - (Unparsed) Character Data\nThe term CDATA is used about text data that should not be parsed by the XML parser.\nCharacters like \"<\" and \"&\" are illegal in XML elements.\n\"<\" will generate an error because the parser interprets it as the start of a new element.\n\"&\" will generate an error because the parser interprets it as the start of a character entity.\nSome text, like JavaScript code, contains a lot of \"<\" or \"&\" characters. To avoid errors script code can be defined as CDATA.\nEverything inside a CDATA section is ignored by the parser.\nA CDATA section starts with \"<![CDATA[\" and ends with \"]]>\":\nIn the example above, everything inside the CDATA section is ignored by the parser.\nNotes on CDATA sections:\nA CDATA section cannot contain the string \"]]>\". Nested CDATA sections are not allowed.\nThe \"]]>\" that marks the end of the CDATA section cannot contain spaces or line breaks.",
      "examples": [
        "<!DOCTYPE html>\n<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar x, i ,xmlDoc;\nvar txt = \"\";\nvar text = \"<book>\" +\n\"<title>Everyday Italian</title>\" +\n\"<author>Giada De Laurentiis</author>\" +\n\"<year>2005</year>\" +\n\"</book>\";\n\nparser = new DOMParser();\nxmlDoc = parser.parseFromString(text,\"text/xml\");\n\n// documentElement always represents the root node\nx = xmlDoc.documentElement.childNodes;\nfor (i = 0; i < x.length ;i++) {\ntxt += x[i].nodeName + \": \" + x[i].childNodes[0].nodeValue + \"<br>\";\n}\ndocument.getElementById(\"demo\").innerHTML = txt;\n</script>\n\n</body>\n</html>",
        "title: Everyday Italian\nauthor: Giada De Laurentiis\nyear: 2005",
        "<book>\n<title>Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>",
        "function myFunction(xml) {\nvar xmlDoc = xml.responseXML;\nx = xmlDoc.documentElement.childNodes;\ndocument.getElementById(\"demo\").innerHTML =\n\"Number of child nodes: \" + x.length;\n}",
        "<message>This text is also parsed</message>",
        "<name><first>Bill</first><last>Gates</last></name>",
        "<name>\n<first>Bill</first>\n<last>Gates</last>\n</name>",
        "<script>\n<![CDATA[\nfunction matchwo(a,b) {\nif (a < b && a < 0) {\nreturn 1;\n} else {\nreturn 0;\n}\n}\n]]>\n</script>"
      ]
    },
    {
      "title": "XML DOM - Navigating Nodes",
      "summary": "Nodes can be navigated using node relationships.\nNavigating DOM Nodes\nAccessing nodes in the node tree via the relationship between nodes, is often called \"navigating nodes\".\nIn the XML DOM, node relationships are defined as properties to the nodes:\nparentNode\nchildNodes\nfirstChild\nlastChild\nnextSibling\npreviousSibling\nThe following image illustrates a part of the node tree and the relationship between nodes in books.xml:\nDOM - Parent Node\nAll nodes have exactly one parent node. The following code navigates to the parent node of <book>:\nExample\nExample explained:\nLoad books.xml into xmlDoc\nGet the first <book> element\nOutput the node name of the parent node of \"x\"\nREMOVE ADS\nAvoid Empty Text Nodes\nSome browsers might treat empty white-spaces or new lines as text nodes. This causes a problem when using the properties: firstChild, lastChild, nextSibling, previousSibling.\nTo avoid navigating to empty text nodes (spaces and new-line characters between element nodes), we use a function that checks the node type:\nThe function above allows you to use get_nextSibling(node) instead of the property node.nextSibling.\nCode explained:\nElement nodes are type 1. If the sibling node is not an element node, it moves to the next nodes until an element node is found.\nGet the First Child Element\nThe following code displays the first element node of the first <book>:\nExample\nOutput:\nExample explained:\nLoad books.xml into xmlDoc\nUse the get_firstChild function on the first <book> element node to get the first child node that is an element node\nOutput the node name of first child node that is an element node\nMore Examples\nlastChild()\nUse the lastChild() method and a custom function to get the last child node of a node.\nnextSibling()\nUse the nextSibling() method and a custom function to get the next sibling node of a node.\npreviousSibling()\nUse the previousSibling() method and a custom function to get the previous sibling node of a node.",
      "examples": [
        "function myFunction(xml) {\nvar xmlDoc = xml.responseXML;\nvar x = xmlDoc.getElementsByTagName(\"book\")[0];\ndocument.getElementById(\"demo\").innerHTML = x.parentNode.nodeName;\n}",
        "function get_nextSibling(n) {\nvar y = n.nextSibling;\nwhile (y.nodeType != 1) {\ny = y.nextSibling;\n}\nreturn y;\n}",
        "<!DOCTYPE html>\n<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\nmyFunction(this);\n}\n};\nxhttp.open(\"GET\", \"books.xml\", true);\nxhttp.send();\n\nfunction myFunction(xml) {\nvar xmlDoc = xml.responseXML;\nvar x = get_firstChild(xmlDoc.getElementsByTagName(\"book\")[0]);\ndocument.getElementById(\"demo\").innerHTML = x.nodeName;\n}\n\n//check if the first node is an element node\nfunction get_firstChild(n) {\nvar y = n.firstChild;\nwhile (y.nodeType != 1) {\ny = y.nextSibling;\n}\nreturn y;\n}\n</script>\n\n</body>\n</html>",
        "title"
      ]
    },
    {
      "title": "XML DOM Get Node Values",
      "summary": "The nodeValue property is used to get the text value of a node.\nThe getAttribute() method returns the value of an attribute.\nGet the Value of an Element\nIn the DOM, everything is a node. Element nodes do not have a text value.\nThe text value of an element node is stored in a child node. This node is called a text node.\nTo retrieve the text value of an element, you must retrieve the value of the elements' text node.\nThe getElementsByTagName Method\nThe getElementsByTagName() method returns a node list of all elements, with the specified tag name, in the same order as they appear in the source document.\nSuppose books.xml has been loaded into xmlDoc.\nThis code retrieves the first <title> element:\nThe ChildNodes Property\nThe childNodes property returns a list of an element's child nodes.\nThe following code retrieves the text node of the first <title> element:\nThe nodeValue Property\nThe nodeValue property returns the text value of a text node.\nThe following code retrieves the text value of the text node of the first <title> element:\nExample\nResult in z: \"Everyday Italian\"\nREMOVE ADS\nComplete Example\nExample\nLoop through all <title> elements: Try it Yourself\nGet the Value of an Attribute\nIn the DOM, attributes are nodes. Unlike element nodes, attribute nodes have text values.\nThe way to get the value of an attribute, is to get its text value.\nThis can be done using the getAttribute() method or using the nodeValue property of the getAttributeNode() method.\nGet Value Using getAttribute()\nThe getAttribute() method returns an attribute's value.\nThe following code retrieves the text value of the \"lang\" attribute of the first <title> element:\nExample\nLoop through all <book> elements and get their \"category\" attributes:\nExample\nGet Value Using - getAttributeNode()\nThe getAttributeNode() method returns an attribute node.\nThe following code retrieves the text value of the \"lang\" attribute of the first <title> element:\nExample\nLoop through all <book> elements and get their \"category\" attributes:\nExample",
      "examples": [
        "var x = xmlDoc.getElementsByTagName(\"title\")[0];",
        "x = xmlDoc.getElementsByTagName(\"title\")[0];\ny = x.childNodes[0];",
        "x = xmlDoc.getElementsByTagName(\"title\")[0];\ny = x.childNodes[0];\nz = y.nodeValue;",
        "<!DOCTYPE html>\n<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (this.readyState == 4 && this.status == 200) {\nmyFunction(this);\n}\n};\nxhttp.open(\"GET\", \"books.xml\", true);\nxhttp.send();\n\nfunction myFunction(xml) {\nvar xmlDoc = xml.responseXML;\nvar x = xmlDoc.getElementsByTagName('title')[0];\nvar y = x.childNodes[0];\ndocument.getElementById(\"demo\").innerHTML = y.nodeValue;\n}\n</script>\n\n</body>\n</html>",
        "const title = xmlDoc.getElementsByTagName(\"title\")[0];\nlet txt = title.getAttribute(\"lang\");",
        "const book = xmlDoc.getElementsByTagName(\"book\");\nfor (let i = 0; i < book.length; i++) {\ntxt += x[i].getAttributeNode(\"category\").nodeValue + \"<br>\";\n}",
        "const title = xmlDoc.getElementsByTagName(\"title\")[0];\nconst lang = title.getAttributeNode(\"lang\");\nlet txt = lang.nodeValue;"
      ]
    },
    {
      "title": "XML DOM Change Node Values",
      "summary": "The nodeValue property is used to change a node value.\nThe setAttribute() method is used to change an attribute value.\nChange the Value of an Element\nIn the DOM, everything is a node. Element nodes do not have a text value.\nThe text value of an element node is stored in a child node. This node is called a text node.\nTo change the text value of an element, you must change the value of the elements's text node.\nChange the Value of a Text Node\nThe nodeValue property can be used to change the value of a text node.\nThis code changes the text node value of the first <title> element:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nGet the first child node of the <title> element\nChange the node value to \"new content\"\nLoop through and change the text node of all <title> elements: Try it yourself\nREMOVE ADS\nChange the Value of an Attribute\nIn the DOM, attributes are nodes. Unlike element nodes, attribute nodes have text values.\nThe way to change the value of an attribute, is to change its text value.\nThis can be done using the setAttribute() method or setting the nodeValue property of the attribute node.\nChange an Attribute Using setAttribute()\nThe setAttribute() method changes the value of an attribute.\nIf the attribute does not exist, a new attribute is created.\nThis code changes the category attribute of the <book> element:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nGet the first <book> element\nChange the \"category\" attribute value to \"food\"\nLoop through all <title> elements and add a new attribute: Try it yourself\nNote: If the attribute does not exist, a new attribute is created (with the name and value specified).\nChange an Attribute Using nodeValue\nThe nodeValue property is the value of a attribute node.\nChanging the value property changes the value of the attribute.\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nGet the \"category\" attribute of the first <book> element\nChange the attribute node value to \"food\"",
      "examples": [
        "xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue = \"new content\"",
        "xmlDoc.getElementsByTagName(\"book\")[0].setAttribute(\"category\",\"food\");",
        "xmlDoc.getElementsByTagName(\"book\")[0].getAttributeNode(\"category\").nodeValue = \"food\";"
      ]
    },
    {
      "title": "XML DOM Remove Nodes",
      "summary": "The removeChild() method removes a specified node.\nThe removeAttribute() method removes a specified attribute.\nRemove an Element Node\nThe removeChild() method removes a specified node.\nWhen a node is removed, all its child nodes are also removed.\nThis code will remove the first <book> element from the loaded xml:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nSet the variable y to be the element node to remove\nRemove the element node by using the removeChild() method from the parent node\nREMOVE ADS\nRemove Myself - Remove the Current Node\nThe removeChild() method is the only way to remove a specified node.\nWhen you have navigated to the node you want to remove, it is possible to remove that node using the parentNode property and the removeChild() method:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nSet the variable y to be the element node to remove\nRemove the element node by using the parentNode property and the removeChild() method\nRemove a Text Node\nThe removeChild() method can also be used to remove a text node:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nSet the variable x to be the first title element node\nSet the variable y to be the text node to remove\nRemove the element node by using the removeChild() method from the parent node\nIt is not very common to use removeChild() just to remove the text from a node. The nodeValue property can be used instead. See next paragraph.\nClear a Text Node\nThe nodeValue property can be used to change the value of a text node:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nGet the first title element's first child node.\nUse the nodeValue property to clear the text from the text node\nRemove an Attribute Node by Name\nThe removeAttribute() method removes an attribute node by its name.\nExample: removeAttribute('category')\nThis code removes the \"category\" attribute in the first <book> element:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nUse getElementsByTagName() to get book nodes\nRemove the \"category\" attribute form the first book element node\nLoop through and remove the \"category\" attribute of all <book> elements: Try it yourself\nRemove Attribute Nodes by Object\nThe removeAttributeNode() method removes an attribute node, using the node object as parameter.\nExample: removeAttributeNode(x)\nThis code removes all the attributes of all <book> elements:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nUse getElementsByTagName() to get all book nodes\nFor each book element check if there are any attributes\nWhile there are attributes in a book element, remove the attribute",
      "examples": [
        "y = xmlDoc.getElementsByTagName(\"book\")[0];\n\nxmlDoc.documentElement.removeChild(y);",
        "x = xmlDoc.getElementsByTagName(\"book\")[0];\n\nx.parentNode.removeChild(x);",
        "x = xmlDoc.getElementsByTagName(\"title\")[0];\ny = x.childNodes[0];\nx.removeChild(y);",
        "xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].nodeValue = \"\";",
        "x = xmlDoc.getElementsByTagName(\"book\");\nx[0].removeAttribute(\"category\");",
        "x = xmlDoc.getElementsByTagName(\"book\");\n\nfor (i = 0; i < x.length; i++) {\nwhile (x[i].attributes.length > 0) {\nattnode = x[i].attributes[0];\nold_att = x[i].removeAttributeNode(attnode);\n}\n}"
      ]
    },
    {
      "title": "XML DOM Replace Nodes",
      "summary": "The replaceChild() method replaces a specified node.\nThe nodeValue property replaces text in a text node.\nReplace an Element Node\nThe replaceChild() method is used to replace a node.\nThe following code fragment replaces the first <book> element:\nExample\nExample explained:\nLoad books.xml into xmlDoc\nCreate a new element node <book>\nCreate a new element node <title>\nCreate a new text node with the text \"A Notebook\"\nAppend the new text node to the new element node <title>\nAppend the new element node <title> to the new element node <book>\nReplace the first <book> element node with the new <book> element node\nREMOVE ADS\nReplace Data In a Text Node\nThe replaceData() method is used to replace data in a text node.\nThe replaceData() method has three parameters:\noffset - Where to begin replacing characters. Offset value starts at zero\nlength - How many characters to replace\nstring - The string to insert\nExample\nExample explained:\nLoad books.xml into xmlDoc\nGet the text node of the first <title> element node\nUse the replaceData method to replace the eight first characters from the text node with \"Easy\"\nUse the nodeValue Property Instead\nIt is easier to replace the data in a text node using the nodeValue property.\nThe following code fragment will replace the text node value in the first <title> element with \"Easy Italian\":\nExample\nExample explained:\nLoad books.xml into xmlDoc\nGet the text node of the first <title> element node\nUse the nodeValue property to change the text of the text node\nYou can read more about changing node values in the Change Node chapter.",
      "examples": [
        "xmlDoc=loadXMLDoc(\"books.xml\");\n\nx=xmlDoc.documentElement;\n\n//create a book element, title element and a text node\nnewNode=xmlDoc.createElement(\"book\");\nnewTitle=xmlDoc.createElement(\"title\");\nnewText=xmlDoc.createTextNode(\"A Notebook\");\n\n//add the text node to the title node,\nnewTitle.appendChild(newText);\n//add the title node to the book node\nnewNode.appendChild(newTitle);\n\ny=xmlDoc.getElementsByTagName(\"book\")[0]\n//replace the first book node with the new node\nx.replaceChild(newNode,y);",
        "xmlDoc=loadXMLDoc(\"books.xml\");\n\nx=xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0];\n\nx.replaceData(0,8,\"Easy\");",
        "xmlDoc=loadXMLDoc(\"books.xml\");\n\nx=xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0];\n\nx.nodeValue=\"Easy Italian\";"
      ]
    },
    {
      "title": "XML DOM Create Nodes",
      "summary": "Create a New Element Node\nThe createElement() method creates a new element node:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nCreate a new element node <edition>\nAppend the element node to the first <book> element\nLoop through and add an element to all <book> elements: Try it yourself\nREMOVE ADS\nCreate a New Attribute Node\nThe createAttribute() is used to create a new attribute node:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nCreate a new attribute node \"edition\"\nSet the value of the attribute node to \"first\"\nAdd the new attribute node to the first <title> element\nLoop through all <title> elements and add a new attribute node: Try it yourself\nIf the attribute already exists, it is replaced by the new one.\nCreate an Attribute Using setAttribute()\nSince the setAttribute() method creates a new attribute if the attribute does not exist, it can be used to create a new attribute.\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nSet the attribute \"edition\" value to \"first\" for the first <book> element\nLoop through all <title> elements and add a new attribute: Try it yourself\nCreate a Text Node\nThe createTextNode() method creates a new text node:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nCreate a new element node <edition>\nCreate a new text node with the text \"first\"\nAppend the new text node to the element node\nAppend the new element node to the first <book> element\nAdd an element node, with a text node, to all <book> elements: Try it yourself\nCreate a CDATA Section Node\nThe createCDATASection() method creates a new CDATA section node.\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nCreate a new CDATA section node\nAppend the new CDATA node to the first <book> element\nLoop through, and add a CDATA section, to all <book> elements: Try it yourself\nCreate a Comment Node\nThe createComment() method creates a new comment node.\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc using\nCreate a new comment node\nAppend the new comment node to the first <book> element\nLoop through, and add a comment node, to all <book> elements: Try it yourself",
      "examples": [
        "newElement = xmlDoc.createElement(\"edition\");\n\nxmlDoc.getElementsByTagName(\"book\")[0].appendChild(newElement);",
        "newAtt = xmlDoc.createAttribute(\"edition\");\nnewAtt.nodeValue = \"first\";\n\nxmlDoc.getElementsByTagName(\"title\")[0].setAttributeNode(newAtt);",
        "xmlDoc.getElementsByTagName('book')[0].setAttribute(\"edition\",\"first\");",
        "newEle = xmlDoc.createElement(\"edition\");\nnewText = xmlDoc.createTextNode(\"first\");\nnewEle.appendChild(newText);\n\nxmlDoc.getElementsByTagName(\"book\")[0].appendChild(newEle);",
        "newCDATA = xmlDoc.createCDATASection(\"Special Offer & Book Sale\");\n\nxmlDoc.getElementsByTagName(\"book\")[0].appendChild(newCDATA);",
        "newComment = xmlDoc.createComment(\"Revised March 2015\");\n\nxmlDoc.getElementsByTagName(\"book\")[0].appendChild(newComment);"
      ]
    },
    {
      "title": "XML DOM Add Nodes",
      "summary": "Add a Node - appendChild()\nThe appendChild() method adds a child node to an existing node.\nThe new node is added (appended) after any existing child nodes.\nNote: Use insertBefore() if the position of the node is important.\nThis code fragment creates an element (<edition>), and adds it after the last child of the first <book> element:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nCreate a new node <edition>\nAppend the node to the first <book> element\nThis code fragment does the same as above, but the new element is added with a value:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nCreate a new node <edition>\nCreate a new text node \"first\"\nAppend the text node to the <edition> node\nAppend the <addition> node to the <book> element\nREMOVE ADS\nInsert a Node - insertBefore()\nThe insertBefore() method inserts a node before a specified child node.\nThis method is useful when the position of the added node is important:\nExample\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nCreate a new element node <book>\nInsert the new node in front of the last <book> element node\nIf the second parameter of insertBefore() is null, the new node will be added after the last existing child node.\nx.insertBefore(newNode,null) and x.appendChild(newNode) will both append a new child node to x.\nAdd a New Attribute\nThe setAttribute() method sets the value of an attribute.\nExample\nExample explained:\nSuppose books.xml has been loaded into xmlDoc\nSet the value of the attribute \"edition\" to \"first\" for the first <book> element\nThere is no method called add Attribute()\nThe setAttribute() will create a new attribute if the attribute does not exist.\nNote: If the attribute already exists, the setAttribute() method will overwrite the existing value.\nAdd Text to a Text Node - insertData()\nThe insertData() method inserts data into an existing text node.\nThe insertData() method has two parameters:\noffset - Where to begin inserting characters (starts at zero)\nstring - The string to insert\nThe following code fragment will add \"Easy\" to the text node of the first <title> element of the loaded XML:\nExample",
      "examples": [
        "newEle = xmlDoc.createElement(\"edition\");\n\nxmlDoc.getElementsByTagName(\"book\")[0].appendChild(newEle);",
        "newEle = xmlDoc.createElement(\"edition\");\nnewText=xmlDoc.createTextNode(\"first\");\nnewEle.appendChild(newText);\n\nxmlDoc.getElementsByTagName(\"book\")[0].appendChild(newEle);",
        "newNode = xmlDoc.createElement(\"book\");\n\nx = xmlDoc.documentElement;\ny = xmlDoc.getElementsByTagName(\"book\")[3];\n\nx.insertBefore(newNode,y);",
        "xmlDoc.getElementsByTagName('book')[0].setAttribute(\"edition\",\"first\");",
        "xmlDoc.getElementsByTagName(\"title\")[0].childNodes[0].insertData(0,\"Easy \");"
      ]
    },
    {
      "title": "XML DOM Clone Nodes",
      "summary": "Clone a Node\nThe cloneNode() method creates a copy of a specified node.\nThe cloneNode() method has a parameter (true or false). This parameter indicates if the cloned node should include all attributes and child nodes of the original node.\nThe following code fragment copies the first <book> node and appends it to the root node of the document:\nExample\nResult:\nExample explained:\nSuppose books.xml is loaded into xmlDoc\nGet the node to copy (oldNode)\nClone the node into \"newNode\"\nAppend the new node to the root node of the XML document",
      "examples": [
        "oldNode = xmlDoc.getElementsByTagName('book')[0];\nnewNode = oldNode.cloneNode(true);\nxmlDoc.documentElement.appendChild(newNode);",
        "Everyday Italian\nHarry Potter\nXQuery Kick Start\nLearning XML\nEveryday Italian"
      ]
    },
    {
      "title": "XML DOM Examples",
      "summary": "XML DOM Loading XML\nThe examples below use the XML file books.xml.\nLoad and parse an XML file\nLoad and parse an XML file (II)\nLoad and XML string\nLoad and parse an XML string (II)\nXML DOM Accessing Nodes\nThe examples below use the XML file books.xml.\nAccess a node using its index number in a node list\nLoop through nodes using the length property\nSee the node type of an element\nLoop through element nodes\nLoop through element nodes using node relationships\nExamples explained\nXML DOM Node Information\nThe examples below use the XML file books.xml.\nGet the node name of an element node\nGet the text from a text node\nChange the text in a text node\nGet the node name and type of an element node\nExamples explained\nXML DOM Node List and Attribute List\nThe examples below use the XML file books.xml.\nGet the text from the first <title> element\nLoop through nodes using the length property\nGet the attribute of an element\nExamples explained\nREMOVE ADS\nXML DOM Traversing Node Tree\nThe examples below use the XML file books.xml.\nTraverse a node tree\nDisplay the length of a node list\nExamples explained\nXML DOM Navigating Nodes\nThe examples below use the XML file books.xml.\nGet the parent of a node\nGet the first child element of a node\nGet the last child element of a node\nGet the next sibling element of a node\nGet the previous sibling element of a node\nExamples explained\nXML DOM Get Node Values\nThe examples below use the XML file books.xml.\nGet an element's text value\nGet an attribute's text value\nExamples explained\nXML DOM Change Node Values\nThe examples below use the XML file books.xml.\nChange an elements text node\nChange an attributes value using setAttribute\nChange an attributes value using nodeValue\nExamples explained\nXML DOM Remove Nodes\nThe examples below use the XML file books.xml.\nRemove an element node\nRemove the current element node\nRemove a text node\nClear the text of a text node\nRemove an attribute by name\nRemove attributes by object\nExamples explained\nXML DOM Replace Nodes\nThe examples below use the XML file books.xml.\nReplace an element node\nReplace data in a text node\nExamples explained\nXML DOM Create Nodes\nThe examples below use the XML file books.xml.\nCreate an element node\nCreate an attribute node using createAttribute\nCreate an attribute node using setAttribute\nCreate a text node\nCreate a CDATA section node\nCreate a comment node\nExamples explained\nXML DOM Add Nodes\nThe examples below use the XML file books.xml.\nAdd a node after the last child node\nAdd a node before a specified child node\nAdd a new attribute\nAdd data to a text node\nExamples explained\nXML DOM Clone Nodes\nThe examples below use the XML file books.xml.\nCopy a node and append it to an existing node\nExamples explained",
      "examples": []
    },
    {
      "title": "XPath Tutorial",
      "summary": "What is XPath?\nXPath is a major element in the XSLT standard.\nXPath can be used to navigate through elements and attributes in an XML document.\nXPath stands for XML Path Language\nXPath uses \"path like\" syntax to identify and navigate nodes in an XML document\nXPath contains over 200 built-in functions\nXPath is a major element in the XSLT standard\nXPath is a W3C recommendation\nXPath Path Expressions\nXPath uses path expressions to select nodes or node-sets in an XML document.\nThese path expressions look very much like the path expressions you use with traditional computer file systems:\nXPath Standard Functions\nXPath includes over 200 built-in functions.\nThere are functions for string values, numeric values, booleans, date and time comparison, node manipulation, sequence manipulation, and much more.\nToday XPath expressions can also be used in JavaScript, Java, XML Schema, PHP, Python, C and C++, and lots of other languages.\nXPath is Used in XSLT\nXPath is a major element in the XSLT standard.\nWith XPath knowledge you will be able to take great advantage of your XSLT knowledge.\nXPath is a W3C Recommendation\nXPath 1.0 became a W3C Recommendation on November 16, 1999.\nXPath 2.0 became a W3C Recommendation on January 23, 2007.\nXPath 3.0 became a W3C Recommendation on April 8, 2014.",
      "examples": []
    },
    {
      "title": "XPath Nodes",
      "summary": "XPath Terminology\nNodes\nIn XPath, there are seven kinds of nodes: element, attribute, text, namespace, processing-instruction, comment, and root nodes.\nXML documents are treated as trees of nodes. The topmost element of the tree is called the root element.\nLook at the following XML document:\nExample of nodes in the XML document above:\nAtomic values\nAtomic values are nodes with no children or parent.\nExample of atomic values:\nItems\nItems are atomic values or nodes.\nREMOVE ADS\nRelationship of Nodes\nParent\nEach element and attribute has one parent.\nIn the following example; the book element is the parent of the title, author, year, and price:\nChildren\nElement nodes may have zero, one or more children.\nIn the following example; the title, author, year, and price elements are all children of the book element:\nSiblings\nNodes that have the same parent.\nIn the following example; the title, author, year, and price elements are all siblings:\nAncestors\nA node's parent, parent's parent, etc.\nIn the following example; the ancestors of the title element are the book element and the bookstore element:\nDescendants\nA node's children, children's children, etc.\nIn the following example; descendants of the bookstore element are the book, title, author, year, and price elements:",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore>\n<book>\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n</bookstore>",
        "<bookstore> (root element node)\n\n<author>J K. Rowling</author> (element node)\n\nlang=\"en\" (attribute node)",
        "J K. Rowling\n\n\"en\"",
        "<book>\n<title>Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>",
        "<bookstore>\n\n<book>\n<title>Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n</bookstore>"
      ]
    },
    {
      "title": "XPath Syntax",
      "summary": "XPath uses path expressions to select nodes or node-sets in an XML document. The node is selected by following a path or steps.\nThe XML Example Document\nWe will use the following XML document in the examples below.\nSelecting Nodes\nXPath uses path expressions to select nodes in an XML document. The node is selected by following a path or steps. The most useful path expressions are listed below:\nIn the table below we have listed some path expressions and the result of the expressions:\nNote: If the path starts with a slash ( / ) it always represents an absolute path to an element!\nREMOVE ADS\nPredicates\nPredicates are used to find a specific node or a node that contains a specific value.\nPredicates are always embedded in square brackets.\nIn the table below we have listed some path expressions with predicates and the result of the expressions:\nNote: In IE 5,6,7,8,9 first node is[0], but according to W3C, it is [1]. To solve this problem in IE, set the SelectionLanguage to XPath:\nSelecting Unknown Nodes\nXPath wildcards can be used to select unknown XML nodes.\nIn the table below we have listed some path expressions and the result of the expressions:\nSelecting Several Paths\nBy using the | operator in an XPath expression you can select several paths.\nIn the table below we have listed some path expressions and the result of the expressions:",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore>\n\n<book>\n<title lang=\"en\">Harry Potter</title>\n<price>29.99</price>\n</book>\n\n<book>\n<title lang=\"en\">Learning XML</title>\n<price>39.95</price>\n</book>\n\n</bookstore>"
      ]
    },
    {
      "title": "XPath Axes",
      "summary": "The XML Example Document\nWe will use the following XML document in the examples below.\nXPath Axes\nAn axis represents a relationship to the context (current) node, and is used to locate nodes relative to that node on the tree.\nREMOVE ADS\nLocation Path Expression\nA location path can be absolute or relative.\nAn absolute location path starts with a slash ( / ) and a relative location path does not. In both cases the location path consists of one or more steps, each separated by a slash:\nEach step is evaluated against the nodes in the current node-set.\nA step consists of:\nan axis (defines the tree-relationship between the selected nodes and the current node)\na node-test (identifies a node within an axis)\nzero or more predicates (to further refine the selected node-set)\nThe syntax for a location step is:\nExamples",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore>\n\n<book>\n<title lang=\"en\">Harry Potter</title>\n<price>29.99</price>\n</book>\n\n<book>\n<title lang=\"en\">Learning XML</title>\n<price>39.95</price>\n</book>\n\n</bookstore>",
        "An absolute location path:\n\n/step/step/...\n\nA relative location path:\n\nstep/step/...",
        "axisname::nodetest[predicate]"
      ]
    },
    {
      "title": "XPath Operators",
      "summary": "An XPath expression returns either a node-set, a string, a Boolean, or a number.\nXPath Operators\nBelow is a list of the operators that can be used in XPath expressions:",
      "examples": []
    },
    {
      "title": "XPath Examples",
      "summary": "Let's try to learn some basic XPath syntax by looking at some examples.\nThe XML Example Document\nWe will use the following XML document in the examples below.\n\"books.xml\":\nView the \"books.xml\" file in your browser.\nREMOVE ADS\nLoading the XML Document\nUsing an XMLHttpRequest object to load XML documents is supported in all modern browsers.\nSelecting Nodes\nUnfortunately, there are different ways of dealing with XPath in different browsers.\nChrome, Firefox, Edge, Opera, and Safari use the evaluate() method to select nodes:\nInternet Explorer uses the selectNodes() method to select node:\nIn our examples we have included code that should work with most major browsers.\nSelect all the titles\nThe following example selects all the title nodes:\nExample\nSelect the title of the first book\nThe following example selects the title of the first book node under the bookstore element:\nExample\nSelect all the prices\nThe following example selects the text from all the price nodes:\nExample\nSelect price nodes with price>35\nThe following example selects all the price nodes with a price higher than 35:\nExample\nSelect title nodes with price>35\nThe following example selects all the title nodes with a price higher than 35:\nExample",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore>\n\n<book category=\"cooking\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n\n<book category=\"children\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n<book category=\"web\">\n<title lang=\"en\">XQuery Kick Start</title>\n<author>James McGovern</author>\n<author>Per Bothner</author>\n<author>Kurt Cagle</author>\n<author>James Linn</author>\n<author>Vaidyanathan Nagarajan</author>\n<year>2003</year>\n<price>49.99</price>\n</book>\n\n<book category=\"web\">\n<title lang=\"en\">Learning XML</title>\n<author>Erik T. Ray</author>\n<year>2003</year>\n<price>39.95</price>\n</book>\n\n</bookstore>",
        "var xmlhttp = new XMLHttpRequest();",
        "xmlDoc.evaluate(xpath, xmlDoc, null, XPathResult.ANY_TYPE,null);",
        "xmlDoc.selectNodes(xpath);",
        "/bookstore/book/title",
        "/bookstore/book[1]/title",
        "/bookstore/book/price[text()]",
        "/bookstore/book[price>35]/price",
        "/bookstore/book[price>35]/title"
      ]
    },
    {
      "title": "XSLT Introduction",
      "summary": "XSL (eXtensible Stylesheet Language) is a styling language for XML.\nXSLT stands for XSL Transformations.\nThis tutorial will teach you how to use XSLT to transform XML documents into other formats (like transforming XML into HTML).\nOnline XSLT Editor\nWith our online editor, you can edit XML and XSLT code, and click on a button to view the result.\nXSLT Example\nClick on the \"Try it Yourself\" button to see how it works.\nWhat You Should Already Know\nBefore you continue you should have a basic understanding of the following:\nHTML\nXML\nIf you want to study these subjects first, find the tutorials on our Home page.\nXSLT References\nXSLT Elements\nDescription of all the XSLT elements from the W3C Recommendation, and information about browser support.\nXSLT, XPath, and XQuery Functions\nXSLT 2.0, XPath 2.0, and XQuery 1.0, share the same functions library. There are over 100 built-in functions. There are functions for string values, numeric values, date and time comparison, node and QName manipulation, sequence manipulation, and more.",
      "examples": [
        "<?xml version=\"1.0\"?>\n\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<td><xsl:value-of select=\"artist\"/></td>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSL(T) Languages",
      "summary": "XSLT is a language for transforming XML documents.\nXPath is a language for navigating in XML documents.\nXQuery is a language for querying XML documents.\nIt Started with XSL\nXSL stands for EXtensible Stylesheet Language.\nThe World Wide Web Consortium (W3C) started to develop XSL because there was a need for an XML-based Stylesheet Language.\nCSS = Style Sheets for HTML\nHTML uses predefined tags. The meaning of, and how to display each tag is well understood.\nCSS is used to add styles to HTML elements.\nXSL = Style Sheets for XML\nXML does not use predefined tags, and therefore the meaning of each tag is not well understood.\nA <table> element could indicate an HTML table, a piece of furniture, or something else - and browsers do not know how to display it!\nSo, XSL describes how the XML elements should be displayed.\nXSL - More Than a Style Sheet Language\nXSL consists of four parts:\nXSLT - a language for transforming XML documents\nXPath - a language for navigating in XML documents\nXSL-FO - a language for formatting XML documents (discontinued in 2013)\nXQuery - a language for querying XML documents\nWith the CSS3 Paged Media Module, W3C has delivered a new standard for document formatting. So, since 2013, CSS3 is proposed as an XSL-FO replacement.\nWhat is XSLT?\nXSLT stands for XSL Transformations\nXSLT is the most important part of XSL\nXSLT transforms an XML document into another XML document\nXSLT uses XPath to navigate in XML documents\nXSLT is a W3C Recommendation\nREMOVE ADS\nXSLT = XSL Transformations\nXSLT is the most important part of XSL.\nXSLT is used to transform an XML document into another XML document, or another type of document that is recognized by a browser, like HTML and XHTML. Normally XSLT does this by transforming each XML element into an (X)HTML element.\nWith XSLT you can add/remove elements and attributes to or from the output file. You can also rearrange and sort elements, perform tests and make decisions about which elements to hide and display, and a lot more.\nA common way to describe the transformation process is to say that XSLT transforms an XML source-tree into an XML result-tree.\nXSLT Uses XPath\nXSLT uses XPath to find information in an XML document. XPath is used to navigate through elements and attributes in XML documents.\nIf you want to study XPath first, please read our XPath Tutorial.\nHow Does it Work?\nIn the transformation process, XSLT uses XPath to define parts of the source document that should match one or more predefined templates. When a match is found, XSLT will transform the matching part of the source document into the result document.\nXSLT Browser Support\nAll major browsers support XSLT and XPath.\nXSLT is a W3C Recommendation\nXSLT became a W3C Recommendation 16. November 1999.",
      "examples": []
    },
    {
      "title": "XSLT - Transformation",
      "summary": "Example study: How to transform XML into XHTML using XSLT?\nThe details of this example will be explained in the next chapter.\nCorrect Style Sheet Declaration\nThe root element that declares the document to be an XSL style sheet is <xsl:stylesheet> or <xsl:transform>.\nNote: <xsl:stylesheet> and <xsl:transform> are completely synonymous and either can be used!\nThe correct way to declare an XSL style sheet according to the W3C XSLT Recommendation is:\nor:\nTo get access to the XSLT elements, attributes and features we must declare the XSLT namespace at the top of the document.\nThe xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" points to the official W3C XSLT namespace. If you use this namespace, you must also include the attribute version=\"1.0\".\nStart with a Raw XML Document\nWe want to transform the following XML document (\"cdcatalog.xml\") into XHTML:\nViewing XML Files in browsers: Open the XML file (click on the link below) - The XML document will be displayed with color-coded root and child elements. Often, there is an arrow or plus/minus sign to the left of the elements that can be clicked to expand or collapse the element structure. Tip: To view the raw XML source, right-click in XML file and select \"View Page Source\"!\nView \"cdcatalog.xml\"\nREMOVE ADS\nCreate an XSL Style Sheet\nThen you create an XSL Style Sheet (\"cdcatalog.xsl\") with a transformation template:\nView \"cdcatalog.xsl\"\nLink the XSL Style Sheet to the XML Document\nAdd the XSL style sheet reference to your XML document (\"cdcatalog.xml\"):\nIf you have an XSLT compliant browser it will nicely transform your XML into XHTML.\nView the result\nThe details of the example above will be explained in the next chapters.",
      "examples": [
        "<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
        "<xsl:transform version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<catalog>\n<cd>\n<title>Empire Burlesque</title>\n<artist>Bob Dylan</artist>\n<country>USA</country>\n<company>Columbia</company>\n<price>10.90</price>\n<year>1985</year>\n</cd>\n.\n.\n</catalog>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<td><xsl:value-of select=\"artist\"/></td>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"cdcatalog.xsl\"?>\n<catalog>\n<cd>\n<title>Empire Burlesque</title>\n<artist>Bob Dylan</artist>\n<country>USA</country>\n<company>Columbia</company>\n<price>10.90</price>\n<year>1985</year>\n</cd>\n.\n.\n</catalog>"
      ]
    },
    {
      "title": "XSLT <xsl:template> Element",
      "summary": "An XSL style sheet consists of one or more set of rules that are called templates.\nA template contains rules to apply when a specified node is matched.\nThe <xsl:template> Element\nThe <xsl:template> element is used to build templates.\nThe match attribute is used to associate a template with an XML element. The match attribute can also be used to define a template for the entire XML document. The value of the match attribute is an XPath expression (i.e. match=\"/\" defines the whole document).\nOk, let's look at a simplified version of the XSL file from the previous chapter:\nExample\nExample Explained\nSince an XSL style sheet is an XML document, it always begins with the XML declaration: <?xml version=\"1.0\" encoding=\"UTF-8\"?>.\nThe next element, <xsl:stylesheet>, defines that this document is an XSLT style sheet document (along with the version number and XSLT namespace attributes).\nThe <xsl:template> element defines a template. The match=\"/\" attribute associates the template with the root of the XML source document.\nThe content inside the <xsl:template> element defines some HTML to write to the output.\nThe last two lines define the end of the template and the end of the style sheet.\nThe result from this example was a little disappointing, because no data was copied from the XML document to the output. In the next chapter you will learn how to use the <xsl:value-of> element to select values from the XML elements.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<tr>\n<td>.</td>\n<td>.</td>\n</tr>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSLT <xsl:value-of> Element",
      "summary": "The <xsl:value-of> element is used to extract the value of a selected node.\nThe <xsl:value-of> Element\nThe <xsl:value-of> element can be used to extract the value of an XML element and add it to the output stream of the transformation:\nExample\nExample Explained\nNote: The select attribute, in the example above, contains an XPath expression. An XPath expression works like navigating a file system; a forward slash (/) selects subdirectories.\nThe result from the example above was a little disappointing; only one line of data was copied from the XML document to the output. In the next chapter you will learn how to use the <xsl:for-each> element to loop through the XML elements, and display all of the records.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<tr>\n<td><xsl:value-of select=\"catalog/cd/title\"/></td>\n<td><xsl:value-of select=\"catalog/cd/artist\"/></td>\n</tr>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSLT <xsl:for-each> Element",
      "summary": "The <xsl:for-each> element allows you to do looping in XSLT.\nThe <xsl:for-each> Element\nThe XSL <xsl:for-each> element can be used to select every XML element of a specified node-set:\nExample\nNote: The value of the select attribute is an XPath expression. An XPath expression works like navigating a file system; where a forward slash (/) selects subdirectories.\nREMOVE ADS\nFiltering the Output\nWe can also filter the output from the XML file by adding a criterion to the select attribute in the <xsl:for-each> element.\n<xsl:for-each select=\"catalog/cd[artist='Bob Dylan']\">\nLegal filter operators are:\n=  (equal)\n!= (not equal)\n&lt; less than\n&gt; greater than\nTake a look at the adjusted XSL style sheet:\nExample",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<td><xsl:value-of select=\"artist\"/></td>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd[artist='Bob Dylan']\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<td><xsl:value-of select=\"artist\"/></td>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSLT <xsl:sort> Element",
      "summary": "The <xsl:sort> element is used to sort the output.\nWhere to put the Sort Information\nTo sort the output, simply add an <xsl:sort> element inside the <xsl:for-each> element in the XSL file:\nExample\nNote: The select attribute indicates what XML element to sort on.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<xsl:sort select=\"artist\"/>\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<td><xsl:value-of select=\"artist\"/></td>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSLT <xsl:if> Element",
      "summary": "The <xsl:if> element is used to put a conditional test against the content of the XML file.\nThe <xsl:if> Element\nTo put a conditional if test against the content of the XML file, add an <xsl:if> element to the XSL document.\nSyntax\nWhere to Put the <xsl:if> Element\nTo add a conditional test, add the <xsl:if> element inside the <xsl:for-each> element in the XSL file:\nExample\nNote: The value of the required test attribute contains the expression to be evaluated.\nThe code above will only output the title and artist elements of the CDs that has a price that is higher than 10.",
      "examples": [
        "<xsl:if test=\"expression\">\n...some output if the expression is true...\n</xsl:if>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n<th>Price</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<xsl:if test=\"price &gt; 10\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<td><xsl:value-of select=\"artist\"/></td>\n<td><xsl:value-of select=\"price\"/></td>\n</tr>\n</xsl:if>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSLT <xsl:choose> Element",
      "summary": "The <xsl:choose> element is used in conjunction with <xsl:when> and <xsl:otherwise> to express multiple conditional tests.\nThe <xsl:choose> Element\nSyntax\nWhere to put the Choose Condition\nTo insert a multiple conditional test against the XML file, add the <xsl:choose>, <xsl:when>, and <xsl:otherwise> elements to the XSL file:\nExample\nThe code above will add a pink background-color to the \"Artist\" column WHEN the price of the CD is higher than 10.\nREMOVE ADS\nAnother Example\nHere is another example that contains two <xsl:when> elements:\nExample\nThe code above will add a pink background color to the \"Artist\" column WHEN the price of the CD is higher than 10, and a grey background-color WHEN the price of the CD is higher than 9 and lower or equal to 10.",
      "examples": [
        "<xsl:choose>\n<xsl:when test=\"expression\">\n... some output ...\n</xsl:when>\n<xsl:otherwise>\n... some output ....\n</xsl:otherwise>\n</xsl:choose>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<xsl:choose>\n<xsl:when test=\"price &gt; 10\">\n<td bgcolor=\"#ff00ff\">\n<xsl:value-of select=\"artist\"/></td>\n</xsl:when>\n<xsl:otherwise>\n<td><xsl:value-of select=\"artist\"/></td>\n</xsl:otherwise>\n</xsl:choose>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th>Title</th>\n<th>Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\"/></td>\n<xsl:choose>\n<xsl:when test=\"price &gt; 10\">\n<td bgcolor=\"#ff00ff\">\n<xsl:value-of select=\"artist\"/></td>\n</xsl:when>\n<xsl:when test=\"price &gt; 9\">\n<td bgcolor=\"#cccccc\">\n<xsl:value-of select=\"artist\"/></td>\n</xsl:when>\n<xsl:otherwise>\n<td><xsl:value-of select=\"artist\"/></td>\n</xsl:otherwise>\n</xsl:choose>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSLT <xsl:apply-templates> Element",
      "summary": "The <xsl:apply-templates> element applies a template rule to the current element or to the current element's child nodes.\nThe <xsl:apply-templates> Element\nThe <xsl:apply-templates> element applies a template to the current element or to the current element's child nodes.\nIf we add a \"select\" attribute to the <xsl:apply-templates> element, it will process only the child elements that matches the value of the attribute. We can use the \"select\" attribute to specify in which order the child nodes are to be processed.\nLook at the following XSL style sheet:\nExample",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>My CD Collection</h2>\n<xsl:apply-templates/>\n</body>\n</html>\n</xsl:template>\n\n<xsl:template match=\"cd\">\n<p>\n<xsl:apply-templates select=\"title\"/>\n<xsl:apply-templates select=\"artist\"/>\n</p>\n</xsl:template>\n\n<xsl:template match=\"title\">\nTitle: <span style=\"color:#ff0000\">\n<xsl:value-of select=\".\"/></span>\n<br />\n</xsl:template>\n\n<xsl:template match=\"artist\">\nArtist: <span style=\"color:#00ff00\">\n<xsl:value-of select=\".\"/></span>\n<br />\n</xsl:template>\n\n</xsl:stylesheet>"
      ]
    },
    {
      "title": "XSLT - On the Client",
      "summary": "XSLT can be used to transform the document to XHTML in your browser.\nA JavaScript Solution\nEven if this works fine, it is not always desirable to include a style sheet reference in an XML file (e.g. it will not work in a non XSLT aware browser.)\nA more versatile solution would be to use a JavaScript to do the transformation.\nBy using a JavaScript, we can:\ndo browser-specific testing\nuse different style sheets according to browser and user needs\nThat is the beauty of XSLT! One of the design goals for XSLT was to make it possible to transform data from one format to another, supporting different browsers and different user needs.\nThe XML File and the XSL File\nLook at the XML document that you have seen in the previous chapters:\nView the XML file.\nAnd the accompanying XSL style sheet:\nView the XSL file.\nNotice that the XML file does not have a reference to the XSL file.\nIMPORTANT: The above sentence indicates that an XML file could be transformed using many different XSL style sheets.\nREMOVE ADS\nTransforming XML to XHTML in the Browser\nHere is the source code needed to transform the XML file to XHTML on the client:\nExample\nTip: If you don't know how to write JavaScript, please study our JavaScript tutorial.\nExample Explained:\nThe loadXMLDoc() function does the following:\nCreate an XMLHttpRequest object\nUse the open() and send() methods of the XMLHttpRequest object to send a request to a server\nGet the response data as XML data\nThe displayResult() function is used to display the XML file styled by the XSL file:\nLoad XML and XSL files\nTest what kind of browser the user has\nIf Internet Explorer:\nUse the transformNode() method to apply the XSL style sheet to the xml document\nSet the body of the current document (id=\"example\") to contain the styled xml document\nUse the transformNode() method to apply the XSL style sheet to the xml document\nSet the body of the current document (id=\"example\") to contain the styled xml document\nIf other browsers:\nCreate a new XSLTProcessor object and import the XSL file to it\nUse the transformToFragment() method to apply the XSL style sheet to the xml document\nSet the body of the current document (id=\"example\") to contain the styled xml document\nCreate a new XSLTProcessor object and import the XSL file to it\nUse the transformToFragment() method to apply the XSL style sheet to the xml document\nSet the body of the current document (id=\"example\") to contain the styled xml document",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<catalog>\n<cd>\n<title>Empire Burlesque</title>\n<artist>Bob Dylan</artist>\n<country>USA</country>\n<company>Columbia</company>\n<price>10.90</price>\n<year>1985</year>\n</cd>\n.\n.\n</catalog>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th style=\"text-align:left\">Title</th>\n<th style=\"text-align:left\">Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\" /></td>\n<td><xsl:value-of select=\"artist\" /></td>\n</tr>\n</xsl:for-each>\n</table>\n</xsl:template>\n\n</xsl:stylesheet>",
        "<!DOCTYPE html>\n<html>\n<head>\n<script>\nfunction loadXMLDoc(filename)\n{\nif (window.ActiveXObject)\n{\nxhttp = new ActiveXObject(\"Msxml2.XMLHTTP\");\n}\nelse\n{\nxhttp = new XMLHttpRequest();\n}\nxhttp.open(\"GET\", filename, false);\ntry {xhttp.responseType = \"msxml-document\"} catch(err) {} // Helping IE11\nxhttp.send(\"\");\nreturn xhttp.responseXML;\n}\n\nfunction displayResult()\n{\nxml = loadXMLDoc(\"cdcatalog.xml\");\nxsl = loadXMLDoc(\"cdcatalog.xsl\");\n// code for IE\nif (window.ActiveXObject || xhttp.responseType == \"msxml-document\")\n{\nex = xml.transformNode(xsl);\ndocument.getElementById(\"example\").innerHTML = ex;\n}\n// code for Chrome, Firefox, Opera, etc.\nelse if (document.implementation && document.implementation.createDocument)\n{\nxsltProcessor = new XSLTProcessor();\nxsltProcessor.importStylesheet(xsl);\nresultDocument = xsltProcessor.transformToFragment(xml, document);\ndocument.getElementById(\"example\").appendChild(resultDocument);\n}\n}\n</script>\n</head>\n<body onload=\"displayResult()\">\n<div id=\"example\" />\n</body>\n</html>"
      ]
    },
    {
      "title": "XSLT - On the Server",
      "summary": "To make XML data available to all kind of browsers, we can transform the XML document on the SERVER and send it  back to the browser as XHTML.\nA Cross Browser Solution\nTo make XML data available to all kind of browsers, we can transform the XML document on the server and send back to the browser as XHTML.\nThat's another beauty of XSLT. One of the design goals for XSLT was to make it possible to transform data from one format to another on a server, returning readable data to all kinds of browsers.\nThe XML File and the XSLT File\nLook at the XML document that you have seen in the previous chapters:\nView the XML file.\nAnd the accompanying XSL style sheet:\nView the XSL file.\nNotice that the XML file does not have a reference to the XSL file.\nIMPORTANT: The above sentence indicates that an XML file could be transformed using many different XSL style sheets.\nREMOVE ADS\nPHP Code: Transform XML to XHTML on the Server\nHere is the PHP source code needed to transform the XML file to XHTML on the server:\nTip: If you don't know how to write PHP, please study our PHP tutorial.\nSee how it works with PHP.\nASP Code: Transform XML to XHTML on the Server\nHere is the ASP source code needed to transform the XML file to XHTML on the server:\nSee how it works with ASP.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<catalog>\n<cd>\n<title>Empire Burlesque</title>\n<artist>Bob Dylan</artist>\n<country>USA</country>\n<company>Columbia</company>\n<price>10.90</price>\n<year>1985</year>\n</cd>\n.\n.\n</catalog>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<h2>My CD Collection</h2>\n<table border=\"1\">\n<tr bgcolor=\"#9acd32\">\n<th style=\"text-align:left\">Title</th>\n<th style=\"text-align:left\">Artist</th>\n</tr>\n<xsl:for-each select=\"catalog/cd\">\n<tr>\n<td><xsl:value-of select=\"title\" /></td>\n<td><xsl:value-of select=\"artist\" /></td>\n</tr>\n</xsl:for-each>\n</table>\n</xsl:template>\n\n</xsl:stylesheet>",
        "<?php\n// Load XML file\n$xml = new DOMDocument;\n$xml->load('cdcatalog.xml');\n\n// Load XSL file\n$xsl = new DOMDocument;\n$xsl->load('cdcatalog.xsl');\n\n// Configure the transformer\n$proc = new XSLTProcessor;\n\n// Attach the xsl rules\n$proc->importStyleSheet($xsl);\n\necho $proc->transformToXML($xml);\n?>",
        "<%\n'Load XML file\nset xml = Server.CreateObject(\"Microsoft.XMLDOM\")\nxml.async = false\nxml.load(Server.MapPath(\"cdcatalog.xml\"))\n\n'Load XSL file\nset xsl = Server.CreateObject(\"Microsoft.XMLDOM\")\nxsl.async = false\nxsl.load(Server.MapPath(\"cdcatalog.xsl\"))\n\n'Transform file\nResponse.Write(xml.transformNode(xsl))\n%>"
      ]
    },
    {
      "title": "XSLT - Editing XML",
      "summary": "Data stored in XML files can be edited from an Internet browser.\nOpen, Edit and Save XML\nNow, we will show how to open, edit, and save an XML file that is stored on the server.\nWe will use XSL to transform the XML document into an HTML form. The values of the XML elements will be written to HTML input fields in an HTML form. The HTML form is editable. After editing the data, the data is going to be submitted back to the server and the XML file will be updated (we will show code for both PHP and ASP).\nThe XML File and the XSL File\nFirst, take a look at the XML document (\"tool.xml\"):\nView the XML file.\nThen, take a look at the following style sheet (\"tool.xsl\"):\nView the XSL file.\nThe XSL file above loops through the elements in the XML file and creates one input field for each XML \"field\" element. The value of the XML \"field\" element's \"id\" attribute is added to both the \"id\" and \"name\" attributes of each HTML input field. The value of each XML \"value\" element is added to the \"value\" attribute of each HTML input field. The result is an editable HTML form that contains the values from the XML file.\nThen, we have a second style sheet: \"tool_updated.xsl\". This is the XSL file that will be used to display the updated XML data. This style sheet will not result in an editable HTML form, but a static HTML table:\nView the XSL file.\nREMOVE ADS\nThe PHP File\nIn the \"tool.xsl\" file above, change the HTML form's action attribute to \"edittool.php\".\nThe \"edittool.php\" page contains two functions: The loadFile() function loads and transforms the XML file for display and the updateFile() function applies the changes to the XML file:\nTip: If you don't know how to write PHP, please study our PHP tutorial.\nNote: We are doing the transformation and applying the changes to the XML file on the server. This is a cross-browser solution. The client will only get HTML back from the server - which will work in any browser.\nThe ASP File\nThe HTML form in the \"tool.xsl\" file above has an action attribute with a value of \"edittool.asp\".\nThe \"edittool.asp\" page contains two functions: The loadFile() function loads and transforms the XML file for display and the updateFile() function applies the changes to the XML file:",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<tool>\n<field id=\"prodName\">\n<value>HAMMER HG2606</value>\n</field>\n<field id=\"prodNo\">\n<value>32456240</value>\n</field>\n<field id=\"price\">\n<value>$30.00</value>\n</field>\n</tool>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<form method=\"post\" action=\"edittool.asp\">\n<h2>Tool Information (edit):</h2>\n<table border=\"0\">\n<xsl:for-each select=\"tool/field\">\n<tr>\n<td><xsl:value-of select=\"@id\"/></td>\n<td>\n<input type=\"text\">\n<xsl:attribute name=\"id\">\n<xsl:value-of select=\"@id\" />\n</xsl:attribute>\n<xsl:attribute name=\"name\">\n<xsl:value-of select=\"@id\" />\n</xsl:attribute>\n<xsl:attribute name=\"value\">\n<xsl:value-of select=\"value\" />\n</xsl:attribute>\n</input>\n</td>\n</tr>\n</xsl:for-each>\n</table>\n<br />\n<input type=\"submit\" id=\"btn_sub\" name=\"btn_sub\" value=\"Submit\" />\n<input type=\"reset\" id=\"btn_res\" name=\"btn_res\" value=\"Reset\" />\n</form>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n<xsl:template match=\"/\">\n<html>\n<body>\n<h2>Updated Tool Information:</h2>\n<table border=\"1\">\n<xsl:for-each select=\"tool/field\">\n<tr>\n<td><xsl:value-of select=\"@id\" /></td>\n<td><xsl:value-of select=\"value\" /></td>\n</tr>\n</xsl:for-each>\n</table>\n</body>\n</html>\n</xsl:template>\n\n</xsl:stylesheet>",
        "<?php\nfunction loadFile($xml, $xsl)\n{\n$xmlDoc = new DOMDocument();\n$xmlDoc->load($xml);\n\n$xslDoc = new DOMDocument();\n$xslDoc->load($xsl);\n\n$proc = new XSLTProcessor();\n$proc->importStyleSheet($xslDoc);\necho $proc->transformToXML($xmlDoc);\n}\n\nfunction updateFile($xml)\n{\n$xmlLoad = simplexml_load_file($xml);\n$postKeys = array_keys($_POST);\n\nforeach($xmlLoad->children() as $x)\n{\nforeach($_POST as $key=>$value)\n{\nif($key == $x->attributes())\n{\n$x->value = $value;\n}\n}\n}\n\n$xmlLoad->asXML($xml);\nloadFile($xml,\"tool_updated.xsl\");\n}\n\nif($_POST[\"btn_sub\"] == \"\")\n{\nloadFile(\"tool.xml\", \"tool.xsl\");\n}\nelse\n{\nupdateFile(\"tool.xml\");\n}\n?>",
        "<%\nfunction loadFile(xmlfile,xslfile)\nDim xmlDoc,xslDoc\n'Load XML and XSL file\nset xmlDoc = Server.CreateObject(\"Microsoft.XMLDOM\")\nxmlDoc.async = false\nxmlDoc.load(xmlfile)\nset xslDoc = Server.CreateObject(\"Microsoft.XMLDOM\")\nxslDoc.async = false\nxslDoc.load(xslfile)\n'Transform file\nResponse.Write(xmlDoc.transformNode(xslDoc))\nend function\n\nfunction updateFile(xmlfile)\nDim xmlDoc,rootEl,f\nDim i\n'Load XML file\nset xmlDoc = Server.CreateObject(\"Microsoft.XMLDOM\")\nxmlDoc.async = false\nxmlDoc.load(xmlfile)\n\n'Set the rootEl variable equal to the root element\nSet rootEl = xmlDoc.documentElement\n\n'Loop through the form collection\nfor i = 1 To Request.Form.Count\n'Eliminate button elements in the form\nif instr(1,Request.Form.Key(i),\"btn_\")=0 then\n'The selectSingleNode method queries the XML file for a single node\n'that matches a query. This query requests the value element that is\n'the child of a field element that has an id attribute which matches\n'the current key value in the Form Collection. When there is a match -\n'set the text property equal to the value of the current field in the\n'Form Collection.\nset f = rootEl.selectSingleNode(\"field[@id='\" & _\nRequest.Form.Key(i) & \"']/value\")\nf.Text = Request.Form(i)\nend if\nnext\n\n'Save the modified XML file\nxmlDoc.save xmlfile\n\n'Release all object references\nset xmlDoc=nothing\nset rootEl=nothing\nset f=nothing\n\n'Load the modified XML file with a style sheet that\n'allows the client to see the edited information\nloadFile xmlfile,server.MapPath(\"tool_updated.xsl\")\nend function\n\n'If form is submitted, update the XML file and display result\n' - if not, transform the XML file for editing\nif Request.Form(\"btn_sub\")=\"\" then\nloadFile server.MapPath(\"tool.xml\"),server.MapPath(\"tool.xsl\")\nelse\nupdateFile server.MapPath(\"tool.xml\")\nend if\n%>"
      ]
    },
    {
      "title": "XSLT Examples",
      "summary": "The <xsl:template> Element\nA template contains rules to apply when a specified node is matched\nExample explained\nThe <xsl:value-of> Element\nExtract the value of a selected node\nExample explained\nThe <xsl:for-each> Element\nSelect every XML element of a specified node-set with the <xsl:for-each> element\nFilter the output in a node-set\nExamples explained\nThe <xsl:sort> Element\nSort the output in a node-set\nExample explained\nThe <xsl:if> Element\nPut a conditional test against the content of an XML file\nExample explained\nThe <xsl:choose> Element\nExample 1\nThis example will add a pink background-color to the \"Artist\" column WHEN the price of the CD is higher than 10:\nExample 2\nThis example will add a pink background color to the \"Artist\" column WHEN the price of the CD is higher than 10, and a grey background-color WHEN the price of the CD is higher than 9 and lower or equal to 10.\nExamples explained\nThe <xsl:apply-templates> Element\nApply templates to elements\nExamples explained",
      "examples": []
    },
    {
      "title": "XQuery Tutorial",
      "summary": "What is XQuery?\nXQuery is to XML what SQL is to databases.\nXQuery is designed to query XML data.\nXQuery Example\nWhat is XQuery?\nXQuery is the language for querying XML data\nXQuery for XML is like SQL for databases\nXQuery is built on XPath expressions\nXQuery is supported by all major databases\nXQuery is a W3C Recommendation\nXQuery is About Querying XML\nXQuery is a language for finding and extracting elements and attributes from XML documents.\nHere is an example of what XQuery could solve:\n\"Select all CD records with a price less than $10 from the CD collection stored in cd_catalog.xml\"\nXQuery and XPath\nXQuery 1.0 and XPath 2.0 share the same data model and support the same functions and operators. If you have already studied XPath you will have no problems with understanding XQuery.\nXQuery - Examples of Use\nXQuery can be used to:\nExtract information to use in a Web Service\nGenerate summary reports\nTransform XML data to XHTML\nSearch Web documents for relevant information\nXQuery is a W3C Recommendation\nXQuery is compatible with several W3C standards, such as XML, Namespaces, XSLT, XPath, and XML Schema.\nXQuery 1.0 became a W3C Recommendation in 2007.",
      "examples": [
        "for $x in doc(\"books.xml\")/bookstore/book\nwhere $x/price>30\norder by $x/title\nreturn $x/title"
      ]
    },
    {
      "title": "XQuery Example",
      "summary": "Let's learn some basic XQuery by looking at an example.\nThe XML Example Document\nWe will use the following XML document in the examples below.\n\"books.xml\":\nView the \"books.xml\" file in your browser.\nREMOVE ADS\nHow to Select Nodes From \"books.xml\"?\nFunctions\nXQuery uses functions to extract data from XML documents.\nThe doc() function is used to open the \"books.xml\" file:\nPath Expressions\nXQuery uses path expressions to navigate through elements in an XML document.\nThe following path expression is used to select all the title elements in the \"books.xml\" file:\n(/bookstore selects the bookstore element, /book selects all the book elements under the bookstore element, and /title selects all the title elements under each book element)\nThe XQuery above will extract the following:\nPredicates\nXQuery uses predicates to limit the extracted data from XML documents.\nThe following predicate is used to select all the book elements under the bookstore element that have a price element with a value that is less than 30:\nThe XQuery above will extract the following:",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore>\n\n<book category=\"COOKING\">\n<title lang=\"en\">Everyday Italian</title>\n<author>Giada De Laurentiis</author>\n<year>2005</year>\n<price>30.00</price>\n</book>\n\n<book category=\"CHILDREN\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n<book category=\"WEB\">\n<title lang=\"en\">XQuery Kick Start</title>\n<author>James McGovern</author>\n<author>Per Bothner</author>\n<author>Kurt Cagle</author>\n<author>James Linn</author>\n<author>Vaidyanathan Nagarajan</author>\n<year>2003</year>\n<price>49.99</price>\n</book>\n\n<book category=\"WEB\">\n<title lang=\"en\">Learning XML</title>\n<author>Erik T. Ray</author>\n<year>2003</year>\n<price>39.95</price>\n</book>\n\n</bookstore>",
        "doc(\"books.xml\")",
        "doc(\"books.xml\")/bookstore/book/title",
        "<title lang=\"en\">Everyday Italian</title>\n<title lang=\"en\">Harry Potter</title>\n<title lang=\"en\">XQuery Kick Start</title>\n<title lang=\"en\">Learning XML</title>",
        "doc(\"books.xml\")/bookstore/book[price<30]",
        "<book category=\"CHILDREN\">\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>"
      ]
    },
    {
      "title": "XQuery FLWOR Expressions",
      "summary": "What is FLWOR?\nFLWOR (pronounced \"flower\") is an acronym for \"For, Let, Where, Order by, Return\".\nFor - selects a sequence of nodes\nLet - binds a sequence to a variable\nWhere - filters the nodes\nOrder by - sorts the nodes\nReturn - what to return (gets evaluated once for every node)\nThe XML Example Document\nWe will use the \"books.xml\" document in the examples below (same XML file as in the previous chapter).\nView the \"books.xml\" file in your browser.\nHow to Select Nodes From \"books.xml\" With FLWOR\nLook at the following path expression:\nThe expression above will select all the title elements under the book elements that are under the bookstore element that have a price element with a value that is higher than 30.\nThe following FLWOR expression will select exactly the same as the path expression above:\nThe result will be:\nWith FLWOR you can sort the result:\nThe for clause selects all book elements under the bookstore element into a variable called $x.\nThe where clause selects only book elements with a price element with a value greater than 30.\nThe order by clause defines the sort-order. Will be sort by the title element.\nThe return clause specifies what should be returned. Here it returns the title elements.\nThe result of the XQuery expression above will be:",
      "examples": [
        "doc(\"books.xml\")/bookstore/book[price>30]/title",
        "for $x in doc(\"books.xml\")/bookstore/book\nwhere $x/price>30\nreturn $x/title",
        "<title lang=\"en\">XQuery Kick Start</title>\n<title lang=\"en\">Learning XML</title>",
        "for $x in doc(\"books.xml\")/bookstore/book\nwhere $x/price>30\norder by $x/title\nreturn $x/title",
        "<title lang=\"en\">Learning XML</title>\n<title lang=\"en\">XQuery Kick Start</title>"
      ]
    },
    {
      "title": "XQuery FLWOR + HTML",
      "summary": "The XML Example Document\nWe will use the \"books.xml\" document in the examples below (same XML file as in the previous chapters).\nView the \"books.xml\" file in your browser.\nPresent the Result In an HTML List\nLook at the following XQuery FLWOR expression:\nThe expression above will select all the title elements under the book elements that are under the bookstore element, and return the title elements in alphabetical order.\nNow we want to list all the book-titles in our bookstore in an HTML list. We add <ul> and <li> tags to the FLWOR expression:\nThe result of the above will be:\nNow we want to eliminate the title element, and show only the data inside the title element:\nThe result will be (an HTML list):",
      "examples": [
        "for $x in doc(\"books.xml\")/bookstore/book/title\norder by $x\nreturn $x",
        "<ul>\n{\nfor $x in doc(\"books.xml\")/bookstore/book/title\norder by $x\nreturn <li>{$x}</li>\n}\n</ul>",
        "<ul>\n<li><title lang=\"en\">Everyday Italian</title></li>\n<li><title lang=\"en\">Harry Potter</title></li>\n<li><title lang=\"en\">Learning XML</title></li>\n<li><title lang=\"en\">XQuery Kick Start</title></li>\n</ul>",
        "<ul>\n{\nfor $x in doc(\"books.xml\")/bookstore/book/title\norder by $x\nreturn <li>{data($x)}</li>\n}\n</ul>",
        "<ul>\n<li>Everyday Italian</li>\n<li>Harry Potter</li>\n<li>Learning XML</li>\n<li>XQuery Kick Start</li>\n</ul>"
      ]
    },
    {
      "title": "XQuery Terms",
      "summary": "XQuery Terminology\nNodes\nIn XQuery, there are seven kinds of nodes: element, attribute, text, namespace, processing-instruction, comment, and document (root) nodes.\nXML documents are treated as trees of nodes. The root of the tree is called the document node (or root node).\nLook at the following XML document:\nExample of nodes in the XML document above:\nAtomic values\nAtomic values are nodes with no children or parent.\nExample of atomic values:\nItems\nItems are atomic values or nodes.\nREMOVE ADS\nRelationship of Nodes\nParent\nEach element and attribute has one parent.\nIn the following example; the book element is the parent of the title, author, year, and price:\nChildren\nElement nodes may have zero, one or more children.\nIn the following example; the title, author, year, and price elements are all children of the book element:\nSiblings\nNodes that have the same parent.\nIn the following example; the title, author, year, and price elements are all siblings:\nAncestors\nA node's parent, parent's parent, etc.\nIn the following example; the ancestors of the title element are the book element and the bookstore element:\nDescendants\nA node's children, children's children, etc.\nIn the following example; descendants of the bookstore element are the book, title, author, year, and price elements:",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<bookstore>\n\n<book>\n<title lang=\"en\">Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n</bookstore>",
        "<bookstore> (root node)\n\n<author>J K. Rowling</author> (element node)\n\nlang=\"en\" (attribute node)",
        "J K. Rowling\n\n\"en\"",
        "<book>\n<title>Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>",
        "<bookstore>\n\n<book>\n<title>Harry Potter</title>\n<author>J K. Rowling</author>\n<year>2005</year>\n<price>29.99</price>\n</book>\n\n</bookstore>"
      ]
    },
    {
      "title": "XQuery Syntax",
      "summary": "XQuery is case-sensitive and XQuery elements, attributes, and variables must be valid XML names.\nXQuery Basic Syntax Rules\nSome basic syntax rules:\nXQuery is case-sensitive\nXQuery elements, attributes, and variables must be valid XML names\nAn XQuery string value can be in single or double quotes\nAn XQuery variable is defined with a $ followed by a name, e.g. $bookstore\nXQuery comments are delimited by (: and :), e.g. (: XQuery Comment :)\nThe XML Example Document\nWe will use the \"books.xml\" document in the examples below (same XML file as in the previous chapters).\nView the \"books.xml\" file in your browser.\nXQuery Conditional Expressions\n\"If-Then-Else\" expressions are allowed in XQuery.\nLook at the following example:\nNotes on the \"if-then-else\" syntax: parentheses around the if expression are required. else is required, but it can be just else ().\nThe result of the example above will be:\nXQuery Comparisons\nIn XQuery there are two ways of comparing values.\n1. General comparisons: =, !=, <, <=, >, >=\n2. Value comparisons: eq, ne, lt, le, gt, ge\nThe difference between the two comparison methods are shown below.\nThe following expression returns true if any q attributes have a value greater than 10:\nThe following expression returns true if there is only one q attribute returned by the expression, and its value is greater than 10. If more than one q is returned, an error occurs:",
      "examples": [
        "for $x in doc(\"books.xml\")/bookstore/book\nreturn if ($x/@category=\"children\")\nthen <child>{data($x/title)}</child>\nelse <adult>{data($x/title)}</adult>",
        "<adult>Everyday Italian</adult>\n<child>Harry Potter</child>\n<adult>XQuery Kick Start</adult>\n<adult>Learning XML</adult>",
        "$bookstore//book/@q > 10",
        "$bookstore//book/@q gt 10"
      ]
    },
    {
      "title": "XQuery Adding Elements and Attributes",
      "summary": "The XML Example Document\nWe will use the \"books.xml\" document in the examples below (same XML file as in the previous chapters).\nView the \"books.xml\" file in your browser.\nAdding Elements and Attributes to the Result\nAs we have seen in a previous chapter, we may include elements and attributes from the input document (\"books.xml) in the result:\nThe XQuery expression above will include both the title element and the lang attribute in the result, like this:\nThe XQuery expression above returns the title elements the exact same way as they are described in the input document.\nWe now want to add our own elements and attributes to the result!\nAdd HTML Elements and Text\nNow, we want to add some HTML elements to the result. We will put the result in an HTML list - together with some text:\nThe XQuery expression above will generate the following result:\nAdd Attributes to HTML Elements\nNext, we want to use the category attribute as a class attribute in the HTML list:\nThe XQuery expression above will generate the following result:",
      "examples": [
        "for $x in doc(\"books.xml\")/bookstore/book/title\norder by $x\nreturn $x",
        "<title lang=\"en\">Everyday Italian</title>\n<title lang=\"en\">Harry Potter</title>\n<title lang=\"en\">Learning XML</title>\n<title lang=\"en\">XQuery Kick Start</title>",
        "<html>\n<body>\n\n<h1>Bookstore</h1>\n\n<ul>\n{\nfor $x in doc(\"books.xml\")/bookstore/book\norder by $x/title\nreturn <li>{data($x/title)}. Category: {data($x/@category)}</li>\n}\n</ul>\n\n</body>\n</html>",
        "<html>\n<body>\n\n<h1>Bookstore</h1>\n\n<ul>\n<li>Everyday Italian. Category: COOKING</li>\n<li>Harry Potter. Category: CHILDREN</li>\n<li>Learning XML. Category: WEB</li>\n<li>XQuery Kick Start. Category: WEB</li>\n</ul>\n\n</body>\n</html>",
        "<html>\n<body>\n\n<h1>Bookstore</h1>\n\n<ul>\n{\nfor $x in doc(\"books.xml\")/bookstore/book\norder by $x/title\nreturn <li class=\"{data($x/@category)}\">{data($x/title)}</li>\n}\n</ul>\n\n</body>\n</html>",
        "<html>\n<body>\n<h1>Bookstore</h1>\n\n<ul>\n<li class=\"COOKING\">Everyday Italian</li>\n<li class=\"CHILDREN\">Harry Potter</li>\n<li class=\"WEB\">Learning XML</li>\n<li class=\"WEB\">XQuery Kick Start</li>\n</ul>\n\n</body>\n</html>"
      ]
    },
    {
      "title": "XQuery Selecting and Filtering",
      "summary": "The XML Example Document\nWe will use the \"books.xml\" document in the examples below (same XML file as in the previous chapters).\nView the \"books.xml\" file in your browser.\nSelecting and Filtering Elements\nAs we have seen in the previous chapters, we are selecting and filtering elements with either a Path expression or with a FLWOR expression.\nLook at the following FLWOR expression:\nfor - (optional) binds a variable to each item returned by the in expression\nlet - (optional)\nwhere - (optional) specifies a criteria\norder by - (optional) specifies the sort-order of the result\nreturn - specifies what to return in the result\nThe for Clause\nThe for clause binds a variable to each item returned by the in expression. The for clause results in iteration. There can be multiple for clauses in the same FLWOR expression.\nTo loop a specific number of times in a for clause, you may use the to keyword:\nResult:\nThe at keyword can be used to count the iteration:\nResult:\nIt is also allowed with more than one in expression in the for clause. Use comma to separate each in expression:\nResult:\nREMOVE ADS\nThe let Clause\nThe let clause allows variable assignments and it avoids repeating the same expression many times. The let clause does not result in iteration.\nResult:\nThe where Clause\nThe where clause is used to specify one or more criteria for the result:\nThe order by Clause\nThe order by clause is used to specify the sort order of the result. Here we want to order the result by category and title:\nResult:\nThe return Clause\nThe return clause specifies what is to be returned.\nResult:",
      "examples": [
        "for $x in doc(\"books.xml\")/bookstore/book\nwhere $x/price>30\norder by $x/title\nreturn $x/title",
        "for $x in (1 to 5)\nreturn <test>{$x}</test>",
        "<test>1</test>\n<test>2</test>\n<test>3</test>\n<test>4</test>\n<test>5</test>",
        "for $x at $i in doc(\"books.xml\")/bookstore/book/title\nreturn <book>{$i}. {data($x)}</book>",
        "<book>1. Everyday Italian</book>\n<book>2. Harry Potter</book>\n<book>3. XQuery Kick Start</book>\n<book>4. Learning XML</book>",
        "for $x in (10,20), $y in (100,200)\nreturn <test>x={$x} and y={$y}</test>",
        "<test>x=10 and y=100</test>\n<test>x=10 and y=200</test>\n<test>x=20 and y=100</test>\n<test>x=20 and y=200</test>",
        "let $x := (1 to 5)\nreturn <test>{$x}</test>",
        "<test>1 2 3 4 5</test>",
        "where $x/price>30 and $x/price<100",
        "for $x in doc(\"books.xml\")/bookstore/book\norder by $x/@category, $x/title\nreturn $x/title",
        "<title lang=\"en\">Harry Potter</title>\n<title lang=\"en\">Everyday Italian</title>\n<title lang=\"en\">Learning XML</title>\n<title lang=\"en\">XQuery Kick Start</title>",
        "for $x in doc(\"books.xml\")/bookstore/book\nreturn $x/title",
        "<title lang=\"en\">Everyday Italian</title>\n<title lang=\"en\">Harry Potter</title>\n<title lang=\"en\">XQuery Kick Start</title>\n<title lang=\"en\">Learning XML</title>"
      ]
    },
    {
      "title": "XQuery Functions",
      "summary": "XQuery 1.0, XPath 2.0, and XSLT 2.0 share the same functions library.\nXQuery Functions\nXQuery is built on XPath expressions. XQuery 1.0 and XPath 2.0 share the same data model and support the same functions and operators.\nXPath Operators\nXPath Functions\nYou can also define your own functions in XQuery.\nXQuery Data Types\nXQuery shares the same data types as XML Schema 1.0 (XSD).\nXSD String\nXSD Date\nXSD Numeric\nXSD Misc\nExamples of Function Calls\nA call to a function can appear where an expression may appear. Look at the examples below:\nExample 1: In an element\nExample 2: In the predicate of a path expression\nExample 3: In a let clause\nREMOVE ADS\nXQuery User-Defined Functions\nIf you cannot find the XQuery function you need, you can write your own.\nUser-defined functions can be defined in the query or in a separate library.\nSyntax\nNotes on user-defined functions:\nUse the declare function keyword\nThe name of the function must be prefixed\nThe data type of the parameters are mostly the same as the data types defined in XML Schema\nThe body of the function must be surrounded by curly braces\nExample of a User-defined Function Declared in the Query",
      "examples": [
        "<name>{upper-case($booktitle)}</name>",
        "doc(\"books.xml\")/bookstore/book[substring(title,1,5)='Harry']",
        "let $name := (substring($booktitle,1,4))",
        "declare function prefix:function_name($parameter as datatype)\nas returnDatatype\n{\n...function code here...\n};",
        "declare function local:minPrice($p as xs:decimal?,$d as xs:decimal?)\nas xs:decimal?\n{\nlet $disc := ($p * $d) div 100\nreturn ($p - $disc)\n};\n\nBelow is an example of how to call the function above:\n\n<minPrice>{local:minPrice($book/price,$book/discount)}</minPrice>"
      ]
    },
    {
      "title": "DTD Tutorial",
      "summary": "What is a DTD?\nA DTD is a Document Type Definition.\nA DTD defines the structure and the legal elements and attributes of an XML document.\nWhy Use a DTD?\nWith a DTD, independent groups of people can agree on a standard DTD for interchanging data.\nAn application can use a DTD to verify that XML data is valid.\nAn Internal DTD Declaration\nIf the DTD is declared inside the XML file, it must be wrapped inside the <!DOCTYPE> definition:\nXML document with an internal DTD\nIn the XML file, select \"view source\" to view the DTD.\nThe DTD above is interpreted like this:\n!DOCTYPE note defines that the root element of this document is note\n!ELEMENT note defines that the note element must contain four elements: \"to,from,heading,body\"\n!ELEMENT to defines the to element to be of type \"#PCDATA\"\n!ELEMENT from defines the from element to be of type \"#PCDATA\"\n!ELEMENT heading defines the heading element to be of type \"#PCDATA\"\n!ELEMENT body defines the body element to be of type \"#PCDATA\"\nREMOVE ADS\nAn External DTD Declaration\nIf the DTD is declared in an external file, the <!DOCTYPE> definition must contain a reference to the DTD file:\nXML document with a reference to an external DTD\nAnd here is the file \"note.dtd\", which contains the DTD:",
      "examples": [
        "<?xml version=\"1.0\"?>\n<!DOCTYPE note [\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n]>\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend</body>\n</note>",
        "<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"note.dtd\">\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>"
      ]
    },
    {
      "title": "DTD - XML Building Blocks",
      "summary": "The main building blocks of both XML and HTML documents are elements.\nThe Building Blocks of XML Documents\nSeen from a DTD point of view, all XML documents are made up by the following building blocks:\nElements\nAttributes\nEntities\nPCDATA\nCDATA\nElements\nElements are the main building blocks of both XML and HTML documents.\nExamples of HTML elements are \"body\" and \"table\". Examples of XML elements could be \"note\" and \"message\". Elements can contain text, other elements, or be empty. Examples of empty HTML elements are \"hr\", \"br\" and \"img\".\nExamples:\nAttributes\nAttributes provide extra information about elements.\nAttributes are always placed inside the opening tag of an element. Attributes always come in name/value pairs. The following \"img\" element has additional information about a source file:\nThe name of the element is \"img\". The name of the attribute is \"src\". The value of the attribute is \"computer.gif\". Since the element itself is empty it is closed by a \" /\".\nREMOVE ADS\nEntities\nSome characters have a special meaning in XML, like the less than sign (<) that defines the start of an XML tag.\nMost of you know the HTML entity: \"&nbsp;\". This \"no-breaking-space\" entity is used in HTML to insert an extra space in a document. Entities are expanded when a document is parsed by an XML parser.\nThe following entities are predefined in XML:\nPCDATA\nPCDATA means parsed character data.\nThink of character data as the text found between the start tag and the end tag of an XML element.\nPCDATA is text that WILL be parsed by a parser. The text will be examined by the parser for entities and markup.\nTags inside the text will be treated as markup and entities will be expanded.\nHowever, parsed character data should not contain any &, <, or > characters; these need to be represented by the &amp; &lt; and &gt; entities, respectively.\nCDATA\nCDATA means character data.\nCDATA is text that will NOT be parsed by a parser. Tags inside the text will NOT be treated as markup and entities will not be expanded.",
      "examples": [
        "<body>some text</body>\n\n<message>some text</message>",
        "<img src=\"computer.gif\" />"
      ]
    },
    {
      "title": "DTD - Elements",
      "summary": "In a DTD, elements are declared with an ELEMENT declaration.\nDeclaring Elements\nIn a DTD, XML elements are declared with the following syntax:\nEmpty Elements\nEmpty elements are declared with the category keyword EMPTY:\nElements with Parsed Character Data\nElements with only parsed character data are declared with #PCDATA inside parentheses:\nREMOVE ADS\nElements with any Contents\nElements declared with the category keyword ANY, can contain any combination of parsable data:\nElements with Children (sequences)\nElements with one or more children are declared with the name of the children elements inside parentheses:\nWhen children are declared in a sequence separated by commas, the children must appear in the same sequence in the document. In a full declaration, the children must also be declared, and the children can also have children. The full declaration of the \"note\" element is:\nDeclaring Only One Occurrence of an Element\nThe example above declares that the child element \"message\" must occur once, and only once inside the \"note\" element.\nDeclaring Minimum One Occurrence of an Element\nThe + sign in the example above declares that the child element \"message\" must occur one or more times inside the \"note\" element.\nDeclaring Zero or More Occurrences of an Element\nThe * sign in the example above declares that the child element \"message\" can occur zero or more times inside the \"note\" element.\nDeclaring Zero or One Occurrences of an Element\nThe ? sign in the example above declares that the child element \"message\" can occur zero or one time inside the \"note\" element.\nDeclaring either/or Content\nThe example above declares that the \"note\" element must contain a \"to\" element, a \"from\" element, a \"header\" element, and either a \"message\" or a \"body\" element.\nDeclaring Mixed Content\nThe example above declares that the \"note\" element can contain zero or more occurrences of parsed character data, \"to\", \"from\", \"header\", or \"message\" elements.",
      "examples": [
        "<!ELEMENT element-name category>\nor\n<!ELEMENT element-name (element-content)>",
        "<!ELEMENT element-name EMPTY>\n\nExample:\n\n<!ELEMENT br EMPTY>\n\nXML example:\n\n<br />",
        "<!ELEMENT element-name (#PCDATA)>\n\nExample:\n\n<!ELEMENT from (#PCDATA)>",
        "<!ELEMENT element-name ANY>\n\nExample:\n\n<!ELEMENT note ANY>",
        "<!ELEMENT element-name (child1)>\nor\n<!ELEMENT element-name (child1,child2,...)>\n\nExample:\n\n<!ELEMENT note (to,from,heading,body)>",
        "<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>",
        "<!ELEMENT element-name (child-name)>\n\nExample:\n\n<!ELEMENT note (message)>",
        "<!ELEMENT element-name (child-name+)>\n\nExample:\n\n<!ELEMENT note (message+)>",
        "<!ELEMENT element-name (child-name*)>\n\nExample:\n\n<!ELEMENT note (message*)>",
        "<!ELEMENT element-name (child-name?)>\n\nExample:\n\n<!ELEMENT note (message?)>",
        "<!ELEMENT note (to,from,header,(message|body))>",
        "<!ELEMENT note (#PCDATA|to|from|header|message)*>"
      ]
    },
    {
      "title": "DTD - Attributes",
      "summary": "In a DTD, attributes are declared with an ATTLIST declaration.\nDeclaring Attributes\nAn attribute declaration has the following syntax:\nThe attribute-type can be one of the following:\nThe attribute-value can be one of the following:\nREMOVE ADS\nA Default Attribute Value\nIn the example above, the \"square\" element is defined to be an empty element with a \"width\" attribute of  type CDATA. If no width is specified, it has a default value of 0.\n#REQUIRED\nSyntax\nExample\nUse the #REQUIRED keyword if you don't have an option for a default value, but still want to force the attribute to be present.\n#IMPLIED\nSyntax\nExample\nUse the #IMPLIED keyword if you don't want to force the author to include an attribute, and you don't have an option for a default value.\n#FIXED\nSyntax\nExample\nUse the #FIXED keyword when you want an attribute to have a fixed value without allowing the author to change it. If an author includes another value, the XML parser will return an error.\nEnumerated Attribute Values\nSyntax\nExample\nUse enumerated attribute values when you want the attribute value to be one of a fixed set of legal values.",
      "examples": [
        "<!ATTLIST element-name attribute-name attribute-type attribute-value>\n\nDTD example:\n\n<!ATTLIST payment type CDATA \"check\">\n\nXML example:\n\n<payment type=\"check\" />",
        "DTD:\n<!ELEMENT square EMPTY>\n<!ATTLIST square width CDATA \"0\">\n\nValid XML:\n<square width=\"100\" />",
        "<!ATTLIST element-name attribute-name attribute-type #REQUIRED>",
        "DTD:\n<!ATTLIST person number CDATA #REQUIRED>\n\nValid XML:\n<person number=\"5677\" />\n\nInvalid XML:\n<person />",
        "<!ATTLIST element-name attribute-name attribute-type #IMPLIED>",
        "DTD:\n<!ATTLIST contact fax CDATA #IMPLIED>\n\nValid XML:\n<contact fax=\"555-667788\" />\n\nValid XML:\n<contact />",
        "<!ATTLIST element-name attribute-name attribute-type #FIXED \"value\">",
        "DTD:\n<!ATTLIST sender company CDATA #FIXED \"Microsoft\">\n\nValid XML:\n<sender company=\"Microsoft\" />\n\nInvalid XML:\n<sender company=\"W3Schools\" />",
        "<!ATTLIST element-name attribute-name (en1|en2|..) default-value>",
        "DTD:\n<!ATTLIST payment type (check|cash) \"cash\">\n\nXML example:\n<payment type=\"check\" />\nor\n<payment type=\"cash\" />"
      ]
    },
    {
      "title": "XML Elements vs. Attributes",
      "summary": "In XML, there are no rules about when to use attributes, and when to use child elements.\nUse of Elements vs. Attributes\nData can be stored in child elements or in attributes.\nTake a look at these examples:\nIn the first example sex is an attribute. In the last, sex is a child element. Both examples provide the same information.\nThere are no rules about when to use attributes, and when to use child elements. My experience is that attributes are handy in HTML, but in XML you should try to avoid them. Use child elements if the information feels like data.\nMy Favorite Way\nI like to store data in child elements.\nThe following three XML documents contain exactly the same information:\nA date attribute is used in the first example:\nA date element is used in the second example:\nAn expanded date element is used in the third: (THIS IS MY FAVORITE):\nREMOVE ADS\nAvoid using attributes?\nShould you avoid using attributes?\nSome of the problems with attributes are:\nattributes cannot contain multiple values (child elements can)\nattributes are not easily expandable (for future changes)\nattributes cannot describe structures (child elements can)\nattributes are more difficult to manipulate by program code\nattribute values are not easy to test against a DTD\nIf you use attributes as containers for data, you end up with documents that are difficult to read and maintain. Try to use elements to describe data. Use attributes only to provide information that is not relevant to the data.\nDon't end up like this (this is not how XML should be used):\nAn Exception to my Attribute Rule\nRules always have exceptions.\nMy rule about attributes has one exception:\nSometimes I assign ID references to elements. These ID references can be used to access XML elements in much the same way as the NAME or ID attributes in HTML. This example demonstrates this:\nThe ID in these examples is just a counter, or a unique identifier, to identify the different notes in the XML file, and not a part of the note data.\nWhat I am trying to say here is that metadata (data about data) should be stored as attributes, and that data itself should be stored as elements.",
      "examples": [
        "<person sex=\"female\">\n<firstname>Anna</firstname>\n<lastname>Smith</lastname>\n</person>",
        "<person>\n<sex>female</sex>\n<firstname>Anna</firstname>\n<lastname>Smith</lastname>\n</person>",
        "<note date=\"12/11/2002\">\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<note>\n<date>12/11/2002</date>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<note>\n<date>\n<day>12</day>\n<month>11</month>\n<year>2002</year>\n</date>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<note day=\"12\" month=\"11\" year=\"2002\"\nto=\"Tove\" from=\"Jani\" heading=\"Reminder\"\nbody=\"Don't forget me this weekend!\">\n</note>",
        "<messages>\n<note id=\"p501\">\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>\n\n<note id=\"p502\">\n<to>Jani</to>\n<from>Tove</from>\n<heading>Re: Reminder</heading>\n<body>I will not!</body>\n</note>\n</messages>"
      ]
    },
    {
      "title": "DTD - Entities",
      "summary": "Entities are used to define shortcuts to special characters.\nEntities can be declared internal or external.\nAn Internal Entity Declaration\nSyntax\nExample\nNote: An entity has three parts: an ampersand (&), an entity name, and a semicolon (;).\nAn External Entity Declaration\nSyntax\nExample",
      "examples": [
        "<!ENTITY entity-name \"entity-value\">",
        "DTD Example:\n\n<!ENTITY writer \"Donald Duck.\">\n<!ENTITY copyright \"Copyright W3Schools.\">\n\nXML example:\n\n<author>&writer;&copyright;</author>",
        "<!ENTITY entity-name SYSTEM \"URI/URL\">",
        "DTD Example:\n\n<!ENTITY writer SYSTEM \"https://www.w3schools.com/entities.dtd\">\n<!ENTITY copyright SYSTEM \"https://www.w3schools.com/entities.dtd\">\n\nXML example:\n\n<author>&writer;&copyright;</author>"
      ]
    },
    {
      "title": "DTD Examples",
      "summary": "TV Schedule DTD\nNewspaper Article DTD\nREMOVE ADS\nProduct Catalog DTD",
      "examples": [
        "<!DOCTYPE TVSCHEDULE [\n\n<!ELEMENT TVSCHEDULE (CHANNEL+)>\n<!ELEMENT CHANNEL (BANNER,DAY+)>\n<!ELEMENT BANNER (#PCDATA)>\n<!ELEMENT DAY (DATE,(HOLIDAY|PROGRAMSLOT+)+)>\n<!ELEMENT HOLIDAY (#PCDATA)>\n<!ELEMENT DATE (#PCDATA)>\n<!ELEMENT PROGRAMSLOT (TIME,TITLE,DESCRIPTION?)>\n<!ELEMENT TIME (#PCDATA)>\n<!ELEMENT TITLE (#PCDATA)>\n<!ELEMENT DESCRIPTION (#PCDATA)>\n\n<!ATTLIST TVSCHEDULE NAME CDATA #REQUIRED>\n<!ATTLIST CHANNEL CHAN CDATA #REQUIRED>\n<!ATTLIST PROGRAMSLOT VTR CDATA #IMPLIED>\n<!ATTLIST TITLE RATING CDATA #IMPLIED>\n<!ATTLIST TITLE LANGUAGE CDATA #IMPLIED>\n]>",
        "<!DOCTYPE NEWSPAPER [\n\n<!ELEMENT NEWSPAPER (ARTICLE+)>\n<!ELEMENT ARTICLE (HEADLINE,BYLINE,LEAD,BODY,NOTES)>\n<!ELEMENT HEADLINE (#PCDATA)>\n<!ELEMENT BYLINE (#PCDATA)>\n<!ELEMENT LEAD (#PCDATA)>\n<!ELEMENT BODY (#PCDATA)>\n<!ELEMENT NOTES (#PCDATA)>\n\n<!ATTLIST ARTICLE AUTHOR CDATA #REQUIRED>\n<!ATTLIST ARTICLE EDITOR CDATA #IMPLIED>\n<!ATTLIST ARTICLE DATE CDATA #IMPLIED>\n<!ATTLIST ARTICLE EDITION CDATA #IMPLIED>\n\n<!ENTITY NEWSPAPER \"Vervet Logic Times\">\n<!ENTITY PUBLISHER \"Vervet Logic Press\">\n<!ENTITY COPYRIGHT \"Copyright 1998 Vervet Logic Press\">\n\n]>",
        "<!DOCTYPE CATALOG [\n\n<!ENTITY AUTHOR \"John Doe\">\n<!ENTITY COMPANY \"JD Power Tools, Inc.\">\n<!ENTITY EMAIL \"jd@jd-tools.com\">\n\n<!ELEMENT CATALOG (PRODUCT+)>\n\n<!ELEMENT PRODUCT\n(SPECIFICATIONS+,OPTIONS?,PRICE+,NOTES?)>\n<!ATTLIST PRODUCT\nNAME CDATA #IMPLIED\nCATEGORY (HandTool|Table|Shop-Professional) \"HandTool\"\nPARTNUM CDATA #IMPLIED\nPLANT (Pittsburgh|Milwaukee|Chicago) \"Chicago\"\nINVENTORY (InStock|Backordered|Discontinued) \"InStock\">\n\n<!ELEMENT SPECIFICATIONS (#PCDATA)>\n<!ATTLIST SPECIFICATIONS\nWEIGHT CDATA #IMPLIED\nPOWER CDATA #IMPLIED>\n\n<!ELEMENT OPTIONS (#PCDATA)>\n<!ATTLIST OPTIONS\nFINISH (Metal|Polished|Matte) \"Matte\"\nADAPTER (Included|Optional|NotApplicable) \"Included\"\nCASE (HardShell|Soft|NotApplicable) \"HardShell\">\n\n<!ELEMENT PRICE (#PCDATA)>\n<!ATTLIST PRICE\nMSRP CDATA #IMPLIED\nWHOLESALE CDATA #IMPLIED\nSTREET CDATA #IMPLIED\nSHIPPING CDATA #IMPLIED>\n\n<!ELEMENT NOTES (#PCDATA)>\n\n]>"
      ]
    },
    {
      "title": "XML Schema Tutorial",
      "summary": "What is an XML Schema?\nAn XML Schema describes the structure of an XML document.\nThe XML Schema language is also referred to as XML Schema Definition (XSD).\nXSD Example\nThe purpose of an XML Schema is to define the legal building blocks of an XML document:\nthe elements and attributes that can appear in a document\nthe number of (and order of) child elements\ndata types for elements and attributes\ndefault and fixed values for elements and attributes\nWhy Learn XML Schema?\nIn the XML world, hundreds of standardized XML formats are in daily use.\nMany of these XML standards are defined by XML Schemas.\nXML Schema is an XML-based (and more powerful) alternative to DTD.\nREMOVE ADS\nXML Schemas Support Data Types\nOne of the greatest strength of XML Schemas is the support for data types.\nIt is easier to describe allowable document content\nIt is easier to validate the correctness of data\nIt is easier to define data facets (restrictions on data)\nIt is easier to define data patterns (data formats)\nIt is easier to convert data between different data types\nXML Schemas use XML Syntax\nAnother great strength about XML Schemas is that they are written in XML.\nYou don't have to learn a new language\nYou can use your XML editor to edit your Schema files\nYou can use your XML parser to parse your Schema files\nYou can manipulate your Schema with the XML DOM\nYou can transform your Schema with XSLT\nXML Schemas are extensible, because they are written in XML.\nWith an extensible Schema definition you can:\nReuse your Schema in other Schemas\nCreate your own data types derived from the standard types\nReference multiple schemas in the same document\nXML Schemas Secure Data Communication\nWhen sending data from a sender to a receiver, it is essential that both parts have the same \"expectations\" about the content.\nWith XML Schemas, the sender can describe the data in a way that the receiver will understand.\nA date like: \"03-11-2004\" will, in some countries, be interpreted as 3.November and in other countries as 11.March.\nHowever, an XML element with a data type like this:\n<date type=\"date\">2004-03-11</date>\nensures a mutual understanding of the content, because the XML data type \"date\" requires the format \"YYYY-MM-DD\".\nWell-Formed is Not Enough\nA well-formed XML document is a document that conforms to the XML syntax rules, like:\nit must begin with the XML declaration\nit must have one unique root element\nstart-tags must have matching end-tags\nelements are case sensitive\nall elements must be closed\nall elements must be properly nested\nall attribute values must be quoted\nentities must be used for special characters\nEven if documents are well-formed they can still contain errors, and those errors can have serious consequences.\nThink of the following situation: you order 5 gross of laser printers, instead of 5 laser printers. With XML Schemas, most of these errors can be caught by your validating software.",
      "examples": [
        "<?xml version=\"1.0\"?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n\n<xs:element name=\"note\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"to\" type=\"xs:string\"/>\n<xs:element name=\"from\" type=\"xs:string\"/>\n<xs:element name=\"heading\" type=\"xs:string\"/>\n<xs:element name=\"body\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n\n</xs:schema>"
      ]
    },
    {
      "title": "XSD How To?",
      "summary": "XML documents can have a reference to a DTD or to an XML Schema.\nA Simple XML Document\nLook at this simple XML document called \"note.xml\":\nA DTD File\nThe following example is a DTD file called \"note.dtd\" that defines the elements of the XML document above (\"note.xml\"):\nThe first line defines the note element to have four child elements: \"to, from, heading, body\".\nLine 2-5 defines the to, from, heading, body elements to be of type \"#PCDATA\".\nAn XML Schema\nThe following example is an XML Schema file called \"note.xsd\" that defines the elements of the XML document above (\"note.xml\"):\nThe note element is a complex type because it contains other elements. The other elements (to, from, heading, body) are simple types because they do not contain other elements. You will learn more about simple and complex types in the following chapters.\nREMOVE ADS\nA Reference to a DTD\nThis XML document has a reference to a DTD:\nA Reference to an XML Schema\nThis XML document has a reference to an XML Schema:",
      "examples": [
        "<?xml version=\"1.0\"?>\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<!ELEMENT note (to, from, heading, body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>",
        "<?xml version=\"1.0\"?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\ntargetNamespace=\"https://www.w3schools.com\"\nxmlns=\"https://www.w3schools.com\"\nelementFormDefault=\"qualified\">\n\n<xs:element name=\"note\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"to\" type=\"xs:string\"/>\n<xs:element name=\"from\" type=\"xs:string\"/>\n<xs:element name=\"heading\" type=\"xs:string\"/>\n<xs:element name=\"body\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n\n</xs:schema>",
        "<?xml version=\"1.0\"?>\n\n<!DOCTYPE note SYSTEM\n\"https://www.w3schools.com/xml/note.dtd\">\n\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "<?xml version=\"1.0\"?>\n\n<note\nxmlns=\"https://www.w3schools.com\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"https://www.w3schools.com/xml note.xsd\">\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>"
      ]
    },
    {
      "title": "XSD - The <schema> Element",
      "summary": "The <schema> element is the root element of every XML Schema.\nThe <schema> Element\nThe <schema> element is the root element of every XML Schema:\nThe <schema> element may contain some attributes. A schema declaration often looks something like this:\nThe following fragment:\nindicates that the elements and data types used in the schema come from the \"http://www.w3.org/2001/XMLSchema\" namespace. It also specifies that the elements and data types that come from the \"http://www.w3.org/2001/XMLSchema\" namespace should be prefixed with xs:\nThis fragment:\nindicates that the elements defined by this schema (note, to, from, heading, body.) come from the \"https://www.w3schools.com\" namespace.\nThis fragment:\nindicates that the default namespace is \"https://www.w3schools.com\".\nThis fragment:\nindicates that any elements used by the XML instance document which were declared in this schema must be namespace qualified.\nREMOVE ADS\nReferencing a Schema in an XML Document\nThis XML document has a reference to an XML Schema:\nThe following fragment:\nspecifies the default namespace declaration. This declaration tells the schema-validator that all the elements used in this XML document are declared in the \"https://www.w3schools.com\" namespace.\nOnce you have the XML Schema Instance namespace available:\nyou can use the schemaLocation attribute. This attribute has two values, separated by a space. The first value is the namespace to use. The second value is the location of the XML schema to use for that namespace:",
      "examples": [
        "<?xml version=\"1.0\"?>\n\n<xs:schema>\n...\n...\n</xs:schema>",
        "<?xml version=\"1.0\"?>\n\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\ntargetNamespace=\"https://www.w3schools.com\"\nxmlns=\"https://www.w3schools.com\"\nelementFormDefault=\"qualified\">\n...\n...\n</xs:schema>",
        "xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"",
        "targetNamespace=\"https://www.w3schools.com\"",
        "xmlns=\"https://www.w3schools.com\"",
        "elementFormDefault=\"qualified\"",
        "<?xml version=\"1.0\"?>\n\n<note xmlns=\"https://www.w3schools.com\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"https://www.w3schools.com note.xsd\">\n\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>",
        "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
        "xsi:schemaLocation=\"https://www.w3schools.com note.xsd\""
      ]
    },
    {
      "title": "XSD Simple Elements",
      "summary": "XML Schemas define the elements of your XML files.\nA simple element is an XML element that contains only text. It cannot contain any other elements or attributes.\nWhat is a Simple Element?\nA simple element is an XML element that can contain only text. It cannot contain any other elements or attributes.\nHowever, the \"only text\" restriction is quite misleading. The text can be of many different types. It can be one of the types included in the XML Schema definition (boolean, string, date, etc.), or it can be a custom type that you can define yourself.\nYou can also add restrictions (facets) to a data type in order to limit its content, or you can require the data to match a specific pattern.\nDefining a Simple Element\nThe syntax for defining a simple element is:\nwhere xxx is the name of the element and yyy is the data type of the element.\nXML Schema has a lot of built-in data types. The most common types are:\nxs:string\nxs:decimal\nxs:integer\nxs:boolean\nxs:date\nxs:time\nExample\nHere are some XML elements:\nAnd here are the corresponding simple element definitions:\nDefault and Fixed Values for Simple Elements\nSimple elements may have a default value OR a fixed value specified.\nA default value is automatically assigned to the element when no other value is specified.\nIn the following example the default value is \"red\":\nA fixed value is also automatically assigned to the element, and you cannot specify another value.\nIn the following example the fixed value is \"red\":",
      "examples": [
        "<xs:element name=\"xxx\" type=\"yyy\"/>",
        "<lastname>Refsnes</lastname>\n<age>36</age>\n<dateborn>1970-03-27</dateborn>",
        "<xs:element name=\"lastname\" type=\"xs:string\"/>\n<xs:element name=\"age\" type=\"xs:integer\"/>\n<xs:element name=\"dateborn\" type=\"xs:date\"/>",
        "<xs:element name=\"color\" type=\"xs:string\" default=\"red\"/>",
        "<xs:element name=\"color\" type=\"xs:string\" fixed=\"red\"/>"
      ]
    },
    {
      "title": "XSD Attributes",
      "summary": "All attributes are declared as simple types.\nWhat is an Attribute?\nSimple elements cannot have attributes. If an element has attributes, it is considered to be of a complex type. But the attribute itself is always declared as a simple type.\nHow to Define an Attribute?\nThe syntax for defining an attribute is:\nwhere xxx is the name of the attribute and yyy specifies the data type of the attribute.\nXML Schema has a lot of built-in data types. The most common types are:\nxs:string\nxs:decimal\nxs:integer\nxs:boolean\nxs:date\nxs:time\nExample\nHere is an XML element with an attribute:\nAnd here is the corresponding attribute definition:\nDefault and Fixed Values for Attributes\nAttributes may have a default value OR a fixed value specified.\nA default value is automatically assigned to the attribute when no other value is specified.\nIn the following example the default value is \"EN\":\nA fixed value is also automatically assigned to the attribute, and you cannot specify another value.\nIn the following example the fixed value is \"EN\":\nREMOVE ADS\nOptional and Required Attributes\nAttributes are optional by default. To specify that the attribute is required, use the \"use\" attribute:\nRestrictions on Content\nWhen an XML element or attribute has a data type defined, it puts restrictions on the element's or attribute's content.\nIf an XML element is of type \"xs:date\" and contains a string like \"Hello World\", the element will not validate.\nWith XML Schemas, you can also add your own restrictions to your XML elements and attributes. These restrictions are called facets. You can read more about facets in the next chapter.",
      "examples": [
        "<xs:attribute name=\"xxx\" type=\"yyy\"/>",
        "<lastname lang=\"EN\">Smith</lastname>",
        "<xs:attribute name=\"lang\" type=\"xs:string\"/>",
        "<xs:attribute name=\"lang\" type=\"xs:string\" default=\"EN\"/>",
        "<xs:attribute name=\"lang\" type=\"xs:string\" fixed=\"EN\"/>",
        "<xs:attribute name=\"lang\" type=\"xs:string\" use=\"required\"/>"
      ]
    },
    {
      "title": "XSD Restrictions/Facets",
      "summary": "Restrictions are used to define acceptable values for XML elements or attributes. Restrictions on XML elements are called facets.\nRestrictions on Values\nThe following example defines an element called \"age\" with a restriction. The value of age cannot be lower than 0 or greater than 120:\nRestrictions on a Set of Values\nTo limit the content of an XML element to a set of acceptable values, we would use the enumeration constraint.\nThe example below defines an element called \"car\" with a restriction. The only acceptable values are: Audi, Golf, BMW:\nThe example above could also have been written like this:\nNote: In this case the type \"carType\" can be used by other elements because it is not a part of the \"car\" element.\nREMOVE ADS\nRestrictions on a Series of Values\nTo limit the content of an XML element to define a series of numbers or letters that can be used, we would use the pattern constraint.\nThe example below defines an element called \"letter\" with a restriction. The only acceptable value is ONE of the LOWERCASE letters from a to z:\nThe next example defines an element called \"initials\" with a restriction. The only acceptable value is THREE of the UPPERCASE letters from a to z:\nThe next example also defines an element called \"initials\" with a restriction. The only acceptable value is THREE of the LOWERCASE OR UPPERCASE letters from a to z:\nThe next example defines an element called \"choice\" with a restriction. The only acceptable value is ONE of the following letters: x, y, OR z:\nThe next example defines an element called \"prodid\" with a restriction. The only acceptable value is FIVE digits in a sequence, and each digit must be in a range from 0 to 9:\nOther Restrictions on a Series of Values\nThe example below defines an element called \"letter\" with a restriction. The acceptable value is zero or more occurrences of lowercase letters from a to z:\nThe next example also defines an element called \"letter\" with a restriction. The acceptable value is one or more pairs of letters, each pair consisting of a lower case letter followed by an upper case letter. For example, \"sToP\" will be validated by this pattern, but not \"Stop\" or \"STOP\" or \"stop\":\nThe next example defines an element called \"gender\" with a restriction. The only acceptable value is male OR female:\nThe next example defines an element called \"password\" with a restriction. There must be exactly eight characters in a row and those characters must be lowercase or uppercase letters from a to z, or a number from 0 to 9:\nRestrictions on Whitespace Characters\nTo specify how whitespace characters should be handled, we would use the whiteSpace constraint.\nThis example defines an element called \"address\" with a restriction. The whiteSpace constraint is set to \"preserve\", which means that the XML processor WILL NOT remove any white space characters:\nThis example also defines an element called \"address\" with a restriction. The whiteSpace constraint is set to \"replace\", which means that the XML processor WILL REPLACE all white space characters (line feeds, tabs, spaces, and carriage returns) with spaces:\nThis example also defines an element called \"address\" with a restriction. The whiteSpace constraint is set to \"collapse\", which means that the XML processor WILL REMOVE all white space characters (line feeds, tabs, spaces, carriage returns are replaced with spaces, leading and trailing spaces are removed, and multiple spaces are reduced to a single space):\nRestrictions on Length\nTo limit the length of a value in an element, we would use the length, maxLength, and minLength constraints.\nThis example defines an element called \"password\" with a restriction. The value must be exactly eight characters:\nThis example defines another element called \"password\" with a restriction. The value must be minimum five characters and maximum eight characters:\nRestrictions for Datatypes",
      "examples": [
        "<xs:element name=\"age\">\n<xs:simpleType>\n<xs:restriction base=\"xs:integer\">\n<xs:minInclusive value=\"0\"/>\n<xs:maxInclusive value=\"120\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"car\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:enumeration value=\"Audi\"/>\n<xs:enumeration value=\"Golf\"/>\n<xs:enumeration value=\"BMW\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"car\" type=\"carType\"/>\n\n<xs:simpleType name=\"carType\">\n<xs:restriction base=\"xs:string\">\n<xs:enumeration value=\"Audi\"/>\n<xs:enumeration value=\"Golf\"/>\n<xs:enumeration value=\"BMW\"/>\n</xs:restriction>\n</xs:simpleType>",
        "<xs:element name=\"letter\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"[a-z]\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"initials\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"[A-Z][A-Z][A-Z]\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"initials\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"[a-zA-Z][a-zA-Z][a-zA-Z]\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"choice\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"[xyz]\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"prodid\">\n<xs:simpleType>\n<xs:restriction base=\"xs:integer\">\n<xs:pattern value=\"[0-9][0-9][0-9][0-9][0-9]\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"letter\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"([a-z])*\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"letter\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"([a-z][A-Z])+\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"gender\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"male|female\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"password\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"[a-zA-Z0-9]{8}\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"address\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:whiteSpace value=\"preserve\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"address\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:whiteSpace value=\"replace\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"password\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:length value=\"8\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>",
        "<xs:element name=\"password\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:minLength value=\"5\"/>\n<xs:maxLength value=\"8\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:element>"
      ]
    },
    {
      "title": "XSD Complex Elements",
      "summary": "A complex element contains other elements and/or attributes.\nWhat is a Complex Element?\nA complex element is an XML element that contains other elements and/or attributes.\nThere are four kinds of complex elements:\nempty elements\nelements that contain only other elements\nelements that contain only text\nelements that contain both other elements and text\nNote: Each of these elements may contain attributes as well!\nExamples of Complex Elements\nA complex XML element, \"product\", which is empty:\nA complex XML element, \"employee\", which contains only other elements:\nA complex XML element, \"food\", which contains only text:\nA complex XML element, \"description\", which contains both elements and text:\nREMOVE ADS\nHow to Define a Complex Element\nLook at this complex XML element, \"employee\", which contains only other elements:\nWe can define a complex element in an XML Schema two different ways:\n1. The \"employee\" element can be declared directly by naming the element, like this:\nIf you use the method described above, only the \"employee\" element can use the specified complex type. Note that the child elements, \"firstname\" and \"lastname\", are surrounded by the <sequence> indicator. This means that the child elements must appear in the same order as they are declared. You will learn more about indicators in the XSD Indicators chapter.\n2. The \"employee\" element can have a type attribute that refers to the name of the complex type to use:\nIf you use the method described above, several elements can refer to the same complex type, like this:\nYou can also base a complex type on an existing complex type and add some elements, like this:",
      "examples": [
        "<product pid=\"1345\"/>",
        "<employee>\n<firstname>John</firstname>\n<lastname>Smith</lastname>\n</employee>",
        "<food type=\"dessert\">Ice cream</food>",
        "<description>\nIt happened on <date lang=\"norwegian\">03.03.99</date> ....\n</description>",
        "<xs:element name=\"employee\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"employee\" type=\"personinfo\"/>\n\n<xs:complexType name=\"personinfo\">\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>",
        "<xs:element name=\"employee\" type=\"personinfo\"/>\n<xs:element name=\"student\" type=\"personinfo\"/>\n<xs:element name=\"member\" type=\"personinfo\"/>\n\n<xs:complexType name=\"personinfo\">\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>",
        "<xs:element name=\"employee\" type=\"fullpersoninfo\"/>\n\n<xs:complexType name=\"personinfo\">\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n\n<xs:complexType name=\"fullpersoninfo\">\n<xs:complexContent>\n<xs:extension base=\"personinfo\">\n<xs:sequence>\n<xs:element name=\"address\" type=\"xs:string\"/>\n<xs:element name=\"city\" type=\"xs:string\"/>\n<xs:element name=\"country\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:extension>\n</xs:complexContent>\n</xs:complexType>"
      ]
    },
    {
      "title": "XSD Empty Elements",
      "summary": "An empty complex element cannot have contents, only attributes.\nComplex Empty Elements\nAn empty XML element:\nThe \"product\" element above has no content at all. To define a type with no content, we must define a type that allows elements in its content, but we do not actually declare any elements, like this:\nIn the example above, we define a complex type with a complex content. The complexContent element signals that we intend to restrict or extend the content model of a complex type, and the restriction of integer declares one attribute but does not introduce any element content.\nHowever, it is possible to declare the \"product\" element more compactly, like this:\nOr you can give the complexType element a name, and let the \"product\" element have a type attribute that refers to the name of the complexType (if you use this method, several elements can refer to the same complex type):",
      "examples": [
        "<product prodid=\"1345\" />",
        "<xs:element name=\"product\">\n<xs:complexType>\n<xs:complexContent>\n<xs:restriction base=\"xs:integer\">\n<xs:attribute name=\"prodid\" type=\"xs:positiveInteger\"/>\n</xs:restriction>\n</xs:complexContent>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"product\">\n<xs:complexType>\n<xs:attribute name=\"prodid\" type=\"xs:positiveInteger\"/>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"product\" type=\"prodtype\"/>\n\n<xs:complexType name=\"prodtype\">\n<xs:attribute name=\"prodid\" type=\"xs:positiveInteger\"/>\n</xs:complexType>"
      ]
    },
    {
      "title": "XSD Elements Only",
      "summary": "An \"elements-only\" complex type contains an element that contains only other elements.\nComplex Types Containing Elements Only\nAn XML element, \"person\", that contains only other elements:\nYou can define the \"person\" element in a schema, like this:\nNotice the <xs:sequence> tag. It means that the elements defined (\"firstname\" and \"lastname\") must appear in that order inside a \"person\" element.\nOr you can give the complexType element a name, and let the \"person\" element have a type attribute that refers to the name of the complexType (if you use this method, several elements can refer to the same complex type):",
      "examples": [
        "<person>\n<firstname>John</firstname>\n<lastname>Smith</lastname>\n</person>",
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"person\" type=\"persontype\"/>\n\n<xs:complexType name=\"persontype\">\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>"
      ]
    },
    {
      "title": "XSD Text-Only Elements",
      "summary": "A complex text-only element can contain text and attributes.\nComplex Text-Only Elements\nThis type contains only simple content (text and attributes), therefore we add a simpleContent element around the content. When using simple content, you must define an extension OR a restriction within the simpleContent element, like this:\nTip: Use the extension/restriction element to expand or to limit the base simple type for the element.\nHere is an example of an XML element, \"shoesize\", that contains text-only:\nThe following example declares a complexType, \"shoesize\". The content is defined as an integer value, and the \"shoesize\" element also contains an attribute named \"country\":\nWe could also give the complexType element a name, and let the \"shoesize\" element have a type attribute that refers to the name of the complexType (if you use this method, several elements can refer to the same complex type):",
      "examples": [
        "<xs:element name=\"somename\">\n<xs:complexType>\n<xs:simpleContent>\n<xs:extension base=\"basetype\">\n....\n....\n</xs:extension>\n</xs:simpleContent>\n</xs:complexType>\n</xs:element>\n\nOR\n\n<xs:element name=\"somename\">\n<xs:complexType>\n<xs:simpleContent>\n<xs:restriction base=\"basetype\">\n....\n....\n</xs:restriction>\n</xs:simpleContent>\n</xs:complexType>\n</xs:element>",
        "<shoesize country=\"france\">35</shoesize>",
        "<xs:element name=\"shoesize\">\n<xs:complexType>\n<xs:simpleContent>\n<xs:extension base=\"xs:integer\">\n<xs:attribute name=\"country\" type=\"xs:string\" />\n</xs:extension>\n</xs:simpleContent>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"shoesize\" type=\"shoetype\"/>\n\n<xs:complexType name=\"shoetype\">\n<xs:simpleContent>\n<xs:extension base=\"xs:integer\">\n<xs:attribute name=\"country\" type=\"xs:string\" />\n</xs:extension>\n</xs:simpleContent>\n</xs:complexType>"
      ]
    },
    {
      "title": "XSD Mixed Content",
      "summary": "A mixed complex type element can contain attributes, elements, and text.\nComplex Types with Mixed Content\nAn XML element, \"letter\", that contains both text and other elements:\nThe following schema declares the \"letter\" element:\nNote: To enable character data to appear between the child-elements of \"letter\", the mixed attribute must be set to \"true\". The <xs:sequence> tag means that the elements defined (name, orderid and shipdate) must appear in that order inside a \"letter\" element.\nWe could also give the complexType element a name, and let the \"letter\" element have a type attribute that refers to the name of the complexType (if you use this method, several elements can refer to the same complex type):",
      "examples": [
        "<letter>\nDear Mr. <name>John Smith</name>.\nYour order <orderid>1032</orderid>\nwill be shipped on <shipdate>2001-07-13</shipdate>.\n</letter>",
        "<xs:element name=\"letter\">\n<xs:complexType mixed=\"true\">\n<xs:sequence>\n<xs:element name=\"name\" type=\"xs:string\"/>\n<xs:element name=\"orderid\" type=\"xs:positiveInteger\"/>\n<xs:element name=\"shipdate\" type=\"xs:date\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"letter\" type=\"lettertype\"/>\n\n<xs:complexType name=\"lettertype\" mixed=\"true\">\n<xs:sequence>\n<xs:element name=\"name\" type=\"xs:string\"/>\n<xs:element name=\"orderid\" type=\"xs:positiveInteger\"/>\n<xs:element name=\"shipdate\" type=\"xs:date\"/>\n</xs:sequence>\n</xs:complexType>"
      ]
    },
    {
      "title": "XSD Indicators",
      "summary": "We can control HOW elements are to be used in documents with indicators.\nIndicators\nThere are seven indicators:\nOrder indicators:\nAll\nChoice\nSequence\nOccurrence indicators:\nmaxOccurs\nminOccurs\nGroup indicators:\nGroup name\nattributeGroup name\nOrder Indicators\nOrder indicators are used to define the order of the elements.\nAll Indicator\nThe <all> indicator specifies that the child elements can appear in any order, and that each child element must occur only once:\nNote: When using the <all> indicator you can set the <minOccurs> indicator to 0 or 1 and the <maxOccurs> indicator can only be set to 1 (the <minOccurs> and <maxOccurs> are described later).\nChoice Indicator\nThe <choice> indicator specifies that either one child element or another can occur:\nSequence Indicator\nThe <sequence> indicator specifies that the child elements must appear in a specific order:\nREMOVE ADS\nOccurrence Indicators\nOccurrence indicators are used to define how often an element can occur.\nNote: For all \"Order\" and \"Group\" indicators (any, all, choice, sequence, group name, and group reference) the default value for maxOccurs and minOccurs is 1.\nmaxOccurs Indicator\nThe <maxOccurs> indicator specifies the maximum number of times an element can occur:\nThe example above indicates that the \"child_name\" element can occur a minimum of one time (the default value for minOccurs is 1) and a maximum of ten times in the \"person\" element.\nminOccurs Indicator\nThe <minOccurs> indicator specifies the minimum number of times an element can occur:\nThe example above indicates that the \"child_name\" element can occur a minimum of zero times and a maximum of ten times in the \"person\" element.\nTip: To allow an element to appear an unlimited number of times, use the maxOccurs=\"unbounded\" statement:\nA working example:\nAn XML file called \"Myfamily.xml\":\nThe XML file above contains a root element named \"persons\". Inside this root element we have defined three \"person\" elements. Each \"person\" element must contain a \"full_name\" element and it can contain up to five \"child_name\" elements.\nHere is the schema file \"family.xsd\":\nGroup Indicators\nGroup indicators are used to define related sets of elements.\nElement Groups\nElement groups are defined with the group declaration, like this:\nYou must define an all, choice, or sequence element inside the group declaration. The following example defines a group named \"persongroup\", that defines a group of elements that must occur in an exact sequence:\nAfter you have defined a group, you can reference it in another definition, like this:\nAttribute Groups\nAttribute groups are defined with the attributeGroup declaration, like this:\nThe following example defines an attribute group named \"personattrgroup\":\nAfter you have defined an attribute group, you can reference it in another definition, like this:",
      "examples": [
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:all>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:all>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:choice>\n<xs:element name=\"employee\" type=\"employee\"/>\n<xs:element name=\"member\" type=\"member\"/>\n</xs:choice>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"full_name\" type=\"xs:string\"/>\n<xs:element name=\"child_name\" type=\"xs:string\" maxOccurs=\"10\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"full_name\" type=\"xs:string\"/>\n<xs:element name=\"child_name\" type=\"xs:string\"\nmaxOccurs=\"10\" minOccurs=\"0\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<persons xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:noNamespaceSchemaLocation=\"family.xsd\">\n\n<person>\n<full_name>Hege Refsnes</full_name>\n<child_name>Cecilie</child_name>\n</person>\n\n<person>\n<full_name>Tove Refsnes</full_name>\n<child_name>Hege</child_name>\n<child_name>Stale</child_name>\n<child_name>Jim</child_name>\n<child_name>Borge</child_name>\n</person>\n\n<person>\n<full_name>Stale Refsnes</full_name>\n</person>\n\n</persons>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\nelementFormDefault=\"qualified\">\n\n<xs:element name=\"persons\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"person\" maxOccurs=\"unbounded\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"full_name\" type=\"xs:string\"/>\n<xs:element name=\"child_name\" type=\"xs:string\"\nminOccurs=\"0\" maxOccurs=\"5\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n\n</xs:schema>",
        "<xs:group name=\"groupname\">\n...\n</xs:group>",
        "<xs:group name=\"persongroup\">\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n<xs:element name=\"birthday\" type=\"xs:date\"/>\n</xs:sequence>\n</xs:group>",
        "<xs:group name=\"persongroup\">\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n<xs:element name=\"birthday\" type=\"xs:date\"/>\n</xs:sequence>\n</xs:group>\n\n<xs:element name=\"person\" type=\"personinfo\"/>\n\n<xs:complexType name=\"personinfo\">\n<xs:sequence>\n<xs:group ref=\"persongroup\"/>\n<xs:element name=\"country\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>",
        "<xs:attributeGroup name=\"groupname\">\n...\n</xs:attributeGroup>",
        "<xs:attributeGroup name=\"personattrgroup\">\n<xs:attribute name=\"firstname\" type=\"xs:string\"/>\n<xs:attribute name=\"lastname\" type=\"xs:string\"/>\n<xs:attribute name=\"birthday\" type=\"xs:date\"/>\n</xs:attributeGroup>",
        "<xs:attributeGroup name=\"personattrgroup\">\n<xs:attribute name=\"firstname\" type=\"xs:string\"/>\n<xs:attribute name=\"lastname\" type=\"xs:string\"/>\n<xs:attribute name=\"birthday\" type=\"xs:date\"/>\n</xs:attributeGroup>\n\n<xs:element name=\"person\">\n<xs:complexType>\n<xs:attributeGroup ref=\"personattrgroup\"/>\n</xs:complexType>\n</xs:element>"
      ]
    },
    {
      "title": "XSD The <any> Element",
      "summary": "The <any> element enables us to extend the XML document with elements not specified by the schema!\nThe <any> Element\nThe <any> element enables us to extend the XML document with elements not specified by the schema.\nThe following example is a fragment from an XML schema called \"family.xsd\". It shows a declaration for the \"person\" element. By using the <any> element we can extend (after <lastname>) the content of \"person\" with any element:\nNow we want to extend the \"person\" element with a \"children\" element. In this case we can do so, even if the author of the schema above never declared any \"children\" element.\nLook at this schema file, called \"children.xsd\":\nREMOVE ADS\nThe XML file below (called \"Myfamily.xml\"), uses components from two different schemas; \"family.xsd\" and \"children.xsd\":\nThe XML file above is valid because the schema \"family.xsd\" allows us to extend the \"person\" element with an optional element after the \"lastname\" element.\nThe <any> and <anyAttribute> elements are used to make EXTENSIBLE documents! They allow documents to contain additional elements that are not declared in the main XML schema.",
      "examples": [
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n<xs:any minOccurs=\"0\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\ntargetNamespace=\"https://www.w3schools.com\"\nxmlns=\"https://www.w3schools.com\"\nelementFormDefault=\"qualified\">\n\n<xs:element name=\"children\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"childname\" type=\"xs:string\"\nmaxOccurs=\"unbounded\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n\n</xs:schema>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<persons xmlns=\"http://www.microsoft.com\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.microsoft.com family.xsd\nhttps://www.w3schools.com children.xsd\">\n\n<person>\n<firstname>Hege</firstname>\n<lastname>Refsnes</lastname>\n<children>\n<childname>Cecilie</childname>\n</children>\n</person>\n\n<person>\n<firstname>Stale</firstname>\n<lastname>Refsnes</lastname>\n</person>\n\n</persons>"
      ]
    },
    {
      "title": "XSD The <anyAttribute> Element",
      "summary": "The <anyAttribute> element enables us to extend the XML document with attributes not specified by the schema!\nThe <anyAttribute> Element\nThe <anyAttribute> element enables us to extend the XML document with attributes not specified by the schema.\nThe following example is a fragment from an XML schema called \"family.xsd\". It shows a declaration for the \"person\" element. By using the <anyAttribute> element we can add any number of attributes to the \"person\" element:\nNow we want to extend the \"person\" element with a \"eyecolor\" attribute. In this case we can do so, even if the author of the schema above never declared any \"eyecolor\" attribute.\nLook at this schema file, called \"attribute.xsd\":\nREMOVE ADS\nThe XML file below (called \"Myfamily.xml\"), uses components from two different schemas; \"family.xsd\" and \"attribute.xsd\":\nThe XML file above is valid because the schema \"family.xsd\" allows us to add an attribute to the \"person\" element.\nThe <any> and <anyAttribute> elements are used to make EXTENSIBLE documents! They allow documents to contain additional elements that are not declared in the main XML schema.",
      "examples": [
        "<xs:element name=\"person\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"firstname\" type=\"xs:string\"/>\n<xs:element name=\"lastname\" type=\"xs:string\"/>\n</xs:sequence>\n<xs:anyAttribute/>\n</xs:complexType>\n</xs:element>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\ntargetNamespace=\"https://www.w3schools.com\"\nxmlns=\"https://www.w3schools.com\"\nelementFormDefault=\"qualified\">\n\n<xs:attribute name=\"eyecolor\">\n<xs:simpleType>\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"blue|brown|green|grey\"/>\n</xs:restriction>\n</xs:simpleType>\n</xs:attribute>\n\n</xs:schema>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<persons xmlns=\"http://www.microsoft.com\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:SchemaLocation=\"http://www.microsoft.com family.xsd\nhttps://www.w3schools.com attribute.xsd\">\n\n<person eyecolor=\"green\">\n<firstname>Hege</firstname>\n<lastname>Refsnes</lastname>\n</person>\n\n<person eyecolor=\"blue\">\n<firstname>Stale</firstname>\n<lastname>Refsnes</lastname>\n</person>\n\n</persons>"
      ]
    },
    {
      "title": "XSD Element Substitution",
      "summary": "With XML Schemas, one element can substitute another element.\nElement Substitution\nLet's say that we have users from two different countries: England and Norway. We would like the ability to let the user choose whether he or she would like to use the Norwegian element names or the English element names in the XML document.\nTo solve this problem, we could define a substitutionGroup in the XML schema. First, we declare a head element and then we declare the other elements which state that they are substitutable for the head element.\nIn the example above, the \"name\" element is the head element and the \"navn\" element is substitutable for \"name\".\nLook at this fragment of an XML schema:\nA valid XML document (according to the schema above) could look like this:\nor like this:\nREMOVE ADS\nBlocking Element Substitution\nTo prevent other elements from substituting with a specified element, use the block attribute:\nLook at this fragment of an XML schema:\nA valid XML document (according to the schema above) looks like this:\nBUT THIS IS NO LONGER VALID:\nUsing substitutionGroup\nThe type of the substitutable elements must be the same as, or derived from, the type of the head element. If the type of the substitutable element is the same as the type of the head element you will not have to specify the type of the substitutable element.\nNote that all elements in the substitutionGroup (the head element and the substitutable elements) must be declared as global elements, otherwise it will not work!\nWhat are Global Elements?\nGlobal elements are elements that are immediate children of the \"schema\" element! Local elements are elements nested within other elements.",
      "examples": [
        "<xs:element name=\"name\" type=\"xs:string\"/>\n<xs:element name=\"navn\" substitutionGroup=\"name\"/>",
        "<xs:element name=\"name\" type=\"xs:string\"/>\n<xs:element name=\"navn\" substitutionGroup=\"name\"/>\n\n<xs:complexType name=\"custinfo\">\n<xs:sequence>\n<xs:element ref=\"name\"/>\n</xs:sequence>\n</xs:complexType>\n\n<xs:element name=\"customer\" type=\"custinfo\"/>\n<xs:element name=\"kunde\" substitutionGroup=\"customer\"/>",
        "<customer>\n<name>John Smith</name>\n</customer>",
        "<kunde>\n<navn>John Smith</navn>\n</kunde>",
        "<xs:element name=\"name\" type=\"xs:string\" block=\"substitution\"/>",
        "<xs:element name=\"name\" type=\"xs:string\" block=\"substitution\"/>\n<xs:element name=\"navn\" substitutionGroup=\"name\"/>\n\n<xs:complexType name=\"custinfo\">\n<xs:sequence>\n<xs:element ref=\"name\"/>\n</xs:sequence>\n</xs:complexType>\n\n<xs:element name=\"customer\" type=\"custinfo\" block=\"substitution\"/>\n<xs:element name=\"kunde\" substitutionGroup=\"customer\"/>"
      ]
    },
    {
      "title": "An XSD Example",
      "summary": "This chapter will demonstrate how to write an XML Schema. You will also learn that a schema can be written in different ways.\nAn XML Document\nLet's have a look at this XML document called \"shiporder.xml\":\nThe XML document above consists of a root element, \"shiporder\", that contains a required attribute called \"orderid\". The \"shiporder\" element contains three different child elements: \"orderperson\", \"shipto\" and \"item\". The \"item\" element appears twice, and it contains a \"title\", an optional \"note\" element, a \"quantity\", and a \"price\" element.\nThe line above: xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" tells the XML parser that this document should be validated against a schema. The line: xsi:noNamespaceSchemaLocation=\"shiporder.xsd\" specifies WHERE the schema resides (here it is in the same folder as \"shiporder.xml\").\nREMOVE ADS\nCreate an XML Schema\nNow we want to create a schema for the XML document above.\nWe start by opening a new file that we will call \"shiporder.xsd\". To create the schema we could simply follow the structure in the XML document and define each element as we find it. We will start with the standard XML declaration followed by the xs:schema element that defines a schema:\nIn the schema above we use the standard namespace (xs), and the URI associated with this namespace is the Schema language definition, which has the standard value of http://www.w3.org/2001/XMLSchema.\nNext, we have to define the \"shiporder\" element. This element has an attribute and it contains other elements, therefore we consider it as a complex type. The child elements of the \"shiporder\" element is surrounded by a xs:sequence element that defines an ordered sequence of sub elements:\nThen we have to define the \"orderperson\" element as a simple type (because it does not contain any attributes or other elements). The type (xs:string) is prefixed with the namespace prefix associated with XML Schema that indicates a predefined schema data type:\nNext, we have to define two elements that are of the complex type: \"shipto\" and \"item\". We start by defining the \"shipto\" element:\nWith schemas we can define the number of possible occurrences for an element with the maxOccurs and minOccurs attributes. maxOccurs specifies the maximum number of occurrences for an element and minOccurs specifies the minimum number of occurrences for an element. The default value for both maxOccurs and minOccurs is 1!\nNow we can define the \"item\" element. This element can appear multiple times inside a \"shiporder\" element. This is specified by setting the maxOccurs attribute of the \"item\" element to \"unbounded\" which means that there can be as many occurrences of the \"item\" element as the author wishes. Notice that the \"note\" element is optional. We have specified this by setting the minOccurs attribute to zero:\nWe can now declare the attribute of the \"shiporder\" element. Since this is a required attribute we specify use=\"required\".\nNote: The attribute declarations must always come last:\nHere is the complete listing of the schema file called \"shiporder.xsd\":\nDivide the Schema\nThe previous design method is very simple, but can be difficult to read and maintain when documents are complex.\nThe next design method is based on defining all elements and attributes first, and then referring to them using the ref attribute.\nHere is the new design of the schema file (\"shiporder.xsd\"):\nUsing Named Types\nThe third design method defines classes or types, that enables us to reuse element definitions. This is done by naming the simpleTypes and complexTypes elements, and then point to them through the type attribute of the element.\nHere is the third design of the schema file (\"shiporder.xsd\"):\nThe restriction element indicates that the datatype is derived from a W3C XML Schema namespace datatype. So, the following fragment means that the value of the element or attribute must be a string value:\nThe restriction element is more often used to apply restrictions to elements. Look at the following lines from the schema above:\nThis indicates that the value of the element or attribute must be a string, it must be exactly six characters in a row, and those characters must be a number from 0 to 9.",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<shiporder orderid=\"889923\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:noNamespaceSchemaLocation=\"shiporder.xsd\">\n<orderperson>John Smith</orderperson>\n<shipto>\n<name>Ola Nordmann</name>\n<address>Langgt 23</address>\n<city>4000 Stavanger</city>\n<country>Norway</country>\n</shipto>\n<item>\n<title>Empire Burlesque</title>\n<note>Special Edition</note>\n<quantity>1</quantity>\n<price>10.90</price>\n</item>\n<item>\n<title>Hide your heart</title>\n<quantity>1</quantity>\n<price>9.90</price>\n</item>\n</shiporder>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n...\n</xs:schema>",
        "<xs:element name=\"shiporder\">\n<xs:complexType>\n<xs:sequence>\n...\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"orderperson\" type=\"xs:string\"/>",
        "<xs:element name=\"shipto\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"name\" type=\"xs:string\"/>\n<xs:element name=\"address\" type=\"xs:string\"/>\n<xs:element name=\"city\" type=\"xs:string\"/>\n<xs:element name=\"country\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:element name=\"item\" maxOccurs=\"unbounded\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"title\" type=\"xs:string\"/>\n<xs:element name=\"note\" type=\"xs:string\" minOccurs=\"0\"/>\n<xs:element name=\"quantity\" type=\"xs:positiveInteger\"/>\n<xs:element name=\"price\" type=\"xs:decimal\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>",
        "<xs:attribute name=\"orderid\" type=\"xs:string\" use=\"required\"/>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n\n<xs:element name=\"shiporder\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"orderperson\" type=\"xs:string\"/>\n<xs:element name=\"shipto\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"name\" type=\"xs:string\"/>\n<xs:element name=\"address\" type=\"xs:string\"/>\n<xs:element name=\"city\" type=\"xs:string\"/>\n<xs:element name=\"country\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n<xs:element name=\"item\" maxOccurs=\"unbounded\">\n<xs:complexType>\n<xs:sequence>\n<xs:element name=\"title\" type=\"xs:string\"/>\n<xs:element name=\"note\" type=\"xs:string\" minOccurs=\"0\"/>\n<xs:element name=\"quantity\" type=\"xs:positiveInteger\"/>\n<xs:element name=\"price\" type=\"xs:decimal\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n</xs:sequence>\n<xs:attribute name=\"orderid\" type=\"xs:string\" use=\"required\"/>\n</xs:complexType>\n</xs:element>\n\n</xs:schema>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n\n<!-- definition of simple elements -->\n<xs:element name=\"orderperson\" type=\"xs:string\"/>\n<xs:element name=\"name\" type=\"xs:string\"/>\n<xs:element name=\"address\" type=\"xs:string\"/>\n<xs:element name=\"city\" type=\"xs:string\"/>\n<xs:element name=\"country\" type=\"xs:string\"/>\n<xs:element name=\"title\" type=\"xs:string\"/>\n<xs:element name=\"note\" type=\"xs:string\"/>\n<xs:element name=\"quantity\" type=\"xs:positiveInteger\"/>\n<xs:element name=\"price\" type=\"xs:decimal\"/>\n\n<!-- definition of attributes -->\n<xs:attribute name=\"orderid\" type=\"xs:string\"/>\n\n<!-- definition of complex elements -->\n<xs:element name=\"shipto\">\n<xs:complexType>\n<xs:sequence>\n<xs:element ref=\"name\"/>\n<xs:element ref=\"address\"/>\n<xs:element ref=\"city\"/>\n<xs:element ref=\"country\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n\n<xs:element name=\"item\">\n<xs:complexType>\n<xs:sequence>\n<xs:element ref=\"title\"/>\n<xs:element ref=\"note\" minOccurs=\"0\"/>\n<xs:element ref=\"quantity\"/>\n<xs:element ref=\"price\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\n\n<xs:element name=\"shiporder\">\n<xs:complexType>\n<xs:sequence>\n<xs:element ref=\"orderperson\"/>\n<xs:element ref=\"shipto\"/>\n<xs:element ref=\"item\" maxOccurs=\"unbounded\"/>\n</xs:sequence>\n<xs:attribute ref=\"orderid\" use=\"required\"/>\n</xs:complexType>\n</xs:element>\n\n</xs:schema>",
        "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n\n<xs:simpleType name=\"stringtype\">\n<xs:restriction base=\"xs:string\"/>\n</xs:simpleType>\n\n<xs:simpleType name=\"inttype\">\n<xs:restriction base=\"xs:positiveInteger\"/>\n</xs:simpleType>\n\n<xs:simpleType name=\"dectype\">\n<xs:restriction base=\"xs:decimal\"/>\n</xs:simpleType>\n\n<xs:simpleType name=\"orderidtype\">\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"[0-9]{6}\"/>\n</xs:restriction>\n</xs:simpleType>\n\n<xs:complexType name=\"shiptotype\">\n<xs:sequence>\n<xs:element name=\"name\" type=\"stringtype\"/>\n<xs:element name=\"address\" type=\"stringtype\"/>\n<xs:element name=\"city\" type=\"stringtype\"/>\n<xs:element name=\"country\" type=\"stringtype\"/>\n</xs:sequence>\n</xs:complexType>\n\n<xs:complexType name=\"itemtype\">\n<xs:sequence>\n<xs:element name=\"title\" type=\"stringtype\"/>\n<xs:element name=\"note\" type=\"stringtype\" minOccurs=\"0\"/>\n<xs:element name=\"quantity\" type=\"inttype\"/>\n<xs:element name=\"price\" type=\"dectype\"/>\n</xs:sequence>\n</xs:complexType>\n\n<xs:complexType name=\"shipordertype\">\n<xs:sequence>\n<xs:element name=\"orderperson\" type=\"stringtype\"/>\n<xs:element name=\"shipto\" type=\"shiptotype\"/>\n<xs:element name=\"item\" maxOccurs=\"unbounded\" type=\"itemtype\"/>\n</xs:sequence>\n<xs:attribute name=\"orderid\" type=\"orderidtype\" use=\"required\"/>\n</xs:complexType>\n\n<xs:element name=\"shiporder\" type=\"shipordertype\"/>\n\n</xs:schema>",
        "<xs:restriction base=\"xs:string\">",
        "<xs:simpleType name=\"orderidtype\">\n<xs:restriction base=\"xs:string\">\n<xs:pattern value=\"[0-9]{6}\"/>\n</xs:restriction>\n</xs:simpleType>"
      ]
    },
    {
      "title": "XSD String Data Types",
      "summary": "String data types are used for values that contains character strings.\nString Data Type\nThe string data type can contain characters, line feeds, carriage returns, and tab characters.\nThe following is an example of a string declaration in a schema:\nAn element in your document might look like this:\nOr it might look like this:\nNote: The XML processor will not modify the value if you use the string data type.\nNormalizedString Data Type\nThe normalizedString data type is derived from the String data type.\nThe normalizedString data type also contains characters, but the XML processor will remove line feeds, carriage returns, and tab characters.\nThe following is an example of a normalizedString declaration in a schema:\nAn element in your document might look like this:\nOr it might look like this:\nNote: In the example above the XML processor will replace the tabs with spaces.\nREMOVE ADS\nToken Data Type\nThe token data type is also derived from the String data type.\nThe token data type also contains characters, but the XML processor will remove line feeds, carriage returns, tabs, leading and trailing spaces, and multiple spaces.\nThe following is an example of a token declaration in a schema:\nAn element in your document might look like this:\nOr it might look like this:\nNote: In the example above the XML processor will remove the tabs.\nString Data Types\nNote that all of the data types below derive from the String data type (except for string itself)!\nRestrictions on String Data Types\nRestrictions that can be used with String data types:\nenumeration\nlength\nmaxLength\nminLength\npattern (NMTOKENS, IDREFS, and ENTITIES cannot use this constraint)\nwhiteSpace",
      "examples": [
        "<xs:element name=\"customer\" type=\"xs:string\"/>",
        "<customer>John Smith</customer>",
        "<customer>       John Smith     </customer>",
        "<xs:element name=\"customer\" type=\"xs:normalizedString\"/>",
        "<customer>     John Smith     </customer>",
        "<xs:element name=\"customer\" type=\"xs:token\"/>"
      ]
    },
    {
      "title": "XSD Date and Time Data Types",
      "summary": "Date and time data types are used for values that contain date and time.\nDate Data Type\nThe date data type is used to specify a date.\nThe date is specified in the following form \"YYYY-MM-DD\" where:\nYYYY indicates the year\nMM indicates the month\nDD indicates the day\nNote: All components are required!\nThe following is an example of a date declaration in a schema:\nAn element in your document might look like this:\nTime Zones\nTo specify a time zone, you can either enter a date in UTC time by adding a \"Z\" behind the date - like this:\nor you can specify an offset from the UTC time by adding a positive or negative time behind the date - like this:\nREMOVE ADS\nTime Data Type\nThe time data type is used to specify a time.\nThe time is specified in the following form \"hh:mm:ss\" where:\nhh indicates the hour\nmm indicates the minute\nss indicates the second\nNote: All components are required!\nThe following is an example of a time declaration in a schema:\nAn element in your document might look like this:\nOr it might look like this:\nTime Zones\nTo specify a time zone, you can either enter a time in UTC time by adding a \"Z\" behind the time - like this:\nor you can specify an offset from the UTC time by adding a positive or negative time behind the time - like this:\nDateTime Data Type\nThe dateTime data type is used to specify a date and a time.\nThe dateTime is specified in the following form \"YYYY-MM-DDThh:mm:ss\" where:\nYYYY indicates the year\nMM indicates the month\nDD indicates the day\nT indicates the start of the required time section\nhh indicates the hour\nmm indicates the minute\nss indicates the second\nNote: All components are required!\nThe following is an example of a dateTime declaration in a schema:\nAn element in your document might look like this:\nOr it might look like this:\nTime Zones\nTo specify a time zone, you can either enter a dateTime in UTC time by adding a \"Z\" behind the time - like this:\nor you can specify an offset from the UTC time by adding a positive or negative time behind the time - like this:\nDuration Data Type\nThe duration data type is used to specify a time interval.\nThe time interval is specified in the following form \"PnYnMnDTnHnMnS\" where:\nP indicates the period (required)\nnY indicates the number of years\nnM indicates the number of months\nnD indicates the number of days\nT indicates the start of a time section (required if you are going to specify hours, minutes, or seconds)\nnH indicates the number of hours\nnM indicates the number of minutes\nnS indicates the number of seconds\nThe following is an example of a duration declaration in a schema:\nAn element in your document might look like this:\nThe example above indicates a period of five years.\nOr it might look like this:\nThe example above indicates a period of five years, two months, and 10 days.\nOr it might look like this:\nThe example above indicates a period of five years, two months, 10 days, and 15 hours.\nOr it might look like this:\nThe example above indicates a period of 15 hours.\nNegative Duration\nTo specify a negative duration, enter a minus sign before the P:\nThe example above indicates a period of minus 10 days.\nDate and Time Data Types\nRestrictions on Date Data Types\nRestrictions that can be used with Date data types:\nenumeration\nmaxExclusive\nmaxInclusive\nminExclusive\nminInclusive\npattern\nwhiteSpace",
      "examples": [
        "<xs:element name=\"start\" type=\"xs:date\"/>",
        "<start>2002-09-24</start>",
        "<start>2002-09-24Z</start>",
        "<start>2002-09-24-06:00</start>\n\nor\n\n<start>2002-09-24+06:00</start>",
        "<xs:element name=\"start\" type=\"xs:time\"/>",
        "<start>09:00:00</start>",
        "<start>09:30:10.5</start>",
        "<start>09:30:10Z</start>",
        "<start>09:30:10-06:00</start>\n\nor\n\n<start>09:30:10+06:00</start>",
        "<xs:element name=\"startdate\" type=\"xs:dateTime\"/>",
        "<startdate>2002-05-30T09:00:00</startdate>",
        "<startdate>2002-05-30T09:30:10.5</startdate>",
        "<startdate>2002-05-30T09:30:10Z</startdate>",
        "<startdate>2002-05-30T09:30:10-06:00</startdate>\n\nor\n\n<startdate>2002-05-30T09:30:10+06:00</startdate>",
        "<xs:element name=\"period\" type=\"xs:duration\"/>",
        "<period>P5Y</period>",
        "<period>P5Y2M10D</period>",
        "<period>P5Y2M10DT15H</period>",
        "<period>PT15H</period>",
        "<period>-P10D</period>"
      ]
    },
    {
      "title": "XSD Numeric Data Types",
      "summary": "Decimal data types are used for numeric values.\nDecimal Data Type\nThe decimal data type is used to specify a numeric value.\nThe following is an example of a decimal declaration in a schema:\nAn element in your document might look like this:\nOr it might look like this:\nOr it might look like this:\nOr it might look like this:\nOr it might look like this:\nREMOVE ADS\nInteger Data Type\nThe integer data type is used to specify a numeric value without a fractional component.\nThe following is an example of an integer declaration in a schema:\nAn element in your document might look like this:\nOr it might look like this:\nOr it might look like this:\nOr it might look like this:\nNumeric Data Types\nNote that all of the data types below derive from the Decimal data type (except for decimal itself)!\nRestrictions on Numeric Data Types\nRestrictions that can be used with Numeric data types:\nenumeration\nfractionDigits\nmaxExclusive\nmaxInclusive\nminExclusive\nminInclusive\npattern\ntotalDigits\nwhiteSpace",
      "examples": [
        "<xs:element name=\"price\" type=\"xs:decimal\"/>",
        "<price>999.50</price>",
        "<price>+999.5450</price>",
        "<price>-999.5230</price>",
        "<price>0</price>",
        "<price>14</price>",
        "<xs:element name=\"price\" type=\"xs:integer\"/>",
        "<price>999</price>",
        "<price>+999</price>",
        "<price>-999</price>"
      ]
    },
    {
      "title": "XSD Miscellaneous Data Types",
      "summary": "Other miscellaneous data types are boolean, base64Binary, hexBinary, float, double, anyURI, QName, and NOTATION.\nBoolean Data Type\nThe boolean data type is used to specify a true or false value.\nThe following is an example of a boolean declaration in a schema:\nAn element in your document might look like this:\nNote: Legal values for boolean are true, false, 1 (which indicates true), and 0 (which indicates false).\nBinary Data Types\nBinary data types are used to express binary-formatted data.\nWe have two binary data types:\nbase64Binary (Base64-encoded binary data)\nhexBinary (hexadecimal-encoded binary data)\nThe following is an example of a hexBinary declaration in a schema:\nAnyURI Data Type\nThe anyURI data type is used to specify a URI.\nThe following is an example of an anyURI declaration in a schema:\nAn element in your document might look like this:\nNote: If a URI has spaces, replace them with %20.\nREMOVE ADS\nMiscellaneous Data Types\nRestrictions on Miscellaneous Data Types\nRestrictions that can be used with the other data types:\nenumeration (a Boolean data type cannot use this constraint)\nlength (a Boolean data type cannot use this constraint)\nmaxLength (a Boolean data type cannot use this constraint)\nminLength (a Boolean data type cannot use this constraint)\npattern\nwhiteSpace",
      "examples": [
        "<xs:attribute name=\"disabled\" type=\"xs:boolean\"/>",
        "<price disabled=\"true\">999</price>",
        "<xs:element name=\"blobsrc\" type=\"xs:hexBinary\"/>",
        "<xs:attribute name=\"src\" type=\"xs:anyURI\"/>",
        "<pic src=\"https://www.w3schools.com/images/smiley.gif\" />"
      ]
    },
    {
      "title": "XML Schema Reference XSD Elements XSD Restrictions/Facets for Datatypes",
      "summary": "Enables the author to extend the XML document with attributes not specified by the schema\nREMOVE ADS\nLook at XSD Restrictions!",
      "examples": []
    },
    {
      "title": "XML Web Services",
      "summary": "Web services are web application components.\nWeb services can be published, found, and used on the Web.\nThis tutorial introduces WSDL, SOAP, RDF, and RSS.\nWSDL\nWSDL stands for Web Services Description Language\nWSDL is an XML-based language for describing Web services.\nWSDL is a W3C recommendation\nSOAP\nSOAP stands for Simple Object Access Protocol\nSOAP is an XML based protocol for accessing Web Services.\nSOAP is based on XML\nSOAP is a W3C recommendation\nRDF\nRDF stands for Resource Description Framework\nRDF is a framework for describing resources on the web\nRDF is written in XML\nRDF is a W3C Recommendation\nRSS\nRSS stands for Really Simple Syndication\nRSS allows you to syndicate your site content\nRSS defines an easy way to share and view headlines and content\nRSS files can be automatically updated\nRSS allows personalized views for different sites\nRSS is written in XML\nWhat You Should Already Know\nBefore you study web services you should have a basic understanding of XML and XML Namespaces.\nIf you want to study these subjects first, please read our XML Tutorial.\nREMOVE ADS\nWeb Services\nWeb services are application components\nWeb services communicate using open protocols\nWeb services are self-contained and self-describing\nWeb services can be discovered using UDDI\nWeb services can be used by other applications\nHTTP and XML is the basis for Web services\nInteroperability has Highest Priority\nWhen all major platforms could access the Web using Web browsers, different platforms couldn't interact. For these platforms to work together, Web-applications were developed.\nWeb-applications are simply applications that run on the web. These are built around the Web browser standards and can be used by any browser on any platform.\nWeb Services take Web-applications to the Next Level\nBy using Web services, your application can publish its function or message to the rest of the world.\nWeb services use XML to code and to decode data, and SOAP to transport it (using open protocols).\nWith Web services, your accounting department's Win 2k server's billing system can connect with your IT supplier's UNIX server.\nWeb Services have Two Types of Uses\nReusable application-components.\nThere are things applications need very often. So why make these over and over again?\nWeb services can offer application-components like: currency conversion, weather reports, or even language translation as services.\nConnect existing software.\nWeb services can help to solve the interoperability problem by giving different applications a way to link their data.\nWith Web services you can exchange data between different applications and different platforms.\nAny application can have a Web Service component.\nWeb Services can be created regardless of programming language.\nA Web Service Example\nIn the following example we will use ASP.NET to create a simple Web Service that converts the temperature from Fahrenheit to Celsius, and vice versa:\nThis document is saved as an .asmx file. This is the ASP.NET file extension for XML Web Services.\nExample Explained\nNote: To run this example, you will need a .NET server.\nThe first line in the example states that this is a Web Service, written in VBScript, and has the class name \"TempConvert\":\nThe next lines import the namespace \"System.Web.Services\" from the .NET framework:\nThe next line defines that the \"TempConvert\" class is a WebService class type:\nThe next steps are basic VB programming. This application has two functions. One to convert from Fahrenheit to Celsius, and one to convert from Celsius to Fahrenheit.\nThe only difference from a normal application is that this function is defined as a \"WebMethod()\".\nUse \"WebMethod()\" to convert the functions in your application into web services:\nThen, end the class:\nPublish the .asmx file on a server with .NET support, and you will have your first working Web Service.\nPut the Web Service on Your Web Site\nUsing a form and the HTTP POST method, you can put the web service on your site, like this:\nHow To Do It\nHere is the code to add the Web Service to a web page:\nSubstitute the \"tempconvert.asmx\" with the address of your web service like:\nhttp://www.example.com/xml/tempconvert.asmx",
      "examples": [
        "<%@ WebService Language=\"VBScript\" Class=\"TempConvert\" %>\n\nImports System\nImports System.Web.Services\n\nPublic Class TempConvert :Inherits WebService\n\n<WebMethod()> Public Function FahrenheitToCelsius(ByVal Fahrenheit As String) As String\ndim fahr\nfahr=trim(replace(Fahrenheit,\",\",\".\"))\nif fahr=\"\" or IsNumeric(fahr)=false then return \"Error\"\nreturn ((((fahr) - 32) / 9) * 5)\nend function\n\n<WebMethod()> Public Function CelsiusToFahrenheit(ByVal Celsius As String) As String\ndim cel\ncel=trim(replace(Celsius,\",\",\".\"))\nif cel=\"\" or IsNumeric(cel)=false then return \"Error\"\nreturn ((((cel) * 9) / 5) + 32)\nend function\n\nend class",
        "<%@ WebService Language=\"VBScript\" Class=\"TempConvert\" %>",
        "Imports System\nImports System.Web.Services",
        "Public Class TempConvert :Inherits WebService",
        "<WebMethod()> Public Function FahrenheitToCelsius(ByVal Fahrenheit As String) As String\ndim fahr\nfahr=trim(replace(Fahrenheit,\",\",\".\"))\nif fahr=\"\" or IsNumeric(fahr)=false then return \"Error\"\nreturn ((((fahr) - 32) / 9) * 5)\nend function\n\n<WebMethod()> Public Function CelsiusToFahrenheit(ByVal Celsius As String) As String\ndim cel\ncel=trim(replace(Celsius,\",\",\".\"))\nif cel=\"\" or IsNumeric(cel)=false then return \"Error\"\nreturn ((((cel) * 9) / 5) + 32)\nend function",
        "end class",
        "<form action='tempconvert.asmx/FahrenheitToCelsius'\nmethod=\"post\" target=\"_blank\">\n<table>\n<tr>\n<td>Fahrenheit to Celsius:</td>\n<td>\n<input class=\"frmInput\" type=\"text\" size=\"30\" name=\"Fahrenheit\">\n</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"right\">\n<input type=\"submit\" value=\"Submit\" class=\"button\">\n</td>\n</tr>\n</table>\n</form>\n\n<form action='tempconvert.asmx/CelsiusToFahrenheit'\nmethod=\"post\" target=\"_blank\">\n<table>\n<tr>\n<td>Celsius to Fahrenheit:</td>\n<td>\n<input class=\"frmInput\" type=\"text\" size=\"30\" name=\"Celsius\">\n</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"right\">\n<input type=\"submit\" value=\"Submit\" class=\"button\">\n</td>\n</tr>\n</table>\n</form>"
      ]
    },
    {
      "title": "XML WSDL",
      "summary": "WSDL stands for Web Services Description Language\nWSDL is used to describe web services\nWSDL is written in XML\nWSDL is a W3C recommendation from 26. June 2007\nWSDL Documents\nAn WSDL document describes a web service. It specifies the location of the service, and the methods of the service, using these major elements:\nThe main structure of a WSDL document looks like this:\nREMOVE ADS\nWSDL Example\nThis is a simplified fraction of a WSDL document:\nIn this example the <portType> element defines \"glossaryTerms\" as the name of a port, and \"getTerm\" as the name of an operation.\nThe \"getTerm\" operation has an input message called \"getTermRequest\" and an output message called \"getTermResponse\".\nThe <message> elements define the parts of each message and the associated data types.\nThe <portType> Element\nThe <portType> element defines a web service, the operations that can be performed, and the messages that are involved.\nThe request-response type is the most common operation type, but WSDL defines four types:\nWSDL One-Way Operation\nA one-way operation example:\nIn the example above, the portType \"glossaryTerms\" defines a one-way operation called \"setTerm\".\nThe \"setTerm\" operation allows input of new glossary terms messages using a \"newTermValues\" message with the input parameters \"term\" and \"value\". However, no output is defined for the operation.\nWSDL Request-Response Operation\nA request-response operation example:\nIn the example above, the portType \"glossaryTerms\" defines a request-response operation called \"getTerm\".\nThe \"getTerm\" operation requires an input message called \"getTermRequest\" with a parameter called \"term\", and will return an output message called \"getTermResponse\" with a parameter called \"value\".\nWSDL Binding to SOAP\nWSDL bindings defines the message format and protocol details for a web service.\nA request-response operation example:\nThe binding element has two attributes - name and type.\nThe name attribute (you can use any name you want) defines the name of the binding, and the type attribute points to the port for the binding, in this case the \"glossaryTerms\" port.\nThe soap:binding element has two attributes - style and transport.\nThe style attribute can be \"rpc\" or \"document\". In this case we use document. The transport attribute defines the SOAP protocol to use. In this case we use HTTP.\nThe operation element defines each operation that the portType exposes.\nFor each operation the corresponding SOAP action has to be defined. You must also specify how the input and output are encoded. In this case we use \"literal\".",
      "examples": [
        "<definitions>\n\n<types>\ndata type definitions........\n</types>\n\n<message>\ndefinition of the data being communicated....\n</message>\n\n<portType>\nset of operations......\n</portType>\n\n<binding>\nprotocol and data format specification....\n</binding>\n\n</definitions>",
        "<message name=\"getTermRequest\">\n<part name=\"term\" type=\"xs:string\"/>\n</message>\n\n<message name=\"getTermResponse\">\n<part name=\"value\" type=\"xs:string\"/>\n</message>\n\n<portType name=\"glossaryTerms\">\n<operation name=\"getTerm\">\n<input message=\"getTermRequest\"/>\n<output message=\"getTermResponse\"/>\n</operation>\n</portType>",
        "<message name=\"newTermValues\">\n<part name=\"term\" type=\"xs:string\"/>\n<part name=\"value\" type=\"xs:string\"/>\n</message>\n\n<portType name=\"glossaryTerms\">\n<operation name=\"setTerm\">\n<input name=\"newTerm\" message=\"newTermValues\"/>\n</operation>\n</portType >",
        "<message name=\"getTermRequest\">\n<part name=\"term\" type=\"xs:string\"/>\n</message>\n\n<message name=\"getTermResponse\">\n<part name=\"value\" type=\"xs:string\"/>\n</message>\n\n<portType name=\"glossaryTerms\">\n<operation name=\"getTerm\">\n<input message=\"getTermRequest\"/>\n<output message=\"getTermResponse\"/>\n</operation>\n</portType>\n\n<binding type=\"glossaryTerms\" name=\"b1\">\n<soap:binding style=\"document\"\ntransport=\"http://schemas.xmlsoap.org/soap/http\" />\n<operation>\n<soap:operation soapAction=\"http://example.com/getTerm\"/>\n<input><soap:body use=\"literal\"/></input>\n<output><soap:body use=\"literal\"/></output>\n</operation>\n</binding>"
      ]
    },
    {
      "title": "XML Soap",
      "summary": "SOAP stands for Simple Object Access Protocol\nSOAP is an application communication protocol\nSOAP is a format for sending and receiving messages\nSOAP is platform independent\nSOAP is based on XML\nSOAP is a W3C recommendation\nWhy SOAP?\nIt is important for web applications to be able to communicate over the Internet.\nThe best way to communicate between applications is over HTTP, because HTTP is supported by all Internet browsers and servers. SOAP was created to accomplish this.\nSOAP provides a way to communicate between applications running on different operating systems, with different technologies and programming languages.\nSOAP Building Blocks\nA SOAP message is an ordinary XML document containing the following elements:\nAn Envelope element that identifies the XML document as a SOAP message\nA Header element that contains header information\nA Body element that contains call and response information\nA Fault element containing errors and status information\nAll the elements above are declared in the default namespace for the SOAP envelope:\nhttp://www.w3.org/2003/05/soap-envelope\nand the default namespace for SOAP encoding and data types is:\nhttp://www.w3.org/2003/05/soap-encoding\nSyntax Rules\nHere are some important syntax rules:\nA SOAP message MUST be encoded using XML\nA SOAP message MUST use the SOAP Envelope namespace\nA SOAP message must NOT contain a DTD reference\nA SOAP message must NOT contain XML Processing Instructions\nREMOVE ADS\nSkeleton SOAP Message\nThe SOAP Envelope Element\nThe required SOAP Envelope element is the root element of a SOAP message. This element defines the XML document as a SOAP message.\nExample\nThe xmlns:soap Namespace\nNotice the xmlns:soap namespace in the example above. It should always have the value of: \"http://www.w3.org/2003/05/soap-envelope\".\nThe namespace defines the Envelope as a SOAP Envelope.\nIf a different namespace is used, the application generates an error and discards the message.\nThe encodingStyle Attribute\nThe encodingStyle attribute is used to define the data types used in the document. This attribute may appear on any SOAP element, and applies to the element's contents and all child elements.\nA SOAP message has no default encoding.\nThe SOAP Header Element\nThe optional SOAP Header element contains application-specific information (like authentication, payment, etc) about the SOAP message.\nIf the Header element is present, it must be the first child element of the Envelope element.\nNote: All immediate child elements of the Header element must be namespace-qualified.\nThe example above contains a header with a \"Trans\" element, a \"mustUnderstand\" attribute with a value of 1, and a value of 234.\nSOAP defines three attributes in the default namespace. These attributes are: mustUnderstand, actor, and encodingStyle.\nThe attributes defined in the SOAP Header defines how a recipient should process the SOAP message.\nThe mustUnderstand Attribute\nThe SOAP mustUnderstand attribute can be used to indicate whether a header entry is mandatory or optional for the recipient to process.\nIf you add mustUnderstand=\"1\" to a child element of the Header element it indicates that the receiver processing the Header must recognize the element. If the receiver does not recognize the element it will fail when processing the Header.\nSyntax\nExample\nThe actor Attribute\nA SOAP message may travel from a sender to a receiver by passing different endpoints along the message path. However, not all parts of a SOAP message may be intended for the ultimate endpoint, instead, it may be intended for one or more of the endpoints on the message path.\nThe SOAP actor attribute is used to address the Header element to a specific endpoint.\nSyntax\nExample\nThe encodingStyle Attribute\nThe encodingStyle attribute is used to define the data types used in the document. This attribute may appear on any SOAP element, and it will apply to that element's contents and all child elements.\nA SOAP message has no default encoding.\nSyntax\nThe SOAP Body Element\nThe required SOAP Body element contains the actual SOAP message intended for the ultimate endpoint of the message.\nImmediate child elements of the SOAP Body element may be namespace-qualified.\nExample\nThe example above requests the price of apples. Note that the m:GetPrice and the Item elements above are application-specific elements. They are not a part of the SOAP namespace.\nA SOAP response could look something like this:\nThe SOAP Fault Element\nThe optional SOAP Fault element is used to indicate error messages.\nThe SOAP Fault element holds errors and status information for a SOAP message.\nIf a Fault element is present, it must appear as a child element of the Body element. A Fault element can only appear once in a SOAP message.\nThe SOAP Fault element has the following sub elements:\nHolds application specific error information related to the Body element\nSOAP Fault Codes\nThe faultcode values defined below must be used in the faultcode element when describing faults:\nThe HTTP Protocol\nHTTP communicates over TCP/IP. An HTTP client connects to an HTTP server using TCP. After establishing a connection, the client can send an HTTP request message to the server:\nThe server then processes the request and sends an HTTP response back to the client. The response contains a status code that indicates the status of the request:\nIn the example above, the server returned a status code of 200. This is the standard success code for HTTP.\nIf the server could not decode the request, it could have returned something like this:\nSOAP Binding\nThe SOAP specification defines the structure of the SOAP messages, not how they are exchanged. This gap is filled by what is called \"SOAP Bindings\". SOAP bindings are mechanisms which allow SOAP messages to be effectively exchanged using a transport protocol.\nMost SOAP implementations provide bindings for common transport protocols, such as HTTP or SMTP.\nHTTP is synchronous and widely used. A SOAP HTTP request specifies at least two HTTP headers: Content-Type and Content-Length.\nSMTP is asynchronous and is used in last resort or particular cases.\nJava implementations of SOAP usually provide a specific binding for the JMS (Java Messaging System) protocol.\nContent-Type\nThe Content-Type header for a SOAP request and response defines the MIME type for the message and the character encoding (optional) used for the XML body of the request or response.\nContent-Length\nThe Content-Length header for a SOAP request and response specifies the number of bytes in the body of the request or response.\nA SOAP Example\nIn the example below, a GetStockPrice request is sent to a server. The request has a StockName parameter, and a Price parameter that will be returned in the response. The namespace for the function is defined in \"http://www.example.org/stock\".\nA SOAP request:\nThe SOAP response:",
      "examples": [
        "<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n\n<soap:Header>\n...\n</soap:Header>\n\n<soap:Body>\n...\n<soap:Fault>\n...\n</soap:Fault>\n</soap:Body>\n\n</soap:Envelope>",
        "<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n...\nMessage information goes here\n...\n</soap:Envelope>",
        "soap:encodingStyle=\"URI\"",
        "<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n\n<soap:Header>\n<m:Trans xmlns:m=\"https://www.w3schools.com/transaction/\"\nsoap:mustUnderstand=\"1\">234\n</m:Trans>\n</soap:Header>\n...\n...\n</soap:Envelope>",
        "soap:mustUnderstand=\"0|1\"",
        "soap:actor=\"URI\"",
        "<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n\n<soap:Header>\n<m:Trans xmlns:m=\"https://www.w3schools.com/transaction/\"\nsoap:actor=\"https://www.w3schools.com/code/\">234\n</m:Trans>\n</soap:Header>\n...\n...\n</soap:Envelope>",
        "<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n\n<soap:Body>\n<m:GetPrice xmlns:m=\"https://www.w3schools.com/prices\">\n<m:Item>Apples</m:Item>\n</m:GetPrice>\n</soap:Body>\n\n</soap:Envelope>",
        "<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n\n<soap:Body>\n<m:GetPriceResponse xmlns:m=\"https://www.w3schools.com/prices\">\n<m:Price>1.90</m:Price>\n</m:GetPriceResponse>\n</soap:Body>\n\n</soap:Envelope>",
        "POST /item HTTP/1.1\nHost: 189.123.255.239\nContent-Type: text/plain\nContent-Length: 200",
        "200 OK\nContent-Type: text/plain\nContent-Length: 200",
        "400 Bad Request\nContent-Length: 0",
        "Content-Type: MIMEType; charset=character-encoding",
        "POST /item HTTP/1.1\nContent-Type: application/soap+xml; charset=utf-8",
        "Content-Length: bytes",
        "POST /item HTTP/1.1\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: 250",
        "POST /InStock HTTP/1.1\nHost: www.example.org\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n\n<soap:Body xmlns:m=\"http://www.example.org/stock\">\n<m:GetStockPrice>\n<m:StockName>IBM</m:StockName>\n</m:GetStockPrice>\n</soap:Body>\n\n</soap:Envelope>",
        "HTTP/1.1 200 OK\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n<?xml version=\"1.0\"?>\n\n<soap:Envelope\nxmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"\nsoap:encodingStyle=\"http://www.w3.org/2003/05/soap-encoding\">\n\n<soap:Body xmlns:m=\"http://www.example.org/stock\">\n<m:GetStockPriceResponse>\n<m:Price>34.5</m:Price>\n</m:GetStockPriceResponse>\n</soap:Body>\n\n</soap:Envelope>"
      ]
    },
    {
      "title": "XML RDF",
      "summary": "RDF Document Example\nWhat is RDF?\nRDF stands for Resource Description Framework\nRDF is a framework for describing resources on the web\nRDF is designed to be read and understood by computers\nRDF is not designed for being displayed to people\nRDF is written in XML\nRDF is a part of the W3C's Semantic Web Activity\nRDF is a W3C Recommendation from 10. February 2004\nRDF - Examples of Use\nDescribing properties for shopping items, such as price and availability\nDescribing time schedules for web events\nDescribing information about web pages (content, author, created and modified date)\nDescribing content and rating for web pictures\nDescribing content for search engines\nDescribing electronic libraries\nRDF is Designed to be Read by Computers\nRDF was designed to provide a common way to describe information so it can be read and understood by computer applications.\nRDF descriptions are not designed to be displayed on the web.\nREMOVE ADS\nRDF is Written in XML\nRDF documents are written in XML. The XML language used by RDF is called RDF/XML.\nBy using XML, RDF information can easily be exchanged between different types of computers using different types of operating systems and application languages.\nRDF and \"The Semantic Web\"\nThe RDF language is a part of the W3C's Semantic Web Activity. W3C's \"Semantic Web Vision\" is a future where:\nWeb information has exact meaning\nWeb information can be understood and processed by computers\nComputers can integrate information from the web\nRDF uses Web identifiers (URIs) to identify resources.\nRDF describes resources with properties and property values.\nRDF Resource, Property, and Property Value\nRDF identifies things using Web identifiers (URIs), and describes resources with properties and property values.\nExplanation of Resource, Property, and Property value:\nA Resource is anything that can have a URI, such as \"https://www.w3schools.com/rdf\"\nA Property is a Resource that has a name, such as \"author\" or \"homepage\"\nA Property value is the value of a Property, such as \"Jan Egil Refsnes\" or \"https://www.w3schools.com\" (note that a property value can be another resource)\nThe following RDF document could describe the resource \"https://www.w3schools.com/rdf\":\nThe example above is simplified. Namespaces are omitted.\nRDF Statements\nThe combination of a Resource, a Property, and a Property value forms a Statement (known as the subject, predicate and object of a Statement).\nLet's look at some example statements to get a better understanding:\nStatement: \"The author of https://www.w3schools.com/rdf is Jan Egil Refsnes\".\nThe subject of the statement above is: https://www.w3schools.com/rdf\nThe predicate is: author\nThe object is: Jan Egil Refsnes\nStatement: \"The homepage of https://www.w3schools.com/rdf is https://www.w3schools.com\".\nThe subject of the statement above is: https://www.w3schools.com/rdf\nThe predicate is: homepage\nThe object is: https://www.w3schools.com\nRDF Example\nHere are two records from a CD-list:\nBelow is a few lines from an RDF document:\nThe first line of the RDF document is the XML declaration. The XML declaration is followed by the root element of RDF documents: <rdf:RDF>.\nThe xmlns:rdf namespace, specifies that elements with the rdf prefix are from the namespace \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\".\nThe xmlns:cd namespace, specifies that elements with the cd prefix are from the namespace \"http://www.recshop.fake/cd#\".\nThe <rdf:Description> element contains the description of the resource identified by the rdf:about attribute.\nThe elements: <cd:artist>, <cd:country>, <cd:company>, etc. are properties of the resource.\nRDF Online Validator\nW3C's RDF Validation Service is useful when learning RDF. Here you can experiment with RDF files.\nThe online RDF Validator parses your RDF document, checks your syntax, and generates tabular and graphical views of your RDF document.\nCopy and paste the example below into W3C's RDF validator:\nWhen you parse the example above, the result will look something like this.\nRDF Elements\nThe main elements of RDF are the root element, <RDF>, and the <Description> element, which identifies a resource.\nThe <rdf:RDF> Element\n<rdf:RDF> is the root element of an RDF document. It defines the XML document to be an RDF document. It also contains a reference to the RDF namespace:\nThe <rdf:Description> Element\nThe <rdf:Description> element identifies a resource with the about attribute.\nThe <rdf:Description> element contains elements that describe the resource:\nThe elements, artist, country, company, price, and year, are defined in the http://www.recshop.fake/cd# namespace. This namespace is outside RDF (and not a part of RDF). RDF defines only the framework. The elements, artist, country, company, price, and year, must be defined by someone else (company, organization, person, etc).\nProperties as Attributes\nThe property elements can also be defined as attributes (instead of elements):\nProperties as Resources\nThe property elements can also be defined as resources:\nIn the example above, the property artist does not have a value, but a reference to a resource containing information about the artist.\nRDF Containers\nRDF containers are used to describe group of things.\nThe following RDF elements are used to describe groups: <Bag>, <Seq>, and <Alt>.\nThe <rdf:Bag> Element\nThe <rdf:Bag> element is used to describe a list of values that do not have to be in a specific order.\nThe <rdf:Bag> element may contain duplicate values.\nExample\nThe <rdf:Seq> Element\nThe <rdf:Seq> element is used to describe an ordered list of values (For example, in alphabetical order).\nThe <rdf:Seq> element may contain duplicate values.\nExample\nThe <rdf:Alt> Element\nThe <rdf:Alt> element is used to describe a list of alternative values (the user can select only one of the values).\nExample\nRDF Terms\nIn the examples above we have talked about \"list of values\" when describing the container elements. In RDF these \"list of values\" are called members.\nSo, we have the following:\nA container is a resource that contains things\nThe contained things are called members (not list of values)\nRDF Collections\nRDF collections describe groups that can ONLY contain the specified members.\nThe rdf:parseType=\"Collection\" Attribute\nAs seen in the previous chapter, a container says that the containing resources are members - it does not say that other members are not allowed.\nRDF collections are used to describe groups that can ONLY contain the specified members.\nA collection is described by the attribute rdf:parseType=\"Collection\".\nExample\nRDF Schema and Application Classes\nRDF Schema (RDFS) is an extension to RDF.\nRDF describes resources with classes, properties, and values.\nIn addition, RDF also needs a way to define application-specific classes and properties. Application-specific classes and properties must be defined using extensions to RDF.\nOne such extension is RDF Schema.\nRDF Schema (RDFS)\nRDF Schema does not provide actual application-specific classes and properties.\nInstead RDF Schema provides the framework to describe application-specific classes and properties.\nClasses in RDF Schema are much like classes in object oriented programming languages. This allows resources to be defined as instances of classes, and subclasses of classes.\nRDFS Example\nThe following example demonstrates some of the RDFS facilities:\nIn the example above, the resource \"horse\" is a subclass of the class \"animal\".\nExample Abbreviated\nSince an RDFS class is an RDF resource we can abbreviate the example above by using rdfs:Class instead of rdf:Description, and drop the rdf:type information:\nThat's it!\nThe Dublin Core\nThe Dublin Core Metadata Initiative (DCMI) has created some predefined properties for describing documents.\nRDF is metadata (data about data). RDF is used to describe information resources.\nThe Dublin Core is a set of predefined properties for describing documents.\nThe first Dublin Core properties were defined at the Metadata Workshop in Dublin, Ohio in 1995 and is currently maintained by the Dublin Core Metadata Initiative.\nA quick look at the table above indicates that RDF is ideal for representing Dublin Core information.\nRDF Example\nThe following example demonstrates the use of some of the Dublin Core properties in an RDF document:\nRDF Reference\nThe RDF namespace (xmlns:rdf) is: http://www.w3.org/1999/02/22-rdf-syntax-ns#\nThe RDFS namespace (xmlns:rdfs ) is: http://www.w3.org/2000/01/rdf-schema#\nThe recommended file extension for RDF files is .rdf. However, the extension .xml is often used to provide compatibility with old xml parsers.\nThe MIME type should be \"application/rdf+xml\".\nRDFS / RDF Classes\nRDFS / RDF Properties\nRDF Attributes",
      "examples": [
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:si=\"https://www.w3schools.com/rdf/\">\n\n<rdf:Description rdf:about=\"https://www.w3schools.com\">\n<si:title>W3Schools</si:title>\n<si:author>Jan Egil Refsnes</si:author>\n</rdf:Description>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<RDF>\n<Description about=\"https://www.w3schools.com/rdf\">\n<author>Jan Egil Refsnes</author>\n<homepage>https://www.w3schools.com</homepage>\n</Description>\n</RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:cd=\"http://www.recshop.fake/cd#\">\n\n<rdf:Description\nrdf:about=\"http://www.recshop.fake/cd/Empire Burlesque\">\n<cd:artist>Bob Dylan</cd:artist>\n<cd:country>USA</cd:country>\n<cd:company>Columbia</cd:company>\n<cd:price>10.90</cd:price>\n<cd:year>1985</cd:year>\n</rdf:Description>\n\n<rdf:Description\nrdf:about=\"http://www.recshop.fake/cd/Hide your heart\">\n<cd:artist>Bonnie Tyler</cd:artist>\n<cd:country>UK</cd:country>\n<cd:company>CBS Records</cd:company>\n<cd:price>9.90</cd:price>\n<cd:year>1988</cd:year>\n</rdf:Description>\n.\n.\n.\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:si=\"https://www.w3schools.com/rdf/\">\n<rdf:Description rdf:about=\"https://www.w3schools.com\">\n<si:title>W3Schools.com</si:title>\n<si:author>Jan Egil Refsnes</si:author>\n</rdf:Description>\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n...Description goes here...\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:cd=\"http://www.recshop.fake/cd#\">\n\n<rdf:Description\nrdf:about=\"http://www.recshop.fake/cd/Empire Burlesque\">\n<cd:artist>Bob Dylan</cd:artist>\n<cd:country>USA</cd:country>\n<cd:company>Columbia</cd:company>\n<cd:price>10.90</cd:price>\n<cd:year>1985</cd:year>\n</rdf:Description>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:cd=\"http://www.recshop.fake/cd#\">\n\n<rdf:Description\nrdf:about=\"http://www.recshop.fake/cd/Empire Burlesque\"\ncd:artist=\"Bob Dylan\" cd:country=\"USA\"\ncd:company=\"Columbia\" cd:price=\"10.90\"\ncd:year=\"1985\" />\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:cd=\"http://www.recshop.fake/cd#\">\n\n<rdf:Description\nrdf:about=\"http://www.recshop.fake/cd/Empire Burlesque\">\n<cd:artist rdf:resource=\"http://www.recshop.fake/cd/dylan\" />\n...\n...\n</rdf:Description>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:cd=\"http://www.recshop.fake/cd#\">\n\n<rdf:Description\nrdf:about=\"http://www.recshop.fake/cd/Beatles\">\n<cd:artist>\n<rdf:Bag>\n<rdf:li>John</rdf:li>\n<rdf:li>Paul</rdf:li>\n<rdf:li>George</rdf:li>\n<rdf:li>Ringo</rdf:li>\n</rdf:Bag>\n</cd:artist>\n</rdf:Description>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:cd=\"http://www.recshop.fake/cd#\">\n\n<rdf:Description\nrdf:about=\"http://www.recshop.fake/cd/Beatles\">\n<cd:format>\n<rdf:Alt>\n<rdf:li>CD</rdf:li>\n<rdf:li>Record</rdf:li>\n<rdf:li>Tape</rdf:li>\n</rdf:Alt>\n</cd:format>\n</rdf:Description>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:cd=\"http://recshop.fake/cd#\">\n\n<rdf:Description\nrdf:about=\"http://recshop.fake/cd/Beatles\">\n<cd:artist rdf:parseType=\"Collection\">\n<rdf:Description rdf:about=\"http://recshop.fake/cd/Beatles/George\"/>\n<rdf:Description rdf:about=\"http://recshop.fake/cd/Beatles/John\"/>\n<rdf:Description rdf:about=\"http://recshop.fake/cd/Beatles/Paul\"/>\n<rdf:Description rdf:about=\"http://recshop.fake/cd/Beatles/Ringo\"/>\n</cd:artist>\n</rdf:Description>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\nxml:base=\"http://www.animals.fake/animals#\">\n\n<rdf:Description rdf:ID=\"animal\">\n<rdf:type rdf:resource=\"http://www.w3.org/2000/01/rdf-schema#Class\"/>\n</rdf:Description>\n\n<rdf:Description rdf:ID=\"horse\">\n<rdf:type rdf:resource=\"http://www.w3.org/2000/01/rdf-schema#Class\"/>\n<rdfs:subClassOf rdf:resource=\"#animal\"/>\n</rdf:Description>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\nxml:base=\"http://www.animals.fake/animals#\">\n\n<rdfs:Class rdf:ID=\"animal\" />\n\n<rdfs:Class rdf:ID=\"horse\">\n<rdfs:subClassOf rdf:resource=\"#animal\"/>\n</rdfs:Class>\n\n</rdf:RDF>",
        "<?xml version=\"1.0\"?>\n\n<rdf:RDF\nxmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\nxmlns:dc= \"http://purl.org/dc/elements/1.1/\">\n\n<rdf:Description rdf:about=\"https://www.w3schools.com\">\n<dc:description>W3Schools - Free tutorials</dc:description>\n<dc:publisher>Refsnes Data as</dc:publisher>\n<dc:date>2008-09-01</dc:date>\n<dc:type>Web Development</dc:type>\n<dc:format>text/html</dc:format>\n<dc:language>en</dc:language>\n</rdf:Description>\n\n</rdf:RDF>"
      ]
    },
    {
      "title": "XML RSS",
      "summary": "With RSS it is possible to distribute up-to-date web content from one web site to thousands of other web sites around the world.\nRSS allows fast browsing for news and updates.\nRSS Document Example\nWhat is RSS?\nRSS stands for Really Simple Syndication\nRSS allows you to syndicate your site content\nRSS defines an easy way to share and view headlines and content\nRSS files can be automatically updated\nRSS allows personalized views for different sites\nRSS is written in XML\nWhy use RSS?\nRSS was designed to show selected data.\nWithout RSS, users will have to check your site daily for new updates. This may be too time-consuming for many users. With an RSS feed (RSS is often called a News feed or RSS feed) they can check your site faster using an RSS aggregator (a site or program that gathers and sorts out RSS feeds).\nSince RSS data is small and fast-loading, it can easily be used with services like cell phones or PDA's.\nWeb-rings with similar information can easily share data on their web sites to make them better and more useful.\nREMOVE ADS\nWho Should use RSS?\nWebmasters who seldom update their web sites do not need RSS!\nRSS is useful for web sites that are updated frequently, like:\nNews sites - Lists news with title, date and descriptions\nCompanies - Lists news and new products\nCalendars - Lists upcoming events and important days\nSite changes - Lists changed pages or new pages\nBenefits of RSS\nHere are some benefits of using RSS:\nChoose your news\nWith RSS you can choose to view the news you want, the news that interest you and are relevant to your work.\nRemove unwanted information\nWith RSS you can (finally) separate wanted information from unwanted information (spam)!\nIncrease your site traffic\nWith RSS you can create your own news channel, and publish it to the Internet!\nThe History of RSS\n1997 - Dave Winer at UserLand develops scriptingNews. RSS was born\n1999 - Netscape develops RSS 0.90 (which supported scriptingNews)\n1999 - Dave Winer develops scriptingNews 2.0b1 (which included RSS 0.90 features)\n1999 - Netscape develops RSS 0.91 (which included most features from scriptingNews 2.0b1)\n1999 - UserLand gets rid of scriptingNews and uses only RSS 0.91\n1999 - Netscape stops their RSS development\n2000 - UserLand releases the official RSS 0.91 specification\n2000 - O'Reilly develops RSS 1.0. This format uses RDF and namespaces.\n2000 - Dave Winer at UserLand develops RSS 0.92\n2002 - Dave Winer develops RSS 2.0 after leaving UserLand\n2003 - The official RSS 2.0 specification is released\nRSS 1.0 is the only version that was developed using the W3C RDF (Resource Description Framework) standard.\nThe idea behind RDF was to help create a Semantic Web. However, this does not matter too much for ordinary users, but by using web standards it will be easier for persons and applications to exchange data.\nWhat RSS Version Should I Use?\nRSS 0.91 and RSS 2.0 are easier to understand than RSS 1.0. Our tutorial is based on RSS 2.0.\nThe syntax rules of RSS 2.0 are very simple and very strict.\nIs RSS a Web Standard?\nThere is no official standard for RSS.\nAbout 50 % of all RSS feeds use RSS 0.91\nAbout 25 % use RSS 1.0\nThe last 25 % is split between RSS 0.9x versions and RSS 2.0\nHow RSS Works\nRSS is used to share content between websites.\nWith RSS, you register your content with companies called aggregators.\nSo, to be a part of it: First, create an RSS document and save it with an .xml extension. Then, upload the file to your website. Next, register with an RSS aggregator. Each day the aggregator searches the registered websites for RSS documents, verifies the link, and displays information about the feed so clients can link to documents that interests them.\nTip: Read our RSS Publishing chapter to view free RSS aggregation services.\nRSS Example\nRSS documents use a self-describing and simple syntax.\nHere is a simple RSS document:\nThe first line in the document - the XML declaration - defines the XML version and the character encoding used in the document. In this case the document conforms to the 1.0 specification of XML and uses the UTF-8 character set.\nThe next line is the RSS declaration which identifies that this is an RSS document (in this case, RSS version 2.0).\nThe next line contains the <channel> element. This element is used to describe the RSS feed.\nThe <channel> element has three required child elements:\n<title> - Defines the title of the channel (e.g. W3Schools Home Page)\n<link> - Defines the hyperlink to the channel (e.g. https://www.w3schools.com)\n<description> - Describes the channel (e.g. Free web building tutorials)\nEach <channel> element can have one or more <item> elements.\nEach <item> element defines an article or \"story\" in the RSS feed.\nThe <item> element has three required child elements:\n<title> - Defines the title of the item (e.g. RSS Tutorial)\n<link> - Defines the hyperlink to the item (e.g. https://www.w3schools.com/xml/xml_rss.asp)\n<description> - Describes the item (e.g. New RSS tutorial on W3Schools)\nFinally, the two last lines close the <channel> and <rss> elements.\nComments in RSS\nThe syntax for writing comments in RSS is similar to that of HTML:\nRSS is Written in XML\nBecause RSS is XML, keep in mind that:\nAll elements must have a closing tag\nElements are case sensitive\nElements must be properly nested\nAttribute values must always be quoted\nThe RSS <channel> Element\nThe RSS <channel> element describes the RSS feed.\nLook at the following RSS document:\nAs mentioned before, the <channel> element describes the RSS feed, and has three required child elements:\n<title> - Defines the title of the channel (e.g. W3Schools Home Page)\n<link> - Defines the hyperlink to the channel (e.g. https://www.w3schools.com)\n<description> - Describes the channel (e.g. Free web building tutorials)\nThe <channel> element usually contains one or more <item> elements. Each <item> element defines an article or \"story\" in the RSS feed.\nFurthermore, there are several optional child elements of <channel>. We will explain the most important ones below.\nThe <category> Element\nThe <category> child element is used to specify a category for your feed.\nThe <category> element makes it possible for RSS aggregators to group sites based on category.\nThe category for the RSS document above could be:\nThe <copyright> Element\nThe <copyright> child element notifies about copyrighted material.\nThe copyright for the RSS document above could be:\nThe <image> Element\nThe <image> child element allows an image to be displayed when aggregators present a feed.\nThe <image> element has three required child elements:\n<url> - Defines the URL to the image\n<title> - Defines the text to display if the image could not be shown\n<link> - Defines the hyperlink to the website that offers the channel\nThe image for the RSS document above could be:\nThe <language> Element\nThe <language> child element is used to specify the language used to write your document.\nThe <language> element makes it possible for RSS aggregators to group sites based on language.\nThe language for the RSS document above could be:\nThe <item> Element\nEach <item> element defines an article or \"story\" in an RSS feed.\nLook at the following RSS document:\nAs mentioned before, each <item> element defines an article or \"story\" in the RSS feed.\nThe <item> element has three required child elements:\n<title> - Defines the title of the item (e.g. RSS Tutorial)\n<link> - Defines the hyperlink to the item (e.g. https://www.w3schools.com/xml/xml_rss.asp)\n<description> - Describes the item (e.g. New RSS tutorial on W3Schools)\nFurthermore, there are several optional child elements of <item>. We will explain the most important ones below.\nThe <author> Element\nThe <author> child element is used to specify the e-mail address of the author of an item.\nNote: To prevent spam e-mails, some developers do not include the <author> element.\nThe author of the item in the RSS document above could be:\nThe <comments> Element\nThe <comments> child element allows an item to link to comments about that item.\nA comment of the item in the RSS document above could be:\nThe <enclosure> Element\nThe <enclosure> child element allows a media-file to be included with an item.\nThe <enclosure> element has three required attributes:\nurl - Defines the URL to the media file\nlength - Defines the length (in bytes) of the media file\ntype - Defines the type of media file\nA media-file included in the item in the RSS document above could be:\nGet Your RSS Feed Up On The Web\nHaving an RSS document is not useful if other people cannot reach it.\nNow it's time to get your RSS file up on the web. Here are the steps:\n1. Name your RSS file. Notice that the file must have an .xml extension.\n2. Validate your RSS file\n3. Upload the RSS file to your web directory on your web server.\n4. Copy the little orange or button to your web directory.\n5. Put the little orange \"RSS\" or \"XML\" button on the page where you will offer RSS to the world (e.g. on your home page). Then add a link to the button that links to the RSS file. The code will look something like this:\n<a href=\"https://www.w3schools.com/xml/myfirstrss.xml\">\n<img src=\"https://www.w3schools.com/xml/pic_rss.gif\" width=\"36\" height=\"14\">\n</a>.\n6. Submit your RSS feed to the RSS Feed Directories (you can Google or Yahoo for \"RSS Feed Directories\"). Note! The URL to your feed is not your home page, it is the URL to your feed, like \"https://www.w3schools.com/xml/myfirstrss.xml\".\n7. Register your feed with the major search engines:\nGoogle - http://www.google.com/submityourcontent/website-owner\n8. Update your feed - After registering your RSS feed, you must make sure that you update your content frequently and that your RSS feed is constantly available.\nCan I Manage my RSS Feed Myself?\nThe best way to ensure your RSS feed works the way you want, is to manage it yourself.\nHowever, this can be very time consuming, especially for pages with lot of updates.\nAn alternative is to use a third-party automated RSS.\nAutomated RSS\nFor users who only need an RSS feed for their personal website, some of the most popular blog (Web Log) managers that offer built-in RSS services are:\nWordpress\nBlogger\nRadio\nRSS Readers\nAn RSS Reader is used to read RSS Feeds!\nRSS readers are available for many different devices and OS.\nThere are a lot of different RSS readers. Some work as web services, and some are limited to windows (or Mac, PDA or UNIX):\nQuiteRSS - An open-source, cross-platform RSS/Atom news feed reader\nFeedReader - A simple, straightforward feed reader that easily handles large number of feeds\nTip: Most browsers have a built-in RSS Reader. If you go to a web site that offers RSS feeds, you will see an RSS icon in the address bar, or toolbar. Click on the icon to view a list of the different feeds. Choose the feed you want to read.\nI have an RSS Reader. Now what?\nClick on the little or button next to the RSS feed you want to read. Copy The URL you get in the browser window and paste it in your RSS reader.\nRSS Reference\nThe <channel> Element\nThe links in the \"Element\" column point to more information about each specific element.\nThe <item> Element",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n\n<channel>\n<title>W3Schools Home Page</title>\n<link>https://www.w3schools.com</link>\n<description>Free web building tutorials</description>\n<item>\n<title>RSS Tutorial</title>\n<link>https://www.w3schools.com/xml/xml_rss.asp</link>\n<description>New RSS tutorial on W3Schools</description>\n</item>\n<item>\n<title>XML Tutorial</title>\n<link>https://www.w3schools.com/xml</link>\n<description>New XML tutorial on W3Schools</description>\n</item>\n</channel>\n\n</rss>",
        "<!-- This is an RSS comment -->",
        "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n\n<channel>\n<title>W3Schools Home Page</title>\n<link>https://www.w3schools.com</link>\n<description>Free web building tutorials</description>\n<item>\n<title>RSS Tutorial</title>\n<link>https://www.w3schools.com/xml/xml_rss.asp</link>\n<description>New RSS tutorial on W3Schools</description>\n</item>\n</channel>\n\n</rss>",
        "<category>Web development</category>",
        "<copyright>2006 Refsnes Data as. All rights reserved.</copyright>",
        "<image>\n<url>https://www.w3schools.com/images/logo.gif</url>\n<title>W3Schools.com</title>\n<link>https://www.w3schools.com</link>\n</image>",
        "<language>en-us</language>",
        "<author>hege@refsnesdata.no</author>",
        "<comments>https://www.w3schools.com/comments</comments>",
        "<enclosure url=\"https://www.w3schools.com/xml/rss.mp3\"\nlength=\"5000\" type=\"audio/mpeg\" />"
      ]
    },
    {
      "title": "XML Examples",
      "summary": "Viewing XML Files\nView a simple XML file (note.xml)\nView the same XML file with an error\nView an XML CD catalog\nView an XML plant catalog\nView an XML food menu\nExamples explained\nXML and CSS\nView an XML CD catalog\nView the corresponding CSS file\nDisplay the CD catalog formatted with the CSS file\nExamples explained\nXML and XSLT\nView an XML food menu\nDisplay the food menu styled with an XSLT style sheet\nExamples explained\nParsing XML and the XML DOM\nView a simple XML file (note.xml)\nParse an XML string\nParse the XML file\nExamples explained\nXML Output From a Server\nSee how ASP can return XML\nSee how PHP can return XML\nView XML output from a database\nExamples explained",
      "examples": []
    },
    {
      "title": "XML Quiz",
      "summary": "You can test your XML skills with W3Schools' Quiz.\nThe Test\nThe test contains 25 questions and there is no time limit.\nThe test is not official, it's just a nice way to see how much you know, or don't know, about XML.\nCount Your Score\nYou will get 1 point for each correct answer. At the end of the Quiz, your total score will be displayed. Maximum score is 25 points.\nStart the Quiz\nGood luck!\nStart the XML Quiz ❯\nKickstart your career\nGet certified by completing the XML course",
      "examples": []
    },
    {
      "title": "XML Syllabus",
      "summary": "Introduction\nThe W3Schools XML Tutorial is comprehensive and beginner-friendly.\nIt will give you a fundamental knowledge of XML.\nIt is designed for beginners and requires no prior experience with markup languages.\nThe content has been carefully made to be bite-sized, simple, and easy to understand.\nThe content has been proven by millions of users over the years. It is updated and improved frequently.\nThe syllabus outline and its sequence are structured so you can learn XML step by step, from the introduction to creating structured data.\nGet Started With XML »\nLearning Outcomes\nLearn what XML is and how it works\nCreate basic XML documents with elements and attributes\nDisplay XML data on web pages\nUse XML with AJAX for dynamic web content\nWork with XML DOM to access and change XML\nUse XPath to find information in XML documents\nTransform XML into other formats using XSLT\nValidate XML using DTD and XML Schema\nStore and share data using XML\nNote: Are you a teacher teaching XML? W3Schools Academy is a toolbox of features that can help you teach. It offers classroom features such as pre-built study plans, classroom administration and much more. Read more about Academy here.\nWhich Subjects Are XML Relevant For?\nData Exchange:\nXML is essential for structured data exchange between systems.\nWeb Services:\nXML is fundamental for SOAP web services and APIs.\nConfiguration:\nXML is widely used for application configuration files.\nData Storage:\nXML provides a format for storing structured data.\nDocument Management:\nXML supports document structures and metadata.\nSystem Integration:\nXML enables communication between different systems.\nEnterprise Applications:\nXML is used in many enterprise-level applications.\nGet Started\nActivities\nIn this tutorial we offer different activities for you to learn XML for free:\nLessons\nQuizzes\nSign in to Track Progress\nYou can also create a free account to track your progress.\nAs a signed-in user, you get access to features such as:\nLearning paths\nSandbox and lab environments\nAchievements\nAnd much more!\nSign Up - It's free\nOverview of the Modules\nXML HOME\nXML Introduction\nXML How to use\nXML Tree\nXML Syntax\nXML Elements\nXML Attributes\nXML Namespaces\nXML Display\nXML HttpRequest\nXML Parser\nXML DOM\nXML XPath\nXML XSLT\nXML XQuery\nXML XLink\nXML Validator\nXML DTD\nXML Schema\nXML Server\nXML Examples\nXML Quiz\nAJAX Introduction\nAJAX XMLHttp\nAJAX Request\nAJAX Response\nAJAX XML File\nAJAX PHP\nAJAX ASP\nAJAX Database\nAJAX Applications\nDOM Introduction\nDOM Nodes\nDOM Accessing\nDOM Node Info\nDOM Node List\nDOM Traversing\nDOM Navigating\nDOM Get Values\nDOM Change Nodes\nDOM Remove Nodes\nDOM Replace Nodes\nDOM Create Nodes\nDOM Add Nodes\nDOM Clone Nodes\nXPath Introduction\nXPath Nodes\nXPath Syntax\nXPath Axes\nXPath Operators\nXSLT Introduction\nXSL Languages\nXSLT Transform\nXSLT <template>\nXSLT <value-of>\nXSLT <for-each>\nXSLT <sort>\nXSLT <if>\nXSLT <choose>\nXSLT Apply\nXSLT on the Client\nXSLT on the Server\nXSLT Edit XML\nXQuery Introduction\nXQuery Example\nXQuery FLWOR\nXQuery HTML\nXQuery Terms\nXQuery Syntax\nXQuery Add\nXQuery Select\nDTD Introduction\nDTD Building Blocks\nDTD Elements\nDTD Attributes\nDTD Elements vs Attr\nDTD Entities\nXSD Introduction\nXSD How To\nXSD <schema>\nXSD Elements\nXSD Attributes\nXSD Restrictions\nXSD Complex Elements\nXSD Empty\nXSD Elements-only\nXSD Text-only\nXSD Mixed\nXSD Indicators\nXSD <any>\nXSD <anyAttribute>\nXSD Substitution\nXSD String\nXSD Date/Time\nXSD Numeric\nXSD Misc\nXML Services\nXML WSDL\nXML SOAP\nXML RDF\nDOM Node Types\nDOM Node\nDOM NodeList\nDOM NamedNodeMap\nDOM Document\nDOM Element\nDOM Attribute\nDOM Text\nDOM CDATA\nDOM Comment\nDOM XMLHttpRequest\nDOM Parser\nXSLT Elements\nXSLT/XPath Functions\nGet Started\nSandbox and Lab Environment\nXML, like any markup language, is best learned through hands-on practice.\nTry this example using our editor:\nXML Example 1\nDisplay the XML File » Display the XML File as a Note »\nIf you want to explore more and host your project, we have a feature called Spaces that allows you to build, test and validate XML documents for free.\nHere you get a secure sandbox environment called Spaces, where you can practice XML and test documents in real-time.\nSpaces allow you to test, validate, and transform XML. This includes a W3Schools subdomain, hosting, and secure SSL certificates.\nSpaces require no installation and run directly in the browser.\nFeatures include:\nCollaboration\nFile navigator\nTerminal & log\nPackage manager\nDatabase\nEnvironment manager\nAnalytics\nCreate a Spaces Account\nXML Certification\nW3Schools offers an end-of-pathway certification program.\nHere you can take exams to get certified.\nThe XML exam is a test that summarizes the W3Schools XML syllabus.\nAfter passing the exam you get the \"Certified XML Developer\" Certification.\nThere are two different types of certifications:\nNon-adaptive\nAdaptive\nThe non-adaptive is pass or no pass.\nThe adaptive certification is adaptive and graded; students will get a grade from intermediate, advanced to professional.\nBuy Certificate »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach XML?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »\nHeader",
      "examples": [
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<note>\n<to>Tove</to>\n<from>Jani</from>\n<heading>Reminder</heading>\n<body>Don't forget me this weekend!</body>\n</note>"
      ]
    },
    {
      "title": "XML Study Plan",
      "summary": "Introduction\nThe XML study plan helps you teach your students XML step-by-step.\nCreating a study plan for XML is easy.\nYou can use a pre-built study plan or customize it.\nStudents have different skill levels. The study plans can be customized to ensure that everyone is challenged.\nSave time with pre-built teacher materials and study plans. Easily organize your class with a timeline from the introduction of XML to the final exam.\nW3Schools Academy\nThis study plan is a feature of W3Schools Academy.\nW3Schools Academy is a platform that has everything you need to teach coding, all in one place.\nIt offers you as a teacher a toolbox of features that helps you succeed with teaching in your classroom.\nYou need to have an active subscription to access the study plan feature. There are two different subscription tiers:\nEssentials ($1.99 / month per student)\nFull Access ($5.99 / month per student)\nCalculate your price and order here.\nLearn More »\nAcademy also offer other features such as:\nManaging your classroom\nTracking of student progress and reports\nLabs, assignments, and code challenges (prebuilt challenges or create your own ones)\nAuto-grading\nTeaching materials\nCertification exams\nGet a free demo »\nTeacher Materials\nW3Schools has everything you need to teach XML.\nThe XML training materials is available for you to include and use in your study plan:\nW3Schools XML Tutorial\nXML Quiz\nXML Challenges (Coding challenges)\nXML Certification Exam (End of Pathway Exam)\nXML Syllabus\nWith the XML Syllabus, your students will start with the basics, like understanding XML syntax, structure, and elements, and move to more advanced topics, like working with XML parsers, using XPath, and defining XML schemas. Each chapter includes examples, try-it-yourself sections, exercises, and quizzes to make learning easy, interactive, and fun.\nRead more about XML Syllabus.\nStudy Plan Overview\nThe study plan features are made to help teachers and students. They make learning easy, flexible, and fun. These features work for different types of classes, learning styles and student level.\nLearning Paths\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nInteractive Content\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTimeline and Pace\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nTrack Student Progress\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nEnd of Pathway Exam\nThe XML study plan aligns with the XML Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the XML Tutorial.\nYou get reports of the students' results.\nThe XML study plan aligns with the XML Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the XML Tutorial.\nYou get reports of the students' results.\nAccessibility\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nLearn More »\nSample Study Plan\nYou choose the timeline and pace of your study plans.\nSchools have different preferences.\nSome would like more intensive pace, e.g. 5 weeks, others 12 or more weeks.\nIt is completely up to you.\nFor example, this is how a 3-week XML study plan could look like:\nWeek 1: Introduction, Basic use, AJAX\nWeek 2: DOM, XPath, XSLT, XQuery, DTD, XSD Schema\nWeek 3: XSD Complex, XSD Data Types, Web Services, XML Certification Exam\nImage of Sample XML study plan:\nReady to get started?\nStart with XML Study Plans today.\nGet Started »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach XML programming?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": []
    },
    {
      "title": "W3Schools XML Certificate",
      "summary": "W3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nW3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nWho Should Consider Getting Certified?\nAny student or professional within the digital industry.\nCertifications are valuable assets to gain trust and demonstrate knowledge to your clients, current or future employers on a ever increasing competitive market.\nW3Schools is Trusted by Top Companies\nW3Schools has over two decades of experience with teaching coding online.\nOur certificates are recognized and valued by companies looking to employ skilled developers.\nSave Time and Money\nShow the world your coding skills by getting a certification.\nThe prices is a small fraction compared to the price of traditional education.\nDocument and validate your competence by getting certified!\nExam overview\nFee: 95 USD\nAchievable certification levels:\nIntermediate (40%)\nAdvanced (75%)\nProfessional (90%)\nNumber of questions:\nAdaptive, 60 on average\nRequirement to pass:\nMinimum 40% - Intermediate level\nTime limit: 60 minutes\nNumber of attempts to pass: 3\nExam deadline: None\nCertification Expiration: None\nFormat: Online, multiple choice\nRegister now »\nAdvance Faster in Your Career\nGetting a certificate proves your commitment to upgrading your skills.\nThe certificate can be added as credentials to your CV, Resume, LinkedIn profile, and so on.\nIt gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nKnowledge is power, especially in the current job market.\nDocumentation of your skills enables you to advance your career or helps you to start a new one.\nHow Does It Work?\nStudy for free at W3Schools.com\nStudy at your own speed\nTest your skills with W3Schools online quizzes\nApply for your certificate by paying an exam fee\nTake your exam online, at any time, and from any location\nGet Your Certificate and Share It With The World\nExample certificate:\nEach certificate gets a unique link that can be shared with others.\nValidate your certification with the link or QR code.\nCheck how it looks like in this Example.\nShare your certificate on Linked in the Certifications section in just one click!\nDocument Your Skills\nGetting a certificate proves your commitment to upgrade your skills, gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nGet Your Certificate »\nLooking to add multiple users?\nAre you an educator, manager or business owner looking for courses or certifications?\nWe are working with schools, companies and organizations from all over the world.\nGet courses and/or certifications for your team here.",
      "examples": []
    },
    {
      "title": "XML DOM Node Types",
      "summary": "The DOM presents a document as a hierarchy of node objects.\nNode Types\nThe following table lists the different W3C node types, and which node types they may have as children:\nREMOVE ADS\nNode Types - Return Values\nThe following table lists what the nodeName and the nodeValue properties will return for each node type:\nNodeTypes - Named Constants",
      "examples": []
    },
    {
      "title": "XML DOM - The Node Object",
      "summary": "The Node Object\nThe Node object represents a single node in the document tree.\nA node can be an element node, an attribute node, a text node, or any other of the node types explained in the Node Types chapter.\nNotice that while all objects inherits the Node properties / methods for dealing with parents and children, not all objects can have parents or children. For example, Text nodes may not have children, and adding children to such nodes results in a DOM error.\nNode Object Properties\nREMOVE ADS\nNode Object Methods",
      "examples": []
    },
    {
      "title": "XML DOM - The NodeList Object",
      "summary": "The NodeList object represents an ordered list of nodes.\nThe NodeList object\nThe nodes in the node list can be accessed through their index number (starting from 0).\nThe node list keeps itself up-to-date. If an element is deleted or added, in the node list or the XML document, the list is automatically updated.\nNote: In a node list, the nodes are returned in the order in which they are specified in the XML document.\nNodeList Object Properties\nNodeList Object Methods",
      "examples": []
    },
    {
      "title": "XML DOM - The NamedNodeMap Object",
      "summary": "The NamedNodeMap object represents an unordered list of nodes.\nThe NamedNodeMap object\nThe nodes in the NamedNodeMap can be accessed through their name.\nThe NamedNodeMap keeps itself up-to-date. If an element is deleted or added, in the node list or the XML document, the list is automatically updated.\nNote: In a named node map, the nodes are not returned in any particular order.\nNamedNodeMap Object Properties\nNamedNodeMap Object Methods",
      "examples": []
    },
    {
      "title": "XML DOM - The Document Object",
      "summary": "The Document object represents the entire XML document.\nThe XML Document Object\nThe Document object is the root of an XML document tree, and gives us the primary access to the document's data.\nSince element nodes, text nodes, comments, processing instructions, etc. cannot exist outside the document, the Document object also contains methods to create these objects. The Node objects have a ownerDocument property which associates them with the Document where they were created.\nDocument Object Properties\nDocument Object Methods\nREMOVE ADS\nDocumentType Object Properties\nEach document has a DOCTYPE attribute that whose value is either null or a DocumentType object.\nThe DocumentType object provides an interface to the entities defined for an XML document.\nDocumentImplementation Object Methods\nThe DOMImplementation object performs operations that are independent of any particular instance of the document object model.\nProcessingInstruction Object Properties\nThe ProcessingInstruction object represents a processing instruction.\nA processing instruction is used as a way to keep processor-specific information in the text of the XML document.",
      "examples": []
    },
    {
      "title": "XML DOM - The Element Object",
      "summary": "The Element object\nThe Element object represents an element in an XML document. Elements may contain attributes, other elements, or text. If an element contains text, the text is represented in a text-node.\nIMPORTANT! Text is always stored in text nodes. A common error in DOM processing is to navigate to an element node and expect it to contain the text. However, even the simplest element node has a text node under it. For example, in <year>2005</year>, there is an element node (year), and a text node under it, which contains the text (2005).\nBecause the Element object is also a Node, it inherits the Node object's properties and methods.\nElement Object Properties\nREMOVE ADS\nElement Object Methods",
      "examples": []
    },
    {
      "title": "XML DOM - The Attr Object",
      "summary": "The Attr object\nThe Attr object represents an attribute of an Element object. The allowable values for attributes are usually defined in a DTD.\nBecause the Attr object is also a Node, it inherits the Node object's properties and methods. However, an attribute does not have a parent node and is not considered to be a child node of an element, and will return null for many of the Node properties.\nAttr Object Properties",
      "examples": []
    },
    {
      "title": "XML DOM - The Text Object",
      "summary": "The Text object\nThe Text object represents the textual content of an element or attribute.\nText Object Properties\nText Object Methods",
      "examples": []
    },
    {
      "title": "XML DOM - The CDATASection Object",
      "summary": "The CDATASection object\nThe CDATASection object represents a CDATA section in a document.\nA CDATA section contains text that will NOT be parsed by a parser. Tags inside a CDATA section will NOT be treated as markup and entities will not be expanded. The primary purpose is for including material such as XML fragments, without needing to escape all the delimiters.\nThe only delimiter that is recognized in a CDATA section is \"]]>\" - which indicates the end of the CDATA section. CDATA sections cannot be nested.\nCDATASection Object Properties\nCDATASection Object Methods",
      "examples": []
    },
    {
      "title": "XML DOM - The Comment Object",
      "summary": "The Comment object\nThe Comment object represents the content of comment nodes in a document.\nComment Object Properties\nComment Object Methods",
      "examples": []
    },
    {
      "title": "The XMLHttpRequest Object",
      "summary": "With the XMLHttpRequest object you can update parts of a web page, without reloading the whole page.\nThe XMLHttpRequest Object\nThe XMLHttpRequest object is used to exchange data with a server behind the scenes.\nThe XMLHttpRequest object is the developers dream, because you can:\nUpdate a web page without reloading the page\nRequest data from a server after the page has loaded\nReceive data from a server after the page has loaded\nSend data to a server in the background\nREMOVE ADS\nXMLHttpRequest Object Methods\nXMLHttpRequest Object Properties",
      "examples": []
    },
    {
      "title": "XML DOM Parser Errors",
      "summary": "XML Parser Error\nWhen trying to open an XML document, a parser-error may occur.\nIf the parser encounters an error, it may load an XML document containing the error description.\nThe code example below tries to load an XML document that is not well-formed.\nYou can read more about well-formed XML in XML Syntax.\nExample\nLook at the XML file: note_error.xml",
      "examples": [
        "<html>\n<body>\n\n<p id=\"demo\"></p>\n\n<script>\nvar xhttp = new XMLHttpRequest();\nxhttp.onreadystatechange = function() {\nif (xhttp.this == 4 && this.status == 200) {\nmyFunction(this);\n}\n};\nxhttp.open(\"GET\", \"note_error.xml\", true);\nxhttp.send();\n\nfunction myFunction(xml) {\nvar parser, xmlDoc;\nparser = new DOMParser();\nxmlDoc = parser.parseFromString(xml.responseText,\"text/xml\");\ndocument.getElementById(\"demo\").innerHTML =\nmyLoop(xmlDoc.documentElement);\n}\n\nfunction myLoop(x) {\nvar i, y, xLen, txt;\ntxt = \"\";\nx = x.childNodes;\nxLen = x.length;\nfor (i = 0; i < xLen ;i++) {\ny = x[i];\nif (y.nodeType != 3) {\nif (y.childNodes[0] != undefined) {\ntxt += myLoop(y);\n}\n} else {\ntxt += y.nodeValue + \"<br>\";\n}\n}\nreturn txt;\n}\n</script>\n\n</body>\n</html>"
      ]
    },
    {
      "title": "XSLT Elements Reference",
      "summary": "The XSLT elements from the W3C Recommendation (XSLT Version 1.0).\nXSLT Elements\nThe links in the \"Element\" column point to attributes and more useful information about each specific element.",
      "examples": []
    },
    {
      "title": "XSLT, XPath, and XQuery Functions Functions Reference",
      "summary": "XSLT 2.0, XPath 2.0, and XQuery 1.0, share the same functions library.\nAccessor\nError and Trace\nNumeric\nString\nAnyURI\nBoolean\nDuration/Date/Time\nQName\nNode\nSequence\nContext\nThe default prefix for the function namespace is fn:\nThe URI of the function namespace is: http://www.w3.org/2005/xpath-functions\nTip: Functions are often called with the fn: prefix, such as fn:string(). However, since fn: is the default prefix of the namespace, the function names do not need to be prefixed when called.\nAccessor Functions\nError and Trace Functions\nResult: Returns http://example.com/test#toohigh and the string \"Error: Price is too high\" to the external processing environment\nREMOVE ADS\nFunctions on Numeric Values\nExample: number('100')\nResult: 100\nExample: abs(3.14)\nResult: 3.14\nExample: abs(-3.14)\nResult: 3.14\nExample: ceiling(3.14)\nResult: 4\nExample: floor(3.14)\nResult: 3\nExample: round(3.14)\nResult: 3\nExample: round-half-to-even(1.5)\nResult: 2\nExample: round-half-to-even(2.5)\nResult: 2\nFunctions on Strings\nExample: string(314)\nResult: \"314\"\nExample: codepoints-to-string((84, 104, 233, 114, 232, 115, 101))\nResult: 'Thérèse'\nExample: string-to-codepoints(\"Thérèse\")\nResult: (84, 104, 233, 114, 232, 115, 101)\nExample: compare('ghi', 'ghi')\nResult: 0\nExample: concat('XPath ','is ','FUN!')\nResult: 'XPath is FUN!'\nExample: string-join(('We', 'are', 'having', 'fun!'), ' ')\nResult: ' We are having fun! '\nExample: string-join(('We', 'are', 'having', 'fun!'))\nResult: 'Wearehavingfun!'\nExample:string-join((), 'sep')\nResult: ''\nExample: substring('Beatles',1,4)\nResult: 'Beat'\nExample: substring('Beatles',2)\nResult: 'eatles'\nExample: string-length('Beatles')\nResult: 7\nExample: normalize-space(' The   XML ')\nResult: 'The XML'\nExample: upper-case('The XML')\nResult: 'THE XML'\nExample: lower-case('The XML')\nResult: 'the xml'\nExample: translate('12:30','30','45')\nResult: '12:45'\nExample: translate('12:30','03','54')\nResult: '12:45'\nExample: translate('12:30','0123','abcd')\nResult: 'bc:da'\nExample: escape-uri(\"http://example.com/test#car\", false())\nResult: \"http://example.com/test#car\"\nExample: escape-uri (\"http://example.com/~bébé\", false())\nResult: \"http://example.com/~b%C3%A9b%C3%A9\"\nExample: contains('XML','XM')\nResult: true\nExample: starts-with('XML','X')\nResult: true\nExample: ends-with('XML','X')\nResult: false\nExample: substring-before('12/10','/')\nResult: '12'\nExample: substring-after('12/10','/')\nResult: '10'\nExample: matches(\"Merano\", \"ran\")\nResult: true\nExample: replace(\"Bella Italia\", \"l\", \"*\")\nResult: 'Be**a Ita*ia'\nExample: replace(\"Bella Italia\", \"l\", \"\")\nResult: 'Bea Itaia'\nFunctions for anyURI\nFunctions on Boolean Values\nExample: not(true())\nResult: false\nExample: true()\nResult: true\nExample: false()\nResult: false\nFunctions on Durations, Dates and Times\nComponent Extraction Functions on Durations, Dates and Times\nExample: year-from-dateTime(xs:dateTime(\"2005-01-10T12:30-04:10\"))\nResult: 2005\nExample: month-from-dateTime(xs:dateTime(\"2005-01-10T12:30-04:10\"))\nResult: 01\nExample: day-from-dateTime(xs:dateTime(\"2005-01-10T12:30-04:10\"))\nResult: 10\nExample: hours-from-dateTime(xs:dateTime(\"2005-01-10T12:30-04:10\"))\nResult: 12\nExample: minutes-from-dateTime(xs:dateTime(\"2005-01-10T12:30-04:10\"))\nResult: 30\nExample: seconds-from-dateTime(xs:dateTime(\"2005-01-10T12:30:00-04:10\"))\nResult: 0\nExample: year-from-date(xs:date(\"2005-04-23\"))\nResult: 2005\nExample: month-from-date(xs:date(\"2005-04-23\"))\nResult: 4\nExample: day-from-date(xs:date(\"2005-04-23\"))\nResult: 23\nExample: hours-from-time(xs:time(\"10:22:00\"))\nResult: 10\nExample: minutes-from-time(xs:time(\"10:22:00\"))\nResult: 22\nExample: seconds-from-time(xs:time(\"10:22:00\"))\nResult: 0\nFunctions Related to QNames\nFunctions on Nodes\nExample: Lang(\"en\") is true for\n<p xml:lang=\"en\">...</p>\nExample: Lang(\"de\") is false for\n<p xml:lang=\"en\">...</p>\nFunctions on Sequences\nGeneral Functions on Sequences\nExample: index-of ((15, 40, 25, 40, 10), 40)\nResult: (2, 4)\nExample: index-of ((\"a\", \"dog\", \"and\", \"a\", \"duck\"), \"a\")\nResult (1, 4)\nExample: index-of ((15, 40, 25, 40, 10), 18)\nResult: ()\nExample: remove((\"ab\", \"cd\", \"ef\"), 0)\nResult: (\"ab\", \"cd\", \"ef\")\nExample: remove((\"ab\", \"cd\", \"ef\"), 1)\nResult: (\"cd\", \"ef\")\nExample: remove((\"ab\", \"cd\", \"ef\"), 4)\nResult: (\"ab\", \"cd\", \"ef\")\nExample: empty(remove((\"ab\", \"cd\"), 1))\nResult: false\nExample: exists(remove((\"ab\"), 1))\nResult: false\nExample: distinct-values((1, 2, 3, 1, 2))\nResult: (1, 2, 3)\nExample: insert-before((\"ab\", \"cd\"), 0, \"gh\")\nResult: (\"gh\", \"ab\", \"cd\")\nExample: insert-before((\"ab\", \"cd\"), 1, \"gh\")\nResult: (\"gh\", \"ab\", \"cd\")\nExample: insert-before((\"ab\", \"cd\"), 2, \"gh\")\nResult: (\"ab\", \"gh\", \"cd\")\nExample: insert-before((\"ab\", \"cd\"), 5, \"gh\")\nResult: (\"ab\", \"cd\", \"gh\")\nExample: reverse((\"ab\", \"cd\", \"ef\"))\nResult: (\"ef\", \"cd\", \"ab\")\nExample: reverse((\"ab\"))\nResult: (\"ab\")\nExample: subsequence(($item1, $item2, $item3,...), 3)\nResult: ($item3, ...)\nExample: subsequence(($item1, $item2, $item3, ...), 2, 2)\nResult: ($item2, $item3)\nFunctions That Test the Cardinality of Sequences\nEquals, Union, Intersection and Except\nAggregate Functions\nExample: avg((1,2,3))\nResult: 2\nExample: max((1,2,3))\nResult: 3\nExample: max(('a', 'k'))\nResult: 'k'\nExample: min((1,2,3))\nResult: 1\nExample: min(('a', 'k'))\nResult: 'a'\nFunctions that Generate Sequences\nContext Functions\nExample: //book[position()<=3]\nResult: Selects the first three book elements\nExample: //book[last()]\nResult: Selects the last book element\nXSLT Functions\nIn addition, there are the following built-in XSLT functions:",
      "examples": []
    }
  ],
  "glossary": [
    "ajax applications",
    "ajax asp",
    "ajax database",
    "ajax php",
    "ajax request",
    "ajax response",
    "ajax xmlhttp",
    "backend",
    "dom accessing",
    "dom attribute",
    "dom cdata",
    "dom comment",
    "dom document",
    "dom element",
    "dom namednodemap",
    "dom navigating",
    "dom node",
    "dom nodelist",
    "dom nodes",
    "dom parser",
    "dom text",
    "dom traversing",
    "dom xmlhttprequest",
    "dtd attributes",
    "dtd elements",
    "dtd entities",
    "exercises",
    "free",
    "header",
    "javascript",
    "note",
    "programs",
    "references",
    "report error",
    "w3schools spaces",
    "xml ajax",
    "xml attributes",
    "xml display",
    "xml dom",
    "xml dtd",
    "xml elements",
    "xml home",
    "xml httprequest",
    "xml namespaces",
    "xml parser",
    "xml quiz",
    "xml rdf",
    "xml rss",
    "xml schema",
    "xml server",
    "xml soap",
    "xml syllabus",
    "xml syntax",
    "xml tree",
    "xml validator",
    "xml wsdl",
    "xml xlink",
    "xml xpath",
    "xml xquery",
    "xml xslt",
    "xpath axes",
    "xpath nodes",
    "xpath operators",
    "xpath syntax",
    "xquery add",
    "xquery flwor",
    "xquery functions",
    "xquery html",
    "xquery select",
    "xquery syntax",
    "xquery terms",
    "xsd  any",
    "xsd  anyattribute",
    "xsd  schema",
    "xsd attributes",
    "xsd elements",
    "xsd empty",
    "xsd indicators",
    "xsd misc",
    "xsd mixed",
    "xsd numeric",
    "xsd reference",
    "xsd restrictions",
    "xsd schema",
    "xsd string",
    "xsd substitution",
    "xsl languages",
    "xslt  choose",
    "xslt  if",
    "xslt  sort",
    "xslt  template",
    "xslt apply",
    "xslt elements",
    "xslt transform"
  ],
  "objectives": [
    "What is XML?",
    "How does XML work?",
    "How can I use XML?",
    "What can I use XML for?"
  ]
}