{
  "course_name": "Vue",
  "description": "Vue is a popular JavaScript framework. User interfaces built in Vue updates automatically when data changes. Vue is easy to learn. This tutorial is specially designed to help you learn Vue as quickly and efficiently as possible. First, you will learn the basics of Vue: text interpolation, directives, and how to incorporate events and forms into your project. Then you will learn everything else you need to know about Vue: Computed properties, watchers, methods, setup for Single-File Components (SFCs, *.vue files), and more. In every chapter, you can edit the examples online, and click on a button to view the result. REMOVE ADS Before you study Vue, you should have a basic understanding of: Evan You, a Google employee using AngularJS, started to develop Vue in 2013. Vue version 1.0 was released in 2015. What is the name of the programming language missing here? Start the Exercise Learn by taking a quiz! The quiz will give you a signal of how much you know about Vue.",
  "course_summary": [
    {
      "title": "Vue Introduction",
      "summary": "Vue is a JavaScript framework. It can be added to an HTML page with a <script> tag.\nVue extends HTML attributes with Directives, and binds data to HTML with Expressions.\nVue is a JavaScript Framework\nVue is a front-end JavaScript framework written in JavaScript.\nSimilar frameworks to Vue are React and Angular, but Vue is more lightweight and easier to start with.\nVue is distributed as a JavaScript file, and can be added to a web page with a script tag:\nWhy Learn Vue?\nIt is simple and easy to use.\nIt is able to handle both simple and complex projects.\nIts growing popularity and open-source community support.\nIn normal JavaScript we need to write HOW HTML and JavaScript is connected, but in Vue we simply need to make sure that there IS a connection and let Vue take care of the rest.\nIt allows for a more efficient development process with a template-based syntax, two-way data binding, and a centralized state management.\nIf some of these points are hard to understand, don't worry, you will understand at the end of the tutorial.\nThe Options API\nThere are two different ways to write code in Vue: The Options API and The Composition API.\nThe underlying concepts are the same for both the Options API and Composition API, so after learning one, you can easily switch to the other.\nThe Options API is what is written in this tutorial because it is considered to be more beginner-friendly, with a more recognizable structure.\nTake a look at this page at the end of this tutorial to learn more about the differences between the Options API and the Composition API.\nMy first page\nWe will now learn how we can create our very first Vue web page, in 5 basic steps:\nStart with a basic HTML file.\nAdd a <div> tag with id=\"app\" for Vue to connect with.\nTell the browser how to handle Vue code by adding a <script> tag with a link to Vue.\nAdd a <script> tag with the Vue instance inside.\nConnect the Vue instance to the <div id=\"app\"> tag.\nThese steps are described in detail below, with the full code in a 'Try It Yourself' example in the end.\nStep 1: HTML page\nStart with a simple HTML page:\nStep 2: Add a <div>\nVue needs an HTML element on your page to connect to.\nPut a <div> tag inside the <body> tag and give it an id:\nStep 3: Add a link to Vue\nTo help our browser to interpret our Vue code, add this <script> tag:\nStep 4: Add the Vue instance\nNow we need to add our Vue code.\nThis is called the Vue instance and can contain data and methods and other things, but now it just contains a message.\nOn the last line in this <script> tag our Vue instance is connected to the <div id=\"app\"> tag:\nStep 5: Display 'message' with Text Interpolation\nFinally, we can use text interpolation, a Vue syntax with double curly braces {{ }} as a placeholder for data.\nThe browser will exchange {{ message }} with the text stored in the 'message' property inside the Vue instance.\nHere is our very first Vue page:\nExample: My first Vue page!Get your own Vue Server\nTest this code with the 'Try it Yourself' button below.\nText Interpolation\nText interpolation is when text is taken from the Vue instance to show on the web page.\nThe browser receives the page with this code inside:\nThen the browser finds the text inside the 'message' property of the Vue instance and translates the Vue code into this:\nJavaScript in Text Interpolation\nSimple JavaScript expressions can also be written inside the double curly braces {{ }}.\nExample\nUse JavaScript syntax to add a random number to the message inside the div element:\nGet Started\nThis tutorial will teach you the basics of Vue.\nYou need basic prior experience with HTML, CSS and JavaScript to follow this tutorial.\nClick the 'Next' button to continue with this tutorial.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nUse text interpolation to display the 'message' data property value.\nStart the Exercise",
      "examples": [
        "<script\nsrc=\"https://unpkg.com/vue@3/dist/vue.global.js\">\n</script>",
        "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<title>My first Vue page</title>\n</head>\n<body>\n\n</body>\n</html>",
        "<body>\n<div id=\"app\"></div>\n</body>",
        "<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>",
        "<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n<script>\n\nconst app = Vue.createApp({\ndata() {\nreturn {\nmessage: \"Hello World!\"\n}\n}\n})\n\napp.mount('#app')\n\n</script>",
        "<div id=\"app\"> {{ message }} </div>",
        "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<title>My first Vue page</title>\n</head>\n<body>\n\n<div id=\"app\">\n{{ message }}\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nmessage: \"Hello World!\"\n}\n}\n})\n\napp.mount('#app')\n\n</script>\n</body>\n</html>",
        "<div id=\"app\">Hello World!</div>",
        "<div id=\"app\">\n{{ message }} <br>\n{{'Random number: ' + Math.ceil(Math.random()*6) }}\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n<script>\n\nconst app = Vue.createApp({\ndata() {\nreturn {\nmessage: \"Hello World!\"\n}\n}\n})\n\napp.mount('#app')\n\n</script>",
        "<div id=\"app\"></div> <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> <script> const app = Vue.createApp({ data() { return { message: \"Hello World!\" } } }) app.mount('#app') </script>",
        "<div>",
        "id=\"app\"",
        "<script>",
        "<div id=\"app\">",
        "<body>",
        "{{ }}",
        "{{ message }}"
      ]
    },
    {
      "title": "Vue Directives",
      "summary": "Vue directives are special HTML attributes with the prefix v- that give the HTML tag extra functionality.\nVue directives connect to the Vue instance to create dynamic and reactive user interfaces.\nWith Vue, creating responsive pages is much easier and requires less code compared to traditional JavaScript methods.\nDifferent Vue Directives\nThe different Vue directives we use in this tutorial are listed below.\nExample: The v-bind DirectiveGet your own Vue Server\nThe browser finds what class to connect the <div> element to from the Vue instance.\nNote: The example above could be written much simpler without the Vue code, but be patient. The real benefits of Vue can be seen in later examples when we make pages that are responsive.\nLearning Vue at W3Schools\nWhen learning Vue at W3Schools.com, you can use our \"Try it Yourself\" tool, which shows both the code and the result. This will make it easier for you to understand every part as we move forward.\nClick 'Next' to continue the tutorial.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nFill in the missing part to connect the class attribute to the \"myClass\" data property.\nStart the Exercise",
      "examples": [
        "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<style>\n.pinkBG {\nbackground-color: lightpink;\n}\n</style>\n</head>\n<body>\n\n<div id=\"app\">\n<div v-bind:class=\"vueClass\"></div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nvueClass: \"pinkBG\"\n}\n}\n})\napp.mount('#app')\n</script>\n</body>\n</html>",
        "<p :class=\"myClass\"></p>",
        "v-",
        "v-bind",
        "v-if",
        "v-else-if",
        "v-else",
        "v-show",
        "v-for",
        "v-on",
        "v-model",
        "<form>",
        "<input>",
        "<button>"
      ]
    },
    {
      "title": "Vue v-bind Directive",
      "summary": "You have already seen that a basic Vue setup consists of a Vue instance and that we can access it from the <div id=\"app\"> tag with {{ }} or the v-bind directive.\nOn this page we will explain the v-bind directive in more detail.\nThe v-bind Directive\nThe v-bind directive lets us bind an HTML attribute to data in the Vue instance. This makes it easy to change the attribute value dynamically.\nSyntaxGet your own Vue Server\nExample\nThe src attribute value of an <img> tag is taken from the Vue instance data property 'url':\nCSS Binding\nWe can use the v-bind directive to do in-line styling and modify classes dynamically. We will show you briefly how to do that in this section, and later in this tutorial, on the CSS Binding page, we will explain this in more detail.\nBind style\nIn-line styling with Vue is done by binding the style attribute to Vue with v-bind.\nAs a value to the v-bind directive, we can write a JavaScript object with the CSS property and value:\nExample\nThe font size depends on the Vue data property 'size'.\nWe can also separate the font size number value from the font size unit if we want to, like this:\nExample\nThe font size number value is stored the Vue data property 'size'.\nWe could also write the CSS property name with CSS syntax (kebab-case) in hyphens, but it is not recommended:\nExample\nThe CSS property fontSize is referred to as 'font-size'.\nExample\nThe background color depends on the 'bgVal' data property value inside the Vue instance.\nExample\nThe background color is set with a JavaScript conditional (ternary) expression depending on whether the 'isImportant' data property value is 'true' or 'false'.\nBind class\nWe can use v-bind to change the class attribute.\nThe value of v-bind:class can be a variable:\nExample\nThe class name is taken from the 'className' Vue data property:\nThe value of v-bind:class can also be an object, where the class name will only take effect if it is set to 'true':\nExample\nThe class attribute is assigned or not depending on if the class 'myClass' is set to 'true' or 'false':\nWhen the value of v-bind:class is an object, the class can be assigned depending on a Vue property:\nExample\nThe class attribute is assigned depending on the 'isImportant' property, if it is 'true' or 'false':\nShorthand for v-bind\nThe shorthand for 'v-bind:' is simply ':'.\nExample\nHere we just write ':' instead of 'v-bind:':\nWe will continue to use v-bind: syntax in this tutorial to avoid confusion.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nProvide the missing code so that the class is set equal to the 'className' data property, using a Vue directive shorthand.\nStart the Exercise",
      "examples": [
        "<div v-bind:[attribute]=\"[Vue data]\"></div>",
        "<img v-bind:src=\"url\">",
        "<div v-bind:style=\"{ fontSize: size }\">\nText example\n</div>",
        "<div v-bind:style=\"{ fontSize: size + 'px' }\">\nText example\n</div>",
        "<div v-bind:style=\"{ 'font-size': size + 'px' }\">\nText example\n</div>",
        "<div v-bind:style=\"{ backgroundColor: 'hsl('+bgVal+',80%,80%)' }\">\nNotice the background color on this div tag.\n</div>",
        "<div v-bind:style=\"{ backgroundColor: isImportant ? 'lightcoral' : 'lightgray' }\">\nConditional background color\n</div>",
        "<div v-bind:class=\"className\">\nThe class is set with Vue\n</div>",
        "<div v-bind:class=\"{ myClass: true }\">\nThe class is set conditionally to change the background color\n</div>",
        "<div v-bind:class=\"{ myClass: isImportant }\">\nThe class is set conditionally to change the background color\n</div>",
        "<div :class=\"{ impClass: isImportant }\">\nThe class is set conditionally to change the background color\n</div>",
        "<div =\"className\"> The class is set with Vue </div>",
        "v-bind",
        "<div id=\"app\">",
        "{{ }}",
        "src",
        "<img>",
        "v-bind:class",
        "class",
        "v-bind:",
        ":"
      ]
    },
    {
      "title": "Vue v-if Directive",
      "summary": "It is a lot easier to create an HTML element depending on a condition in Vue with the v-if directive than with plain JavaScript.\nWith Vue you just write the if-statement directly in the HTML element you want to create conditionally. It's that simple.\nConditional Rendering in Vue\nConditional rendering in Vue is done by using the v-if, v-else-if and v-else directives.\nConditional rendering is when an HTML element is created only if a condition is true, i.e. create the text \"In stock\" if a variable is 'true', or 'Not in stock' if that variable is 'false'.\nExampleGet your own Vue Server\nWrite different messages depending on whether there are any typewriters in stock or not:\nConditions in Vue\nA condition, or \"if-statement\", is something that is either true or false.\nA condition is often a comparison check between two values like in the example above to see if one value is greater than the other.\nWe use comparison operators like <, >= or !== to do such checks.\nWe use comparison operators like <, >= or !== to do such checks.\nComparison checks can also be combined with logical operators such as && or ||.\nComparison checks can also be combined with logical operators such as && or ||.\nGo to our JavaScript tutorial page to find out more about JavaScript comparisons.\nGo to our JavaScript tutorial page to find out more about JavaScript comparisons.\nWe can use the number of typewriters in storage with a comparison check to decide if they are in stock or not:\nExample\nUse a comparison check to decide whether to write \"In stock\" or \"Not in stock\" depending on the number of typewriters in storage.\nDirectives for Conditional Rendering\nThis overview describes how the different Vue directives used for conditional rendering are used together.\nTo see an example with all three directives shown above, we can expand the previous example with v-else-if so that the user sees 'In stock', 'Very few left!' or 'Out of stock':\nExample\nUse a comparison check to decide whether to write \"In stock\", \"Very few left!\" or \"Not in stock\" depending on the number of typewriters in storage.\nUse The Return Value from a Function\nInstead of using a comparison check with the v-if directive, we can use the 'true' or 'false' return value from a function:\nExample\nIf a certain text contains the word 'pizza', create a <p> tag with an appropriate message. The 'includes()' method is a native JavaScript method that checks if a text contain certain words.\nThe example above can be expanded to show that v-if also can create other tags like <div> and <img> tags:\nExample\nIf a certain text contains the word 'pizza', create a <div> tag with a pizza image and a <p> tag with a message. The 'includes()' method is a native JavaScript method that check if a text contain certain words.\nBelow the example is expanded even more.\nExample\nIf a certain text contains the word 'pizza' or 'burrito' or none of these words, different images and texts will be created.\nWith Vue we can now write code that create elements under certain conditions in a much easier way than with traditional JavaScript.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nFill in the missing part so that Vue toggles the visibility of the <div> tag below for us, depending on the 'typewritersInStock' boolean data property.\nStart the Exercise",
      "examples": [
        "<p v-if=\"typewritersInStock\">\nin stock\n</p>\n\n<p v-else>\nnot in stock\n</p>",
        "<p v-if=\"typewriterCount > 0\">\nin stock\n</p>\n\n<p v-else>\nnot in stock\n</p>",
        "<p v-if=\"typewriterCount>3\">\nIn stock\n</p>\n\n<p v-else-if=\"typewriterCount>0\">\nVery few left!\n</p>\n\n<p v-else>\nNot in stock\n</p>",
        "<div id=\"app\">\n<p v-if=\"text.includes('pizza')\">The text includes the word 'pizza'</p>\n<p v-else>The word 'pizza' is not found in the text</p>\n</div>",
        "data() {\nreturn {\ntext: 'I like taco, pizza, Thai beef salad, pho soup and tagine.'\n}\n}",
        "<div id=\"app\">\n<div v-if=\"text.includes('pizza')\">\n<p>The text includes the word 'pizza'</p>\n<img src=\"img_pizza.svg\">\n</div>\n<p v-else>The word 'pizza' is not found in the text</p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntext: 'I like taco, pizza, Thai beef salad, pho soup and tagine.'\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<div v-if=\"text.includes('pizza')\">\n<p>The text includes the word 'pizza'</p>\n<img src=\"img_pizza.svg\">\n</div>\n<div v-else-if=\"text.includes('burrito')\">\n<p>The text includes the word 'burrito', but not 'pizza'</p>\n<img src=\"img_burrito.svg\">\n</div>\n<p v-else>The words 'pizza' or 'burrito' are not found in the text</p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntext: 'I like taco, pizza, Thai beef salad, pho soup and tagine.'\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\"> <p =\"typewritersInStock\"> in stock </p> <p > not in stock </p> </div> <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> <script> const app = Vue.createApp({ data() { return { typewritersInStock: true } } }) app.mount('#app') </script>",
        "v-if",
        "v-else-if",
        "v-else",
        "true",
        "false",
        "<",
        ">=",
        "!==",
        "&&",
        "||"
      ]
    },
    {
      "title": "Vue v-show Directive",
      "summary": "Learn how to make an element visible or not with v-show.\nv-show is easy to use because the condition is written right in the HTML tag attribute.\nConditional Visibility\nThe v-show directive hides an element when the condition is 'false' by setting the CSS 'display' property value to 'none'.\nAfter writing v-show as an HTML attribute we must give a conditon to decide to have the tag visible or not.\nSyntaxGet your own Vue Server\nIn the code above, 'showDiv' represents a boolean Vue data property with either 'true' or 'false' as property value. If 'showDiv' is 'true' the div tag is shown, and if it is 'false' the tag is not shown.\nExample\nDisplay the <div> element only if the showDiv property is set to 'true'.\nv-show vs. v-if\nThe difference between v-show and v-if is that v-if creates (renders) the element depending on the condition, but with v-show the element is already created, v-show only changes its visibility.\nTherefore, it is better to use v-show when switching visibility of an object, because it is easier for the browser to do, and it can lead to a faster response and better user experience.\nA reason for using v-if over v-show is that v-if can be used with v-else-if and v-else.\nIn the example below v-show and v-if are used separately on two different <div> elements, but based on the same Vue property. You can open the example and inspect the code to see that v-show keeps the <div> element, and only sets the CSS display property to 'none', but v-if actually destroys the <div> element.\nExample\nDisplay the two <div> elements only if the showDiv property is set to 'true'. If the showDiv property is set to 'false' and we inspect the example page with the browser we can see that the <div> element with v-if is destroyed, but the <div> element with v-show has just CSS display property set to 'none'.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nFill in the missing part so that Vue toggles the visibility of the <div> tag below for us, depending on the 'lightOn' boolean data property.\nStart the Exercise",
      "examples": [
        "<div v-show=\"showDiv\">This div tag can be hidden</div>",
        "<div id=\"app\">\n<div v-show=\"showDiv\">This div tag can be hidden</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nshowDiv: true\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<div v-show=\"showDiv\">Div tag with v-show</div>\n<div v-if=\"showDiv\">Div tag with v-if</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nshowDiv: true\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\"> <div id=\"lightDiv\"> <div =\"lightOn\"></div> <img src=\"img_lightBulb.svg\"> </div> <button v-on:click=\" lightOn =! lightOn \">Switch light</button> </div> <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> <script> const app = Vue.createApp({ data() { return { lightOn: false } } }) app.mount('#app') </script>",
        "v-show",
        "v-if",
        "v-else-if",
        "v-else"
      ]
    },
    {
      "title": "Vue v-for Directive",
      "summary": "With normal JavaScript you might want to create HTML elements based on an array. You use a for-loop, and inside you need to create the elements, adjust them, and then add each element to your page. And these elements will not react to a change in the array.\nWith Vue you start with the HTML element you want to create into a list, with v-for as an attribute, refer to the array inside the Vue instance, and let Vue take care of the rest. And the elements created with v-for will automatically update when the array changes.\nList Rendering\nList rendering in Vue is done by using the v-for directive, so that several HTML elements are created with a for-loop.\nBelow are three slightly different examples where v-for is used.\nExampleGet your own Vue Server\nDisplay a list based on the items of an array.\nLoop Through an Array\nLoop through an array to display different images:\nExample\nShow images of food, based on an array in the Vue instance.\nLoop Through Array of Objects\nLoop through an array of objects and display the object properties:\nExample\nShow both images and names of different types of food, based on an array in the Vue instance.\nGet the index\nThe index number of an array element can be really useful in JavaScript for-loops. Luckily we can get the index number when using v-for in Vue as well.\nTo get the index number with v-for we need to give two comma separated words in parentheses: the first word will be the array element, and the second word will be the index of that array element.\nExample\nShow index number and food name of elements in the 'manyFoods' array in the Vue instance.\nWe can also display both array element index and information from the array element itself, if the array elements are objects:\nExample\nShow both the array element index number, and text from the objects in the 'manyFoods' array.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nList rendering in Vue can be done so that several HTML elements are created based on an array.\nWhat Vue directive makes this possible?\nStart the Exercise",
      "examples": [
        "<ol>\n<li v-for=\"x in manyFoods\">{{ x }}</li>\n</ol>",
        "<div>\n<img v-for=\"x in manyFoods\" v-bind:src=\"x\">\n</div>",
        "<div>\n<figure v-for=\"x in manyFoods\">\n<img v-bind:src=\"x.url\">\n<figcaption>{{ x.name }}</figcaption>\n</figure>\n</div>",
        "<p v-for=\"(x, index) in manyFoods\">\n{{ index }}: \"{{ x }}\" <br>\n</p>",
        "<p v-for=\"(x, index) in manyFoods\">\n{{ index }}: \"{{ x.name }}\", url: \"{{ x.url }}\" <br>\n</p>",
        "v-",
        "v-for"
      ]
    },
    {
      "title": "Vue Events",
      "summary": "Event handling in Vue is done with the v-on directive, so that we can make something happen when for example a button is clicked.\nEvent handling is when HTML elements are set up to run a certain code when a certain event happens.\nEvents in Vue are easy to use and will make our page truly responsive.\nVue methods are code that can be set up to run when an event happens.\nWith v-on modifiers you can describe in more detail how to react to an event.\nGet started with events\nLets start with an example to show how we can click a button to count moose in a forest.\nWe need:\nA button\nv-on on the <button> tag to listen to the 'click' event\nCode to increase the number of moose\nA property (variable) in the Vue instance to hold the number of moose\nDouble curly braces {{}} to show the increased number of moose\nExampleGet your own Vue Server\nClick the button to count one more moose in the forest. The count property increases each time the button is clicked.\nNote: A benefit that comes with Vue is that the number of moose in the <p> tag is updated automatically. With plain JavaScript we would need to update the number the user sees with an additional line of code.\nEvents\nThere are lots of events we can use as triggers for running code, among the most common ones are: 'click', 'mouseover', 'mouseout', 'keydown' and 'input'.\nFor a complete list of events to use you can visit our HTML DOM Events page.\n'v-on'\nThe v-on directive allows us to create pages that respond to what the user does.\nThe Vue v-on works by telling the browser what event to listen to, and what to do when that event occurs.\nMethods\nIf we want to run more complex code when an event occurs we can put the code in a Vue method and refer to this method from the HTML attribute, like this:\nEvent Modifiers\nIn addition to v-on and Vue methods we can use something called event modifiers to modify an event so that it for example only happens once after a page is loaded, or modify an event like 'submit' to prevent a form from being submitted.\nLearn More\nAs we can see, there are three techniques we need to learn about to use events in Vue:\nThe Vue v-on directive\nVue methods\nVue v-on modifiers\nClick 'Next' to continue this tutorial and learn more about these techniques for event handling.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nFill in the missing field.\nStart the Exercise",
      "examples": [
        "<div id=\"app\">\n<img src=\"img_moose.jpg\">\n<p>{{ \"Moose count: \" + count }}</p>\n<button v-on:click=\"count++\">Count moose</button>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ncount: 0\n}\n}\n})\napp.mount('#app')\n</script>",
        "<p v-on:click=\"changeColor\">Click me</p>",
        "In Vue, events are handled with the directive.",
        "v-on",
        "{{}}"
      ]
    },
    {
      "title": "Vue v-on Directive",
      "summary": "Like event handling in plain JavaScript, the v-on directive in Vue tells the browser:\nwhich event to listen to ('click', 'keydown', 'mouseover', etc)\nwhat to do when that event occurs\nExamples using v-on\nLet's take a look at some examples to see how v-on can be used with different events and different code to run when these events occur.\nNote: To run more advanced code when an event occurs we need to introduce Vue methods. Learn about Vue methods on the next page in this tutorial.\nonclick Event\nThe v-on directive allows us to perform actions based on specified events.\nUse v-on:click to perform action when the element is clicked.\nExampleGet your own Vue Server\nThe v-on directive is used on the <button> tag to listen to the 'click' event. When the 'click' event occurs the 'lightOn' data property is toggled between 'true' and 'false', making the yellow <div> behind the lightbulb visible/hidden.\noninput Event\nUse v-on:input to perform action when the element gets an input, like a keystroke inside a text field.\nExample\nCount the number of keystroke for a input text field:\nmousemove Event\nUse v-on:mousemove to perform action when the mouse pointer moves over an element.\nExample\nChange the background color of a <div> element whenever the mouse pointer moves over it:\nUse v-on in a v-for Loop\nYou can also use the v-on directive inside a v-for loop.\nThe items of the array are available for each iteration inside the v-on value.\nExample\nDisplay a list based on the food array and add an click event for each item that will use a value from the array item to change the source of an image.\nShorthand for v-on\nThe shorthand for 'v-on' is simply '@'.\nExample\nHere we just write '@' instead of 'v-on':\nWe will start using @ syntax a little later in this tutorial.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nComplete the code so that the image toggles when the button is clicked.\nStart the Exercise",
      "examples": [
        "<div id=\"app\">\n<div id=\"lightDiv\">\n<div v-show=\"lightOn\"></div>\n<img src=\"img_lightBulb.svg\">\n</div>\n<button v-on:click=\"lightOn = !lightOn\">Switch light</button>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nlightOn: false\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<input v-on:input=\"inpCount++\">\n<p>{{ 'Input events occured: ' + inpCount }}</p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ninpCount: 0\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<p>Move the mouse pointer over the box below</p>\n<div v-on:mousemove=\"colorVal=Math.floor(Math.random()*360)\"\nv-bind:style=\"{backgroundColor:'hsl('+colorVal+',80%,80%)'}\">\n</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ncolorVal: 50\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<img v-bind:src=\"imgUrl\">\n<ol>\n<li v-for=\"food in manyFoods\" v-on:click=\"imgUrl=food.url\">\n{{ food.name }}\n</li>\n</ol>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nimgUrl: 'img_salad.svg',\nmanyFoods: [\n{name: 'Burrito', url: 'img_burrito.svg'},\n{name: 'Salad', url: 'img_salad.svg'},\n{name: 'Cake', url: 'img_cake.svg'},\n{name: 'Soup', url: 'img_soup.svg'}\n]\n}\n}\n})\napp.mount('#app')\n</script>",
        "<button @:click=\"lightOn = !lightOn\">Switch light</button>",
        "<template> <button =\"showImg = !showImg\"> Toggle image </button> <img src=\"flower.jpg\" alt=\"flower\" v-show=\"showImg\"> </template> <script> export default { data() { return { : true } } } </script>",
        "v-on",
        "v-on:click",
        "v-on:input",
        "v-on:mousemove",
        "v-for",
        "@"
      ]
    },
    {
      "title": "Vue Methods",
      "summary": "Vue methods are functions that belong to the Vue instance under the 'methods' property.\nVue methods are great to use with event handling (v-on) to do more complex things.\nVue methods can also be used to do other things than event handling.\nThe Vue 'methods' Property\nWe have already used one Vue property in this tutorial, the 'data' property, where we can store values.\nThere is another Vue property called 'methods' where we can store functions that belong to the Vue instance. A method can be stored in the Vue instance like this:\nTip: We need to write this. as prefix to refer to a data property from inside a method.\nTo call the 'writeText' method when we click the <div> element we can write the code below:\nThe example looks like this:\nExampleGet your own Vue Server\nThe v-on directive is used on the <div> element to listen to the 'click' event. When the 'click' event occurs the 'writeText' method is called and the text is changed.\nCall a Method with the Event Object\nWhen an event occurs so that a method is called, the event object is passed with the method by default. This is very convenient because the event object contains a lot of useful data, like for example the target object, the event type, or the mouse position when the 'click' or 'mousemove' event occurred.\nExample\nThe v-on directive is used on the <div> element to listen to the 'mousemove' event. When the 'mousemove' event occurs the 'mousePos' method is called and the event object is sent with the method by default so we can get the mouse pointer position.\nWe must use the this. prefix to refer to \"xPos\" inside the Vue instance data property from the method.\nIf we expand the example above by just one line, we can also make the background color change based on the mouse pointer position in the x-direction. The only thing we need to add is v-bind to change the background-color in the style attribute:\nExample\nThe difference here from the example above is that the background color is bound to 'xPos' with v-bind so that hsl 'hue' value is set equal to 'xPos'.\nIn the example below the event object carries a text from the <textarea> tag to make it look like we are writing inside a notebook.\nExample\nThe v-on directive is used on the <textarea> tag to listen to the 'input' event which occurs whenever there is a change in the text inside the textarea element.\nWhen the 'input' event occurs the 'writeText' method is called and the event object is sent with the method by default so we can get the text from the <textarea> tag. The 'text' property in the Vue instance is updated by the 'writeText' method. A span element is set up to show the 'text' value with the double curly braces syntax, and this is updated automatically by Vue.\nPassing Arguments\nSometimes we want to pass an argument with the method when an event occurs.\nLets say you work as a forest ranger, and you want to keep count of moose sightings. Sometimes one or two moose are seen, other times over 10 moose might be seen during a day. We add buttons to count sightings '+1' and '+5', and a '-1' button in case we have counted too many.\nIn this case we can use the same method for all three buttons, and just call the method with a different number as an argument from the different buttons. This is how we can call a method with an argument:\nAnd this is how the 'addMoose' method looks like:\nLets see how passing an argument with a method works in a full example.\nExample\nPassing both an Argument and The Event Object\nIf we want to pass both the event object and another argument, there is a reserved name '$event' we can use where the method is called, like this:\nAnd this is how the method in the Vue instance looks like:\nNow let us look at an example to see how to pass both the event object and another argument with a method.\nExample\nIn this example our method receives both the event object and a text.\nLarger Example\nIn this example we see that it is possible to use only one method to count three different animals with three different increments for each animal. We achieve this by passing both the event object and the increment number:\nExample\nBoth the increment size and the event object are passed as arguments with the method when a button is clicked. The reserved word '$event' is used to pass the event object with the method to tell what animal to count.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWrite the missing code so that the 'writeText' method is called when the <div> tag is clicked.\nStart the Exercise",
      "examples": [
        "const app = Vue.createApp({\ndata() {\nreturn {\ntext: ''\n}\n},\nmethods: {\nwriteText() {\nthis.text = 'Hello World!'\n}\n}\n})",
        "<div v-on:click=\"writeText\"></div>",
        "<div id=\"app\">\n<p>Click on the box below:</p>\n<div v-on:click=\"writeText\">\n{{ text }}\n</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntext: ''\n}\n},\nmethods: {\nwriteText() {\nthis.text = 'Hello World!'\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<p>Move the mouse pointer over the box below:</p>\n<div v-on:mousemove=\"mousePos\"></div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nxPos: 0,\nyPos: 0\n}\n},\nmethods: {\nmousePos(event) {\nthis.xPos = event.offsetX\nthis.yPos = event.offsetY\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div\nv-on:mousemove=\"mousePos\"\nv-bind:style=\"{backgroundColor:'hsl('+xPos+',80%,80%)'}\">\n</div>",
        "<div id=\"app\">\n<textarea v-on:input=\"writeText\" placeholder=\"Start writing..\"></textarea>\n<span>{{ text }}</span>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntext: ''\n}\n},\nmethods: {\nwriteText(event) {\nthis.text = event.target.value\n}\n}\n})\napp.mount('#app')\n</script>",
        "<button v-on:click=\"addMoose(5)\">+5</button>",
        "methods: {\naddMoose(number) {\nthis.count = this.count + number\n}\n}",
        "<div id=\"app\">\n<img src=\"img_moose.jpg\">\n<p>{{ \"Moose count: \" + count }}</p>\n<button v-on:click=\"addMoose(+1)\">+1</button>\n<button v-on:click=\"addMoose(+5)\">+5</button>\n<button v-on:click=\"addMoose(-1)\">-1</button>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ncount: 0\n}\n},\nmethods: {\naddMoose(number) {\nthis.count+=number\n}\n}\n})\napp.mount('#app')\n</script>",
        "<button v-on:click=\"addAnimal($event, 5)\">+5</button>",
        "methods: {\naddAnimal(e, number) {\nif(e.target.parentElement.id===\"tigers\"){\nthis.tigers = this.tigers + number\n}\n}\n}",
        "<div id=\"app\">\n<img\nsrc=\"img_tiger.jpg\"\nid=\"tiger\"\nv-on:click=\"myMethod($event,'Hello')\">\n<p>\"{{ msgAndId }}\"</p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nmsgAndId: ''\n}\n},\nmethods: {\nmyMethod(e,msg) {\nthis.msgAndId = msg + ', '\nthis.msgAndId += e.target.id\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<div id=\"tigers\">\n<img src=\"img_tiger.jpg\">\n<button v-on:click=\"addAnimal($event,1)\">+1</button>\n<button v-on:click=\"addAnimal($event,5)\">+5</button>\n<button v-on:click=\"addAnimal($event,-1)\">-1</button>\n</div>\n<div id=\"moose\">\n<img src=\"img_moose.jpg\">\n<button v-on:click=\"addAnimal($event,1)\">+1</button>\n<button v-on:click=\"addAnimal($event,5)\">+5</button>\n<button v-on:click=\"addAnimal($event,-1)\">-1</button>\n</div>\n<div id=\"kangaroos\">\n<img src=\"img_kangaroo.jpg\">\n<button v-on:click=\"addAnimal($event,1)\">+1</button>\n<button v-on:click=\"addAnimal($event,5)\">+5</button>\n<button v-on:click=\"addAnimal($event,-1)\">-1</button>\n</div>\n<ul>\n<li>Tigers: {{ tigers }} </li>\n<li>Moose: {{ moose }} </li>\n<li>Kangaroos: {{ kangaroos }} </li>\n</ul>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntigers: 0,\nmoose: 0,\nkangaroos: 0\n}\n},\nmethods: {\naddAnimal(e,number) {\nif(e.target.parentElement.id===\"tigers\") {\nthis.tigers+=number\n}\nelse if(e.target.parentElement.id===\"moose\") {\nthis.moose+=number\n}\nelse {\nthis.kangaroos+=number\n}\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\"> <p>Click on the box below:</p> <div => {{ text }} </div> </div> <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> <script> const app = Vue.createApp({ data() { return { text: '' } }, : { writeText() { this. = 'Hello World!' } } }) app.mount('#app') </script>",
        "v-on",
        "this.",
        "<div>",
        "v-bind",
        "<textarea>",
        "$event"
      ]
    },
    {
      "title": "Vue Event Modifiers",
      "summary": "Event modifiers in Vue modify how events trigger the running of methods and help us handle events in a more efficient and straightforward way.\nEvent modifiers are used together with the Vue v-on directive, to for example:\nPrevent the default submit behavior of HTML forms (v-on:submit.prevent)\nMake sure that an event can only run once after the page is loaded (v-on:click.once)\nSpecify what keyboard key to use as an event to run a method (v-on:keyup.enter)\nHow To Modify The v-on Directive\nEvent modifiers are used to define how to react on an event in more detail.\nWe use event modifiers by first connecting a tag to an event like we have seen before:\nNow, to define more specifically that the button click event should only fire one time after the page loads, we can add the .once modifier, like this:\nHere is an example with the .once modifier:\nExampleGet your own Vue Server\nThe .once modifier is used on the <button> tag to only run the method the first time the 'click' event happens.\nNote: It is also possible to handle an event inside the method instead of using event modifiers, but event modifiers make it a lot easier.\nDifferent v-on Modifiers\nEvent modifiers are used in different situations. We can use event modifiers when we listen to keyboard events, mouse click events, and we can even use event modifiers in combination with each other.\nThe event modifier .once can be used after both keyboard and mouse click events.\nKeyboard Key Event Modifiers\nWe have three different keyboard event types keydown, keypress, and keyup.\nWith each key event type, we can specify exactly what key to listen to after a key event occurs. We have .space, .enter, .w and .up to name a few.\nYou can write the key event to the web page, or to the console with console.log(event.key), to find the value of a certain key yourself:\nExample\nThe keydown keyboard event triggers the 'getKey' method, and the value 'key' from the event object is written to the console and to the web page.\nWe can also choose to limit the event to happen only when a mouse click or a key press happens in combination with system modifier keys .alt, .ctrl, .shift or .meta. The system modifier key .meta represents the Windows key on Windows computers, or command key on Apple computers.\n.enter\n.tab\n.delete\n.esc\n.space\n.up\n.down\n.left\n.right\nExample\nUse the .s modifier to create an alert when the user writes an 's' inside the <textarea> tag.\nCombine Keyboard Event Modifiers\nEvent modifiers can also be used in combination with each other so that more than one thing must happen simultaneous for the method to be called.\nExample\nUse the .s and .ctrl modifiers in combination to create an alert when 's' and 'ctrl' are pressed simultaneously inside the <textarea> tag.\nMouse Button Modifiers\nTo react on a mouse click, we can write v-on:click, but to specify which mouse button that was clicked, we can use .left, .center or .right modifiers.\nTrackpad users: You might need to click with two fingers, or in the lower right hand side of the trackpad on your computer to create a right click.\nExample\nChange the background color when a user right-clicks in the <div> element:\nMouse button events can also work in combination with a system modifier key.\nExample\nChange the background color when a user right-clicks in the <div> element in combination with the 'ctrl' key:\nThe event modifier .prevent can be used in addition to the .right modifier to prevent the default drop-down menu to appear when we right click.\nExample\nThe drop-down menu is prevented from appearing when you right click to change the background color of the <div> element:\nIt would be possible to prevent the drop-down menu from appearing after right click by using event.preventDefault() inside the method, but with the Vue .prevent modifier the code becomes more readable and easier to maintain.\nYou can also react on left button mouse clicks in combination with other modifiers, like click.left.shift:\nExample\nHold the 'shift' keyboard key and press left mouse button on the <img> tag to change image.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nProvide the correct code so that the <div> element changes color when right clicked.\nALSO, add code so that the default drop down menu that appears when you right click a web page, is not shown.\nStart the Exercise",
      "examples": [
        "<button v-on:click=\"createAlert\">Create alert</button>",
        "<button v-on:click.once=\"createAlert\">Create alert</button>",
        "<div id=\"app\">\n<p>Click the button to create an alert:</p>\n<button v-on:click.once=\"creteAlert\">Create Alert</button>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\nmethods: {\ncreateAlert() {\nalert(\"Alert created from button click\")\n}\n}\n})\napp.mount('#app')\n</script>",
        "<input v-on:keydown=\"getKey\">\n<p> {{ keyValue }} </p>",
        "data() {\nreturn {\nkeyValue = ''\n}\n},\nmethods: {\ngetKey(evt) {\nthis.keyValue = evt.key\nconsole.log(evt.key)\n}\n}",
        "<div id=\"app\">\n<p>Try pressing the 's' key:</p>\n<textarea v-on:keyup.s=\"createAlert\"></textarea>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\nmethods: {\ncreateAlert() {\nalert(\"You pressed the 'S' key!\")\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<p>Try pressing the 's' key:</p>\n<textarea v-on:keydown.ctrl.s=\"createAlert\"></textarea>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\nmethods: {\ncreateAlert() {\nalert(\"You pressed the 'S' and 'Ctrl' keys, in combination!\")\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<div v-on:click.right=\"changeColor\"\nv-bind:style=\"{backgroundColor:'hsl('+bgColor+',80%,80%)'}\">\n<p>Press right mouse button here.</p>\n</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nbgColor: 0\n}\n},\nmethods: {\nchangeColor() {\nthis.bgColor+=50\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<div v-on:click.right.ctrl=\"changeColor\"\nv-bind:style=\"{backgroundColor:'hsl('+bgColor+',80%,80%)'}\">\n<p>Press right mouse button here.</p>\n</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nbgColor: 0\n}\n},\nmethods: {\nchangeColor() {\nthis.bgColor+=50\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<div v-on:click.right.prevent=\"changeColor\"\nv-bind:style=\"{backgroundColor:'hsl('+bgColor+',80%,80%)'}\">\n<p>Press right mouse button here.</p>\n</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nbgColor: 0\n}\n},\nmethods: {\nchangeColor() {\nthis.bgColor+=50\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<p>Hold 'Shift' key and press left mouse button:</p>\n<img v-on:click.left.shift=\"changeImg\" v-bind:src=\"imgUrl\">\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nimgUrlIndex: 0,\nimgUrl: 'img_tiger_square.jpeg',\nimgages: [\n'img_tiger_square.jpeg',\n'img_moose_square.jpeg',\n'img_kangaroo_square.jpeg'\n]\n}\n},\nmethods: {\nchangeImg() {\nthis.imgUrlIndex++\nif(this.imgUrlIndex>=3){\nthis.imgUrlIndex=0\n}\nthis.imgUrl = this.images[this.imgUrlIndex]\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\"> <div v-on:click.=\"changeColor\" v-bind:style=\"{backgroundColor:'hsl('+bgColor+',80%,80%)'}\"> <p>Press right mouse button here.</p> </div> </div> <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> <script> const app = Vue.createApp({ data() { return { bgColor: 0 } }, methods: { changeColor() { this.bgColor+=50 } } }) app.mount('#app') </script>",
        "v-on",
        "v-on:submit.prevent",
        "v-on:click.once",
        "v-on:keyup.enter",
        ".once",
        "<button>",
        "keydown",
        "keypress",
        "keyup",
        ".space",
        ".enter",
        ".w",
        ".up",
        "console.log(event.key)",
        ".alt",
        ".ctrl",
        ".shift",
        ".meta",
        ".[Vue key alias]",
        ".tab",
        ".delete",
        ".esc",
        ".down",
        ".left",
        ".right",
        ".[letter]",
        ".s",
        ".[system modifier key]",
        "<textarea>",
        "v-on:click",
        ".center",
        "<div>",
        ".prevent",
        "event.preventDefault()",
        "click.left.shift",
        "<img>"
      ]
    },
    {
      "title": "Vue Forms",
      "summary": "Vue gives us an easy way to improve the user experience with forms by adding extra functionality like responsiveness and form validation.\nVue uses the v-model directive when handling forms.\nOur First Form with Vue\nLets start with a simple shopping list example to see how Vue can be used when creating a form.\nFor more information about forms in HTML, with related tags and attributes, see our HTML Forms tutorial.\n1. Add standard HTML form elements:\n2. Create the Vue instance with the current item name, number and the shopping list, and use v-model to connect our inputs to it.\n3. Call the method to add an item to the shopping list, and prevent the default browser refresh on submit.\n4. Create the method that adds the item to the shopping list, and clears the form:\n5. Use v-for to show an automatically updated shopping list below the form:\nBelow is the final code for our first Vue form.\nExampleGet your own Vue Server\nIn this example we can add new items to a shopping list.\nNotice the two-way binding v-model provides in the example above:\nv-model updates the Vue instance data when the HTML input change\nv-model also updates the HTML input when the Vue instance data changes\nTo learn more about v-model and see more form examples, click 'Next'.",
      "examples": [
        "<form>\n<p>Add item</p>\n<p>Item name: <input type=\"text\" required></p>\n<p>How many: <input type=\"number\"></p>\n<button type=\"submit\">Add item</button>\n</form>",
        "<div id=\"app\">\n<form>\n<p>Add item</p>\n<p>Item name: <input type=\"text\" required v-model=\"itemName\"></p>\n<p>How many: <input type=\"number\" v-model=\"itemNumber\"></p>\n<button type=\"submit\">Add item</button>\n</form>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nitemName: null,\nitemNumber: null,\nshoppingList: [\n{ name: 'Tomatoes', number: 5 }\n]\n}\n}\n})\napp.mount('#app')\n</script>",
        "<form v-on:submit.prevent=\"addItem\">",
        "methods: {\naddItem() {\nlet item = {\nname: this.itemName,\nnumber: this.itemNumber\n}\nthis.shoppingList.push(item);\nthis.itemName = null\nthis.itemNumber = null\n}\n}",
        "<p>Shopping list:</p>\n<ul>\n<li v-for=\"item in shoppingList\">{{item.name}}, {{item.number}}</li>\n</ul>",
        "<div id=\"app\">\n<form v-on:submit.prevent=\"addItem\">\n<p>Add item</p>\n<p>Item name: <input type=\"text\" required v-model=\"itemName\"></p>\n<p>How many: <input type=\"number\" v-model=\"itemNumber\"></p>\n<button type=\"submit\">Add item</button>\n</form>\n\n<p>Shopping list:</p>\n<ul>\n<li v-for=\"item in shoppingList\">{{item.name}}, {{item.number}}</li>\n</ul>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nitemName: null,\nitemNumber: null,\nshoppingList: [\n{ name: 'Tomatoes', number: 5 }\n]\n}\n},\nmethods: {\naddItem() {\nlet item = {\nname: this.itemName,\nnumber: this.itemNumber\n}\nthis.shoppingList.push(item)\nthis.itemName = null\nthis.itemNumber = null\n}\n}\n})\napp.mount('#app')\n</script>",
        "v-model",
        "v-for"
      ]
    },
    {
      "title": "Vue v-model Directive",
      "summary": "Compared to normal JavaScript, it is easier to work with forms in Vue because the v-model directive connects with all types of input elements in the same way.\nv-model creates a link between the input element value attribute and a data value in the Vue instance. When you change the input, the data updates and when the data changes, the input updates as well (two-way binding).\nTwo-way Binding\nAs we have already seen in the shopping list example on the previous page, v-model provides us with a two-way binding, meaning that the form input elements update the Vue data instance, and a change in the Vue instance data updates the inputs.\nThe example below also demonstrates the two-way binding with v-model.\nExampleGet your own Vue Server\nTwo-way binding: Try to write inside the input field to see that the Vue data property value gets updated. Try also to write directly in the code to change the Vue data property value, run the code, and see how the input field is updated.\nNote: The v-model two-way binding functionality could actually be achieved with a combination of v-bind:value and v-on:input:\nv-bind:value to update the input element from the Vue instance data,\nand v-on:input to update the Vue instance data from the input.\nBut v-model is much easier to use so that is what we will do.\nA Dynamic Checkbox\nWe add a checkbox to our shopping list on the previous page to mark if an item is important or not.\nNext to the checkbox we add a text that always reflects the current 'important' status, changing dynamically between 'true' or 'false'.\nWe use v-model to add this dynamic checkbox and text to improve user interaction.\nWe need:\na boolean value in the Vue instance data property called 'important'\na checkbox where the user can check if the item is important\na dynamic feedback text so that the user can see if the item is important\nBelow is how the 'important' feature looks, isolated from the shopping list.\nExample\nThe checkbox text is made dynamic so that the text reflects the current checkbox input value.\nLet's include this dynamic feature in our shopping list example.\nExample\nMark Found Items in The Shopping List\nLet's add functionality so that items added to the shopping list can be marked as found.\nWe need:\nthe list items to react on click\nto change the status of the clicked item to 'found', and use this to visually move the item away and strike it through with CSS\nWe create one list with all items we need to find, and one list below with items found striked through. We can actually put all the items in the first list, and all the items in the second list, and just use v-show with the Vue data property 'found' to define whether to show the item in the first or second list.\nExample\nAfter adding items to the shopping list we can pretend to go shopping, clicking the items away after finding them. If we click an item by mistake we can take it back to the 'not found' list by clicking the item once more.\nUse v-model to make The Form Itself Dynamic\nWe can make a form where the customer orders from a menu. To make it easy for the customer, we only present the drinks to choose from after the customer chooses to order drinks. This is can be argued to be better than presenting the customer with all items from the menu at once. In this example we use v-model and v-show to make the form itself dynamic.\nWe need:\nA form, with relevant input tags and 'Order' button.\nRadio-buttons to select 'Dinner', 'Drink' or 'Dessert'.\nAfter category is chosen, a dropdown menu appears with all the items in that category.\nWhen an item is chosen you see an image of it, you can choose how many and add it to the order. The form is reset when the item is added to the order.\nExample\nThis form is dynamic. It changes based on user choices. The user must first choose category, then product and how many, before the order button becomes visible and the user can order it.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nProvide the correct code so that the default browser refresh on submit is prevented.\nAlso, provide code so that the input field values get a two-way binding to the Vue data instance properties 'itemName' and 'itemNumber'.\nStart the Exercise",
      "examples": [
        "<div id=\"app\">\n<input type=\"text\" v-model=\"inpText\">\n<p> {{ inpText }} </p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ninpText: 'Initial text'\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<form>\n<p>\nImportant item?\n<label>\n<input type=\"checkbox\" v-model=\"important\">\n{{ important }}\n</label>\n</p>\n</form>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nimportant: false\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<form v-on:submit.prevent=\"addItem\">\n<p>Add item</p>\n<p>Item name: <input type=\"text\" required v-model=\"itemName\"></p>\n<p>How many: <input type=\"number\" v-model=\"itemNumber\"></p>\n<p>\nImportant?\n<label>\n<input type=\"checkbox\" v-model=\"itemImportant\">\n{{ important }}\n</label>\n</p>\n<button type=\"submit\">Add item</button>\n</form>\n<hr>\n<p>Shopping list:</p>\n<ul>\n<li v-for=\"item in shoppingList\">{{item.name}}, {{item.number}}</li>\n</ul>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nitemName: null,\nitemNumber: null,\nimportant: false,\nshoppingList: [\n{ name: 'Tomatoes', number: 5, important: false }\n]\n}\n},\nmethods: {\naddItem() {\nlet item = {\nname: this.itemName,\nnumber: this.itemNumber\nimportant: this.itemImportant\n}\nthis.shoppingList.push(item)\nthis.itemName = null\nthis.itemNumber = null\nthis.itemImportant = false\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">\n<form v-on:submit.prevent=\"addItem\">\n<p>Add item</p>\n<p>Item name: <input type=\"text\" required v-model=\"itemName\"></p>\n<p>How many: <input type=\"number\" v-model=\"itemNumber\"></p>\n<p>\nImportant?\n<label>\n<input type=\"checkbox\" v-model=\"itemImportant\">\n{{ important }}\n</label>\n</p>\n<button type=\"submit\">Add item</button>\n</form>\n\n<p><strong>Shopping list:</strong></p>\n<ul id=\"ulToFind\">\n<li v-for=\"item in shoppingList\"\nv-bind:class=\"{ impClass: item.important }\"\nv-on:click=\"item.found=!item.found\"\nv-show=\"!item.found\">\n{{ item.name }}, {{ item.number}}\n</li>\n</ul>\n<ul id=\"ulFound\">\n<li v-for=\"item in shoppingList\"\nv-bind:class=\"{ impClass: item.important }\"\nv-on:click=\"item.found=!item.found\"\nv-show=\"item.found\">\n{{ item.name }}, {{ item.number}}\n</li>\n</ul>\n\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nitemName: null,\nitemNumber: null,\nimportant: false,\nshoppingList: [\n{ name: 'Tomatoes', number: 5, important: false, found: false }\n]\n}\n},\nmethods: {\naddItem() {\nlet item = {\nname: this.itemName,\nnumber: this.itemNumber,\nimportant: this.itemImportant,\nfound: false\n}\nthis.shoppingList.push(item)\nthis.itemName = null\nthis.itemNumber = null\nthis.itemImportant = false\n}\n}\n})\napp.mount('#app')\n</script>",
        "<form v-on:=\"addItem\"> <p>Add item</p> <p> Item name: <input type=\"text\" required =\"itemName\"> </p> <p> How many: <input type=\"number\" =\"itemNumber\"> </p> <button type=\"submit\">Add item</button> </form>",
        "v-model",
        "value",
        "v-bind:value",
        "v-on:input",
        "v-show"
      ]
    },
    {
      "title": "Vue CSS Binding",
      "summary": "Learn more about how to use v-bind to modify CSS with the style and class attributes.\nWhile the concept to change the style and class attributes with v-bind is fairly straight forward, the syntax might need some getting used to.\nDynamic CSS in Vue\nYou have already seen how we can use Vue to modify CSS by using v-bind on the style and class attributes. It has been explained briefly in this tutorial under v-bind and several examples with Vue changing CSS has also been given.\nHere we will explain in more detail how CSS can be changed dynamically with Vue. But first lets look at two examples with techniques we have already seen in this tutorial: in-line styling with v-bind:style and assigning a class with v-bind:class\nInline Styling\nWe use v-bind:style to do in-line styling in Vue.\nExampleGet your own Vue Server\nAn <input type=\"range\"> element is used to change the opacity of a <div> element with the use of in-line styling.\nAssign a Class\nWe use v-bind:class to assign a class to an HTML tag in Vue.\nExample\nSelect images of food. Selected food is highlighted with the use of v-bind:class to show what you have selected.\nOther Ways to Assign Classes and Style\nHere are different aspects regarding the use of v-bind:class and v-bind:style that we have not seen before in this tutorial:\nWhen CSS classes are assigned to an HTML tag with both class=\"\" and v-bind:class=\"\" Vue merges the classes.\nAn object containing one or more classes is assigned with v-bind:class=\"{}\". Inside the object one or more classes might be toggled on or off.\nWith in-line styling (v-bind:style) camelCase is preferred when defining a CSS property, but 'kebab-case' can also be used if it is written inside quotes.\nCSS classes can be assigned with arrays / with array notation / syntax\nThese points are explained in more detail below.\n1. Vue Merges 'class' And 'v-bind:class'\nIn cases when an HTML tag belongs to a class assigned with class=\"\", and is also assigned to a class with v-bind:class=\"\", Vue merges the classes for us.\nExample\nA <div> element belongs to two classes: 'impClass' and 'yelClass'. The 'important' class is set the normal way with the class attribute, and 'yellow' class is set with v-bind:class.\n2. Assign More Than One Class With 'v-bind:class'\nWhen assigning an HTML element to a class with v-bind:class=\"{}\", we can simply use comma to separate and assign multiple classes.\nExample\nA <div> element can belong to both 'impClass' and 'yelClass' classes, depending on the boolean Vue data properties 'isYellow' and 'isImportant'.\n3. Camel case vs kebab case notation with 'v-bind:style'\nWhen modifying CSS in Vue with in-line styling (v-bind:style), it is recommended to use camel Case notation for the CSS property, but 'kebab-case' can also be used if the CSS property is inside quotes.\nExample\nHere, we set CSS properties background-color and font-weight for a <div> element in two different ways: the recommended way with camel Case backgroundColor, and the not recommended way with 'kebab-case' in quotes 'font-weight'. Both alternatives work.\n'Camel case' and 'kebab case' notation are ways of writing a series of words without space or punctuation.\nCamel case notation is when the first word starts with a small letter, and every word after starts with a capital letter, like 'backgroundColor' or 'camelCaseNotation'. It is called camel case because we can imagine every capital letter resembling a hump on a camels back.\nKebab case notation is when the words are separated with a dash -, like 'background-color' or 'kebab-case-notation'. It is called kebab case because we can imagine the dashes resembling the skewer in a 'shish kebab'.\n4. Array Syntax with 'v-bind:class'\nWe can use array syntax with v-bind:class to add multiple classes. With array syntax we can use both classes that depend on a Vue property and classes that do not depend on a Vue property.\nExample\nHere, we set CSS classes 'impClass' and 'yelClass' with array syntax. The class 'impClass' depends on a Vue property isImportant and the class 'yelClass' is always attached to the <div> element.",
      "examples": [
        "<input type=\"range\" v-model=\"opacityVal\">\n<div v-bind:style=\"{ backgroundColor: 'rgba(155,20,20,'+opacityVal+')' }\">\nDrag the range input above to change opacity here.\n</div>",
        "<div v-for=\"(img, index) in images\">\n<img v-bind:src=\"img.url\"\nv-on:click=\"select(index)\"\nv-bind:class=\"{ selClass: img.sel }\">\n</div>",
        "<div class=\"impClass\" v-bind:class=\"{yelClass: isYellow}\">\nThis div belongs to both 'impClass' and 'yelClass'.\n</div>",
        "<div v-bind:class=\"{yelClass: isYellow, impClass: isImportant}\">\nThis tag can belong to both the 'impClass' and 'yelClass' classes.\n</div>",
        "<div v-bind:style=\"{ backgroundColor: 'lightpink', 'font-weight': 'bolder' }\">\nThis div tag has pink background and bold text.\n</div>",
        "<div v-bind:class=\"[{ impClass: isImportant }, 'yelClass' ]\">\nThis div tag belongs to one or two classes depending on the isImportant property.\n</div>",
        "v-bind",
        "style",
        "class",
        "v-bind:style",
        "v-bind:class",
        "<input type=\"range\">",
        "<div>",
        "class=\"\"",
        "v-bind:class=\"\"",
        "v-bind:class=\"{}\"",
        "background-color",
        "font-weight",
        "backgroundColor",
        "'font-weight'",
        "-",
        "isImportant"
      ]
    },
    {
      "title": "Vue Computed Properties",
      "summary": "Computed properties are like data properties, except they depend on other properties.\nComputed properties are written like methods, but they do not accept any input arguments.\nComputed properties are updated automatically when a dependency changes, while methods are called on when something happens, like with event handling for example.\nComputed properties are used when outputting something that depends on something else.\nComputed Properties are Dynamic\nThe big advantage with a computed property is that it is dynamic, meaning it changes depending on for example the value of one or more data properties.\nComputed properties is the third configuration option in the Vue instance that we will learn. The first two configuration options we have already looked at are 'data' and 'methods'.\nAs with 'data' and 'methods' computed properties also has a reserved name in the Vue instance: 'computed'.\nSyntaxGet your own Vue Server\nComputed Property 'yes' or 'no'\nLet's say we want a form to create items in a shopping list, and we want to mark if a new item is important or not. We could add a 'true' or 'false' feedback when the checkbox gets checked, like we have done in an example before:\nExample\nAn input element is made dynamic so that the text reflects the status.\nHowever, if you you ask someone if something is important, they will most likely answer 'yes' or 'no' instead of 'true' or 'false'. So to make our form more fitting with normal language (more intuitive) we should have 'yes' or 'no' as feedback on the checkbox instead of 'true' or 'false'.\nAnd guess what, a computed property is a perfect tool to help us with that.\nExample\nWith a computed property 'isImportant' we can now customize the text feedback to the user when the checkbox is toggled on and off.\nComputed Properties vs. Methods\nComputed properties and methods are both written as functions, but they are different:\nMethods runs when called from HTML, but computed properties updates automatically when a dependency change.\nComputed properties are used the same way we use data properties, but they are dynamic.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nProvide the correct code so that the 'isImportant' computed property is shown on the screen.\nStart the Exercise",
      "examples": [
        "const app = Vue.createApp({\ndata() {\n...\n},\ncomputed: {\n...\n},\nmethods: {\n...\n}\n})",
        "<input type=\"checkbox\" v-model=\"chbxVal\"> {{ chbxVal }}",
        "data() {\nreturn {\nchbxVal: false\n}\n}",
        "<input type=\"checkbox\" v-model=\"chbxVal\"> {{ isImportant }}",
        "data() {\nreturn {\nchbxVal: false\n}\n},\ncomputed: {\nisImportant() {\nif(this.chbxVal){\nreturn 'yes'\n}\nelse {\nreturn 'no'\n}\n}",
        "<div id=\"app\"> <form> <p> Important item? <label> <input type=\"checkbox\" v-model=\"chbxVal\"> </label> </p> </form> </div> <script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script> <script> const app = Vue.createApp({ data() { return { chbxVal: false } }, : { isImportant() { if(this.chbxVal){ return 'yes' } else { return 'no' } } } }) app.mount('#app') </script>"
      ]
    },
    {
      "title": "Vue Watchers",
      "summary": "A watcher is a method that watches a data property with the same name.\nA watcher runs every time the data property value changes.\nUse a watcher if a certain data property value requires an action.\nThe Watcher Concept\nWatchers is the fourth configuration option in the Vue instance that we will learn. The first three configuration options we have already looked at are 'data', 'methods' and 'computed'.\nAs with 'data', 'methods' and 'computed' watchers also has a reserved name in the Vue instance: 'watch'.\nSyntaxGet your own Vue Server\nAs mentioned in the green area at the top, a watcher monitors a data property with the same name.\nWe never call a watcher method. It is only called automatically when the property value changes.\nThe new property value is always available as an input argument to the watcher method, and so is the old value.\nExample\nAn <input type=\"range\"> element is used to change a value 'rangeVal'. A watcher is used to prevent the user from choosing values between 20 and 60 that are considered illegal.\nA Watcher with New and Old Values\nIn addition to the new property value, the previous property value is also automatically available as an input argument to watcher methods.\nExample\nWe set up click event on a <div> element to record mouse pointer x-position 'xPos' with a method 'updatePos'. A watcher calculates the difference in pixels between the new x-position and the previous with the use of old and new input arguments to the watcher method.\nWe can also use new and old values to give feedback to the user the exact moment the input goes from being invalid to valid:\nExample\nThe value from an <input> element is connected to a watcher. If the value includes a '@' it is considered a valid e-mail address. The user gets a feedback text to inform if the input is valid, invalid, or if it just got valid with the last keystroke.\nWatchers vs. Methods\nWatchers and methods are both written as functions, but there are many differences:\nMethods are called from HTML.\nMethods are often called when an event happens.\nMethods automatically receives the event object as an input.\nWe can also send other values we choose as an input to a method.\nWatchers are only called when the watched data property value changes, and this happens automatically.\nWatchers automatically receives the new and old value from the watched property.\nWe cannot choose to send any other values with a watcher as an input.\nWatchers vs. Computed Properties\nWatchers and computed properties are both written as functions.\nWatchers and computed properties are both called automatically when a dependency change, and never called from HTML.\nHere are some differences between computed properties and watchers:\nWatchers only depend on one property, the property they are set up to watch.\nComputed properties can depend on many properties.\nComputed properties are used like data properties, except they are dynamic.\nWatchers are not referred to from HTML.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nThe watcher in this exercise is supposed to increment the 'count' data property by one every time 'rangeVal' data property changes.\nWhat must the watcher be called?\nStart the Exercise",
      "examples": [
        "const app = Vue.createApp({\ndata() {\n...\n},\nwatch: {\n...\n},\ncomputed: {\n...\n},\nmethods: {\n...\n}\n})",
        "<input type=\"range\" v-model=\"rangeVal\">\n<p>{{ rangeVal }}</p>",
        "const app = Vue.createApp({\ndata() {\nrangeVal: 70\n},\nwatch: {\nrangeVal(val){\nif( val>20 && val<60) {\nif(val<40){\nthis.rangeVal = 20;\n}\nelse {\nthis.rangeVal = 60;\n}\n}\n}\n}\n})",
        "<div v-on:click=\"updatePos\"></div>\n<p>{{ xDiff }}</p>",
        "const app = Vue.createApp({\ndata() {\nxPos: 0,\nxDiff: 0\n},\nwatch: {\nxPos(newVal,oldVal){\nthis.xDiff = newVal-oldVal\n}\n},\nmethods: {\nupdatePos(evt) {\nthis.xPos = evt.offsetX\n}\n}\n})",
        "<input v-type=\"email\" v-model=\"inpAddress\">\n<p v-bind:class=\"myClass\">{{ feedbackText }}</p>",
        "const app = Vue.createApp({\ndata() {\ninpAddress: '',\nfeedbackText: '',\nmyClass: 'invalid'\n},\nwatch: {\ninpAddress(newVal,oldVal) {\nif( !newVal.includes('@') ) {\nthis.feedbackText = 'The e-mail address is NOT valid';\nthis.myClass = 'invalid';\n}\nelse if( !oldVal.includes('@') && newVal.includes('@') ) {\nthis.feedbackText = 'Perfect! You fixed it!';\nthis.myClass = 'valid';\n}\nelse {\nthis.feedbackText = 'The e-mail address is valid :)';\n}\n}\n}\n})",
        "<script> const app = Vue.createApp({ data() { return { rangeVal: 70, count: 0 } }, watch: { () { this.count++ } } }) app.mount('#app') </script>",
        "<input type=\"range\">",
        "<div>",
        "<input>"
      ]
    },
    {
      "title": "Vue Templates",
      "summary": "A template in Vue is what we call the HTML part of our Vue application.\nThe <template> tag will later be used in *.vue files to structure our code in a better way.\nIt is possible to use template as a configuration option in the Vue instance, and put the HTML code inside.\nThe Vue Template\nLet's look at an example where we use 'template' as a configuration option. This is a simple example where we have just moved the HTML part into the configuration option 'template':\nExampleGet your own Vue Server\nThe HTML content from inside the <div id=\"app\"> is moved to the configuration option 'template', encapsulated in backtick quotes `...`. We can write many lines of HTML inside a back tick quote.\nSingle File Components (SFCs)\nAs you can see in the code example above, also the HTML part of our Vue application can be gathered inside the Vue instance, but this does not make it easier to get an overview in the HTML file.\nTo get a better overview, to make it easier to handle larger projects, and to get a better development environment, we will now switch to write our Vue code in SFCs, or *.vue files.\nAll *.vue files only consist of three parts:\n<template> where the HTML content is.\n<template> where the HTML content is.\n<script> for our Vue code.\n<script> for our Vue code.\n<style> where we write the CSS styling.\n<style> where we write the CSS styling.\nBut before we can use *.vue files in our project we need to set up our computer in a different way. The next pages in this tutorial will explain this.",
      "examples": [
        "<div id=\"app\"></div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ntemplate:\n`<h1>{{ message }}</h1>\n<p>This is a second line of HTML code, inside back tick quotes</p>`,\ndata() {\nreturn {\nmessage: \"Hello World!\"\n}\n}\n})\napp.mount('#app')\n</script>",
        "<div id=\"app\">",
        "`...`",
        "<template>",
        "<script>",
        "<style>"
      ]
    },
    {
      "title": "Scaling up Vue",
      "summary": "Using *.vue files for our Vue project makes sense because:\nit becomes easier to handle larger projects with the use of templates and components.\nwe can see and test our project through the https protocol, like the users will see the page.\nthe page updates immediately when changes are saved, without reloading.\nthis is how real web pages in Vue are built.\nit is how developers work.\nWhy?\nAs we saw on the previous page about templates and components in Vue, there is now a need for different way to work because we want to:\nhave larger projects\ngather all Vue related code in one place\nuse components in Vue (we will come to this soon)\nhave highlighting and auto-completion support in the editor\nauto-update the browser\nAnd to make all this possible we must switch to *.vue files.\nHow?\nSFCs (Single File Components), or *.vue files, are easier to work with but cannot run directly in the browser, so we need to set up our computer to compile our *.vue files to *.html, *.css and *.js files so that the browser can run our Vue application.\nTo build our web page based on SFCs we use a program called Vite as the build tool, and we write our code in the VS Code editor with the Volar extension for Vue 3 language features.\nSetup\nFollow the three steps below to install what you need to run Vue SFC applications on your computer.\nThe \"VS Code\" Editor\nThere are many different editors that can be used for Vue projects. We use the VS Code editor. Download VS Code and install it.\nThe \"VS Code\" Editor\nThere are many different editors that can be used for Vue projects. We use the VS Code editor. Download VS Code and install it.\nThe VS Code \"Volar\" Extension\nTo get highlighting and auto-completion with *.vue files in the editor, open VS Code, go to \"Extensions\" on the left hand side. Search for \"Volar\" and install the extension with the most downloads and the description \"Language support for Vue 3\".\nThe VS Code \"Volar\" Extension\nTo get highlighting and auto-completion with *.vue files in the editor, open VS Code, go to \"Extensions\" on the left hand side. Search for \"Volar\" and install the extension with the most downloads and the description \"Language support for Vue 3\".\nNode.js\nDownload and install the latest version of Node.js, as the Vue build tool \"Vite\" runs on top of this.\nNode.js is an open-source server-side JavaScript runtime environment.\nNode.js\nDownload and install the latest version of Node.js, as the Vue build tool \"Vite\" runs on top of this.\nNode.js is an open-source server-side JavaScript runtime environment.\nCreate The Default Example Project\nFollow the steps below to create the default Vue example project on your computer.\nCreate a folder for your Vue projects on your computer.\nCreate a folder for your Vue projects on your computer.\nIn VS Code, open a terminal by choosing Terminal -> New Terminal from the menu:\nIn VS Code, open a terminal by choosing Terminal -> New Terminal from the menu:\nUse the terminal to navigate to the Vue folder you just created by using commands like cd <folder-name>, cd .., ls (Mac/Linux) and dir (Windows). If you are not familiar with writing commands in the terminal, see our introduction to Command Line Interface (CLI) here.\nUse the terminal to navigate to the Vue folder you just created by using commands like cd <folder-name>, cd .., ls (Mac/Linux) and dir (Windows). If you are not familiar with writing commands in the terminal, see our introduction to Command Line Interface (CLI) here.\nAfter you have navigated to your Vue folder in the terminal, write:\nnpm init vue@latest\nAfter you have navigated to your Vue folder in the terminal, write:\nCreate your first project, with project name \"firstsfc\":\nCreate your first project, with project name \"firstsfc\":\nAnswer \"No\" to all options:\nAnswer \"No\" to all options:\nNow you should be presented with this in your terminal:\nNow you should be presented with this in your terminal:\nWe will now run the commands as suggested above.\nRun this command to change directory to your new project inside the 'firstsfc' folder:\ncd firstsfc\nWe will now run the commands as suggested above.\nRun this command to change directory to your new project inside the 'firstsfc' folder:\nInstall all required dependencies so that the Vue project works:\nnpm install\nInstall all required dependencies so that the Vue project works:\nStart the development server:\nnpm run dev\nStart the development server:\nThe terminal window should now look like this:\nAnd your browser should open the example project automatically:\nIf you cannot find the example project in the browser, use the link from the terminal. The link you find in your terminal window might have a different address than the address in the screenshot above.\nNow the example project is running on your machine in development mode by the Vite build tool.\nThe terminal window should now look like this:\nAnd your browser should open the example project automatically:\nIf you cannot find the example project in the browser, use the link from the terminal. The link you find in your terminal window might have a different address than the address in the screenshot above.\nNow the example project is running on your machine in development mode by the Vite build tool.\nThe Project Files\nThe example project that has automatically been created contains many files, and we will take a quick look at a few of them.\nmain.js\nGo to your Vue project in the VS Code editor, find the \"main.js\" file in the \"src\" folder:\n\"main.js\" tells Vite how to build the Vue project based on the \"App.vue\" file. This is similar to how we previously gave a CDN link with the script tag to tell the browser how to run our Vue code, and how we mounted the Vue instance to the <div id=\"app\"> tag.\nApp.vue\nIn the same example project folder, find the \"App.vue\" file and open it. Like all other *.vue files, \"App.vue\" contains three parts: a <script> part, a <template> part and a <style> part.\nApp.vue:\nAs you can see in the script part of \"App.vue\", other *.vue files are referred to: those are 'components' and are located in the 'components' folder. If you take a look in the 'template' part of the 'App.vue' file, you can see tags that are not normal HTML tags: <HelloWorld> and <TheWelcome>. This is how the components are referred to. Components are like apps within the app. We will learn more about components soon.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhat is the name of the file?\nStart the Exercise",
      "examples": [
        "<script setup> import HelloWorld from './components/HelloWorld.vue' import TheWelcome from './components/TheWelcome.vue' </script> <template> <header> <img alt=\"Vue logo\" class=\"logo\" src=\"./assets/logo.svg\" width=\"125\" height=\"125\" /> <div class=\"wrapper\"> <HelloWorld msg=\"You did it!\" /> </div> </header> <main> <TheWelcome /> </main> </template> <style scoped> header { line-height: 1.5; } .logo { display: block; margin: 0 auto 2rem; } @media (min-width: 1024px) { header { display: flex; place-items: center; padding-right: calc(var(--section-gap) / 2); } .logo { margin: 0 2rem 0 0; } header .wrapper { display: flex; place-items: flex-start; flex-wrap: wrap; } } </style>",
        "npm init vue@latest",
        "cd firstsfc",
        "npm install",
        "npm run dev",
        "is responsible for telling the compiler which files the Vue project consists of.",
        "cd <folder-name>",
        "cd ..",
        "ls",
        "dir",
        "<div id=\"app\">",
        "<script>",
        "<template>",
        "<style>",
        "App.vue",
        "<HelloWorld>",
        "<TheWelcome>"
      ]
    },
    {
      "title": "Our First SFC Web Page",
      "summary": "To create our first SFC web page from scratch we will:\nCreate a new clean Vue project\nWrite code in the 'App.vue' file\nSee how the web page updates automatically during development\nBuild the page for production\nCreate a Clean Project\nNow we will remove all content in the example project we made on the previous page to create our own simple web page in Vue.\nBefore we start to write code, remove all content inside the <template>, <script> and <style> tags, and remove any attributes like 'setup' or 'scoped'.\nYour 'App.vue' file should now look like this:\nApp.vue:\nAlso remove the folders 'assets' and 'components' inside the 'src' folder.\nRemove the line where assets are imported inside the 'main.js' file so that 'main.js' looks like this:\nmain.js:\nWe now have an empty project to work with.\nWrite code in 'App.vue'\nNow that we have a clean project, add a header inside the <template> tag, like this:\nSave the 'App.vue' file, go to your browser by following the localhost link in the terminal. Do you see the result? The browser should now update automatically every time you save a change in VS Code, without having to manually refresh the browser.\nNow lets take a look at a slightly larger Vue example:\nExampleGet your own Vue Server\nApp.vue:\nNote: In the example above, export default makes it possible for 'main.js' to catch the data with the import App from './App.vue' so that it can be mounted on the <div id=\"app\"> tag inside 'index.html'.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhat is the command we need to write to run the project in development mode?\nStart the Exercise",
      "examples": [
        "<script></script> <template></template> <style></style>",
        "import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app')",
        "<template> <h1>Hello World!</h1> </template> <script></script> <style></style>",
        "<template> <h1>{{ message }}</h1> </template> <script> export default { data() { return { message: 'This is some text' }; } }; </script> <style></style>",
        "npm",
        "<template>",
        "<script>",
        "<style>",
        "App.vue:",
        "main.js:",
        "App.vue",
        "export default",
        "import App from './App.vue'",
        "<div id=\"app\">"
      ]
    },
    {
      "title": "Vue Components",
      "summary": "Components in Vue lets us decompose our web page into smaller pieces that are easy to work with.\nWe can work with a Vue component in isolation from the rest of the web page, with its own content and logic.\nA web page often consists of many Vue components.\nWhat are Components?\nComponents are reusable and self-contained pieces of code that encapsulates a specific part of the user interface, so that we can make Vue applications that are scalable and easier to maintain.\nWe can make components in Vue ourselves, or use built-in components that we will learn about later, like <Teleport> or <KeepAlive>. Here we will focus on components we make ourselves.\nCreating a Component\nComponents in Vue is a very powerful tool because it lets our web page become more scalable and bigger projects become easier to handle.\nLet's make a component and add it to our project.\nCreate a new folder components inside the src folder.\nCreate a new folder components inside the src folder.\nInside the components folder, create a new file FoodItem.vue. It is common to name components with PascalCase naming convention, without spaces and where all new words starts with a capital letter, also the first word.\nInside the components folder, create a new file FoodItem.vue. It is common to name components with PascalCase naming convention, without spaces and where all new words starts with a capital letter, also the first word.\nMake sure the FoodItem.vue file look like this:\nMake sure the FoodItem.vue file look like this:\nCode inside the FoodItem.vue component:\nAs you can see in the example above, components also consist of <template>, <script> and <style> tags, just like our main App.vue file.\nAdding The Component\nNotice that the <script> tag in the example above start with export default. This means that the object containing the data properties can be received, or imported, in another file. We will use this to implement the FoodItem.vue component into our existing project by importing it with the main.js file.\nFirst, rewrite the last line into two lines in your original main.js file:\nmain.js:\nNow, add the FoodItem.vue component by inserting lines 4 and 7 in your main.js file:\nmain.js:\nOn line 7, the component is added so that we can use it as a custom tag <food-item/> inside the <template> tag in our App.vue file like this:\nApp.vue:\nAnd, let's add some styling inside the <style> tag in the App.vue file. Make sure the development server is running, and check out the result.\nExampleGet your own Vue Server\nApp.vue:\nDevelopment mode: When working with your Vue projects, it is useful to always have your project in development mode by running the following code line in the terminal:\nIndividual Components\nA very useful and powerful property when working with components in Vue is that we can make them behave individually, without having to mark elements with unique IDs like we must do with plain JavaScript. Vue automatically takes care to treat each component individually.\nLet's make the <div> elements count when we click them.\nThe only thing added to our main application file App.vue is in CSS to have the cursor look like a hand pointing during hover to imply that there is some sort of click functionality.\nCSS code added to the <style> tag in App.vue:\nIn our component file FoodItem.vue we must add a data property count, a click listener to the <div> element, a method to run when click happens to increment the counter, and text interpolation {{}} to show the count.\nExample\nFoodItem.vue:\nWe don't have to define unique IDs or do any extra work for Vue to handle the counting individually for each <div> element, Vue just does this automatically.\nBut except for the different counter values, the content of the <div> elements is still the same. In the next page we will learn more about components so that we can use components in a way that makes more sense. For example it would make more sense to display different kind of food in each <div> element.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nThe line below in main.js adds a component to our Vue project:\napp.component('fish-type', FishType)\nHow can we add this component to App.vue?\nStart the Exercise",
      "examples": [
        "<template> <div> <h2>{{ name }}</h2> <p>{{ message }}</p> </div> </template> <script> export default { data() { return { name: 'Apples', message: 'I like apples' } } }; </script> <style></style>",
        "import { createApp } from 'vue' import App from './App.vue' const app = createApp(App) app.mount('#app')",
        "import { createApp } from 'vue' import App from './App.vue' import FoodItem from './components/FoodItem.vue' const app = createApp(App) app.component('food-item', FoodItem) app.mount('#app')",
        "<template> <h1>Food</h1> <food-item/> <food-item/> <food-item/> </template> <script></script> <style></style>",
        "<template> <h1>Food</h1> <food-item/> <food-item/> <food-item/> </template> <script></script> <style> #app > div { border: dashed black 1px; display: inline-block; margin: 10px; padding: 10px; background-color: lightgreen; } </style>",
        "#app > div:hover { cursor: pointer; }",
        "<template> <div v-on:click=\"countClicks\"> <h2>{{ name }}</h2> <p>{{ message }}</p> <p id=\"red\">You have clicked me {{ clicks }} times.</p> </div> </template> <script> export default { data() { return { name: 'Apples', message: 'I like apples', clicks: 0 } }, methods: { countClicks() { this.clicks++; } } } </script> <style> #red { font-weight: bold ; color: rgb(144, 12, 12); } </style>",
        "npm run dev",
        "<template> <h1>Fish</h1> </template>",
        "<Teleport>",
        "<KeepAlive>",
        "components",
        "src",
        "FoodItem.vue",
        "<template>",
        "<script>",
        "<style>",
        "App.vue",
        "export default",
        "main.js",
        "<food-item/>",
        "<div>",
        "count",
        "{{}}",
        "app.component('fish-type', FishType)"
      ]
    },
    {
      "title": "Vue Props",
      "summary": "Props is a configuration option in Vue.\nWith props we can pass data to the components via custom attributes to the component tag.\nPass Data To a Component\nDo you remember the example on the previous page where all three components said 'Apple'? With props we can now pass data down to our components to give them different content and make them look different.\nLet's make a simple page to show 'Apples', 'Pizza' and 'Rice'.\nIn the main application file App.vue we create our own attribute 'food-name' to pass a prop with the <food-item/> component tags:\nApp.vue:\nReceive Data Inside a Component\nTo receive the data sent via the 'food-item' attribute from App.vue we use this new 'props' configuration option. We list the attributes received so that our component *.vue file knows about them, and now we can use the props wherever we want in the same way as we use a data property.\nFoodItem.vue:\nProps attributes are written with a dash - to separate words (kebab-case) in the <template> tag, but kebab-case is not legal in JavaScript. So instead we need to write the attribute names as camel Case in JavaScript, and Vue understands this automatically!\nFinally, our example with <div> elements for 'Apples', 'Pizza' and 'Rice' looks like this:\nExampleGet your own Vue Server\nApp.vue:\nFoodItem.vue:\nSoon we will see how to pass different data types as props attributes to components, but before we do that, let's expand our code with a description of each type of food, and put the food <div> elements inside a Flexbox wrapper.\nExample\nApp.vue:\nFoodItem.vue:\nBoolean Props\nWe can achieve different functionality by passing props of different data types, and we are able to define rules for how attributes are given when components are created from App.vue.\nLet's add a new prop 'isFavorite'. This should be a boolean prop with value either true or false so that we can use it directly with v-show to display a favorite stamp <img> tag if the food is considered a favorite.\nTo pass props with a data type different to String, we must write v-bind: in front of the attribute we want to pass.\nThis is how we pass the boolean 'isFavorite' prop from App.vue as an attribute 'is-favorite':\nApp.vue:\nWe receive the boolean 'isFavorite' prop inside FoodItem.vue and show a favorite stamp if the food is considered favorite:\nExample\nFoodItem.vue:\nImages: To make the image in the example above work locally in the project on your machine, open the example above, right click the image, choose \"Save Image As...\" and save it in the \"public\" folder in your project.\nProps Interface\nIn the example above, based on the code inside FoodItem.vue, we cannot know for sure that we receive the 'isFavorite' prop, and we cannot know for sure if it is a boolean value. To help us with this we can define the data-type of props we receive, we can set props to be required, and we can even make validation functions to validate the props we receive.\nDefining props we receive serves as a documentation for other people if you work in a team, and it provides us with warnings in the console if the rules that we have defined are broken.\nProps as an Object\nIn FoodItem.vue, we comment out how we defined the props in an array to have it as reference, and instead define the props in an object. We can also define the data type of each prop in addition to the prop name, like this:\nFoodItem.vue:\nWith props defined in this way, other people can look inside FoodItem.vue and easily see what the component expects.\nIf a component is created from the parent element (in our case App.vue) and given a prop with the wrong data type, you get a warning in the console, like this:\nSuch warnings are useful to let ourselves and others know that a component is not used how it is supposed to, and to tell what is wrong so that we can correct the mistake.\nRequired Props\nTo tell Vue that a prop is required we need to define the prop as an object. Let's make the prop 'foodName' required, like this:\nFoodItem.vue:\nIf a component is created from the parent element (in our case App.vue) and a required prop is not defined, you get a warning in the console, like this:\nSuch warnings are useful to let ourselves and others know that a component is not used how it is supposed to, and to tell what is wrong so that we can correct the mistake.\nDefault Value\nWe can set a default value for a prop.\nLet's create a default value for the 'foodDesc' prop in the 'FoodItem' component, and then create such an item for rice without defining the 'foodDesc' prop:\nExample\nApp.vue:\nFoodItem.vue:\nProps Validator Function\nWe can also define a validator function that decides if the prop value is valid or not.\nSuch validator functions must return either true or false. When the validator returns false, it means the prop value is invalid. An invalid prop value generates a warning in the browser console when we run our page in developer mode, and the warning is a useful hint to make sure the components are used as intended.\nLet's say we want the food description to be a certain length, between 20 and 50 characters. We can add a validator function to make sure the food description provided has a valid length.\nFoodItem.vue:\nNote: If you add the validator code above to your local project, you will get a warning in development mode because the food description for pizza is 65 characters, which is 15 characters longer than the validator function allows.\nModify Props\nWhen a component is created in the parent element we are not allowed to change the value of the prop received in the child element. So inside FoodItem.vue we cannot change the value of the 'isFavorite' prop we get from App.vue. The prop is read-only from the parent, which is App.vue in our case.\nBut let's say we want the user to be able to change what food is considered favorite by clicking a button. Now there is a need to change the 'isFavorite' prop, but we cannot do it because it is read only.\nWe are not allowed to change 'isFavorite'. This will generate an error.\nTo get around this we can use the prop to initialize a new data value 'foodIsFavorite', inside FoodItem.vue, like this:\nAnd now we can add a method so the user can toggle this new data value:\nWe must also add the toggle button to each food item, and change v-show in the <img> tag to depend on the new data property 'foodIsFavorite'. And to make our example simpler we also slim down the props declaration to just an array.\nExample\nFoodItem.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhat must we write in a component so that it receives data sent via the 'fish-name' attribute from App.vue as a prop?\nStart the Exercise",
      "examples": [
        "<template> <h1>Food</h1> <food-item food-name=\"Apples\"/> <food-item food-name=\"Pizza\"/> <food-item food-name=\"Rice\"/> </template> <script></script> <style> #app > div { border: dashed black 1px; display: inline-block; width: 120px; margin: 10px; padding: 10px; background-color: lightgreen; } </style>",
        "<script> export default { props: [ 'foodName' ] } </script>",
        "<template> <h1>Food</h1> <food-item food-name=\"Apples\"/> <food-item food-name=\"Pizza\"/> <food-item food-name=\"Rice\"/> </template>",
        "<template> <div> <h2>{{ foodName }}</h2> </div> </template> <script> export default { props: [ 'foodName' ] } </script> <style></style>",
        "<template> <h1>Food</h1> <div id=\"wrapper\"> <food-item food-name=\"Apples\" food-desc=\"Apples are a type of fruit that grow on trees.\"/> <food-item food-name=\"Pizza\" food-desc=\"Pizza has a bread base with tomato sauce, cheese, and toppings on top.\"/> <food-item food-name=\"Rice\" food-desc=\"Rice is a type of grain that people like to eat.\"/> </div> </template> <script></script> <style> #wrapper { display: flex; flex-wrap: wrap; } #wrapper > div { border: dashed black 1px; margin: 10px; padding: 10px; background-color: lightgreen; } </style>",
        "<template> <div> <h2>{{ foodName }}</h2> <p>{{ foodDesc }}</p> </div> </template> <script> export default { props: [ 'foodName', 'foodDesc' ] } </script> <style></style>",
        "<template> <h1>Food</h1> <p>My favorite food has a diploma image attached to it.</p> <div id=\"wrapper\"> <food-item food-name=\"Apples\" food-desc=\"Apples are a type of fruit that grow on trees.\" v-bind:is-favorite=\"true\"/> <food-item food-name=\"Pizza\" food-desc=\"Pizza has a bread base with tomato sauce, cheese, and toppings on top.\" v-bind:is-favorite=\"false\"/> <food-item food-name=\"Rice\" food-desc=\"Rice is a type of grain that people like to eat.\" v-bind:is-favorite=\"false\"/> </div> </template>",
        "<template> <div> <h2> {{ foodName }} <img src=\"/img_quality.svg\" v-show=\"isFavorite\"> </h2> <p>{{ foodDesc }}</p> </div> </template> <script> export default { props: ['foodName','foodDesc','isFavorite'] } </script> <style> img { height: 1.5em; float: right; } </style>",
        "<script> export default { // props: ['foodName','foodDesc','isFavorite'] props: { foodName: String, foodDesc: String, isFavorite: Boolean } } </script>",
        "<script> export default { // props: ['foodName','foodDesc','isFavorite'] props: { foodName: { type: String, required: true }, foodDesc: String, isFavorite: Boolean } } </script>",
        "<script> export default { props: { foodName: { type: String, required: true }, foodDesc: { type: String, required: false, default: 'This is the default description.' }, isFavorite: { type: Boolean, required: false, default: false } } } </script>",
        "<script> export default { props: { foodName: { type: String, required: true }, foodDesc: { type: String, required: false, default: 'This is the default description.', validator: function(value) { if( 20<value.length && value.length<50 ) { return true; } else { return false; } } }, isFavorite: { type: Boolean, required: false, default: false } } } </script>",
        "methods: { toggleFavorite() { this.isFavorite = !this.isFavorite; } }",
        "data() { return { foodIsFavorite: this.isFavorite } }",
        "methods: { toggleFavorite() { this.foodIsFavorite = !this.foodIsFavorite; } }",
        "<template> <div> <h2> {{ foodName }} <img src=\"/img_quality.svg\" v-show=\"foodIsFavorite\"> </h2> <p>{{ foodDesc }}</p> <button v-on:click=\"toggleFavorite\">Favorite</button> </div> </template> <script> export default { props: ['foodName','foodDesc','isFavorite'], data() { return { foodIsFavorite: this.isFavorite } }, methods: { toggleFavorite() { this.foodIsFavorite = !this.foodIsFavorite; } } }; </script> <style> img { height: 1.5em; float: right; } </style>",
        "<script> export default { : [ '' ] } </script>",
        "App.vue",
        "<food-item/>",
        "FoodItem.vue",
        "-",
        "<template>",
        "<div>",
        "true",
        "false",
        "v-show",
        "<img>",
        "v-bind:"
      ]
    },
    {
      "title": "Vue v-for Components",
      "summary": "Components can be reused with v-for to generate many elements of the same kind.\nWhen generating elements with v-for from a component, it is also very helpful that props can be assigned dynamically based on values from an array.\nCreate Component Elements with v-for\nWe will now create component elements with v-for based on an array with food item names.\nExampleGet your own Vue Server\nApp.vue:\nFoodItem.vue:\nv-bind Shorthand\nTo bind props dynamically we use v-bind, and because we will use v-bind much more now than before we will use the v-bind: shorthand : in the rest of this tutorial.\nThe 'key' Attribute\nIf we modify the array after the elements are created with v-for, errors can emerge because of the way Vue updates such elements created with v-for. Vue reuses elements to optimize performance, so if we remove an item, already existing elements are reused instead of recreating all elements, and element properties might not be correct anymore.\nThe reason for elements being reused incorrectly is that elements do not have a unique identifier, and that is exactly what we use the key attribute for: to let Vue tell the elements apart.\nWe will generate faulty behavior without the key attribute, but first let's build a web page with foods using v-for to display: food name, description, image for favorite food and button to change favorite status.\nExample\nApp.vue:\nFoodItem.vue:\nTo see that we need the key attribute, let's create a button that removes the second element in the array. When this happens, without the key attribute, the favorite image is transferred from the 'Fish' element to the 'Cake' element, and that is NOT correct:\nExample\nThe only difference from the previous example is that we add a button:\nand a method:\nin App.vue.\nAs mentioned before: this fault, that the favorite image changes from 'fish' to 'cake' when an element is removed, has to do with Vue optimizing the page by reusing elements, and at the same time Vue cannot fully tell the elements apart. That is why we should always include the key attribute to uniquely mark each element when generating elements with v-for. When we use the key attribute, we no longer get this problem.\nWe do not use the array element index as the key attribute value because that changes when array elements are removed and added. We could create a new data property to keep a unique value for each item, like an ID number, but because the food items already have unique names we can just use that:\nExample\nWe only need to add one line in App.vue to uniquely identify each element created with v-for and fix the problem:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhen generating elements with v-for, which specific attribute is always recommended to use?\nStart the Exercise",
      "examples": [
        "<template> <h1>Food</h1> <p>Components created with v-for based on an array.</p> <div id=\"wrapper\"> <food-item v-for=\"x in foods\" v-bind:food-name=\"x\"/> </div> </template> <script> export default { data() { return { foods: ['Apples','Pizza','Rice','Fish','Cake'] }; } } </script>",
        "<template> <div> <h2>{{ foodName }}</h2> </div> </template> <script> export default { props: ['foodName'] } </script>",
        "<template> <h1>Food</h1> <p>Food items are generated with v-for from the 'foods' array.</p> <div id=\"wrapper\"> <food-item v-for=\"x in foods\" :food-name=\"x.name\" :food-desc=\"x.desc\" :is-favorite=\"x.favorite\"/> </div> </template> <script> export default { data() { return { foods: [ { name: 'Apples', desc: 'Apples are a type of fruit that grow on trees.', favorite: true }, { name: 'Pizza', desc: 'Pizza has a bread base with tomato sauce, cheese, and toppings on top.', favorite: false }, { name: 'Rice', desc: 'Rice is a type of grain that people like to eat.', favorite: false } { name: 'Fish', desc: 'Fish is an animal that lives in water.', favorite: true } { name: 'Cake', desc: 'Cake is something sweet that tastes good.', favorite: false } ] }; } } </script> <style> #wrapper { display: flex; flex-wrap: wrap; } #wrapper > div { border: dashed black 1px; flex-basis: 120px; margin: 10px; padding: 10px; background-color: lightgreen; } </style>",
        "<template> <div> <h2> {{ foodName }} <img src=\"/img_quality.svg\" v-show=\"foodIsFavorite\"> </h2> <p>{{ foodDesc }}</p> <button v-on:click=\"toggleFavorite\">Favorite</button> </div> </template> <script> export default { props: ['foodName','foodDesc','isFavorite'], data() { return { foodIsFavorite: this.isFavorite } }, methods: { toggleFavorite() { this.foodIsFavorite = !this.foodIsFavorite; } } } </script> <style> img { height: 1.5em; float: right; } </style>",
        "<button @click=\"removeItem\">Remove Item</button>",
        "methods: { removeItem() { this.foods.splice(1,1); } }",
        "<food-item v-for=\"x in foods\" :key=\"x.name\" :food-name=\"x.name\" :food-desc=\"x.desc\" :is-favorite=\"x.favorite\" />",
        "<fish-type v-for=\"x in fish\" :=\"x.id\" :fish-name=\"x.name\" :img-url=\"x.url\" />",
        "v-for",
        "App.vue",
        "FoodItem.vue",
        "v-bind",
        "v-bind:",
        ":",
        "key"
      ]
    },
    {
      "title": "Vue $emit() Method",
      "summary": "With the built-in $emit() method in Vue we can create a custom event in the child component that can be captured in the parent element.\nProps are used to send data from the parent element to the child component, and $emit() is used to do the opposite: to pass information from the child component to the parent.\nThe purpose of the things we will do next is to end up with the 'favorite' status of a food item to be changed in the parent App.vue instead of in the the FoodItem.vue child component where the change is currently happening.\nThe reason for changing the favorite status in App.vue instead of in FoodItem.vue is that App.vue is where the favorite status is stored in the first place, so that needs to be updated. In a larger project the data might come from a database we have connection to in App.vue, and we want a change happening from the component to make a change in the database, so we need to communicate back to the parent from the child component.\nEmit a Custom Event\nThere is a need to send information from the component to the parent, and we use the built-in method $emit() to do that.\nWe already have the toggleFavorite method inside the FoodItem.vue component that runs when the toggle button is clicked. Now let's remove the existing line and add a line to emit our custom event 'toggle-favorite':\nFoodItem.vue:\nWe can choose the name of our custom event, but it is normal to use kebab-case for emit events.\nReceive an Emit Event\nThe custom emit event 'toggle-favorite' is now emitted from the FoodItem.vue component, but we need to listen to the event in the App.vue parent and call a method that does something so that we can see that the event happened.\nWe listen to the event with the shorthand @ instead of v-on: in App.vue where the component is created:\nExampleGet your own Vue Server\nListen to the 'toggle-favorite' event in App.vue:\nWhen our custom 'toggle-favorite' event happens, we need to create the receiveEmit method in App.vue so that we can see that the event happened:\nChange The Food Item 'favorite' Status in The Parent\nWe now have an event that notifies App.vue when the 'Favorite' button is clicked from the child component.\nWe want to change the 'favorite' property in the 'foods' array in App.vue for the correct food item when a 'Favorite' button is clicked. To do that we send the food item name from FoodItem.vue to App.vue because that is unique for each food item:\nFoodItem.vue:\nWe can now receive the food item name in App.vue as an argument to the method called when the 'toggle-favorite' event happens, like this:\nExample\nApp.vue:\nNow that we know what food item that was clicked we can update the 'favorite' status for the correct food item inside the 'foods' array:\nApp.vue:\nIn the code above, the array method 'find' goes through the 'foods' array and looks for an object with name property equal to the food item we have clicked, and returns that object as 'foundFood'. After that we can set 'foundFood.health' to be opposite to what it was before so that it toggles between true and false.\nLearn more about the JavaScript array method 'find' here.\nLearn more about JavaScript arrow functions here.\nThe correct food inside the 'foods' array now gets its 'favorite' status updated. The only thing remaining is to get the image indicating favorite food updated.\nBecause the food item components are already created with the 'favorite' status from the 'foods' array and sent as a prop 'is-favorite' from App.vue, we just need to refer to this 'isFavorite' prop in FoodItem.vue from v-show where the <img> element is to update the image:\nWe can also delete the 'foodIsFavorite' data property in FoodItem.vue because it is no longer in use.\nExample\nIn this final example code the favorite status of the food items can be toggled in a similar way as before, but now the favorite status is modified in the correct place, inside App.vue.\nThe 'emits' Option\nIn the same way that we declare props inside the FoodItem.vue component, we can also document what the component emits by using the Vue 'emits' option.\nProps must be declared in the component, while emits are just recommended to be documented.\nThis is how we can document our emit in the FoodItem.vue component:\nThe component becomes easier for others to use when the emits are documented.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nStart the Exercise",
      "examples": [
        "methods: { toggleFavorite() {\nthis.foodIsFavorite = !this.foodIsFavorite;\nthis.$emit('toggle-Favorite'); } }",
        "<food-item v-for=\"x in foods\" :key=\"x.name\" :food-name=\"x.name\" :food-desc=\"x.desc\" :is-favorite=\"x.favorite\" @toggle-favorite=\"receiveEmit\" />",
        "methods: { receiveEmit() { alert('Hello World!'); } }",
        "methods: { toggleFavorite() { this.$emit('toggle-favorite', this.foodName); } }",
        "methods: { receiveEmit(foodId) { alert( 'You clicked: ' + foodId ); } }",
        "methods: { receiveEmit(foodId) { const foundFood = this.foods.find( food => food.name === foodId ); foundFood.favorite = !foundFood.favorite; } }",
        "<img src=\"/img_quality.svg\" v-show=\"isFavorite\">",
        "<script> export default { props: ['foodName','foodDesc','isFavorite'], emits: ['toggle-favorite'], methods: { toggleFavorite() { this.$emit('toggle-favorite', this.foodName); } } }; </script>",
        "Props are used to send data from the parent element to the child component, and is used to to pass information from the child component to the parent.",
        "$emit()",
        "App.vue",
        "FoodItem.vue",
        "toggleFavorite",
        "@",
        "v-on:",
        "receiveEmit",
        "true",
        "false",
        "v-show",
        "<img>"
      ]
    },
    {
      "title": "Vue Fallthrough Attributes",
      "summary": "A component can be called with attributes that are not declared as props, and they will simply fall through to the root element in the component.\nWith fallthrough attributes you get a better overview from the parent where the component is created, and it simplifies our code because we don't need to declare the attribute as a prop.\nTypical attributes used to fall through are class, style and v-on.\nFallthrough Attributes\nIt can be nice to for example control the component styling from the parent rather than having the styling hidden away inside the component.\nLet's create a new example, a basic to-do list in Vue, and see how the style attribute falls through to the components representing things to do.\nSo, our App.vue should contain the list of things to do, and an <input> element and a <button> to add new things to do. Each list item is a <todo-item /> component.\nApp.vue:\nAnd TodoItem.vue just receives the description of what to do as a prop:\nTodoItem.vue:\nTo build our application correctly we also need the right setup in main.js:\nmain.js:\nTo see the point of this section, that properties can fall through to the root element inside the <template> of our component, we can give the list items some styling from App.vue:\nExampleGet your own Vue Server\nWe give styling to the <li> elements inside the component, from App.vue:\nTo confirm that the style attribute has actually fallen through we can right click an <li> element in our to-do list in the browser, choose 'Inspect', and we can see the style attribute is now on the <li> element:\nMerging 'class' and 'style' Attributes\nIf 'class' or 'style' attributes are already set, and 'class' or 'style' attributes also comes from the parent as fallthrough attributes, the attributes will be merged.\nExample\nIn addition to the existing styling from the parent, we add a margin to the <li> elements inside the TodoItem.vue component:\nIf we right click an <li> element in the browser we can see that the attributes have been merged. Margin is set directly on the <li> element inside the component, and is merged with the background-color that falls through from the parent:\n$attrs\nIf we have more than one element on the root level of the component, it is no longer clear which element the attributes should fall through to.\nTo define which root element gets the fallthrough attributes we can mark the element with the built-in $attrs object, like this:\nExample\nTodoItem.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nSet the root element of the 'fish-type' component to belong to the 'blue' CSS class (create a fallthrough attribute).\nStart the Exercise",
      "examples": [
        "<template> <h3>Todo List</h3> <ul> <todo-item v-for=\"x in items\" :key=\"x\" :item-name=\"x\" /> </ul> <input v-model=\"newItem\"> <button @click=\"addItem\">Add</button> </template> <script> export default { data() { return { newItem: '', items: ['Buy apples','Make pizza','Mow the lawn'] }; }, methods: { addItem() { this.items.push(this.newItem), this.newItem = ''; } } } </script>",
        "<template> <li>{{ itemName }}</li> </template> <script> export default { props: ['itemName'] } </script>",
        "import { createApp } from 'vue' import App from './App.vue' import TodoItem from './components/TodoItem.vue' const app = createApp(App) app.component('todo-item', TodoItem) app.mount('#app')",
        "<template> <h3>Todo List</h3> <ul> <todo-item v-for=\"x in items\" :key=\"x\" :item-name=\"x\" style=\"background-color: lightgreen;\" /> </ul> <input v-model=\"newItem\"> <button @click=\"addItem\">Add</button> </template>",
        "<template> <li style=\"margin: 5px 0;\">{{ itemName }}</li> </template> <script> export default { props: ['itemName'] } </script>",
        "<template> <div class=\"pinkBall\"></div> <li v-bind=\"$attrs\">{{ itemName }}</li> <div class=\"pinkBall\"></div> </template>",
        "<fish-type />",
        "class",
        "style",
        "v-on",
        "App.vue",
        "<input>",
        "<button>",
        "<todo-item />",
        "TodoItem.vue",
        "main.js",
        "<template>",
        "<li>",
        "$attrs"
      ]
    },
    {
      "title": "Scoped Styling",
      "summary": "Styling defined inside the <style> tag in a component, or in App.vue, is actually available globally in all components.\nTo keep the styling limited locally to just the component, we can use the scope attribute on that component: <style scoped>\nGlobal Styling\nCSS written inside the <style> tag in any *.vue file works globally.\nThis means that if we for example set <p> tags to have pink background color inside the <style> tag in one *.vue file, this will affect <p> tags in all of the *.vue files in that project.\nExampleGet your own Vue Server\nIn this application we have three *.vue files: App.vue, and two components CompOne.vue and CompTwo.vue.\nThe CSS styling inside CompOne.vue affects <p> tags in all three *.vue files:\nScoped Styling\nTo avoid that the styling in one component affects the styling of elements in other components we use the 'scoped' attribute on the <style> tag:\nExample\nThe <style> tag in CompOne.vue is given the scoped attribute:",
      "examples": [
        "<template> <p>This p-tag belongs to 'CompOne.vue'</p> </template> <script></script> <style> p { background-color: pink; width: 150px; } </style>",
        "<template> <p>This p-tag belongs to 'CompOne.vue'</p> </template> <script></script> <style scoped> p { background-color: pink; width: 150px; } </style>",
        "<style>",
        "App.vue",
        "scope",
        "<style scoped>",
        "*.vue",
        "<p>",
        "CompOne.vue",
        "CompTwo.vue",
        "scoped"
      ]
    },
    {
      "title": "Local Components",
      "summary": "The way we have included components so far makes them accessible from all *.vue files in a project.\nComponents can be made to be local, meaning that they are only accessible inside a specific *.vue file.\nGlobal Components\nThe way we have included components inside main.js so far make the components accessible inside the <template> of all other *.vue files in that project.\nExampleGet your own Vue Server\nWe use the CompOne.vue component inside both CompTwo.vue and App.vue to show that components are accessible to each other with our current main.js setup.\nmain.js:\nLocal Components\nWe can include a component directly in the <script> tag in a *.vue file instead of including it in main.js.\nIf we include a component directly in a *.vue file, the component becomes accessible only locally in that file.\nExample\nTo make CompOne.vue local to App.vue, and only accessible there, we remove it from main.js.\nmain.js:\nAnd include CompOne.vue directly in the <script> tag of App.vue instead.\nApp.vue:\nThe CompOne.vue component is now only available in App.vue.\nIf you run the application in development mode and try to use CompOne.vue from inside CompTwo.vue you get a warning:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nHow can we make the 'comp-one' component available locally, only to one component?\nStart the Exercise",
      "examples": [
        "import { createApp } from 'vue' import App from './App.vue' import CompOne from './components/CompOne.vue' import CompTwo from './components/CompTwo.vue' const app = createApp(App) app.component('comp-one', CompOne) app.component('comp-two', CompTwo) app.mount('#app')",
        "import { createApp } from 'vue' import App from './App.vue'\nimport CompOne from './components/CompOne.vue'\nimport CompTwo from './components/CompTwo.vue' const app = createApp(App)\napp.component('comp-one', CompOne)\napp.component('comp-two', CompTwo) app.mount('#app')",
        "<template> <h3>Local Component</h3> <p>The CompOne.vue component is a local component and can only be used inside App.vue.</p> <comp-one /> <comp-two /> </template> <script> import CompOne from './components/CompOne.vue'; export default { components: { 'comp-one': CompOne } } </script>",
        "<script> CompOne from './components/CompOne.vue'; export default { : { 'comp-one': } } </script>",
        "*.vue",
        "main.js",
        "<template>",
        "CompOne.vue",
        "CompTwo.vue",
        "App.vue",
        "<script>"
      ]
    },
    {
      "title": "Vue Slots",
      "summary": "Slots are a powerful feature in Vue that allow for more flexible and reusable components.\nWe use slots in Vue to send content from the parent into the <template> of a child component.\nSlots\nSo far we have just used components inside <template> as self-closing tags like this:\nApp.vue:\nInstead, we can use opening and closing tags, and put some content inside, like for example a text:\nApp.vue:\nBut to receive 'Hello World!' inside the component and display it on our page, we need to use the <slot> tag inside the component. The <slot> tag acts as a placeholder for the content, so that after the application is built the <slot> will be replaced by the content sent to it.\nExampleGet your own Vue Server\nSlotComp.vue:\nSlots as Cards\nSlots can also be used to wrap around larger chunks of dynamic html content to get a card-like appearance.\nEarlier we have sent data as props to create content inside components, now we can just send the HTML content directly inside the <slot> tag as it is.\nExample\nApp.vue:\nAs the content enters the component where the <slot> is, we use a div around the <slot> and style the <div> locally to create a card-like appearance around the content without affecting other divs in our application.\nSlotComp.vue:\nComponents that produce a card-like frame around content can be reused to create different elements, but with the same card-like frame around.\nIn this example we use the same component as for the food items to create a footer.\nExample\nApp.vue:\nFallback Content\nIf a component is created without content we can have fallback content in the <slot>.\nExample\nThe first component in this application has no content provided, so the fallback content is rendered.\nApp.vue:\nSlotComp.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhen a text is provided between the start tag and end tag of a component like this:\n<comp-one>Hello World!</comp-one>\nThe text provided can be received in the component using slots, like this:\nStart the Exercise",
      "examples": [
        "<template> <slot-comp /> </template>",
        "<template> <slot-comp>Hello World!</slot-comp> </template>",
        "<template> <div> <p>SlotComp.vue</p> <slot></slot> </div> </template>",
        "<template> <h3>Slots in Vue</h3> <p>We create card-like div boxes from the foods array.</p> <div id=\"wrapper\"> <slot-comp v-for=\"x in foods\"> <img v-bind:src=\"x.url\"> <h4>{{x.name}}</h4> <p>{{x.desc}}</p> </slot-comp> </div> </template>",
        "<template> <div> <!-- This div makes the card-like appearance --> <slot></slot> </div> </template> <script></script> <style scoped> div { box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); border-radius: 10px; margin: 10px; } </style>",
        "<template> <h3>Reusable Slot Cards</h3> <p>We create card-like div boxes from the foods array.</p> <p>We also create a card-like footer by reusing the same component.</p> <div id=\"wrapper\"> <slot-comp v-for=\"x in foods\"> <img v-bind:src=\"x.url\"> <h4>{{x.name}}</h4> </slot-comp> </div> <footer> <slot-comp> <h4>Footer</h4> </slot-comp> </footer> </template>",
        "<template> <h3>Slots Fallback Content</h3> <p>A component without content provided can have fallback content in the slot tag.</p> <slot-comp> <!-- Empty --> </slot-comp> <slot-comp> <h4>This content is provided from App.vue</h4> </slot-comp> </template>",
        "<template> <div> <slot> <h4>This is fallback content</h4> </slot> </div> </template>",
        "<template> <div> <p>CompOne.vue</p> </div> </template>",
        "<template>",
        "App.vue",
        "<slot>",
        "SlotComp.vue",
        "<div>",
        "<comp-one>Hello World!</comp-one>"
      ]
    },
    {
      "title": "Vue v-slot",
      "summary": "We need the v-slot directive to refer to named slots.\nNamed slots allow for more control over where the content is placed within the child component's template.\nNamed slots can be used to create more flexible and reusable components.\nBefore using v-slot and named slots, let's see what happens if we use two slots in the component:\nExampleGet your own Vue Server\nApp.vue:\nSlotComp.vue:\nWith two slots in a component, we can see that the content simply appears both places.\nv-slot and Named Slots\nIf we have more than one <slot> in a component, but we want to control in which <slot> the content should appear, we need to name the slots and use v-slot to send the content to the right place.\nExample\nTo be able to differentiate the slots we give the slots different names.\nSlotComp.vue:\nAnd now we can use v-slot in App.vue to direct the content to the right slot.\nApp.vue:\nDefault Slots\nIf you have a <slot> with no name, that <slot> will be default for components marked with v-slot:default, or components that are not marked with v-slot.\nTo see how this works we just need to make two small changes in our previous example:\nExample\nSlotComp.vue:\nApp.vue:\nAs already mentioned, we can mark content with the default value v-slot:default to make it even more clear that the content belongs to the default slot.\nExample\nSlotComp.vue:\nApp.vue:\nv-slot in <template>\nAs you have seen the v-slot directive can be used as an attribute in the component tag.\nv-slot can also be used in a <template> tag to direct larger parts of content to a certain <slot>.\nExample\nApp.vue:\nSlotComp.vue:\nWe use the <template> tag to direct some content to a certain <slot> because the <template> tag is not rendered, it is just a placeholder for the content. You can see this by inspecting the built page: you will not find the template tag there.\nv-slot Shorthand #\nThe shorthand for v-slot: is #.\nThis means that:\nCan be written as:\nExample\nApp.vue:\nSlotComp.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nIf a component 'CompOne' has two slots, like this:\n<slot name=\"headerSlot\"></slot>\n<slot name=\"mainSlot\"></slot>\nHow can we, from App.vue, direct the text 'Animals are interesting!' into the slot 'mainSlot' in 'CompOne'?\nStart the Exercise",
      "examples": [
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp>'Hello!'</slot-comp>",
        "<h3>Component</h3> <div> <slot></slot> </div> <div> <slot></slot> </div>",
        "<h3>Component</h3> <div> <slot name=\"topSlot\"></slot> </div> <div> <slot name=\"bottomSlot\"></slot> </div>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp v-slot:bottomSlot>'Hello!'</slot-comp>",
        "<h3>Component</h3> <div> <slot\nname=\"topSlot\"\n></slot> </div> <div> <slot name=\"bottomSlot\"></slot> </div>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp\nv-slot:bottomSlot\n>'Hello!'</slot-comp>",
        "<h3>Component</h3> <div> <slot></slot> </div> <div> <slot name=\"bottomSlot\"></slot> </div>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp v-slot:default>'Default slot'</slot-comp>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp> <template v-slot:bottomSlot> <h4>To the bottom slot!</h4> <p>This p tag and the h4 tag above are directed to the bottom slot with the v-slot directive used on the template tag.</p> </template> <p>This goes into the default slot</p> </slot-comp>",
        "<slot-comp v-slot:topSlot>'Hello!'</slot-comp>",
        "<slot-comp #topSlot>'Hello!'</slot-comp>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp #topSlot>'Hello!'</slot-comp>",
        "<slot-comp > Animals are interesting! </slot-comp>",
        "v-slot",
        "App.vue",
        "SlotComp.vue",
        "<slot>",
        "v-slot:default",
        "<template>",
        "v-slot:",
        "#",
        "<slot name=\"headerSlot\"></slot>",
        "<slot name=\"mainSlot\"></slot>"
      ]
    },
    {
      "title": "Scoped Slots",
      "summary": "A Scoped slot provides local data from the component so that the parent can choose how to render it.\nSend Data to Parent\nWe use v-bind in the component slot to send local data to the parent:\nSlotComp.vue:\nThe data inside the component can be referred to as 'local' because it is not accessible to the parent unless it is sent up to the parent like we do here with v-bind.\nReceive Data from Scoped Slot\nThe local data in the component is sent with v-bind, and it can be received in the parent with v-slot:\nExampleGet your own Vue Server\nApp.vue:\nIn the example above, 'dataFromSlot' is just a name we can choose ourselves to represent the data object we receive from the scoped slot. We get the text string from the slot by using the 'lclData' property, and we use interpolation to finally render the text in an <h2> tag.\nScoped Slot with an Array\nA scoped slot can send data from an array by using v-for, but the code in App.vue is basically the same:\nExample\nSlotComp.vue:\nApp.vue:\nScoped Slot with an Array of Objects\nA scoped slot can send data from an array of objects by using v-for:\nExample\nSlotComp.vue:\nApp.vue:\nStatic Data from a Scoped Slot\nA scoped slot can also send static data, that is data that does not belong to the data property of the Vue instance.\nWhen sending static data we do not use v-bind.\nIn the example below we send one static text, and one text bound dynamically to the data instance so that we can see the difference.\nExample\nSlotComp.vue:\nApp.vue:\nNamed Scoped Slots\nScoped slots can be named.\nTo use named scoped slots we need to name the slots inside the component with the 'name' attribute.\nAnd to receive data from a named slot we need to refer to that name in the parent where we use the component, with the v-slot directive, or shorthand #.\nExample\nIn this example the component is created one time referring to the slot \"leftSlot\", and one time referring to the slot \"rightSlot\".\nSlotComp.vue:\nApp.vue:\nAlternatively, we can create the component one time, with two different \"template\" tags, each \"template\" tag referring to a different slot.\nExample\nIn this example the component is created only one time, but with two \"template\" tags, each referring to a different slot.\nSlotComp.vue is exactly the same as in the previous example.\nApp.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhat directives are needed to provide data from a components slot to the parent?\nStart the Exercise",
      "examples": [
        "<template> <slot v-bind:lclData=\"data\"></slot> </template> <script> export default { data() { return { data: 'This is local data' } } } </script>",
        "<slot-comp v-slot:\"dataFromSlot\"> <h2>{{ dataFromSlot.lclData }}</h2> </slot-comp>",
        "<template> <slot v-for=\"x in foods\" :key=\"x\" :foodName=\"x\" ></slot> </template> <script> export default { data() { return { foods: ['Apple','Pizza','Rice','Fish','Cake'] } } } </script>",
        "<slot-comp v-slot=\"food\"> <h2>{{ food.foodName }}</h2> </slot-comp>",
        "<template> <slot v-for=\"x in foods\" :key=\"x.name\" :foodName=\"x.name\" :foodDesc=\"x.desc\" :foodUrl=\"x.url\" ></slot> </template> <script> export default { data() { return { foods: [ { name: 'Apple', desc: 'Apples are a type of fruit that grow on trees.', url: 'img_apple.svg' }, { name: 'Pizza', desc: 'Pizza has a bread base with tomato sauce, cheese, and toppings on top.', url: 'img_pizza.svg' }, { name: 'Rice', desc: 'Rice is a type of grain that people like to eat.', url: 'img_rice.svg' }, { name: 'Fish', desc: 'Fish is an animal that lives in water.', url: 'img_fish.svg' }, { name: 'Cake', desc: 'Cake is something sweet that tastes good but is not considered healthy.', url: 'img_cake.svg' } ] } } } </script>",
        "<slot-comp v-slot=\"food\"> <hr> <h2>{{ food.foodName }}<img :src=food.foodUrl></h2> <p>{{ food.foodDesc }}</p> </slot-comp>",
        "<template> <slot staticText=\"This text is static\" :dynamicText=\"text\" ></slot> </template> <script> export default { data() { return { text: 'This text is from the data property' } } } </script>",
        "<slot-comp v-slot=\"texts\"> <h2>{{ texts.staticText }}</h2> <p>{{ texts.dynamicText }}</p> </slot-comp>",
        "<template> <slot name=\"leftSlot\" :text=\"leftText\" ></slot> <slot name=\"rightSlot\" :text=\"rightText\" ></slot> </template> <script> export default { data() { return { leftText: 'This text belongs to the LEFT slot.', rightText: 'This text belongs to the RIGHT slot.' } } } </script>",
        "<slot-comp #leftSlot=\"leftProps\"> <div>{{ leftProps.text }}</div> </slot-comp> <slot-comp #rightSlot=\"rightProps\"> <div>{{ rightProps.text }}</div> </slot-comp>",
        "<slot-comp> <template #leftSlot=\"leftProps\"> <div>{{ leftProps.text }}</div> </template> <template #rightSlot=\"rightProps\"> <div>{{ rightProps.text }}</div> </template> </slot-comp>",
        "Local data in a component is sent from a slot with , and it can be received in the parent with . CompOne.vue: <slot :lclData=\"data\"></slot> App.vue: <comp-one :\"dataFromSlot\"> <h2>{{ dataFromSlot.lclData }}</h2> </comp-one>",
        "v-bind",
        "SlotComp.vue",
        "v-slot",
        "App.vue",
        "<h2>",
        "v-for",
        "#",
        "\"template\""
      ]
    },
    {
      "title": "Dynamic Components",
      "summary": "Dynamic Components can be used to flip through pages within your page, like tabs in your browser, with the use of the 'is' attribute.\nThe Component Tag and The 'is' Attribute\nTo make a dynamic component we use the <component> tag to represent the active component. The 'is' attribute is tied to a value with v-bind, and we change that value to the name of the component we want to have active.\nExampleGet your own Vue Server\nIn this example we have a <component> tag that acts as a placeholder for either the comp-one component or the comp-two component. The 'is' attribute is set on the <component> tag and listens to the computed value 'activeComp' that holds either 'comp-one' or 'comp-two' as value. And we have a button that toggles a data property between 'true' and 'false' to make the computed value switch between the active components.\nApp.vue:\n<KeepAlive>\nRun the example below. You will notice that changes you make in one component is forgotten when you switch back to it. That is because the component is unmounted and mounted again, reloading the component.\nExample\nThis example is the same as the previous example except the components are different. In comp-one you can choose between 'Apple' and 'Cake', and in comp-two you can write a message. Your inputs will be gone when you return to a component.\nTo keep the state, your previous inputs, when returning to a component we use the <KeepAlive> tag around the <component> tag.\nExample\nThe components now remember the user inputs.\nApp.vue:\nThe 'include' and 'exclude' Attributes\nAll components inside the <KeepAlive> tag will be kept alive by default.\nBut we can also define only some components to be kept alive by using 'include' or 'exclude' attributes on the <KeepAlive> tag.\nIf we use the 'include' or 'exclude' attributes on the <KeepAlive> tag we also need to give the components names with the 'name' option:\nCompOne.vue:\nExample\nWith <KeepAlive include=\"CompOne\">, only the 'CompOne' component will remember its state, the previous inputs.\nApp.vue:\nWe can also use 'exclude' to choose which components to keep alive or not.\nExample\nWith <KeepAlive exclude=\"CompOne\">, only the 'CompTwo' component will remember its state.\nApp.vue:\nBoth 'include' and 'exclude' can be used with multiple components by using comma separation.\nTo show this we will add one more component so that we get three components in total.\nExample\nWith <KeepAlive include=\"CompOne, CompThree\">, both the 'CompOne' and the 'CompThree' components will remember their state.\nApp.vue:\nThe 'max' Attribute\nWe can use 'max' as an attribute to the <KeepAlive> tag to limit the number of components the browser needs to remember the state of.\nExample\nWith <KeepAlive :max=\"2\">, the browser will only remember the user input of the last two visited components.\nApp.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhat attribute is used when making dynamic components?\nStart the Exercise",
      "examples": [
        "<template> <h1>Dynamic Components</h1> <p>App.vue switches between which component to show.</p> <button @click=\"toggleValue = !toggleValue\"> Switch component </button> <component :is=\"activeComp\"></component> </template> <script> export default { data() { return { toggleValue: true } }, computed: { activeComp() { if(this.toggleValue) { return 'comp-one' } else { return 'comp-two' } } } } </script>",
        "<template> <h1>Dynamic Components</h1> <p>App.vue switches between which component to show.</p> <button @click=\"toggleValue = !toggleValue\"> Switch component </button> <KeepAlive> <component :is=\"activeComp\"></component> </KeepAlive> </template>",
        "<script> export default { name: 'CompOne', data() { return { imgSrc: 'img_question.svg' } } } </script>",
        "<template> <h1>Dynamic Components</h1> <p>App.vue switches between which component to show.</p> <button @click=\"toggleValue = !toggleValue\"> Switch component </button> <KeepAlive include=\"CompOne\"> <component :is=\"activeComp\"></component> </KeepAlive> </template>",
        "<template> <h1>Dynamic Components</h1> <button @click=\"compNbr++\"> Next component </button> <KeepAlive include=\"CompOne,CompThree\"> <component :is=\"activeComp\"></component> </KeepAlive> </template>",
        "<template> <h1>Dynamic Components</h1> <label><input type=\"radio\" name=\"rbgComp\" v-model=\"compName\" :value=\"'comp-one'\"> One</label> <label><input type=\"radio\" name=\"rbgComp\" v-model=\"compName\" :value=\"'comp-two'\"> Two</label> <label><input type=\"radio\" name=\"rbgComp\" v-model=\"compName\" :value=\"'comp-three'\"> Three</label> <KeepAlive :max=\"2\"> <component :is=\"activeComp\"></component> </KeepAlive> </template>",
        "<component :=\"activeComp\"></component>",
        "<component>",
        "v-bind",
        "comp-one",
        "comp-two",
        "App.vue",
        "<KeepAlive>",
        "CompOne.vue",
        "<KeepAlive include=\"CompOne\">",
        "<KeepAlive exclude=\"CompOne\">",
        "<KeepAlive include=\"CompOne, CompThree\">",
        "<KeepAlive :max=\"2\">"
      ]
    },
    {
      "title": "Vue Teleport",
      "summary": "The Vue <Teleport> tag is used to move content to a different place in the DOM structure.\n<Teleport> and The 'to' Attribute\nTo move some content to somewhere else in the DOM structure we use the Vue <Teleport> tag around the content and the 'to' attribute to define where to move it.\nThe 'to' attribute value is given as CSS notation, so if we want to send some content to the body tag like in the code above we simply write <Teleport to=\"body\">.\nWe can see that the content is moved to the body tag by inspecting the page after it has loaded.\nExampleGet your own Vue Server\nCompOne.vue:\nIf we right-click our page and choose 'Inspect', we can see that the red <div> element is moved out of the component and to the end of the <body> tag.\nWe could also for example have a tag with an id <div id=\"receivingDiv\"> and teleport some content to that <div> by using <Teleport to=\"#receivingDiv\"> around the content we want to teleport/move.\nScript and Style of Teleported Elements\nEven though some content is moved out of a component with the <Teleport> tag, relevant code inside the component in the <script> and <style> tags still works for the moved content.\nExample\nRelevant code from the <style> and <script> tags still works for the teleported <div> tag even though it is no longer inside the component after compilation.\nCompOne.vue:",
      "examples": [
        "<Teleport to=\"body\"> <p>Hello!</p> </Teleport>",
        "<template> <div> <h2>Component</h2> <p>This is the inside of the component.</p> <Teleport to=\"body\"> <div id=\"redDiv\">Hello!</div> </Teleport> </div> </template>",
        "<template> <div> <h2>Component</h2> <p>This is the inside of the component.</p> <Teleport to=\"body\"> <div id=\"redDiv\" @click=\"toggleVal = !toggleVal\" :style=\"{ backgroundColor: bgColor }\" > Hello!<br> Click me! </div> </Teleport> </div> </template> <script> export default { data() { return { toggleVal: true } }, computed: { bgColor() { if (this.toggleVal) { return 'lightpink' } else { return 'lightgreen' } } } } </script> <style scoped> #redDiv { margin: 10px; padding: 10px; display: inline-block; } #redDiv:hover { cursor: pointer; } </style>",
        "<Teleport>",
        "<Teleport to=\"body\">",
        "CompOne.vue",
        "<div>",
        "<body>",
        "<div id=\"receivingDiv\">",
        "<Teleport to=\"#receivingDiv\">",
        "<script>",
        "<style>"
      ]
    },
    {
      "title": "Vue HTTP Requests",
      "summary": "The HTTP request is a part of the communication between a client and a server.\nThe client sends an HTTP request to the server, which handles the request and returns an HTTP response.\nHTTP\nHTTP stands for Hyper Text Transfer Protocol.\nOur browser makes HTTP requests all the time in the background when we browse the Internet. When we access an Internet page, our browser (the client) sends several HTTP requests to make the server send us the page we want with all the relevant files and data as HTTP responses.\nThe most common kinds of HTTP requests are POST, GET, PUT, PATCH, and DELETE. Learn more about the different kinds of HTTP requests on our HTTP Request Methods page.\nLearn more about what HTTP is on our What is HTTP page.\nThe 'fetch' Method\nTo get data from a server in Vue we can use the JavaScript fetch() method.\nWhen we use the fetch() method in this tutorial we will not specify the HTTP request method, and that means that the default request method GET is what is used in the background.\nThe fetch() method expects a URL address as an argument so that it knows where to get the data from.\nHere is a simple example that uses the fetch() method to send an HTTP GET request, and receive data as an HTTP response. The data requested in this case is the text inside the local file file.txt:\nExampleGet your own Vue Server\nApp.vue:\nIn the example above, we only get \"[object Promise]\" as a result, but that is not what we want.\nWe get this result because fetch() is a promised-based method that returns a promise object. The first return the fetch() method gives is therefore just an object which means that the HTTP request has been sent. This is the \"pending\" state.\nWhen the fetch() method actually gets the data we want, the promise is fulfilled.\nTo wait for the response to be fulfilled, with the data we want, we need to use the await operator in front of the fetch() method:\nWhen the await operator is used inside a method, the method is required to be declared with the async operator:\nThe async operator tells the browser that the method is asynchronous, which means that it waits for something, and the browser can continue to do other tasks while it waits for the method to complete.\nNow what we get is a \"Response\", and no longer just a \"Promise\", which means we are one step closer to get the actual text inside the file.txt file:\nExample\nApp.vue:\nTo get the text inside the file.txt file we need to use the text() method on the response. Because the text() method is a promise based method, we need to use the await operator in front of it.\nFinally! We now have what we need to get the text from inside the file.txt file with the fetch() method:\nExample\nApp.vue:\nFetch Data from a JSON File\nIn the previous example we fetched text from a .txt file. But there are many ways to store data, and now we will see how we can fetch information from a .json file.\nJSON is a common file format that is easy to work with because data is stored as text so that it is easy to read for humans, and the JSON format is also widely supported by programming languages, so that we can, for example, specify what data to extract from a .json file.\nTo read data from a .json file, the only change we need to do to the example above is to fetch a .json file, and use the json() method instead of the text() method on the response.\nThe json() method reads the response from the HTTP request and returns a JavaScript object.\nWe use the <pre> tag here to show the JSON formatted text because it preserves spaces and line breaks so that it is easier to read.\nExample\nApp.vue:\nBecause the result of the json() method is a JavaScript object, we can modify the example above to show a random animal from the bigLandMammals.json file:\nExample\nApp.vue:\nData from an API\nAPI stands for Application Programming Interface. You can learn more about API here.\nThere are a lot of interesting free APIs we can connect with and use, to get weather data, stock exchange data, etc.\nThe response we get when we call an API with an HTTP request can contain all kinds of data, but often contains data in the JSON format.\nExample\nA button can be clicked to get a random user from the random-data-api.com API.\nApp.vue:\nWe can modify our previous example a little bit to include the random user in a more user friendly way:\nExample\nWe show the random user name in a <pre> tag, along with the job title and image when the button is clicked.\nApp.vue:\nHTTP Request in Vue with The 'axios' Library\nThe 'axios' JavaScript library also allows us to make HTTP requests.\nTo create and run the example on your own machine you first need to install the 'axios' library using the terminal in your project folder, like this:\nThis is how we can use the 'axios' library in Vue to fetch a random user:\nExample\nOnly small changes are made to the previous example to do the HTTP request with the 'axios' library instead.\nApp.vue:",
      "examples": [
        "<template> <div> <button @click=\"fetchData\">Fetch Data</button> <p v-if=\"data\">{{ data }}</p> </div> </template> <script> export default { data() { return { data: null, }; }, methods: { fetchData() { const response = fetch(\"file.txt\"); this.data = response; } } }; </script>",
        "const response = await fetch(\"file.txt\");",
        "async fetchData() { const response = await fetch(\"file.txt\"); this.data = response; }",
        "<template> <div> <button @click=\"fetchData\">Fetch Data</button> <p v-if=\"data\">{{ data }}</p> </div> </template> <script> export default { data() { return { data: null, }; }, methods: { async fetchData() { const response = await fetch(\"file.txt\"); this.data = response; } } }; </script>",
        "<template> <div> <button @click=\"fetchData\">Fetch Data</button> <p v-if=\"data\">{{ data }}</p> </div> </template> <script> export default { data() { return { data: null, }; }, methods: { async fetchData() { const response = await fetch(\"file.txt\"); this.data = await response.text(); } } }; </script>",
        "<template> <div> <button @click=\"fetchData\">Fetch Data</button> <pre v-if=\"data\">{{ data }}</pre> </div> </template> <script> export default { data() { return { data: null, }; }, methods: { async fetchData() { const response = await fetch(\"bigLandMammals.json\"); this.data = await response.json(); } } }; </script>",
        "<template> <p>Try clicking the button more than once to see new animals picked randomly.</p> <button @click=\"fetchData\">Fetch Data</button> <div v-if=\"randomMammal\"> <h2>{{ randomMammal.name }}</h2> <p>Max weight: {{ randomMammal.maxWeight }} kg</p> </div> </template> <script> export default { data() { return { randomMammal: null }; }, methods: { async fetchData() { const response = await fetch(\"bigLandMammals.json\"); const data = await response.json(); const randIndex = Math.floor(Math.random()*data.results.length); this.randomMammal = data.results[randIndex]; } } }; </script>",
        "<template> <h1>Example</h1> <p>Click the button to fetch data with an HTTP request.</p> <p>Each click generates an object with a random user from <a href=\"https://random-data-api.com/\" target=\"_blank\">https://random-data-api.com/</a>.</p> <p>The robot avatars are lovingly delivered by <a href=\"http://Robohash.org\" target=\"_blank\">RoboHash</a>.</p> <button @click=\"fetchData\">Fetch data</button> <pre v-if=\"data\">{{ data }}</pre> </template> <script> export default { data() { return { data: null, }; }, methods: { async fetchData() { const response = await fetch(\"https://random-data-api.com/api/v2/users\"); this.data = await response.json(); } } }; </script>",
        "<template> <h1>Example</h1> <p>Click the button to fetch data with an HTTP request.</p> <p>Each click generates an object with a random user from <a href=\"https://random-data-api.com/\" target=\"_blank\">https://random-data-api.com/</a>.</p> <p>The robot avatars are lovingly delivered by <a href=\"http://Robohash.org\" target=\"_blank\">RoboHash</a>.</p> <button @click=\"fetchData\">Fetch data</button> <div v-if=\"data\" id=\"dataDiv\"> <img :src=\"data.avatar\" alt=\"avatar\"> <pre>{{ data.first_name + \" \" + data.last_name }}</pre> <p>\"{{ data.employment.title }}\"</p> </div> </template> <script> export default { data() { return { data: null, }; }, methods: { async fetchData() { const response = await fetch(\"https://random-data-api.com/api/v2/users\"); this.data = await response.json(); }, } }; </script> <style> #dataDiv { width: 240px; background-color: aquamarine; border: solid black 1px; margin-top: 10px; padding: 10px; } #dataDiv > img { width: 100%; } pre { font-size: larger; font-weight: bold; } </style>",
        "<template> <h1>Example</h1> <p>Click the button to fetch data with an HTTP request.</p> <p>Each click generates an object with a random user from <a href=\"https://random-data-api.com/\" target=\"_blank\">https://random-data-api.com/</a>.</p> <p>The robot avatars are lovingly delivered by <a href=\"http://Robohash.org\" target=\"_blank\">RoboHash</a>.</p> <button @click=\"fetchData\">Fetch data</button> <div v-if=\"data\" id=\"dataDiv\"> <img :src=\"data.data.avatar\" alt=\"avatar\"> <pre>{{ data.data.first_name + \" \" + data.data.last_name }}</pre> <p>\"{{ data.data.employment.title }}\"</p> </div> </template> <script> import axios from 'axios' export default { data() { return { data: null, }; }, methods: { async fetchData() { this.data = await axios.get(\"https://random-data-api.com/api/v2/users\"); } } }; </script> <style> #dataDiv { width: 240px; background-color: aquamarine; border: solid black 1px; margin-top: 10px; padding: 10px; } #dataDiv > img { width: 100%; } pre { font-size: larger; font-weight: bold; } </style>",
        "npm install axios",
        "POST",
        "GET",
        "PUT",
        "PATCH",
        "DELETE",
        "fetch()",
        "file.txt",
        "App.vue",
        "await",
        "async",
        "text()",
        ".txt",
        ".json",
        "JSON",
        "json()",
        "<pre>",
        "bigLandMammals.json"
      ]
    },
    {
      "title": "Vue Template Refs",
      "summary": "Vue Template Refs are used to refer to specific DOM elements.\nWhen the ref attribute is set on an HTML tag, the resulting DOM element is added to the $refs object.\nWe can use the ref attribute and the $refs object in Vue as an alternative to methods in plain JavaScript like getElementById() or querySelector().\nThe 'ref' Attribute and The '$refs' Object\nHTML tags with the ref attribute will be added to the $refs object and can be reached later from inside the <script> tag.\nExampleGet your own Vue Server\nThe text inside a <p> element is changed.\nApp.vue:\nBelow is another example where the $refs object is used to copy the value of one tag into another tag.\nExample\nThe text from the first <p> tag is copied into the second <p> tag.\nApp.vue:\nGet The Input Value from '$refs'\nWe can go further into an HTML element added to the $refs object to access any property we want.\nExample\nA <p> element gets the same content as what's being written in the input field.\nApp.vue:\n'ref' with v-for\nHTML elements created with v-for, with the ref attribute, will be added to the $refs object as an array.\nExample\nThe button reveals the the third list element stored as an array element inside the $refs object.\nApp.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nRefs are used to refer to specific DOM elements.\nSupply the missing code so that 'Hello World' is displayed in the second <p> tag when the application is mounted.\nStart the Exercise",
      "examples": [
        "<template> <h1>Example</h1> <p>Click the button to put \"Hello!\" as the text in the green p element.</p> <button @click=\"changeVal\">Change Text</button> <p ref=\"pEl\">This is the initial text</p> </template> <script> export default { methods: { changeVal() { this.$refs.pEl.innerHTML = \"Hello!\"; } } } </script>",
        "<template> <h1>Example</h1> <p ref=\"p1\">Click the button to copy this text into the paragraph below.</p> <button @click=\"transferText\">Transfer text</button> <p ref=\"p2\">...</p> </template> <script> export default { methods: { transferText() { this.$refs.p2.innerHTML = this.$refs.p1.innerHTML; } } }; </script>",
        "<template> <h1>Example</h1> <p>Start writing inside the input element, and the text will be copied into the last paragraph by the use of the '$refs' object.</p> <input ref=\"inputEl\" @input=\"getRefs\" placeholder=\"Write something..\"> <p ref=\"pEl\"></p> </template> <script> export default { methods: { getRefs() { this.$refs.pEl.innerHTML = this.$refs.inputEl.value; } } }; </script>",
        "<template> <h1>Example</h1> <p>Click the button to reveal the 3rd list element stored as an array element in the $refs object.</p> <button @click=\"getValue\">Get the 3rd list element</button><br> <ul> <li v-for=\"x in liTexts\" ref=\"liEl\">{{ x }}</li> </ul> <pre>{{ thirdEl }}</pre> </template> <script> export default { data() { return { thirdEl: ' ', liTexts: ['Apple','Banana','Kiwi','Tomato','Lichi'] } }, methods: { getValue() { this.thirdEl = this.$refs.liEl[2].innerHTML; console.log(\"this.$refs.liEl = \",this.$refs.liEl); } } }; </script> <style> pre { background-color: lightgreen; display: inline-block; } </style>",
        "<template> <p>This is just some text.</p> <p >This is the initial text</p> </template> <script> export default { mounted() { this..pEl.innerHTML = \"Hello World!\"; } }; </script>",
        "ref",
        "$refs",
        "<script>",
        "<p>",
        "App.vue",
        "v-for"
      ]
    },
    {
      "title": "Vue Lifecycle Hooks",
      "summary": "Lifecycle hooks in Vue are certain stages in the lifecycle of a component where we can add code to do things.\nLifecycle Hooks\nEvery time a component reaches a new stage in its lifecycle, a specific function runs, and we can add code to that function. Such functions are called lifecycle hooks, because we can \"hook\" our code into that stage.\nThese are all the lifecycle hooks a component has:\nbeforeCreate\ncreated\nbeforeMount\nmounted\nbeforeUpdate\nupdated\nbeforeUnmount\nunmounted\nerrorCaptured\nrenderTracked\nrenderTriggered\nactivated\ndeactivated\nserverPrefetch\nBelow are examples of these lifecycle hooks.\nThe 'beforeCreate' Hook\nThe beforeCreate lifecycle hook happens before the component is initialized, so this is before Vue has set up the component's data, computed properties, methods, and event listeners.\nThe beforeCreate hook can be used to for example set up a global event listener, but we should avoid trying to access elements that belong to the component from the beforeCreate lifecycle hook, such as data, watchers and methods, because they are not created yet at this stage.\nAlso, it does not make sense to try to access DOM elements from the beforeCreate lifecycle hook, because they are not created until after the component is mounted.\nExampleGet your own Vue Server\nCompOne.vue:\nApp.vue:\nIn the example above, line 15 in CompOne.vue has no effect because in that line we try to change the text inside the Vue data property, but the Vue data property is actually not created yet. Also, remember to open the browser console to see the result of the console.log() call on line 16.\nThe 'created' Hook\nThe created lifecycle hook happens after the component is initialized, so Vue has already set up the component's data, computed properties, methods, and event listeners.\nWe should avoid trying to access DOM elements from the created lifecycle hook, because DOM elements are not accessible until the component is mounted.\nThe created lifecycle hook can be used to fetch data with HTTP requests, or set up initial data values. Like in the example below, the data property 'text' is given an initial value:\nExample\nCompOne.vue:\nApp.vue:\nThe 'beforeMount' Hook\nThe beforeMount lifecycle hook happens right before the component is mounted, so just before the component is added to the DOM.\nWe should avoid trying to access DOM elements from the beforeMount lifecycle hook, because DOM elements are not accessible until the component is mounted.\nThe example below shows that we cannot access DOM elements in the component yet, line 11 in CompOne.vue does not work, and generates an error in the browser console:\nExample\nCompOne.vue:\nApp.vue:\nThe 'mounted' Hook\nRight after a component is added to the DOM tree, the mounted() function is called, and we can add our code to that stage.\nThis is the first chance we have to do things related to DOM elements that belong to the component, like using the ref attribute and $refs object, as we do in the second example below here.\nExample\nCompOne.vue:\nApp.vue:\nNote: The mounted stage happens AFTER the the component is added to the DOM, but in the example above the alert() is visible BEFORE we see the component. The reason for this is that first the component is added to the DOM, but before the browser gets to render the component to the screen, the mounted stage happens and the alert() becomes visible and pauses the browser rendering the component.\nBelow is an example that is perhaps more useful: To put the cursor inside the input field after the form component is mounted, so the user can just start typing.\nExample\nCompOne.vue:\nThe 'beforeUpdate' Hook\nThe beforeUpdate lifecycle hook is called whenever there is a change in the data of our component, but before the update is rendered to the screen. The beforeUpdate lifecycle hook happens right before the updated lifecycle hook.\nSomething special about the beforeUpdate hook is that we can do changes to the application without it triggering a new update, so we avoid the otherwise infinite loop. That is the reason for not doing changes to the application in the updated lifecycle hook, because with that hook, an infinite loop will be created. Just take a look at the third example below from here, in red.\nExample\nThe beforeUpdate() function adds an <li> tag to the document to indicate that the beforeUpdate() function has run.\nCompOne.vue:\nApp.vue:\nThe 'updated' Hook\nThe updated lifecycle hook is called after our component has updated its DOM tree.\nExample\nThe updated() function writes a message with console.log(). This happens whenever the page is updated, which in this example is every time the component is added or removed.\nCompOne.vue:\nApp.vue:\nWe can see the result in the browser console after clicking the \"Add/Remove Component\" button 10 times:\nNote: We must be careful not to modify the page itself when the updated lifecycle hook is called, because then the page will update again and again, creating an infinite loop.\nLets try and see what happens if we do exactly like the note above warn us against. Will the page update indefinitely?:\nExample\nThe updated() function adds text to a paragraph, which in turn updates the page again, and the function runs again and again in an infinite loop. Luckily, your browser will stop this loop eventually.\nCompOne.vue:\nApp.vue:\nWhen running the code above locally on your machine in dev mode, the Chrome browser console warning looks like this:\nThe 'beforeUnmount' Hook\nThe beforeUnmount lifecycle hook is called just before a component is removed from the DOM.\nAs we can see in the example below, we can still access component elements in the DOM in the beforeUnmount hook.\nExample\nCompOne.vue:\nApp.vue:\nThe 'unmounted' Hook\nThe unmounted lifecycle hook is called after a component is removed from the DOM.\nThis hook can for example be used to remove event listeners or cancelling timers or intervals.\nWhen a component is unmounted, the unmounted() function is called, and we can add our code to it:\nExample\nCompOne.vue:\nApp.vue:\nNote: The unmounted stage happens AFTER the the component is removed from the DOM, but in the example above the alert() is visible BEFORE the component disappears. The reason for this is that first the component is removed from the DOM, but before the browser gets to render the removal of the component to the screen, the unmounted stage happens and the alert() becomes visible and pauses the browser from visibly removing the component.\nThe 'errorCaptured' Hook\nThe errorCaptured lifecycle hook is called when an error happens in a child/descendant component.\nThis hook can be used for error handling, logging or to display the error to the user.\nExample\nCompOne.vue:\nApp.vue:\nInformation about the error can also be captured as arguments to the errorCaptured() function and these arguments are:\nthe error\nthe component that triggered the error\nthe error source type\nIn the example below these arguments are captured in the errorCaptured() function and written to the console:\nExample\nCompOne.vue:\nApp.vue:\nThe 'renderTracked' and 'renderTriggered' Lifecycle Hooks\nThe renderTracked hook runs when a render function is set to track, or monitor, a reactive component. The renderTracked hook usually runs when a reactive component is initialized.\nThe renderTriggered hook runs when such a tracked reactive component changes, and therefore triggers a new render, so that the screen gets updated with the latest changes.\nA reactive component is a component that can change.\nA render function is a function compiled by Vue that keeps track of reactive components. When a reactive component changes, the render function is triggered and re-renders the application to the screen.\nThe renderTracked and renderTriggered hooks are meant to be used in debugging, and are only available in development mode.\nTo see the alert() and console.log() from the renderTracked and renderTriggered hooks, you must copy the code in the example below to your computer and run the application in development mode.\nExample\nCompOne.vue:\nApp.vue:\nNote: The code in the example above is intended to be copied and run locally on your computer in development mode, because the renderTracked and renderTriggered hooks only works in development mode.\nThe 'activated' and 'deactivated' Lifecycle Hooks\nAs we can see above on this page, we have the mounted and unmounted lifecycle hooks for when a component is removed or added to the DOM.\nThe activated and deactivated lifecycle hooks are for when a cached dynamic component is added or removed, but not from the DOM. The <KeepAlive> tag is used in the example below to cache the dynamic component.\nExample\nCompOne.vue:\nApp.vue:\nLet's expand the example above to see how both the activated and deactivated hooks work. Let's also use the mounted and unmounted hooks so that we can see that the mounted hook runs once the first time the cached component is added, and that the unmounted hook never runs for the cached component.\nExample\nCompOne.vue:\nApp.vue:\nThe 'serverPrefetch' Lifecycle Hook\nThe 'serverPrefetch' hook is only called during server-side rendering (SSR).\nExplaining and creating an example for the 'serverPrefetch' hook would require a relatively long introduction and setup, and that is beyond the scope of this tutorial.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nStart the Exercise",
      "examples": [
        "<template> <h2>Component</h2> <p>This is the component</p> <p id=\"pResult\">{{ text }}</p> </template> <script> export default { data() { return { text: '...' } }, beforeCreate() { this.text = 'initial text'; // This line has no effect console.log(\"beforeCreate: The component is not created yet.\"); } } </script>",
        "<template> <h1>The 'beforeCreate' Lifecycle Hook</h1> <p>We can see the console.log() message from 'beforeCreate' lifecycle hook, but there is no effect from the text change we try to do to the Vue data property, because the Vue data property is not created yet.</p> <button @click=\"this.activeComp = !this.activeComp\">Add/Remove Component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> </template> <script> export default { data() { return { activeComp: false } } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } #pResult { background-color: lightcoral; display: inline-block; } </style>",
        "<template> <h2>Component</h2> <p>This is the component</p> <p id=\"pResult\">{{ text }}</p> </template> <script> export default { data() { return { text: '...' } }, created() { this.text = 'initial text'; console.log(\"created: The component just got created.\"); } } </script>",
        "<template> <h1>The 'created' Lifecycle Hook</h1> <p>We can see the console.log() message from 'created' lifecycle hook, and the text change we try to do to the Vue data property works, because the Vue data property is already created at this stage.</p> <button @click=\"this.activeComp = !this.activeComp\">Add/Remove Component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> </template> <script> export default { data() { return { activeComp: false } } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } #pResult { background-color: lightcoral; display: inline-block; } </style>",
        "<template> <h2>Component</h2> <p>This is the component</p> <p ref=\"pEl\" id=\"pEl\">We try to access this text from the 'beforeMount' hook.</p> </template> <script> export default { beforeMount() { console.log(\"beforeMount: This is just before the component is mounted.\"); this.$refs.pEl.innerHTML = \"Hello World!\"; // <-- We cannot reach the 'pEl' DOM element at this stage } } </script>",
        "<template> <h1>The 'beforeMount' Lifecycle Hook</h1> <p>We can see the console.log() message from the 'beforeMount' lifecycle hook, but the text change we try to do to the 'pEl' paragraph DOM element does not work, because the 'pEl' paragraph DOM element does not exist yet at this stage.</p> <button @click=\"this.activeComp = !this.activeComp\">Add/Remove Component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> </template> <script> export default { data() { return { activeComp: false } } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } #pEl { background-color: lightcoral; display: inline-block; } </style>",
        "<template> <h2>Component</h2> <p>Right after this component is added to the DOM, the mounted() function is called and we can add code to that mounted() function. In this example, an alert popup box appears after this component is mounted.</p> <p><strong>Note:</strong> The reason that the alert is visible before the component is visible is because the alert is called before the browser gets to render the component to the screen.</p> </template> <script> export default { mounted() { alert(\"The component is mounted!\"); } } </script>",
        "<template> <h1>The 'mounted' Lifecycle Hook</h1> <button @click=\"this.activeComp = !this.activeComp\">Create component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> </template> <script> export default { data() { return { activeComp: false } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 20px; margin: 10px; width: 400px; background-color: lightgreen; } </style>",
        "<template> <h2>Form Component</h2> <p>When this component is added to the DOM tree, the mounted() function is called, and we put the cursor inside the input element.</p> <form @submit.prevent> <label> <p> Name: <br> <input type=\"text\" ref=\"inpName\"> </p> </label> <label> <p> Age: <br> <input type=\"number\"> </p> </label> <button>Submit</button> </form> <p>(This form does not work, it is only here to show the mounted lifecycle hook.)</p> </template> <script> export default { mounted() { this.$refs.inpName.focus(); } } </script>",
        "<template> <h2>Component</h2> <p>This is the component</p> </template>",
        "<template> <h1>The 'beforeUpdate' Lifecycle Hook</h1> <p>Whenever there is a change in our page, the application is 'updated' and the 'beforeUpdate' hook happens just before that.</p> <p>It is safe to modify our page in the 'beforeUpdate' hook like we do here, but if we modify our page in the 'updated' hook, we will generate an infinite loop.</p> <button @click=\"this.activeComp = !this.activeComp\">Add/Remove Component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> <ol ref=\"divLog\"></ol> </template> <script> export default { data() { return { activeComp: true } }, beforeUpdate() { this.$refs.divLog.innerHTML += \"<li>beforeUpdate: This happened just before the 'updated' hook.</li>\"; } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } </style>",
        "<template> <h1>The 'updated' Lifecycle Hook</h1> <p>Whenever there is a change in our page, the application is updated and the updated() function is called. In this example we use console.log() in the updated() function that runs when our application is updated.</p> <button @click=\"this.activeComp = !this.activeComp\">Add/Remove Component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> </template> <script> export default { data() { return { activeComp: true } }, updated() { console.log(\"The component is updated!\"); } } </script> <style> #app { max-width: 450px; } #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; width: 80%; background-color: lightgreen; } </style>",
        "<template> <h1>The 'updated' Lifecycle Hook</h1> <p>Whenever there is a change in our page, the application is updated and the updated() function is called.</p> <p>The first change that causes the updated hook to be called is when we remove the component by clicking the button. When this happens, the update() function adds text to the last paragraph, which in turn updates the page again and again.</p> <button @click=\"this.activeComp = !this.activeComp\">Add/Remove Component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> <div>{{ text }}</div> </template> <script> export default { data() { return { activeComp: true, text: \"Hello, \" } }, updated() { this.text += \"hi, \"; } } </script> <style> #app { max-width: 450px; } #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; width: 80%; background-color: lightgreen; } </style>",
        "<template> <h2>Component</h2> <p ref=\"pEl\">Strawberries!</p> </template> <script> export default { beforeUnmount() { alert(\"beforeUnmount: The text inside the p-tag is: \" + this.$refs.pEl.innerHTML); } } </script>",
        "<template> <h1>Lifecycle Hooks</h1> <button @click=\"this.activeComp = !this.activeComp\">{{ btnText }}</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> </template> <script> export default { data() { return { activeComp: true } }, computed: { btnText() { if(this.activeComp) { return 'Remove component' } else { return 'Add component' } } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 20px; margin: 10px; width: 400px; background-color: lightgreen; } </style>",
        "<template> <h2>Component</h2> <p>When this component is removed from the DOM tree, the unmounted() function is called and we can add code to that function. In this example we create an alert popup box when this component is removed.</p> </template> <script> export default { unmounted() { alert(\"The component is removed (unmounted)!\"); } } </script>",
        "<template> <h2>Component</h2> <p>This is the component</p> <button @click=\"generateError\">Generate Error</button> </template> <script> export default { methods: { generateError() { this.$refs.objEl.innerHTML = \"hi\"; } } } </script>",
        "<template> <h1>The 'errorCaptured' Lifecycle Hook</h1> <p>Whenever there is an error in a child component, the errorCaptured() function is called on the parent.</p> <p>When the button inside the component is clicked, a method will run that tries to do changes to a $refs object that does not exist. This creates an error in the component that triggers the 'errorCaptured' lifecycle hook in the parent, and an alert box is displayed with information about the error.</p> <p>After clicking \"Ok\" in the alert box you can see the error in the browser console.</p> <div> <comp-one></comp-one> </div> </template> <script> export default { errorCaptured() { alert(\"An error occurred\"); } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } </style>",
        "<template> <h1>The 'errorCaptured' Lifecycle Hook</h1> <p>Whenever there is an error in a child component, the errorCaptured() function is called on the parent.</p> <p>Open the browser console to see the captured error details.</p> <div> <comp-one></comp-one> </div> </template> <script> export default { errorCaptured(error,compInst,errorInfo) { console.log(\"error: \", error); console.log(\"compInst: \", compInst); console.log(\"errorInfo: \", errorInfo); } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } </style>",
        "<template> <h2>Component One</h2> <p>This is a component.</p> <button @click=\"counter++\">Add One</button> <p>{{ counter }}</p> </template> <script> export default { data() { return { counter: 0 } }, renderTracked(evt) { console.log(\"renderTracked: \",evt); alert(\"renderTracked\"); }, renderTriggered(evt) { console.log(\"renderTriggered: \",evt) alert(\"renderTriggered\"); } } </script>",
        "<template> <h1>The 'renderTracked' and 'renderTriggered' Lifecycle Hooks</h1> <p>The 'renderTracked' and 'renderTriggered' lifecycle hooks are used for debugging.</p> <p><mark>This example only works in development mode, so to see the hooks run, you must copy this code and run it on you own computer in development mode.</mark></p> <div> <comp-one></comp-one> </div> </template> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 20px; margin-top: 10px; background-color: lightgreen; } </style>",
        "<template> <h2>Component</h2> <p>Below is a log with every time the 'mounted' or 'activated' hooks run.</p> <ol ref=\"olEl\"></ol> <p>You can also see when these hooks run in the console.</p> </template> <script> export default { mounted() { console.log(\"mounted\"); const liEl = document.createElement(\"li\"); liEl.innerHTML = \"mounted\"; this.$refs.olEl.appendChild(liEl); }, activated() { console.log(\"activated\"); const liEl = document.createElement(\"li\"); liEl.innerHTML = \"activated\"; this.$refs.olEl.appendChild(liEl); } } </script> <style> li { background-color: lightcoral; width: 5em; } </style>",
        "<template> <h1>The 'activated' Lifecycle Hook</h1> <p>In this example for the 'activated' hook we check if the component is cached properly with <KeepAlive>.</p> <p>If the component is cached properly with <KeepAlive> we expect the 'mounted' hook to run once the first time the component is included (must be added to the DOM the first time), and we expect the 'activated' hook to run every time the component is included (also the first time).</p> <button @click=\"this.activeComp = !this.activeComp\">Include component</button> <div> <KeepAlive> <comp-one v-if=\"activeComp\"></comp-one> </KeepAlive> </div> </template> <script> export default { data() { return { activeComp: false } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 20px; margin-top: 10px; background-color: lightgreen; } </style>",
        "<template> <h2>Component</h2> <p>Below is a log with every time the 'activated', 'deactivated', 'mounted' or 'unmounted' hooks run.</p> <ol ref=\"olEl\"></ol> <p>You can also see when these hooks run in the console.</p> </template> <script> export default { mounted() { this.logHook(\"mounted\"); }, unmounted() { this.logHook(\"unmounted\"); }, activated() { this.logHook(\"activated\"); }, deactivated() { this.logHook(\"deactivated\"); }, methods: { logHook(hookName) { console.log(hookName); const liEl = document.createElement(\"li\"); liEl.innerHTML = hookName; this.$refs.olEl.appendChild(liEl); } } } </script> <style> li { background-color: lightcoral; width: 5em; } </style>",
        "<template> <h1>The 'activated' and 'deactivated' Lifecycle Hooks</h1> <p>In this example for the 'activated' and 'deactivated' hooks we also see when and if the 'mounted' and 'unmounted' hooks are run.</p> <button @click=\"this.activeComp = !this.activeComp\">Include component</button> <div> <KeepAlive> <comp-one v-if=\"activeComp\"></comp-one> </KeepAlive> </div> </template> <script> export default { data() { return { activeComp: false } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 20px; margin-top: 10px; background-color: lightgreen; } </style>",
        "The lifecycle hook is called just before a component is removed from the DOM.",
        "beforeCreate",
        "created",
        "beforeMount",
        "mounted",
        "beforeUpdate",
        "updated",
        "beforeUnmount",
        "unmounted",
        "errorCaptured",
        "renderTracked",
        "renderTriggered",
        "activated",
        "deactivated",
        "serverPrefetch",
        "CompOne.vue",
        "App.vue",
        "console.log()",
        "mounted()",
        "ref",
        "$refs",
        "alert()",
        "beforeUpdate()",
        "<li>",
        "updated()",
        "unmounted()",
        "errorCaptured()",
        "<KeepAlive>"
      ]
    },
    {
      "title": "Vue Provide/Inject",
      "summary": "Provide/Inject in Vue is used to provide data from one component to other components, particularly in large projects.\nProvide makes data available to other components.\nInject is used to get the provided data.\nProvide/Inject is a way to share data as an alternative to passing data using props.\nProvide/Inject\nIn a large project, with components inside components, it can be hard to use props to provide data from \"App.vue\" to a sub-component, because it requires props to be defined in every component the data passes through.\nIf we use provide/inject instead of props, we only need to define the provided data where it is provided, and we only need to define the injected data where it is injected.\nProvide Data\nWe use the 'provide' configuration option to make data available to other components:\nApp.vue:\nIn the code above, the 'foods' array is now provided so that it is available to be injected in other components in your project.\nInject Data\nNow that the 'foods' array is made available by 'provide' in 'App.vue', we can include it in the 'FoodKinds' component.\nWith the 'foods' data injected in the 'FoodKinds' component, we can use the data from App.vue to display different foods in the 'FoodKinds' component:\nExampleGet your own Vue Server\nFoodKinds.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhich configuration option is needed in the code below so that the fish name 'Turbot' becomes available to other components?\nStart the Exercise",
      "examples": [
        "<template> <h1>Food</h1> <div @click=\"this.activeComp = 'food-about'\" class=\"divBtn\">About</div> <div @click=\"this.activeComp = 'food-kinds'\" class=\"divBtn\">Kinds</div> <div id=\"divComp\"> <component :is=\"activeComp\"></component> </div> </template> <script> export default { data() { return { activeComp: 'food-about', foods: [ { name: 'Pizza', imgUrl: '/img_pizza.svg' }, { name: 'Apple', imgUrl: '/img_apple.svg' }, { name: 'Cake', imgUrl: '/img_cake.svg' }, { name: 'Fish', imgUrl: '/img_fish.svg' }, { name: 'Rice', imgUrl: '/img_rice.svg' } ] } }, provide() { return { foods: this.foods } } } </script>",
        "<template> <h2>Different Kinds of Food</h2> <p><mark>In this application, food data is provided in \"App.vue\", and injected in the \"FoodKinds.vue\" component so that it can be shown here:</mark></p> <div v-for=\"x in foods\"> <img :src=\"x.imgUrl\"> <p class=\"pName\">{{ x.name }}</p> </div> </template> <script> export default { inject: ['foods'] } </script> <style scoped> div { margin: 10px; padding: 10px; display: inline-block; width: 80px; background-color: #28e49f47; border-radius: 10px; } .pName { text-align: center; } img { width: 100%; } </style>",
        "data() { return { fishName: 'Turbot', count: 4 } }, () { return { fishName: this.fishName } }",
        "App.vue",
        "FoodKinds.vue"
      ]
    },
    {
      "title": "Vue Routing",
      "summary": "Routing in Vue is used to navigate the Vue application, and it happens on the client side (in the browser) without full page reload, which results in a faster user experience.\nRouting is a way to navigate, similar to how we have used dynamic components earlier.\nWith routing we can use the URL address to direct someone to a specific place in our Vue application.\nNavigate Using a Dynamic Component\nTo understand routing in Vue, let's first look at an application that uses a dynamic component to switch between two components.\nWe can switch between the components using buttons:\nExampleGet your own Vue Server\nFoodItems.vue:\nAnimalCollection.vue:\nApp.vue:\nFrom Dynamic Component to Routing\nWe build SPAs (Single Page Applications) with Vue, which means that our application only contains one *.html file. And that means we cannot direct people to other *.html files to show them different content on our page.\nIn the example above, we can navigate between different content on the page, but we cannot give someone else an address to the page so that they come directly to the part about food, but with routing we can do that.\nWith routing set up appropriately, if you open the Vue application with an extension to the URL address, like \"/food-items\" for example, you will come directly to the part with the food content.\nInstall The Vue Router Library\nTo use routing in Vue on your machine, install the Vue Router library in your project folder using the terminal:\nUpdate main.js\nTo use routing we must create a router, and we do that in the main.js file.\nmain.js:\nLines 2, 8-14 and 18 are added to add router functionality.\nLines 19-20 are deleted because the components already get included via the router on lines 11-12.\nWe have now created a router that can for example open the 'AnimalCollection' component if '/animals' is added to the end of the original URL address, but it won't work until the next section when we add the <router-view> component. The router also keep track of the web history so that you can go back and forwards in the history with the arrows usually located in the top left corner in the web browser next to the URL.\nUse The <router-view> Component\nTo change the content on our page with the new router, we need to remove the dynamic component in the previous example and use the <router-view> component instead.\nApp.vue:\nIf you have done the change above on your computer you can add '/food' to the URL address of your project page in the browser, and the page should update to show the food content, like this:\nUse The <router-link> Component\nWe can replace the buttons with the <router-link> component because that works better with the router.\nWe have no need for the 'activeComp' data property anymore, so we can delete it, and we can actually delete the whole <script> tag, because it is empty.\nApp.vue:\nStyle to The <router-link> Component\nThe <router-link> component is rendered to an <a> tag. We can see that if we right-click the element in the browser and inspect it:\nAs you can see in the screenshot above, Vue also keeps track on which component is the active one, and provides the 'router-link-active' class to the active <router-link> component (that is now rendered to an <a> tag).\nWe can use the information above to give style to highlight which <router-link> component is the active one:\nExample\nApp.vue:\nNote: In the example above, the URL address is not updated, but if you do this on your own machine the URL address will be updated. The example above works even if the URL address is not updated because the routing is taken care of internally by the router in Vue.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nRouting in Vue is set up in the 'main.js' file.\nFill the blanks below so that the route is created successfully.\nStart the Exercise",
      "examples": [
        "<template> <h1>Food!</h1> <p>I like most types of food.</p> </template>",
        "<template> <h1>Animals!</h1> <p>I want to learn about at least one new animal every year.</p> </template>",
        "<template> <p>Choose what part of this page you want to see:</p> <button @click=\"activeComp = 'animal-collection'\">Animals</button> <button @click=\"activeComp = 'food-items'\">Food</button><br> <div> <component :is=\"activeComp\"></component> </div> </template> <script> export default { data() { return { activeComp: '' } } } </script> <style scoped> button { padding: 5px; margin: 10px; } div { border: dashed black 1px; padding: 20px; margin: 10px; display: inline-block; } </style>",
        "import { createApp } from 'vue' import { createRouter, createWebHistory } from 'vue-router' import App from './App.vue' import FoodItems from './components/FoodItems.vue' import AnimalCollection from './components/AnimalCollection.vue' const router = createRouter({ history: createWebHistory(), routes: [ { path: '/animals', component: AnimalCollection }, { path: '/food', component: FoodItems }, ] }); const app = createApp(App) app.use(router);\napp.component('food-items', FoodItems);\napp.component('animal-collection', AnimalCollection);\napp.mount('#app')",
        "<template> <p>Choose what part of this page you want to see:</p> <button @click=\"activeComp = 'animal-collection'\">Animals</button> <button @click=\"activeComp = 'food-items'\">Food</button><br> <div> <router-view></router-view>\n<component :is=\"activeComp\"></component>\n</div> </template>",
        "<template> <p>Choose what part of this page you want to see:</p> <router-link to=\"/animals\">Animals</router-link> <router-link to=\"/food\">Food</router-link><br> <div> <router-view></router-view> </div> </template>\n<script></script>",
        "<template> <p>Choose what part of this page you want to see:</p> <router-link to=\"/animals\">Animals</router-link> <router-link to=\"/food\">Food</router-link><br> <div> <router-view></router-view> </div> </template> <style scoped> a { display: inline-block; background-color: black; border: solid 1px black; color: white; padding: 5px; margin: 10px; } a:hover, a.router-link-active { background-color: rgb(110, 79, 13); } div { border: dashed black 1px; padding: 20px; margin: 10px; display: inline-block; } </style>",
        "npm install vue-router@4",
        "import { createApp } from 'vue' import { createRouter, createWebHistory } from 'vue-router' import App from './App.vue' import FishTypes from './components/FishTypes.vue' const router = createRouter({ history: createWebHistory(), routes: [ { : '/fish', : FishTypes } ] }); const app = createApp(App) app.use(router); app.mount('#app')",
        "FoodItems.vue",
        "AnimalCollection.vue",
        "App.vue",
        "main.js",
        "<router-view>",
        "<router-link>",
        "<script>",
        "<a>"
      ]
    },
    {
      "title": "Vue Form Inputs",
      "summary": "We have seen a few examples of form inputs earlier in this tutorial, on the Vue Forms and v-model pages.\nThis page is a collection of more form input examples in Vue, like radio buttons, checkboxes, drop-down list and normal text input field.\nRadio Buttons\nRadio buttons that belong to the same choice must have the same name so that only one radio button can be chosen.\nAs with all inputs in Vue, we capture the radio button input value with v-model, but the value attribute must also be set explicitly on the <input type=\"radio\"> tag.\nThis is how we can use radio buttons in a Vue form:\nExampleGet your own Vue Server\nApp.vue:\nCheckboxes\nWhen checkbox inputs (<input type=\"checkbox\">) are connected to the same array with v-model, the values for the checked checkboxes are gathered in that array:\nExample\nApp.vue:\nDrop-down List\nA drop-down list consists of a <select> tag with <option> tags inside.\nWhen using a drop-down list in Vue we need to connect the <select> tag with v-model, and give values to the <option> tags:\nExample\nApp.vue:\n<select multiple>\nWith the multiple attribute in the <select> tag, the drop-down list becomes expanded, and we can choose more than one option.\nTo choose more than one option, windows users must press the 'ctrl' key, and macOS users must press the 'command' key.\nWhen using <select multiple> in Vue we need to connect the <select> tag with v-model, and give values to the <option> tags:\nExample\nApp.vue:\nRead Only Form Inputs\nUsing v-model on form inputs creates a two-way binding, which means that if the Vue data instance changes, the input value attribute also changes.\nFor read-only form inputs, like <input type=\"file\">, the value attribute cannot be changed from the Vue data instance, and so we cannot use v-model.\nFor read-only form inputs, like <input type=\"file\">, we need to use @change to call a method that updates the Vue data instance:\nExample\nApp.vue:\nInfo: In the example above, the submitted file name gets a file path C:\\fakepath\\ in front of it. This is to prevent malicious software from guessing the user's file structure.\nOther Form Inputs\nWith the form inputs mentioned above we had to provide a value for the value attribute, but with the form inputs below, the user provides the value:\n<input type=\"color\">\n<input type=\"date\">\n<input type=\"datetime-local\">\n<input type=\"number\">\n<input type=\"password\">\n<input type=\"range\">\n<input type=\"search\">\n<input type=\"tel\">\n<input type=\"text\">\n<input type=\"time\">\n<textarea>\nBecause the user already gives the value for these kinds of form inputs, all we need to do in Vue is to connect the input to a data property with v-model.\nThis is how to use <input type=\"range\"> in Vue:\nExample\nApp.vue:\nAnd this is how to use <input type=\"color\"> in Vue:\nExample\nApp.vue:\nAnd this is how to use <textarea> in Vue:\nExample\nApp.vue:\nLearn more about how the different kinds of HTML form inputs work in our HTML Tutorial .\nVue Exercises\nTest Yourself With Exercises\nExercise:\nFill in the missing code so that the input gets a two-way binding with the 'inpText' data property.\nStart the Exercise",
      "examples": [
        "<template> <h1>Radio Buttons in Vue</h1> <form @submit.prevent=\"registerAnswer\"> <p>What is your favorite animal?</p> <label> <input type=\"radio\" name=\"favAnimal\" v-model=\"inpVal\" value=\"Cat\"> Cat </label> <label> <input type=\"radio\" name=\"favAnimal\" v-model=\"inpVal\" value=\"Dog\"> Dog </label> <label> <input type=\"radio\" name=\"favAnimal\" v-model=\"inpVal\" value=\"Turtle\"> Turtle </label> <label> <input type=\"radio\" name=\"favAnimal\" v-model=\"inpVal\" value=\"Moose\"> Moose </label> <button type=\"submit\">Submit</button> </form> <div> <h3>Submitted choice:</h3> <p id=\"pAnswer\">{{ inpValSubmitted }}</p> </div> </template> <script> export default { data() { return { inpVal: '', inpValSubmitted: 'Not submitted yet' } }, methods: { registerAnswer() { if(this.inpVal) { this.inpValSubmitted = this.inpVal; } } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 0 20px 20px 20px; margin-top: 20px; display: inline-block; } button { margin: 10px; } label { display: block; width: 80px; padding: 5px; } label:hover { cursor: pointer; background-color: rgb(211, 244, 211); border-radius: 5px; } #pAnswer { background-color: lightgreen; padding: 5px; } </style>",
        "<template> <h1>Checkbox Inputs in Vue</h1> <form @submit.prevent=\"registerAnswer\"> <p>What kinds of food do you like?</p> <label> <input type=\"checkbox\" v-model=\"likeFoods\" value=\"Pizza\"> Pizza </label> <label> <input type=\"checkbox\" v-model=\"likeFoods\" value=\"Rice\"> Rice </label> <label> <input type=\"checkbox\" v-model=\"likeFoods\" value=\"Fish\"> Fish </label> <label> <input type=\"checkbox\" v-model=\"likeFoods\" value=\"Salad\"> Salad </label> <button type=\"submit\">Submit</button> </form> <div> <h3>Submitted answer:</h3> <p id=\"pAnswer\">{{ inpValSubmitted }}</p> </div> </template> <script> export default { data() { return { likeFoods: [], inpValSubmitted: 'Not submitted yet' } }, methods: { registerAnswer() { this.inpValSubmitted = this.likeFoods; } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 0 20px 20px 20px; margin-top: 20px; display: inline-block; } button { margin: 10px; } label { display: block; width: 80px; padding: 5px; } label:hover { cursor: pointer; background-color: rgb(211, 244, 211); border-radius: 5px; } #pAnswer { background-color: lightgreen; padding: 5px; } </style>",
        "<template> <h1>Drop-down List in Vue</h1> <form @submit.prevent=\"registerAnswer\"> <label for=\"cars\">Choose a car:</label> <select v-model=\"carSelected\" id=\"cars\"> <option disabled value=\"\">Please select one</option> <option>Volvo</option> <option>Saab</option> <option>Opel</option> <option>Audi</option> </select> <br><br> <input type=\"submit\" value=\"Submit\"> </form> <div> <h3>Submitted answer:</h3> <p id=\"pAnswer\">{{ inpValSubmitted }}</p> </div> </template> <script> export default { data() { return { carSelected: '', inpValSubmitted: 'Not submitted yet' } }, methods: { registerAnswer() { if(this.carSelected) { this.inpValSubmitted = this.carSelected; } } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 0 20px 20px 20px; margin-top: 20px; display: inline-block; } button { margin: 10px; } label { width: 80px; padding: 5px; } label:hover { cursor: pointer; background-color: rgb(211, 244, 211); border-radius: 5px; } #pAnswer { background-color: lightgreen; padding: 5px; } </style>",
        "<template> <h1>Select Multiple in Vue</h1> <p>Depending on your operating system, use the 'ctrl' or the 'command' key to select multiple options.</p> <form @submit.prevent=\"registerAnswer\"> <label for=\"cars\">Choose one or more cars:</label><br> <select v-model=\"carsSelected\" id=\"cars\" multiple> <option>Volvo</option> <option>Saab</option> <option>Opel</option> <option>Audi</option> <option>Kia</option> </select> <button type=\"submit\">Submit</button> </form> <div> <h3>Submitted answer:</h3> <p id=\"pAnswer\">{{ inpValSubmitted }}</p> </div> </template> <script> export default { data() { return { carsSelected: [], inpValSubmitted: 'Not submitted yet' } }, methods: { registerAnswer() { if(this.carsSelected) { this.inpValSubmitted = this.carsSelected; } } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 0 20px 20px 20px; margin-top: 20px; display: inline-block; } button, select { margin: 10px; display: block; } label { width: 80px; padding: 5px; } label:hover { cursor: pointer; background-color: rgb(211, 244, 211); border-radius: 5px; } #pAnswer { background-color: lightgreen; padding: 5px; } </style>",
        "<template> <h1>Input Type File</h1> <form @submit.prevent=\"registerAnswer\"> <label>Choose a file: <input @change=\"updateVal\" type=\"file\"> </label> <button type=\"submit\">Submit</button> </form> <div> <h3>Submitted answer:</h3> <p id=\"pAnswer\">{{ inpValSubmitted }}</p> </div> </template> <script> export default { data() { return { fileInp: null, inpValSubmitted: 'Not submitted yet' } }, methods: { registerAnswer() { if(this.fileInp) { this.inpValSubmitted = this.fileInp; } }, updateVal(e) { this.fileInp = e.target.value; } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 0 20px 20px 20px; margin-top: 20px; display: inline-block; } button { margin: 10px; display: block; } #pAnswer { background-color: lightgreen; padding: 5px; } </style>",
        "<form @submit.prevent=\"registerAnswer\"> <label>How tall are you?<br> <input v-model=\"heightInp\" type=\"range\" min=\"50\" max=\"235\"> {{ heightInp }} cm </label> <button type=\"submit\">Submit</button> </form>",
        "<form @submit.prevent=\"registerAnswer\"> <label>Choose a color: <input v-model=\"colorInp\" type=\"color\"> </label> <button type=\"submit\">Submit</button> </form>",
        "<form @submit.prevent=\"registerAnswer\"> <label> <p>What do you think about our product?</p> <textarea v-model=\"txtInp\" placeholder=\"Write something..\" rows=\"4\" cols=\"35\"></textarea> </label> <button type=\"submit\">Submit</button> </form>",
        "<template> <input type=\"text\" > <p> {{ inpText }} </p> </template> <script> const app = Vue.createApp({ data() { return { inpText: 'Initial text' } } }) app.mount('#app') </script>",
        "v-model",
        "value",
        "<input type=\"radio\">",
        "App.vue",
        "<input type=\"checkbox\">",
        "<select>",
        "<option>",
        "multiple",
        "<select multiple>",
        "<input type=\"file\">",
        "@change",
        "C:\\fakepath\\",
        "<input type=\"color\">",
        "<input type=\"date\">",
        "<input type=\"datetime-local\">",
        "<input type=\"number\">",
        "<input type=\"password\">",
        "<input type=\"range\">",
        "<input type=\"search\">",
        "<input type=\"tel\">",
        "<input type=\"text\">",
        "<input type=\"time\">",
        "<textarea>"
      ]
    },
    {
      "title": "Vue Animations",
      "summary": "The built-in <Transition> component in Vue helps us to do animations when elements are added or removed with v-if, v-show or with dynamic components.\nThere is nothing wrong with using plain CSS transitions and animations in other cases.\nA Short Introduction to CSS Transition and Animation\nThis part of the tutorial requires knowledge about basic CSS animations and transitions.\nBut before we use the Vue specific built-in <Transition> component to create animations, let's look at two examples of how plain CSS animations and transitions can be used with Vue.\nExampleGet your own Vue Server\nApp.vue:\nIn the example above, we use v-bind to give the <div> tag a class so that it rotates. The reason that the rotation takes 1 second, is that it is defined with the CSS transition property.\nIn the example below, we see how we can move an object with the CSS animation property.\nExample\nApp.vue:\nThe <Transition> Component\nThere is nothing wrong with using plain CSS transitions and animations like we did in the two examples above.\nBut luckily Vue provides us with the built-in <Transition> component in cases where we want to animate an element as it is removed from, or added to, our application with v-if or v-show, because that would be hard to do with plain CSS animation.\nLet's first make an application where a button adds or removes a <p> tag:\nExample\nApp.vue:\nNow let's wrap the <Transition> component around the <p> tag, and see how we can animate the removal of the <p> tag.\nWhen we use the <Transition> component, we automatically get six different CSS classes we can use to animate when elements are added or removed.\nIn the example below we will use the automatically available classes v-leave-from and v-leave-to to make a fade out animation when the <p> tag is removed:\nExample\nApp.vue:\nThe Six <Transition> Classes\nThere are six classes automatically available to us when we use the <Transition> component.\nAs an element inside the <Transition> component is added, we can use these first three classes to animate that transition:\nv-enter-from\nv-enter-active\nv-enter-to\nAnd as an element is removed inside the <Transition> component, we can use the next three classes :\nv-leave-from\nv-leave-active\nv-leave-to\nNote: There can only be one element on root level of the <Transition> component.\nNow, let's use four of these classes so that we can animate both when the <p> tag is added, and when it is removed.\nExample\nApp.vue:\nWe can also use the v-enter-active and v-leave-active to set styling or animation during adding or during removal of an element:\nExample\nApp.vue:\nThe Transition 'name' Prop\nIn case you have several <Transition> components, but you want at least one of the <Transition> components to have a different animation, you need different names for the <Transition> components to tell them apart.\nWe can choose the name of a <Transition> component with the name prop, and that changes the name of the transition classes as well, so that we can set different CSS animation rules for that component.\nIf the transition name prop value is set to 'swirl', the automatically available classes will now start with 'swirl-' instead of 'v-':\nswirl-enter-from\nswirl-enter-active\nswirl-enter-to\nswirl-leave-from\nswirl-leave-active\nswirl-leave-to\nIn the example below we use the name prop to give the <Transition> components different animations. One <Transition> component is not given a name, and is therefore given animations using the automatically generated CSS classes starting with 'v-'. The other <Transition> component is given a name 'swirl' so that it can be given rules for animation with the automatically generated CSS classes starting with 'swirl-'.\nExample\nApp.vue:\nJavaScript Transition Hooks\nEvery Transition class as just mentioned corresponds to an event that we can hook into to run some JavaScript code.\nWhen the after-enter event happens in the example below, a method runs that displays a red <div> element.\nExample\nApp.vue:\nYou can use the \"Toggle\" button in the example below to interrupt the enter transition phase of the <p> element so that the enter-cancelled event is triggered:\nExample\nApp.vue:\nThe 'appear' Prop\nIf we have an element that we want to animate when the page loads, we need to use the appear prop on the <Transition> component.\nIn this example, the appear prop starts an animation when the page load for the first time:\nExample\nApp.vue:\nTransition Between Elements\nThe <Transition> component can also be used to switch between several elements, as long as we make sure that only one element is shown at a time with the use of <v-if> and <v-else-if>:\nExample\nApp.vue:\nmode=\"out-in\"\nIn the example above, the next image is added before the previous image is removed.\nWe use the mode=\"out-in\" prop and prop value on the <Transition> component so that the removal of an element is finished before the next element is added.\nExample\nIn addition to mode=\"out-in\", this example also uses a computed value 'imgActive' instead of the 'newImg' method we used in the previous example.\nApp.vue:\nTransition with Dynamic Components\nWe can also use the <Transition> component to animate switching between dynamic components:\nExample\nApp.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nThe <Transition> component automatically gives us 6 different CSS classes we can use to animate an element.\nFill the blanks so that the 3 first class names are completed, in the correct order, for when an element becomes visible:\nStart the Exercise",
      "examples": [
        "<template> <h1>Basic CSS Transition</h1> <button @click=\"this.doesRotate = true\">Rotate</button> <div :class=\"{ rotate: doesRotate }\"></div> </template> <script> export default { data() { return { doesRotate: false } } } </script> <style scoped> .rotate { rotate: 160deg; transition: rotate 1s; } div { border: solid black 2px; background-color: lightcoral; width: 60px; height: 60px; } h1, button, div { margin: 10px; } </style>",
        "<template> <h1>Basic CSS Animation</h1> <button @click=\"this.doesMove = true\">Start</button> <div :class=\"{ move: doesMove }\"></div> </template> <script> export default { data() { return { doesMove: false } } } </script> <style scoped> .move { animation: move .5s alternate 4 ease-in-out; } @keyframes move { from { translate: 0 0; } to { translate: 70px 0; } } div { border: solid black 2px; background-color: lightcoral; border-radius: 50%; width: 60px; height: 60px; } h1, button, div { margin: 10px; } </style>",
        "<template> <h1>Add/Remove <p> Tag</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <p v-if=\"exists\">Hello World!</p> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> p { background-color: lightgreen; display: inline-block; padding: 10px; } </style>",
        "<template> <h1>Add/Remove <p> Tag</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <Transition> <p v-if=\"exists\">Hello World!</p> </Transition> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } p { background-color: lightgreen; display: inline-block; padding: 10px; transition: opacity 0.5s; } </style>",
        "<template> <h1>Add/Remove <p> Tag</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <Transition> <p v-if=\"exists\">Hello World!</p> </Transition> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .v-enter-from { opacity: 0; translate: -100px 0; } .v-enter-to { opacity: 1; translate: 0 0; } .v-leave-from { opacity: 1; translate: 0 0; } .v-leave-to { opacity: 0; translate: 100px 0; } p { background-color: lightgreen; display: inline-block; padding: 10px; transition: all 0.5s; } </style>",
        "<template> <h1>Add/Remove <p> Tag</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <Transition> <p v-if=\"exists\">Hello World!</p> </Transition> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .v-enter-active { background-color: lightgreen; animation: added 1s; } .v-leave-active { background-color: lightcoral; animation: added 1s reverse; } @keyframes added { from { opacity: 0; translate: -100px 0; } to { opacity: 1; translate: 0 0; } } p { display: inline-block; padding: 10px; border: dashed black 1px; } </style>",
        "<Transition name=\"swirl\">",
        "<template> <h1>Add/Remove <p> Tag</h1> <p>The second transition in this example has the name prop \"swirl\", so that we can keep the transitions apart with different class names.</p> <hr> <button @click=\"this.p1Exists = !this.p1Exists\">{{btn1Text}}</button><br> <Transition> <p v-if=\"p1Exists\" id=\"p1\">Hello World!</p> </Transition> <hr> <button @click=\"this.p2Exists = !this.p2Exists\">{{btn2Text}}</button><br> <Transition name=\"swirl\"> <p v-if=\"p2Exists\" id=\"p2\">Hello World!</p> </Transition> </template> <script> export default { data() { return { p1Exists: false, p2Exists: false } }, computed: { btn1Text() { if(this.p1Exists) { return 'Remove'; } else { return 'Add'; } }, btn2Text() { if(this.p2Exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .v-enter-active { background-color: lightgreen; animation: added 1s; } .v-leave-active { background-color: lightcoral; animation: added 1s reverse; } @keyframes added { from { opacity: 0; translate: -100px 0; } to { opacity: 1; translate: 0 0; } } .swirl-enter-active { animation: swirlAdded 1s; } .swirl-leave-active { animation: swirlAdded 1s reverse; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } #p1, #p2 { display: inline-block; padding: 10px; border: dashed black 1px; } #p2 { background-color: lightcoral; } </style>",
        "<template> <h1>JavaScript Transition Hooks</h1> <p>This code hooks into \"after-enter\" so that after the initial animation is done, a method runs that displays a red div.</p> <button @click=\"pVisible=true\">Create p-tag!</button><br> <Transition @after-enter=\"onAfterEnter\"> <p v-show=\"pVisible\" id=\"p1\">Hello World!</p> </Transition> <br> <div v-show=\"divVisible\">This appears after the \"enter-active\" phase of the transition.</div> </template> <script> export default { data() { return { pVisible: false, divVisible: false } }, methods: { onAfterEnter() { this.divVisible = true; } } } </script> <style scoped> .v-enter-active { animation: swirlAdded 1s; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } #p1, div { display: inline-block; padding: 10px; border: dashed black 1px; } #p1 { background-color: lightgreen; } div { background-color: lightcoral; } </style>",
        "<template> <h1>The 'enter-cancelled' Event</h1> <p>Click the toggle button again before the enter animation is finished to trigger the 'enter-cancelled' event.</p> <button @click=\"pVisible=!pVisible\">Toggle</button><br> <Transition @enter-cancelled=\"onEnterCancelled\"> <p v-if=\"pVisible\" id=\"p1\">Hello World!</p> </Transition> <br> <div v-if=\"divVisible\">You interrupted the \"enter-active\" transition.</div> </template> <script> export default { data() { return { pVisible: false, divVisible: false } }, methods: { onEnterCancelled() { this.divVisible = true; } } } </script> <style scoped> .v-enter-active { animation: swirlAdded 2s; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 720deg; scale: 1; } } #p1, div { display: inline-block; padding: 10px; border: dashed black 1px; } #p1 { background-color: lightgreen; } div { background-color: lightcoral; } </style>",
        "<Transition appear> ... </Transition>",
        "<template> <h1>The 'appear' Prop</h1> <p>The 'appear' prop starts the animation when the p tag below is rendered for the first time as the page opens. Without the 'appear' prop, this example would have had no animation.</p> <Transition appear> <p id=\"p1\">Hello World!</p> </Transition> </template> <style> .v-enter-active { animation: swirlAdded 1s; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } #p1 { display: inline-block; padding: 10px; border: dashed black 1px; background-color: lightgreen; } </style>",
        "<template> <h1>Transition Between Elements</h1> <p>Click the button to get a new image.</p> <p>The new image is added before the previous is removed. We will fix this in the next example with mode=\"out-in\".</p> <button @click=\"newImg\">Next image</button><br> <Transition> <img src=\"/img_pizza.svg\" v-if=\"imgActive === 'pizza'\"> <img src=\"/img_apple.svg\" v-else-if=\"imgActive === 'apple'\"> <img src=\"/img_cake.svg\" v-else-if=\"imgActive === 'cake'\"> <img src=\"/img_fish.svg\" v-else-if=\"imgActive === 'fish'\"> <img src=\"/img_rice.svg\" v-else-if=\"imgActive === 'rice'\"> </Transition> </template> <script> export default { data() { return { imgActive: 'pizza', imgs: ['pizza', 'apple', 'cake', 'fish', 'rice'], indexNbr: 0 } }, methods: { newImg() { this.indexNbr++; if(this.indexNbr >= this.imgs.length) { this.indexNbr = 0; } this.imgActive = this.imgs[this.indexNbr]; } } } </script> <style> .v-enter-active { animation: swirlAdded 1s; } .v-leave-active { animation: swirlAdded 1s reverse; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } img { width: 100px; margin: 20px; } img:hover { cursor: pointer; } </style>",
        "<template> <h1>mode=\"out-in\"</h1> <p>Click the button to get a new image.</p> <p>With mode=\"out-in\", the next image is not added until the current image is removed. Another difference from the previous example, is that here we use computed prop instead of a method.</p> <button @click=\"indexNbr++\">Next image</button><br> <Transition mode=\"out-in\"> <img src=\"/img_pizza.svg\" v-if=\"imgActive === 'pizza'\"> <img src=\"/img_apple.svg\" v-else-if=\"imgActive === 'apple'\"> <img src=\"/img_cake.svg\" v-else-if=\"imgActive === 'cake'\"> <img src=\"/img_fish.svg\" v-else-if=\"imgActive === 'fish'\"> <img src=\"/img_rice.svg\" v-else-if=\"imgActive === 'rice'\"> </Transition> </template> <script> export default { data() { return { imgs: ['pizza', 'apple', 'cake', 'fish', 'rice'], indexNbr: 0 } }, computed: { imgActive() { if(this.indexNbr >= this.imgs.length) { this.indexNbr = 0; } return this.imgs[this.indexNbr]; } } } </script> <style> .v-enter-active { animation: swirlAdded 0.7s; } .v-leave-active { animation: swirlAdded 0.7s reverse; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } img { width: 100px; margin: 20px; } img:hover { cursor: pointer; } </style>",
        "<template> <h1>Transition with Dynamic Components</h1> <p>The Transition component wraps around the dynamic component so that the switching can be animated.</p> <button @click=\"toggleValue = !toggleValue\">Switch component</button> <Transition mode=\"out-in\"> <component :is=\"activeComp\"></component> </Transition> </template> <script> export default { data () { return { toggleValue: true } }, computed: { activeComp() { if(this.toggleValue) { return 'comp-one' } else { return 'comp-two' } } } } </script> <style> .v-enter-active { animation: slideIn 0.5s; } @keyframes slideIn { from { translate: -200px 0; opacity: 0; } to { translate: 0 0; opacity: 1; } } .v-leave-active { animation: slideOut 0.5s; } @keyframes slideOut { from { translate: 0 0; opacity: 1; } to { translate: 200px 0; opacity: 0; } } #app { width: 350px; margin: 10px; } #app > div { border: solid black 2px; padding: 10px; margin-top: 10px; } </style>",
        "1. v-enter- 2. v-enter- 3. v-enter-",
        "<Transition>",
        "v-if",
        "v-show",
        "App.vue",
        "v-bind",
        "<div>",
        "transition",
        "animation",
        "<p>",
        "v-leave-from",
        "v-leave-to",
        "v-enter-active",
        "v-leave-active",
        "name",
        "before-enter",
        "enter",
        "after-enter",
        "enter-cancelled",
        "before-leave",
        "leave",
        "after-leave",
        "leave-cancelled",
        "appear",
        "<v-if>",
        "<v-else-if>",
        "mode=\"out-in\""
      ]
    },
    {
      "title": "Vue Animations with v-for",
      "summary": "The built-in <TransitionGroup> component in Vue helps us to animate elements that are added to our page with v-for.\nThe <TransitionGroup> Component\nThe <TransitionGroup> component is used around elements created with v-for, to give these elements individual animations when they are added or removed.\nTags created with v-for inside the <TransitionGroup> component must be defined with the key attribute.\nThe <TransitionGroup> component is only rendered as an HTML tag if we define it to be a specific tag by using the tag prop, like this:\nThis is the result from the code above, after it is rendered by Vue:\nWe can now add CSS code to animate new items when they are added to the list:\nIn this example, new items will be animated simply by adding them to 'products' array:\nExampleGet your own Vue Server\nApp.vue:\nAdd and Remove Elements\nWhen removing elements in between other elements, the other elements will fall into place where removed element was. To animate how the rest of the list items fall into place when an element is removed, we will use the automatically generated v-move class.\nBut first, let's look at an example where it is not animated how other items fall into place when an element is removed:\nExample\nApp.vue:\nAs you can see in the example above, when an item is removed, the items after the removed item suddenly jumps into their new positions. To animate the rest of the items when an item is removed, we use the automatically generated v-move class.\nThe v-move class animates the other elements as the removed item leaves, but there is one problem: The removed item still exists and takes up place until it is removed, and so the v-move class will not have any effect. To give the v-move class something to animate we can set position: absolute; to the v-leave-active class. When position: absolute; is set during the removal period, the removed item is still visible, but does not take up place.\nIn this example, the only difference from the previous example are the two new CSS classes added on line 14 and 17:\nExample\nApp.vue:\nA Larger Example\nLet's use the example above as the basis for a new example.\nIn this example it becomes even more clear how the whole list is animated when a new item is added or removed, or when the whole array is sorted.\nIn this example we can:\nRemove items by clicking on them\nSort the items\nAdd new items at a random place in the list\nExample\nApp.vue:\nVue Exercises\nTest Yourself With Exercises\nExercise:\nWhat is the name of the Vue specific component used to animate elements created or removed with v-for?\nStart the Exercise",
      "examples": [
        "<TransitionGroup tag=\"ol\"> <li v-for=\"x in products\" :key=\"x\"> {{ x }} </li> </TransitionGroup>",
        "<ol> <li>Apple</li> <li>Pizza</li> <li>Rice</li> </ol>",
        "<style> .v-enter-from { opacity: 0; rotate: 180deg; } .v-enter-to { opacity: 1; rotate: 0deg; } .v-enter-active { transition: all 0.7s; } </style>",
        "<template> <h3>The <TransitionGroup> Component</h3> <p>New products are given animations using the <TransitionGroup> component.</p> <input type=\"text\" v-model=\"inpName\"> <button @click=\"addEl\">Add</button> <TransitionGroup tag=\"ol\"> <li v-for=\"x in products\" :key=\"x\"> {{ x }} </li> </TransitionGroup> </template> <script> export default { data() { return { products: ['Apple','Pizza','Rice'], inpName: '' } }, methods: { addEl() { const el = this.inpName; this.products.push(el); this.inpName = null; } } } </script> <style> .v-enter-from { opacity: 0; rotate: 180deg; } .v-enter-to { opacity: 1; rotate: 0deg; } .v-enter-active { transition: all 0.7s; } </style>",
        "<template> <h3>The <TransitionGroup> Component</h3> <p>New products are given animations using the <TransitionGroup> component.</p> <button @click=\"addDie\">Roll</button> <button @click=\"removeDie\">Remove random</button><br> <TransitionGroup> <div v-for=\"x in dice\" :key=\"x\" class=\"diceDiv\" :style=\"{ backgroundColor: 'hsl('+x*40+',85%,85%)' }\"> {{ x }} </div> </TransitionGroup> </template> <script> export default { data() { return { dice: [], inpName: '' } }, methods: { addDie() { const newDie = Math.ceil(Math.random()*6); this.dice.push(newDie); }, removeDie() { if(this.dice.length>0){ this.dice.splice(Math.floor(Math.random()*this.dice.length), 1); } } }, mounted() { this.addDie(); this.addDie(); this.addDie(); } } </script> <style> .v-enter-from { opacity: 0; translate: 200px 0; rotate: 360deg; } .v-enter-to { opacity: 1; translate: 0 0; rotate: 0deg; } .v-enter-active, .v-leave-active { transition: all 0.7s; } .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } .diceDiv { margin: 10px; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; text-align: center; border: solid black 1px; border-radius: 5px; display: inline-block; } </style>",
        "<style> .v-enter-from { opacity: 0; translate: 200px 0; rotate: 360deg; } .v-enter-to { opacity: 1; translate: 0 0; rotate: 0deg; } .v-enter-active, .v-leave-active, .v-move { transition: all 0.7s; } .v-leave-active { position: absolute; } .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } .diceDiv { margin: 10px; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; text-align: center; border: solid black 1px; border-radius: 5px; display: inline-block; } </style>",
        "<template> <h3>The <TransitionGroup> Component</h3> <p>Items inside the <TransitionGroup> component are animated when they are created or removed.</p> <button @click=\"addDie\">Roll</button> <button @click=\"addDie10\">Roll 10 dice</button> <button @click=\"dice.sort(compareFunc)\">Sort</button> <button @click=\"dice.sort(shuffleFunc)\">Shuffle</button><br> <TransitionGroup> <div v-for=\"x in dice\" :key=\"x.keyNmbr\" class=\"diceDiv\" :style=\"{ backgroundColor: 'hsl('+x.dieNmbr*60+',85%,85%)' }\" @click=\"removeDie(x.keyNmbr)\"> {{ x.dieNmbr }} </div> </TransitionGroup> </template> <script> export default { data() { return { dice: [], keyNumber: 0 } }, methods: { addDie() { const newDie = { dieNmbr: Math.ceil(Math.random()*6), keyNmbr: this.keyNumber }; this.dice.splice(Math.floor(Math.random()*this.dice.length),0,newDie); this.keyNumber++; }, addDie10() { for(let i=0; i<10; i++) { this.addDie(); } }, compareFunc(a,b){ return a.dieNmbr - b.dieNmbr; }, shuffleFunc(a,b){ return Math.random()-0.5; }, removeDie(key) { const pos = this.dice.map(e => e.keyNmbr).indexOf(key); this.dice.splice(pos, 1); } }, mounted() { this.addDie10(); } } </script> <style> .v-enter-from { opacity: 0; scale: 0; rotate: 360deg; } .v-enter-to { opacity: 1; scale: 1; rotate: 0deg; } .v-enter-active, .v-leave-active, .v-move { transition: all 0.7s; } .v-leave-active { position: absolute; } .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } .diceDiv { margin: 10px; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; text-align: center; border: solid black 1px; border-radius: 5px; display: inline-block; } .diceDiv:hover { cursor: pointer; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } #app { position: relative; } </style>",
        "< tag=\"ol\"> <li v-for=\"x in products\" :key=\"x\"> {{ x }} </li> </>",
        "<TransitionGroup>",
        "v-for",
        "key",
        "tag",
        "App.vue",
        "v-move",
        "position: absolute;",
        "v-leave-active"
      ]
    },
    {
      "title": "Build Your Project",
      "summary": "When a Vue project is finished, it should move from being in \"development mode\" into \"build\" mode.\nThe build command compiles our Vue project into .html, .js and .css files that are optimized to run directly in the browser.\nWe build our Vue project to create files on a server for others to access.\nTo 'Build' The Web Page\nSo far in this tutorial we have had our projects running in development mode, meaning that the Vite build tool is running a development server. When you make changes during development and save them, Vite will update the page instantly. This requires a lot of resources from the computer.\nThe build step comes after the development phase, when the page is ready to go public. We then have to build our project into files the browser understands without running Vite in development mode. The build step is done to minimize server resource usage and improve performance.\nTo build your Vue application, stop the development server if it is running, by pressing 'Q' or 'ctrl'+'C', then write:\nWhen your project is built, Vite creates a folder dist with all the files needed to run your project on a public server, with files the browser understands *.html, *.css and *.js instead of the *.vue files we use during development.\nTo see your built project in the browser, use the commando:\nThis commando should open a browser window that displays the built project from the dist folder.\nVue Exercises\nTest Yourself With Exercises\nExercise:\nStart the Exercise",
      "examples": [
        "npm run build",
        "npm run preview",
        "The command compiles our Vue project into .html, .js and .css files that are optimized to run directly in the .",
        "dist",
        "*.html",
        "*.css",
        "*.js",
        "*.vue"
      ]
    },
    {
      "title": "Vue Composition API",
      "summary": "The Composition API is an alternative way of writing Vue applications to the Options API that is used elsewhere in this tutorial.\nIn Composition API we can write code more freely, but it requires a deeper understanding, and it is considered to be less beginner-friendly.\nThe Composition API\nWith Composition API, logic is written using imported Vue functions instead of using the Vue instance structure that we are used to from Options API.\nThis is how Composition API can be used to write a Vue application that decreases the number of typewriters in storage with a button:\nExampleGet your own Vue Server\nApp.vue:\nOn line 9 in the example above, the setup attribute makes it easier to use Composition API. For example, by using the setup attribute, variables and functions can be used directly inside the <template>.\nOn line 10, ref and computed must be imported before they can be used. In Options API, we do not need to import anything to declare reactive variables or to use computed properties.\nOn line 12, ref is used to declare the 'typewriters' property as reactive with '10' as the initial value.\nTo declare the 'typewriters' property as reactive means that the line {{ typewriters }} in the <template> will be re-rendered automatically to show the updated value when the 'typewriters' property value is changed. With Option API, data properties become reactive if they need to be when the application is built, they do not need to be declared explicitly as reactive.\nThe 'remove()' function declared on line 14 would be declared under the Vue property 'methods' if the example was written in Options API.\nThe 'storageComment' computed property on line 20 would be declared under the Vue property 'computed' if the example was written in Options API.\nThe Options API\nThe Options API is what is used elsewhere in this tutorial.\nThe Options API is chosen for this tutorial because it has a recognizable structure and is considered easier to start with for beginners.\nAs an example, the structure in the Options API has the data properties, methods and computed properties all placed in different parts of the Vue instance, clearly separated.\nHere is the example above written with Options API:\nExample\nApp.vue:",
      "examples": [
        "<template> <h1>Example</h1> <img src=\"/img_typewriter.jpeg\" alt=\"Typewriter\"> <p>Typewriters left in storage: {{ typeWriters }}</p> <button @click=\"remove\">Remove one</button> <p style=\"font-style: italic;\">\"{{ storageComment }}\"</p> </template> <script setup> import { ref, computed } from 'vue' const typeWriters = ref(10); function remove(){ if(typeWriters.value>0){ typeWriters.value--; } } const storageComment = computed( function(){ if(typeWriters.value > 5) { return \"Many left\" } else if(typeWriters.value > 0){ return \"Very few left\" } else { return \"No typewriters left\" } } ) </script>",
        "<template> <h1>Example</h1> <img src=\"/img_typewriter.jpeg\" alt=\"Typewriter\"> <p>Typewriters left in storage: {{ typeWriters }}</p> <button @click=\"remove\">Remove one</button> <p style=\"font-style: italic;\">\"{{ storageComment }}\"</p> </template> <script> export default { data() { return { typeWriters: 10 }; }, methods: { remove(){ if(this.typeWriters>0){ this.typeWriters--; } } }, computed: { storageComment(){ if(this.typeWriters > 5) { return \"Many left\" } else if(this.typeWriters > 0){ return \"Very few left\" } else { return \"No typewriters left\" } } } } </script>",
        "App.vue",
        "setup",
        "<template>",
        "ref",
        "computed",
        "{{ typewriters }}"
      ]
    },
    {
      "title": "Vue Built-in Attributes",
      "summary": "Vue has a set of built-in attributes.",
      "examples": []
    },
    {
      "title": "Vue 'is' Attribute",
      "summary": "ExampleGet your own Vue Server\nThe is attribute is connected to the computed value 'activeComp' with v-bind (shorthand :) so that either the 'comp-one' component or the 'comp-two' component is displayed.\nApp.vue:\nSee more examples below.\nDefinition and Usage\nThe is attribute can be used for three things:\n1. Dynamic components: The is attribute is set on the built-in <component> element to create a dynamic component, where the is attribute defines which component should be the active one.\nIn more detail, the is attribute is bound to a property with v-bind, and the property holds the name of which component that should be the active one. (See the Example above)\n2. Replace a native element with a Vue component: is=\"vue:my-component\" is placed on a native HTML element to replace it with a Vue component. (See Example 1)\nIf we do not use the vue: prefix, it will be interpreted as a customized built-in element, as explained right below here, and the Vue component will not be inserted.\n3. Customized built-in element: Customized built-in elements can be written in JavaScript, and the is attribute can be used on an HTML tag to define it as such a customized built-in element. This is not a Vue feature.\nMore Examples\nExample 1\nUsing the is attribute to replace an <img> tag with a Vue component.\nApp.vue:\nChildComp.vue:\nRelated Pages\nVue Tutorial: Dynamic Components\nVue Tutorial: Vue Components\nVue Tutorial: Vue Computed Properties\nVue Tutorial: Vue v-bind Directive\nVue Reference: Vue v-bind Directive\nVue Reference: Vue <component> Element\nVue Reference: Vue $refs Object",
      "examples": [
        "<template> <h1>Dynamic Components</h1> <p>App.vue switches between which component to show.</p> <button @click=\"toggleValue = !toggleValue\">Switch component</button> <component :is=\"activeComp\"></component> </template>",
        "<template> <h2>Example Built-in 'is' Attribute</h2> <p>The IMG tag below is set to be replaced by a component by the use of 'is=\"vue:child-comp\"'.</p> <img is=\"vue:child-comp\" /> </template>",
        "<template> <div> <h3>ChildComp.vue</h3> <p>This is the child component</p> </div> </template> <style scoped> div { border: solid black 1px; background-color: lightgreen; padding: 10px; max-width: 250px; margin-top: 20px; } </style>",
        "is",
        "v-bind",
        ":",
        "App.vue",
        "<component>",
        "is=\"vue:my-component\"",
        "vue:",
        "<img>",
        "ChildComp.vue"
      ]
    },
    {
      "title": "Vue 'key' Attribute",
      "summary": "ExampleGet your own Vue Server\nThe key attribute is used on food-item components to uniquely identify each element created with v-for.\nDefinition and Usage\nThe key attribute is used with the v-for directive so that Vue can tell the elements apart properly.\nVue optimizes performance by reusing elements. So when elements are created from an array with v-for, if the key attribute is NOT used, element properties can be mixed when the array gets modified.\nFor a more thorough explanation, and an example of what goes wrong when the key attribute is not used, see The 'key' Attribute chapter in the Vue tutorial.\nRelated Pages\nVue Tutorial: Vue v-for Directive\nVue Tutorial: Vue v-for Components\nVue Tutorial: Vue Animations with v-for",
      "examples": [
        "<food-item v-for=\"x in foods\" :key=\"x.name\" :food-name=\"x.name\" :food-desc=\"x.desc\" :is-favorite=\"x.favorite\" />",
        "key",
        "food-item",
        "v-for"
      ]
    },
    {
      "title": "Vue 'ref' Attribute",
      "summary": "ExampleGet your own Vue Server\nUsing the ref attribute to change the text inside the <p> tag:\nSee more examples below.\nDefinition and Usage\nThe ref attribute is used to mark elements in <template>, so that they can be accessed from the $refs object inside <script>.\nWe can use the ref attribute and the $refs object in Vue as an alternative to methods in plain JavaScript like getElementById() or querySelector().\nIf HTML elements created with v-for have the ref attribute, the resulting DOM elements will be added to the $refs object as an array, like demonstrated in this example:\nExample\nMore Examples\nExample 1\nThe text inside a <p> element is changed.\nExample 2\nThe text from the first <p> tag is copied into the second <p> tag.\nExample 3\nA <p> element gets the same content as what's being written in the input field.\nExample 4\nThe button reveals the the third list element stored as an array element inside the $refs object.\nRelated Pages\nVue Tutorial: Vue Template Refs\nVue Tutorial: Vue v-for Directive\nVue Reference: Vue $refs Object",
      "examples": [
        "<ul> <li v-for=\"x in liTexts\" ref=\"liEl\">{{ x }}</li> </ul>",
        "<template> <h1>Example</h1> <p>Click the button to put \"Hello!\" as the text in the green p element.</p> <button @click=\"changeVal\">Change Text</button><br> <p ref=\"pEl\" id=\"pEl\">This is the initial text</p> </template> <script> export default { methods: { changeVal() { this.$refs.pEl.innerHTML = \"Hello!\"; } } }; </script> <style> #pEl { background-color: lightgreen; display: inline-block; } </style>",
        "<template> <h1>Example</h1> <p ref=\"p1\">Click the button to copy this text into the paragraph below.</p> <button @click=\"transferText\">Transfer text</button> <p ref=\"p2\">...</p> </template> <script> export default { methods: { transferText() { this.$refs.p2.innerHTML = this.$refs.p1.innerHTML; } } }; </script>",
        "<template> <h1>Example</h1> <p>Start writing inside the input element, and the text will be copied into the last paragraph by the use of the '$refs' object.</p> <input ref=\"inputEl\" @input=\"getRefs\" placeholder=\"Write something..\"> <p ref=\"pEl\"></p> </template> <script> export default { methods: { getRefs() { this.$refs.pEl.innerHTML = this.$refs.inputEl.value; } } }; </script>",
        "<template> <h1>Example</h1> <p>Click the button to reveal the 3rd list element stored as an array element in the $refs object.</p> <button @click=\"getValue\">Get the 3rd list element</button><br> <ul> <li v-for=\"x in liTexts\" ref=\"liEl\">{{ x }}</li> </ul> <pre>{{ thirdEl }}</pre> </template> <script> export default { data() { return { thirdEl: ' ', liTexts: ['Apple','Banana','Kiwi','Tomato','Lichi'] } }, methods: { getValue() { this.thirdEl = this.$refs.liEl[2].innerHTML; console.log(\"this.$refs.liEl = \",this.$refs.liEl); } } }; </script> <style> pre { background-color: lightgreen; display: inline-block; } </style>",
        "<div id=\"app\">\n<p ref=\"pEl\">Initial text.</p>\n<button v-on:click=\"changeText\">Change text</button>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script type=\"module\">\nconst app = Vue.createApp({\nmethods: {\nchangeText(){\nthis.$refs.pEl.innerHTML = \"Hello!\";\n}\n}\n})\napp.mount('#app')\n</script>",
        "ref",
        "<p>",
        "<template>",
        "$refs",
        "<script>",
        "getElementById()",
        "querySelector()",
        "v-for"
      ]
    },
    {
      "title": "Vue Built-in Components",
      "summary": "Vue has a set of built-in components.",
      "examples": []
    },
    {
      "title": "Vue <KeepAlive> Component",
      "summary": "ExampleGet your own Vue Server\nUsing the built-in <KeepAlive> component to make the components keep the previously entered user inputs:\nSee more examples below.\nDefinition and Usage\nThe built-in <KeepAlive> component is used around dynamic components to cache the components when they are not active, so that their state is kept.\nProps\nThe <KeepAlive> component can be used together with different props so that we can specify which components that should be cached so that they keep their state.\nThe Lifecycle of Components Cached with <KeepAlive>\nComponents that are cached with the built-in <KeepAlive> component will switch between the activated and deactivated states when they are set, or not set, as the active dynamic component.\nThe activated() and deactivated() lifecycle hooks can be used to run code when such a cached component is set, or not set, as the active component.\nMore Examples\nExample\nUsing the include prop to specify which components that will cache the values:\nExample\nUsing the exclude prop to specify which components that will\nnot\ncache the values:\nExample\nUsing the max prop to specify how many of the last visited components that will cache the values:\nRelated Pages\nVue Tutorial: Dynamic Components\nVue Tutorial: The 'activated' and 'deactivated' Lifecycle Hooks",
      "examples": [
        "<KeepAlive> <component :is=\"activeComp\"></component> </KeepAlive>",
        "<KeepAlive include=\"CompOne,CompThree\"> <component :is=\"activeComp\"></component> </KeepAlive>",
        "<KeepAlive exclude=\"CompOne\"> <component :is=\"activeComp\"></component> </KeepAlive>",
        "<KeepAlive :max=\"2\"> <component :is=\"activeComp\"></component> </KeepAlive>",
        "<KeepAlive>",
        "activated",
        "deactivated",
        "activated()",
        "deactivated()",
        "include",
        "exclude",
        "max"
      ]
    },
    {
      "title": "Vue <Teleport> Component",
      "summary": "ExampleGet your own Vue Server\nUsing the built-in <Teleport> component to move a <div> element to the root of the <body>:\nSee more examples below.\nDefinition and Usage\nThe built-in <Teleport> component is used with the to prop to move an element out of the current HTML structure and into another element already mounted in the DOM.\nTo see that an element actually has been moved somewhere with the <Teleport> component, you might need to right-click and inspect the page.\nA teleported element will end up after other elements that are already mounted in the destination. So in case more than one element is teleported to the same destination, the last element teleported will end up below other teleported elements.\nIf <Teleport> is used to move a component, the communication to and from that component with provide/inject or prop/emit still works like before, as if the component was not moved.\nAlso, if some content is moved out of a component with <Teleport>, Vue makes sure that relevant code inside the component in the <script> and <style> tags still works for the moved content. See the example below.\nProps\nMore Examples\nExample\nRelevant code from the <style> and <script> tags still works for the teleported <div> tag even though it is no longer inside the component after compilation.\nCompOne.vue:\nExample\nThe boolean disabled prop is toggled with a button so that the <div> element is either teleported, or not.\nCompOne.vue:\nRelated Pages\nVue Tutorial: Vue Teleport",
      "examples": [
        "<Teleport to=\"body\"> <div id=\"redDiv\">Hello!</div> </Teleport>",
        "<template> <div> <h2>Component</h2> <p>This is the inside of the component.</p> <Teleport to=\"body\"> <div id=\"redDiv\" @click=\"toggleVal = !toggleVal\" :style=\"{ backgroundColor: bgColor }\" > Hello!<br> Click me! </div> </Teleport> </div> </template> <script> export default { data() { return { toggleVal: true } }, computed: { bgColor() { if (this.toggleVal) { return 'lightpink' } else { return 'lightgreen' } } } } </script> <style scoped> #redDiv { margin: 10px; padding: 10px; display: inline-block; } #redDiv:hover { cursor: pointer; } </style>",
        "<template> <div> <h2>Component</h2> <p>This is the inside of the component.</p> <button @click=\"teleportOn = !teleportOn\">Teleport on/off</button> <Teleport to=\"body\" :disabled=\"teleportOn\"> <div id=\"redDiv\">Hello!</div> </Teleport> </div> </template> <script> export default { data() { return { teleportOn: true } } } </script> <style scoped> #redDiv { background-color: lightcoral; margin: 10px; padding: 10px; width: 100px; } </style>",
        "<Teleport>",
        "<div>",
        "<body>",
        "to",
        "<script>",
        "<style>",
        "CompOne.vue",
        "disabled"
      ]
    },
    {
      "title": "Vue <Transition> Component",
      "summary": "ExampleGet your own Vue Server\nUsing the built-in <Transition> component to animate a <p> element as it is removed with v-if:\nSee more examples below.\nDefinition and Usage\nThe built-in <Transition> component is used to animate elements as they are added or removed with v-if, v-show, or with dynamic components.\nThe rules for how elements are animated is written inside automatically generated classes or JavaScript transition hooks. See tables below.\nThere can only be one element at the root level of the <Transition> component.\nProps\nUsing one of these props like this enter-active-class=\"entering\" means that this transition class can be referred to as .entering in CSS, instead of the default .v-enter-active. The convention is to use kebab-case for props in template to be in line with how attributes are written in HTML.\nCSS Transition Classes\nWhen we use the <Transition> component, we automatically get six different CSS classes we can use to animate elements when they are added or removed.\nThese classes are active at different stages when elements are added (enter) or removed (leave):\nJavaScript Transition Hooks\nThe transition classes above corresponds to events that we can hook into to run JavaScript code.\nMore examples\nExample 1\nA <p> element slides in and out when it is toggled.\nExample 2\nA <p> element has separate background colors during 'enter' and 'leave'\nExample 3\n<p> elements are animated differently, using the name prop to differentiate the <Transition> components.\nExample 4\nThe after-enter event triggers a <div> element to be displayed.\nExample 5\nA toggle button triggers the enter-cancelled event.\nExample 6\nThe appear prop starts the <p> element animation right after the page is loaded.\nExample 7\nFlip through images with animation on 'enter' and 'leave'. A new image is added before the old image is removed.\nExample 8\nFlip through images with animation on 'enter' and 'leave'. The mode=\"out-in\" prevents new images to be added until the old image is removed.\nExample 9\nSwitching between components is animated.\nExample 10\nSwitching between components is animated.\nExample 11\nUsing the enterActiveClass prop to rename the 'v-enter-active' CSS class to 'entering'.\nRelated Pages\nVue Tutorial: Vue Animations\nVue Tutorial: Vue Animations with v-for\nVue Reference: Vue <TransitionGroup> Component",
      "examples": [
        "<Transition> <p v-if=\"exists\">Hello World!</p> </Transition>",
        "<template> <h1>Add/Remove <p> Tag</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <Transition> <p v-if=\"exists\">Hello World!</p> </Transition> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .v-enter-from { opacity: 0; translate: -100px 0; } .v-enter-to { opacity: 1; translate: 0 0; } .v-leave-from { opacity: 1; translate: 0 0; } .v-leave-to { opacity: 0; translate: 100px 0; } p { background-color: lightgreen; display: inline-block; padding: 10px; transition: all 0.5s; } </style>",
        "<template> <h1>Add/Remove <p> Tag</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <Transition> <p v-if=\"exists\">Hello World!</p> </Transition> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .v-enter-active { background-color: lightgreen; animation: added 1s; } .v-leave-active { background-color: lightcoral; animation: added 1s reverse; } @keyframes added { from { opacity: 0; translate: -100px 0; } to { opacity: 1; translate: 0 0; } } p { display: inline-block; padding: 10px; border: dashed black 1px; } </style>",
        "<template> <h1>Add/Remove <p> Tag</h1> <p>The second transition in this example has the name prop \"swirl\", so that we can keep the transitions apart with different class names.</p> <hr> <button @click=\"this.p1Exists = !this.p1Exists\">{{btn1Text}}</button><br> <Transition> <p v-if=\"p1Exists\" id=\"p1\">Hello World!</p> </Transition> <hr> <button @click=\"this.p2Exists = !this.p2Exists\">{{btn2Text}}</button><br> <Transition name=\"swirl\"> <p v-if=\"p2Exists\" id=\"p2\">Hello World!</p> </Transition> </template> <script> export default { data() { return { p1Exists: false, p2Exists: false } }, computed: { btn1Text() { if(this.p1Exists) { return 'Remove'; } else { return 'Add'; } }, btn2Text() { if(this.p2Exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .v-enter-active { background-color: lightgreen; animation: added 1s; } .v-leave-active { background-color: lightcoral; animation: added 1s reverse; } @keyframes added { from { opacity: 0; translate: -100px 0; } to { opacity: 1; translate: 0 0; } } .swirl-enter-active { animation: swirlAdded 1s; } .swirl-leave-active { animation: swirlAdded 1s reverse; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } #p1, #p2 { display: inline-block; padding: 10px; border: dashed black 1px; } #p2 { background-color: lightcoral; } </style>",
        "<template> <h1>JavaScript Transition Hooks</h1> <p>This code hooks into \"after-enter\" so that after the initial animation is done, a method runs that displays a red div.</p> <button @click=\"pVisible=true\">Create p-tag!</button><br> <Transition @after-enter=\"onAfterEnter\"> <p v-show=\"pVisible\" id=\"p1\">Hello World!</p> </Transition> <br> <div v-show=\"divVisible\">This appears after the \"enter-active\" phase of the transition.</div> </template> <script> export default { data() { return { pVisible: false, divVisible: false } }, methods: { onAfterEnter() { this.divVisible = true; } } } </script> <style> .v-enter-active { animation: swirlAdded 1s; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } #p1, div { display: inline-block; padding: 10px; border: dashed black 1px; } #p1 { background-color: lightgreen; } div { background-color: lightcoral; } </style>",
        "<template> <h1>The 'enter-cancelled' Event</h1> <p>Click the toggle button again before the enter animation is finished to trigger the 'enter-cancelled' event.</p> <button @click=\"pVisible=!pVisible\">Toggle</button><br> <Transition @enter-cancelled=\"onEnterCancelled\"> <p v-if=\"pVisible\" id=\"p1\">Hello World!</p> </Transition> <br> <div v-if=\"divVisible\">You interrupted the \"enter-active\" transition.</div> </template> <script> export default { data() { return { pVisible: false, divVisible: false } }, methods: { onEnterCancelled() { this.divVisible = true; } } } </script> <style> .v-enter-active { animation: swirlAdded 2s; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 720deg; scale: 1; } } #p1, div { display: inline-block; padding: 10px; border: dashed black 1px; } #p1 { background-color: lightgreen; } div { background-color: lightcoral; } </style>",
        "<template> <h1>The 'appear' Prop</h1> <p>The 'appear' prop starts the animation when the p tag below is rendered for the first time as the page opens. Without the 'appear' prop, this example would have had no animation.</p> <Transition appear> <p id=\"p1\">Hello World!</p> </Transition> </template> <style> .v-enter-active { animation: swirlAdded 1s; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } #p1 { display: inline-block; padding: 10px; border: dashed black 1px; background-color: lightgreen; } </style>",
        "<template> <h1>Transition Between Elements</h1> <p>Click the button to get a new image.</p> <p>The new image is added before the previous is removed. We will fix this in the next example with mode=\"out-in\".</p> <button @click=\"newImg\">Next image</button><br> <Transition> <img src=\"/img_pizza.svg\" v-if=\"imgActive === 'pizza'\"> <img src=\"/img_apple.svg\" v-else-if=\"imgActive === 'apple'\"> <img src=\"/img_cake.svg\" v-else-if=\"imgActive === 'cake'\"> <img src=\"/img_fish.svg\" v-else-if=\"imgActive === 'fish'\"> <img src=\"/img_rice.svg\" v-else-if=\"imgActive === 'rice'\"> </Transition> </template> <script> export default { data() { return { imgActive: 'pizza', imgs: ['pizza', 'apple', 'cake', 'fish', 'rice'], indexNbr: 0 } }, methods: { newImg() { this.indexNbr++; if(this.indexNbr >= this.imgs.length) { this.indexNbr = 0; } this.imgActive = this.imgs[this.indexNbr]; } } } </script> <style> .v-enter-active { animation: swirlAdded 1s; } .v-leave-active { animation: swirlAdded 1s reverse; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } img { width: 100px; margin: 20px; } img:hover { cursor: pointer; } </style>",
        "<template> <h1>mode=\"out-in\"</h1> <p>Click the button to get a new image.</p> <p>With mode=\"out-in\", the next image is not added until the current image is removed. Another difference from the previous example, is that here we use computed prop instead of a method.</p> <button @click=\"indexNbr++\">Next image</button><br> <Transition mode=\"out-in\"> <img src=\"/img_pizza.svg\" v-if=\"imgActive === 'pizza'\"> <img src=\"/img_apple.svg\" v-else-if=\"imgActive === 'apple'\"> <img src=\"/img_cake.svg\" v-else-if=\"imgActive === 'cake'\"> <img src=\"/img_fish.svg\" v-else-if=\"imgActive === 'fish'\"> <img src=\"/img_rice.svg\" v-else-if=\"imgActive === 'rice'\"> </Transition> </template> <script> export default { data() { return { imgs: ['pizza', 'apple', 'cake', 'fish', 'rice'], indexNbr: 0 } }, computed: { imgActive() { if(this.indexNbr >= this.imgs.length) { this.indexNbr = 0; } return this.imgs[this.indexNbr]; } } } </script> <style> .v-enter-active { animation: swirlAdded 0.7s; } .v-leave-active { animation: swirlAdded 0.7s reverse; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } img { width: 100px; margin: 20px; } img:hover { cursor: pointer; } </style>",
        "<template> <h1>Transition with Dynamic Components</h1> <p>The Transition component wraps around the dynamic component so that the switching can be animated.</p> <button @click=\"toggleValue = !toggleValue\">Switch component</button> <Transition mode=\"out-in\"> <component :is=\"activeComp\"></component> </Transition> </template> <script> export default { data () { return { toggleValue: true } }, computed: { activeComp() { if(this.toggleValue) { return 'comp-one' } else { return 'comp-two' } } } } </script> <style> .v-enter-active { animation: slideIn 0.5s; } @keyframes slideIn { from { translate: -200px 0; opacity: 0; } to { translate: 0 0; opacity: 1; } } .v-leave-active { animation: slideOut 0.5s; } @keyframes slideOut { from { translate: 0 0; opacity: 1; } to { translate: 200px 0; opacity: 0; } } #app { width: 350px; margin: 10px; } #app > div { border: solid black 2px; padding: 10px; margin-top: 10px; } </style>",
        "<template> <h1>The :css=\"false\" Prop</h1> <p>With the 'css' prop set to 'false', we tell the compiler that JavaScript hooks are used instead of CSS transition classes.</p> <p>When we use :css=\"false\", we must call done() inside the 'enter' and the 'leave' hooks, to tell the browser when those transitions are finished.</p> <button @click=\"pVisible=!pVisible\">Toggle</button> <div> <Transition :css=\"false\" @enter=\"onEnter\" @after-enter=\"onAfterEnter\" @before-leave=\"onBeforeLeave\" @leave=\"onLeave\" > <p v-if=\"pVisible\" id=\"p1\"> Hello World! </p> </Transition> </div> </template> <script> export default { data() { return { pVisible: false } }, methods: { onEnter(el,done) { let pos = 0; window.requestAnimationFrame(frame); function frame() { if (pos > 150) { done(); } else { pos++; el.style.left = pos + \"px\"; window.requestAnimationFrame(frame); } } }, onAfterEnter(el) { el.style.backgroundColor = \"yellow\"; }, onBeforeLeave(el) { el.style.backgroundColor = \"lightgreen\"; }, onLeave(el,done) { let pos = 150; window.requestAnimationFrame(frame); function frame() { if (pos < 0) { done(); } else { pos--; el.style.left = pos + \"px\"; window.requestAnimationFrame(frame); } } } } } </script> <style> #p1 { position: absolute; padding: 10px; border: dashed black 1px; background-color: lightgreen; } #app > div { position: relative; background-color: coral; width: 300px; height: 300px; border: dashed black 1px; margin-top: 20px; } </style>",
        "<template> <h1>The 'enterActiveClass' Prop</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <Transition enter-active-class=\"entering\"> <p v-if=\"exists\">Hello World!</p> </Transition> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style> .entering { background-color: lightgreen; animation: added 1s; } .v-leave-active { background-color: lightcoral; animation: added 1s reverse; } @keyframes added { from { opacity: 0; translate: -100px 0; } to { opacity: 1; translate: 0 0; } } p { display: inline-block; padding: 10px; border: dashed black 1px; } </style>",
        "<Transition>",
        "<p>",
        "v-if",
        "v-show",
        "true",
        "false",
        "mode=\"out-in\"",
        "mode=\"in-out\"",
        "name=\"swirl\"",
        "swirl-",
        "v-",
        ":css=\"false\"",
        "done()",
        ":duration=\"{enter:2000, leave:1000 }\"",
        "duration=\"1000\"",
        "enter-active-class=\"entering\"",
        ".entering",
        ".v-enter-active",
        "name",
        "after-enter",
        "<div>",
        "enter-cancelled",
        "appear",
        "enterActiveClass"
      ]
    },
    {
      "title": "Vue <TransitionGroup> Component",
      "summary": "ExampleGet your own Vue Server\nUsing the built-in <TransitionGroup> component to create an <ol> tag with animated <li> tags inside.\nSee more examples below.\nDefinition and Usage\nThe built-in <TransitionGroup> component is used around elements created with v-for, to give these elements individual animations when they are added or removed.\nTags created with v-for inside the <TransitionGroup> component must be uniquely defined with the key attribute.\nThe <TransitionGroup> component is only rendered as an HTML tag if we define it to be a specific tag by using the tag prop.\nWhen tags are created inside the <TransitionGroup> component with v-for based on an array, these tags will be animated automatically when elements are added to, or removed from, the array.\nProps\nThe built-in <TransitionGroup> component can be used with the same props as the built-in <Transition> component, but accepts the name and the moveClass props in addition:\nMore Examples\nExample 1\nDice can be added or removed, added dice are animated using <TransitionGroup>.\nExample 2\nDice can be added or removed, both added and removed dice are animated using <TransitionGroup>.\nExample 3\nDice can be added, removed shuffled or sorted, all animated using <TransitionGroup>.\nExample 4\nThe move class is renamed using the moveClass prop.\nRelated Pages\nVue Tutorial: Vue Animations\nVue Tutorial: Vue Animations with v-for\nVue Tutorial: Vue v-for Directive\nVue Tutorial: Vue v-for Components\nVue Reference: Vue <Transition> Component",
      "examples": [
        "<TransitionGroup tag=\"ol\"> <li v-for=\"x in products\" :key=\"x\"> {{ x }} </li> </TransitionGroup>",
        "<template> <h3>The <TransitionGroup> Component</h3> <p>New products are given animations using the <TransitionGroup> component.</p> <button @click=\"addDie\">Roll</button> <button @click=\"removeDie\">Remove random</button><br> <TransitionGroup> <div v-for=\"x in dice\" :key=\"x\" class=\"diceDiv\" :style=\"{ backgroundColor: 'hsl('+x*40+',85%,85%)' }\"> {{ x }} </div> </TransitionGroup> </template> <script> export default { data() { return { dice: [], inpName: '' } }, methods: { addDie() { const newDie = Math.ceil(Math.random()*6); this.dice.push(newDie); }, removeDie() { if(this.dice.length>0){ this.dice.splice(Math.floor(Math.random()*this.dice.length), 1); } } }, mounted() { this.addDie(); this.addDie(); this.addDie(); } } </script> <style> .v-enter-from { opacity: 0; translate: 200px 0; rotate: 360deg; } .v-enter-to { opacity: 1; translate: 0 0; rotate: 0deg; } .v-enter-active, .v-leave-active { transition: all 0.7s; } .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } .diceDiv { margin: 10px; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; text-align: center; border: solid black 1px; border-radius: 5px; display: inline-block; } </style>",
        "<template> <h3>The <TransitionGroup> Component</h3> <p>When an item is removed inside the <TransitionGroup> component, other items are animated as they fall into their new positions.</p> <button @click=\"addDie\">Roll</button> <button @click=\"removeDie\">Remove random</button><br> <TransitionGroup> <div v-for=\"x in dice\" :key=\"x\" class=\"diceDiv\" :style=\"{ backgroundColor: 'hsl('+x*40+',85%,85%)' }\"> {{ x }} </div> </TransitionGroup> </template> <script> export default { data() { return { dice: [], inpName: '' } }, methods: { addDie() { const newDie = Math.ceil(Math.random()*6); this.dice.push(newDie); }, removeDie() { if(this.dice.length>0){ this.dice.splice(Math.floor(Math.random()*this.dice.length), 1); } } }, mounted() { this.addDie(); this.addDie(); this.addDie(); } } </script> <style> .v-enter-from { opacity: 0; translate: 200px 0; rotate: 360deg; } .v-enter-to { opacity: 1; translate: 0 0; rotate: 0deg; } .v-enter-active, .v-leave-active, .v-move { transition: all 0.7s; } .v-leave-active { position: absolute; } .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } .diceDiv { margin: 10px; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; text-align: center; border: solid black 1px; border-radius: 5px; display: inline-block; } </style>",
        "<template> <h3>The <TransitionGroup> Component</h3> <p>Items inside the <TransitionGroup> component are animated when they are created or removed.</p> <button @click=\"addDie\">Roll</button> <button @click=\"addDie10\">Roll 10 dice</button> <button @click=\"dice.sort(compareFunc)\">Sort</button> <button @click=\"dice.sort(shuffleFunc)\">Shuffle</button><br> <TransitionGroup> <div v-for=\"x in dice\" :key=\"x.keyNmbr\" class=\"diceDiv\" :style=\"{ backgroundColor: 'hsl('+x.dieNmbr*60+',85%,85%)' }\" @click=\"removeDie(x.keyNmbr)\"> {{ x.dieNmbr }} </div> </TransitionGroup> </template> <script> export default { data() { return { dice: [], keyNumber: 0 } }, methods: { addDie() { const newDie = { dieNmbr: Math.ceil(Math.random()*6), keyNmbr: this.keyNumber }; this.dice.splice(Math.floor(Math.random()*this.dice.length),0,newDie); this.keyNumber++; }, addDie10() { for(let i=0; i<10; i++) { this.addDie(); } }, compareFunc(a,b){ return a.dieNmbr - b.dieNmbr; }, shuffleFunc(a,b){ return Math.random()-0.5; }, removeDie(key) { const pos = this.dice.map(e => e.keyNmbr).indexOf(key); this.dice.splice(pos, 1); } }, mounted() { this.addDie10(); } } </script> <style> .v-enter-from { opacity: 0; scale: 0; rotate: 360deg; } .v-enter-to { opacity: 1; scale: 1; rotate: 0deg; } .v-enter-active, .v-leave-active, .v-move { transition: all 0.7s; } .v-leave-active { position: absolute; } .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } .diceDiv { margin: 10px; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; text-align: center; border: solid black 1px; border-radius: 5px; display: inline-block; } .diceDiv:hover { cursor: pointer; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); } #app { position: relative; } </style>",
        "<template> <h3>The <TransitionGroup> Component</h3> <p>When an item is removed inside the <TransitionGroup> component, other items are animated as they fall into their new positions.</p> <button @click=\"addDie\">Roll</button> <button @click=\"removeDie\">Remove random</button><br> <TransitionGroup moveClass=\"good-slide\"> <div v-for=\"x in dice\" :key=\"x\" class=\"diceDiv\" :style=\"{ backgroundColor: 'hsl('+x*40+',85%,85%)' }\" > {{ x }} </div> </TransitionGroup> </template> <script> export default { data() { return { dice: [], inpName: '' } }, methods: { addDie() { const newDie = Math.ceil(Math.random()*6); this.dice.push(newDie); }, removeDie() { if(this.dice.length>0){ this.dice.splice(Math.floor(Math.random()*this.dice.length), 1); } } }, mounted() { this.addDie(); this.addDie(); this.addDie(); } } </script> <style> .v-enter-from { opacity: 0; translate: 200px 0; rotate: 360deg; } .v-enter-to { opacity: 1; translate: 0 0; rotate: 0deg; } .v-enter-active, .v-leave-active, .good-slide { transition: all 0.7s; } .v-leave-active { position: absolute; } .v-leave-from { opacity: 1; } .v-leave-to { opacity: 0; } .diceDiv { margin: 10px; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; text-align: center; border: solid black 1px; border-radius: 5px; display: inline-block; } </style>",
        "<TransitionGroup>",
        "<ol>",
        "<li>",
        "v-for",
        "key",
        "tag",
        "<Transition>",
        "name",
        "moveClass",
        "v-move"
      ]
    },
    {
      "title": "Vue Built-in Elements",
      "summary": "Vue has a set of built-in elements.",
      "examples": []
    },
    {
      "title": "Vue <component> Element",
      "summary": "ExampleGet your own Vue Server\nUsing the built-in <component> element with the is attribute to create a dynamic component.\nSee more examples below.\nDefinition and Usage\nThe built-in <component> element is used together with the built-in is attribute to create an HTML element, or a Vue component.\nHTML element: To create an HTML element with the <component> element, the is attribute is set equal to the name of the HTML element we want to create, either directly (Example 1), or dynamically by the use of v-bind (Example 2).\nVue component: To render a Vue component with the <component> element, the is attribute is set equal to the name of the Vue component we want to create, either directly (Example 3), or dynamically by the use of v-bind to create a dynamic component (Example 4).\nWhen creating a dynamic component, the built-in <KeepAlive> component can be used around the <component> element to remember the state of components that are not active. (Example 5)\nThe active component in a dynamic component can also be changed by using a ternary expression with the is attribute. (Example 6)\nNote: The v-model directive does not work with native HTML form input tags (such as <input> or <option>) created with the <component> element. (Example 7)\nProps\nMore examples\nExample 1\nUsing the built-in <component> element to create a <div> element.\nExample 2\nUsing the built-in <component> element to toggle between an ordered list and an unordered list.\nExample 3\nUsing the built-in <component> element to render a component by providing the name of the component to the is attribute.\nApp.vue:\nChildComp.vue:\nExample 4\nUsing the built-in <component> element to create a dynamic component, where we can switch between two components.\nExample 5\nThe built-in <KeepAlive> component is used around the <component> element to remember the inputs when the components are switched between.\nExample 6\nUsing the <component> element with the is attribute and a ternary expression to toggle which component should be active.\nExample 7\nDemonstrating that the v-model directive does not work with <input> elements created using the <component> element.\nRelated Pages\nVue Tutorial: Vue Components\nVue Tutorial: Dynamic Components\nVue Tutorial: Vue Form Inputs\nVue Tutorial: Vue v-model Directive\nVue Reference: Vue is Attribute\nVue Reference: Vue v-bind Directive\nVue Reference: Vue v-model Directive",
      "examples": [
        "<template> <h1>Dynamic Components</h1> <p>App.vue switches between which component to show.</p> <button @click=\"toggleValue = !toggleValue\">Switch component</button> <component :is=\"activeComp\"></component> </template>",
        "<template> <h2>Example Built-in 'component' Element</h2> <p>The component element is rendered as a div element with is=\"div\":</p> <component is=\"div\">This is a DIV element</component> </template> <style scoped> div { border: solid black 1px; background-color: lightgreen; } </style>",
        "<template> <h2>Example Built-in 'component' Element</h2> <p>Using the component element to toggle between an ordered list (ol), and an unordered list (ul):</p> <button v-on:click=\"toggleValue = !toggleValue\">Toggle</button> <p>Animals from around the world</p> <component :is=\"tagType\"> <li>Kiwi</li> <li>Jaguar</li> <li>Bison</li> <li>Snow Leopard</li> </component> </template> <script> export default { data() { return { toggleValue: true } }, computed: { tagType() { if (this.toggleValue) { return 'ol' } else { return 'ul' } } } } </script>",
        "<template> <h2>Example Built-in 'is' Attribute</h2> <p>The component element below is set to be a component by the use of 'is=\"child-comp\"'.</p> <component is=\"child-comp\"></component> </template>",
        "<template> <div> <h3>ChildComp.vue</h3> <p>This is the child component</p> </div> </template> <style scoped> div { border: solid black 1px; background-color: lightgreen; padding: 10px; max-width: 250px; margin-top: 20px; } </style>",
        "<template> <h1>Dynamic Components</h1> <p>App.vue switches between which component to show.</p> <button @click=\"toggleValue = !toggleValue\">Switch component</button> <component :is=\"activeComp\"></component> </template> <script> export default { data () { return { toggleValue: true } }, computed: { activeComp() { if(this.toggleValue) { return 'comp-one' } else { return 'comp-two' } } } } </script> <style> #app { width: 350px; margin: 10px; } #app > div { border: solid black 2px; padding: 10px; margin-top: 10px; } </style>",
        "<template> <h1>Dynamic Components</h1> <p>App.vue switches between which component to show.</p> <p>With the <KeepAlive> tag the components now remember the user inputs.</p> <button @click=\"toggleValue = !toggleValue\">Switch component</button> <KeepAlive> <component :is=\"activeComp\"></component> </KeepAlive> </template> <script> export default { data () { return { toggleValue: true } }, computed: { activeComp() { if(this.toggleValue) { return 'comp-one' } else { return 'comp-two' } } } } </script> <style> #app { width: 350px; margin: 10px; } #app > div { border: solid black 2px; padding: 10px; margin-top: 10px; } h2 { text-decoration: underline; } </style>",
        "<template> <h1>Dynamic Components</h1> <p>Refresh the page and there is a chance the dynamic component will toggle.</p> <component :is=\"Math.random() > 0.5 ? 'comp-one' : 'comp-two'\"></component> </template> <style> #app { width: 350px; margin: 10px; } #app > div { border: solid black 2px; padding: 10px; margin-top: 10px; } </style>",
        "<template> <h1>Dynamic Components</h1> <p><mark>The v-model directive does not work with input element created with the component element.</mark></p> <hr> <p>Does not work, not updating:</p> <component is=\"input\" type=\"number\" v-model=\"inpVal1\"></component> (try to change value) <p class=\"pResult1\">inpVal1: {{ inpVal1 }}</p> <hr> <p>How it should work, updates:</p> <input type=\"number\" v-model=\"inpVal2\"> (try to change value) <p class=\"pResult2\">inpVal2: {{ inpVal2 }}</p> </template> <script> export default { data() { return { inpVal1: 4, inpVal2: 7, } } } </script> <style> #app { width: 350px; margin: 10px; } .pResult1 { background-color: lightpink; font-family: 'Courier New', Courier, monospace; font-weight: bold; padding: 5px; } .pResult2 { background-color: lightgreen; font-family: 'Courier New', Courier, monospace; font-weight: bold; padding: 5px; } </style>",
        "<component>",
        "is",
        "v-bind",
        "<KeepAlive>",
        "v-model",
        "<input>",
        "<option>",
        "<div>",
        "App.vue",
        "ChildComp.vue"
      ]
    },
    {
      "title": "Vue <slot> Element",
      "summary": "ExampleGet your own Vue Server\nUsing the built-in <slot> element to place content from the parent component in the <template> of the child component.\nSee more examples below.\nDefinition and Usage\nThe built-in <slot> element is used to place content received from the parent component.\nWhen a child component is called, content provided between the start- and end-tag will end up where the <slot> element is inside that child component.\nA component can hold more than one <slot>, and the slots can be named with the name prop. With such components with different named slots, we can use the v-slot directive to send content to specific slots. (Example 3)\nContent between the start- and end-tag of the <slot> element will be used as fallback content if no content is provided by the parent. (Example 5)\nInformation can be provided up to the parent element through <slot> props. (Example 8)\nThe <slot> element is just a placeholder for content, the <slot> element itself is not rendered into a DOM element.\nProps\nMore examples\nExample 1\nUsing slots to wrap around larger chunks of dynamic HTML content to get a card-like appearance.\nApp.vue:\nAs the content enters the component where the <slot> is, we use a div around the <slot> and style the <div> locally to create a card-like appearance around the content without affecting other divs in our application.\nSlotComp.vue:\nExample 2\nUsing a slot to create a footer.\nApp.vue:\nExample 3\nUsing slot names, content can be sent to a specific slot.\nSlotComp.vue:\nApp.vue:\nExample 4\nWith two slots in a component, content sent to the component will end up in both slots.\nApp.vue:\nSlotComp.vue:\nExample 5\nUsing fallback content in a slot so that something is rendered when no content is provided from the parent.\nApp.vue:\nSlotComp.vue:\nExample 6\nThe slot without a name will be the default slot for content from the parent.\nSlotComp.vue:\nApp.vue:\nExample 7\nUsing v-slot:default to explicitly define a slot as the default slot.\nSlotComp.vue:\nApp.vue:\nExample 8\nScoped slot: Using the 'foodName' prop in the slot to communicate the food name to the parent.\nSlotComp.vue:\nApp.vue:\nExample 9\nScoped slot: Using props in the slot to communicate the several things to the parent, based on an array with objects.\nSlotComp.vue:\nApp.vue:\nExample 10\nUsing named scoped slots to put one text into the \"leftSlot\", and another text into the \"rightSlot\".\nSlotComp.vue:\nApp.vue:\nRelated Pages\nVue Tutorial: Vue Slots\nVue Tutorial: Vue v-slot\nVue Tutorial: Scoped Slots\nVue Tutorial: Components\nVue Reference: Vue v-slot directive\nVue Reference: Vue $slots Object",
      "examples": [
        "<template> <div> <p>SlotComp.vue</p> <slot></slot> </div> </template>",
        "<template> <h3>Slots in Vue</h3> <p>We create card-like div boxes from the foods array.</p> <div id=\"wrapper\"> <slot-comp v-for=\"x in foods\"> <img v-bind:src=\"x.url\"> <h4>{{x.name}}</h4> <p>{{x.desc}}</p> </slot-comp> </div> </template>",
        "<template> <div> <!-- This div makes the card-like appearance --> <slot></slot> </div> </template> <script></script> <style scoped> div { box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); border-radius: 10px; margin: 10px; } </style>",
        "<template> <h3>Reusable Slot Cards</h3> <p>We create card-like div boxes from the foods array.</p> <p>We also create a card-like footer by reusing the same component.</p> <div id=\"wrapper\"> <slot-comp v-for=\"x in foods\"> <img v-bind:src=\"x.url\"> <h4>{{x.name}}</h4> </slot-comp> </div> <footer> <slot-comp> <h4>Footer</h4> </slot-comp> </footer> </template>",
        "<h3>Component</h3> <div> <slot name=\"topSlot\"></slot> </div> <div> <slot name=\"bottomSlot\"></slot> </div>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp v-slot:bottomSlot>'Hello!'</slot-comp>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp>'Hello!'</slot-comp>",
        "<h3>Component</h3> <div> <slot></slot> </div> <div> <slot></slot> </div>",
        "<template> <h3>Slots Fallback Content</h3> <p>A component without content provided can have fallback content in the slot tag.</p> <slot-comp> <!-- Empty --> </slot-comp> <slot-comp> <h4>This content is provided from App.vue</h4> </slot-comp> </template>",
        "<template> <div> <slot> <h4>This is fallback content</h4> </slot> </div> </template>",
        "<h3>Component</h3> <div> <slot></slot> </div> <div> <slot name=\"bottomSlot\"></slot> </div>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp v-slot:default>'Default slot'</slot-comp>",
        "<template> <slot v-for=\"x in foods\" :key=\"x\" :foodName=\"x\" ></slot> </template> <script> export default { data() { return { foods: ['Apple','Pizza','Rice','Fish','Cake'] } } } </script>",
        "<slot-comp v-slot=\"food\"> <h2>{{ food.foodName }}</h2> </slot-comp>",
        "<template> <slot v-for=\"x in foods\" :key=\"x.name\" :foodName=\"x.name\" :foodDesc=\"x.desc\" :foodUrl=\"x.url\" ></slot> </template> <script> export default { data() { return { foods: [ { name: 'Apple', desc: 'Apples are a type of fruit that grow on trees.', url: 'img_apple.svg' }, { name: 'Pizza', desc: 'Pizza has a bread base with tomato sauce, cheese, and toppings on top.', url: 'img_pizza.svg' }, { name: 'Rice', desc: 'Rice is a type of grain that people like to eat.', url: 'img_rice.svg' }, { name: 'Fish', desc: 'Fish is an animal that lives in water.', url: 'img_fish.svg' }, { name: 'Cake', desc: 'Cake is something sweet that tastes good but is not considered healthy.', url: 'img_cake.svg' } ] } } } </script>",
        "<slot-comp v-slot=\"food\"> <hr> <h2>{{ food.foodName }}<img :src=food.foodUrl></h2> <p>{{ food.foodDesc }}</p> </slot-comp>",
        "<template> <slot name=\"leftSlot\" :text=\"leftText\" ></slot> <slot name=\"rightSlot\" :text=\"rightText\" ></slot> </template> <script> export default { data() { return { leftText: 'This text belongs to the LEFT slot.', rightText: 'This text belongs to the RIGHT slot.' } } } </script>",
        "<slot-comp #leftSlot=\"leftProps\"> <div>{{ leftProps.text }}</div> </slot-comp> <slot-comp #rightSlot=\"rightProps\"> <div>{{ rightProps.text }}</div> </slot-comp>",
        "<slot>",
        "<template>",
        "name",
        "v-slot",
        "App.vue",
        "<div>",
        "SlotComp.vue",
        "v-slot:default"
      ]
    },
    {
      "title": "Vue <template> Element",
      "summary": "ExampleGet your own Vue Server\nUsing the built-in <template> element to toggle a section of HTML code with the v-if directive.\nDefinition and Usage\nThe HTML <template> tag becomes a built-in Vue <template> element when used with Vue directives v-if, v-else-if, v-else, v-for, or v-slot.\nWhen used with v-if, v-else-if, v-else, or v-for, the built-in <template> element renders a section of HTML code.\nWhen used with v-slot, the built-in <template> element directs a section of HTML code to a specified slot. See Example 1 below.\nThe built-in <template> element itself is not rendered as a DOM element.\nNote: The top-level <template> element is a structural requirement when using SFCs (*.vue) files. For such top-level <template> elements, Vue directives cannot be used.\nMore examples\nExample 1\nUsing the built-in <template> element to encapsulate more than one element and send them to a specific named slot with the v-slot directive.\nExample 2\nUsing the <template> element, more than one element can be rendered with the v-if directive.\nRelated Pages\nVue Tutorial: Vue v-slot\nVue Tutorial: Vue Templates\nVue Tutorial: Vue v-if Directive\nVue Reference: Vue v-if Directive\nVue Reference: Vue v-slot Directive\nHTML Reference: HTML <template> tag",
      "examples": [
        "<ul> <li>Trolltunga</li> <template v-if=\"display\"> <li>Potato Point</li> <li>The souks of Marrakech</li> <li>Dry Tortugas</li> <li>Halong Bay</li> </template> <li>...</li> </ul>",
        "<template> <h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp> <template v-slot:bottomSlot> <h4>To the bottom slot!</h4> <p>This p tag and the h4 tag above are directed to the bottom slot with the v-slot directive used on the template tag.</p> </template> <p>This goes into the default slot</p> </slot-comp> </template>",
        "<div id=\"app\">\n<template v-if=\"text.includes('pizza')\">\n<p>The text includes the word 'pizza'</p>\n<img src=\"img_pizza.svg\">\n</template>\n<p v-else>The word 'pizza' is not found in the text</p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntext: 'I like taco, pizza, Thai beef salad, pho soup and tagine.'\n}\n}\n})\napp.mount('#app')\n</script>",
        "<template>",
        "v-if",
        "v-else-if",
        "v-else",
        "v-for",
        "v-slot"
      ]
    },
    {
      "title": "Vue Component Instance",
      "summary": "Objects\nVue has a set of objects in the component instance.\nMethods\nVue has a set of methods in the component instance that can be reached with the with the 'this' keyword.",
      "examples": []
    },
    {
      "title": "Vue $attrs Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $attrs object to direct the id fallthrough attribute to the <p> tag.\nSee more examples below.\nDefinition and Usage\nThe $attrs object represents the fallthrough attributes and the event listeners set on the component tag.\nWe use v-bind=\"$attrs\" on a root element when we want that element to inherit the fallthrough attributes and event listeners set on the component tag.\nThe $attrs object is read only.\nFallthrough Attributes are attributes (not props) set on the component tag, that falls through to the root element of the component. If there are more than one root element in the component, we use the $attrs object to specify which element that should inherit the fallthrough attributes. Learn more about fallthrough attributes in the tutorial.\nMore Examples\nExample 1\nUsing the the $attrs object to display the fallthrough attributes id and title, and their values.\nExample 2\nUsing the $attrs object on the <img> tag to receive an event listener from the parent component.\nRelated Pages\nVue Tutorial: Vue Fallthrough Attributes\nVue Tutorial: Vue Methods\nVue Tutorial: Vue v-bind Directive\nVue Tutorial: Vue v-on Directive\nVue Reference: Vue v-bind Directive\nVue Reference: Vue v-on Directive",
      "examples": [
        "<template> <h3>Tigers</h3> <img src=\"/img_tiger_small.jpg\" alt=\"tiger\"> <p v-bind=\"$attrs\">Tigers eat meat and not plants, so they are called carnivores.</p> </template>",
        "<template> <h3>Tigers</h3> <img src=\"/img_tiger_small.jpg\" alt=\"tiger\"> <p v-bind=\"$attrs\">Tigers eat meat and not plants, so they are called carnivores.</p> <hr> <p><strong>Below is the content of the $attrs object:</strong></p> <pre>{{ attrsObject }}</pre> </template> <script> export default { data() { return { attrsObject: null } }, mounted() { console.log(this.$attrs); this.attrsObject = this.$attrs; } } </script> <style> #pink { background-color: pink; border-radius: 15px; padding: 10px; } img { width: 100%; border-radius: 15px; } </style>",
        "<template> <h3>Toggle Image Size</h3> <p>Click the image to toggle the image size.</p> <img v-bind=\"$attrs\" src=\"/img_tiger_small.jpg\" class=\"imgSmall\"> </template> <style> .imgSmall { width: 60%; } .imgLarge { width: 100%; } img { border-radius: 15px; cursor: pointer; } </style>",
        "$attrs",
        "id",
        "<p>",
        "v-bind=\"$attrs\"",
        "title",
        "<img>"
      ]
    },
    {
      "title": "Vue $data Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $data object to change the color of a <div> element when it is clicked.\nSee more examples below.\nDefinition and Usage\nThe $data object represents all the properties stored in the data part of the Vue instance.\nIn the example above, the color property is referred to with this.$data.color, but we can refer to the same property by just writing this.color and that is more common.\nThe $data object is used when we need to explicitly state that we are referring to a property in the data part of the Vue instance.\nWe must use the $data object if we want to refer to a data property with a name starting with \"_\" or \"$\", because in such cases the this prefix alone will not work.\nMore Examples\nExample\nUsing the $data object to change the color of a <div> element every time it is clicked.\nRelated Pages\nVue Tutorial: Vue v-on Directive\nVue Tutorial: Vue v-bind Directive\nVue Tutorial: Vue Methods",
      "examples": [
        "export default { data() { return { color: 'lightgreen' } }, methods: { changeColor() { this.$data.color = 'pink'; } } }",
        "<div v-on:click=\"$data.color+=100\" v-bind:style=\"{backgroundColor:'hsl('+$data.color+',80%,80%)'}\" > <p>Click here</p> </div>",
        "$data",
        "<div>",
        "data",
        "color",
        "this.$data.color",
        "this.color",
        "_",
        "$",
        "this"
      ]
    },
    {
      "title": "Vue $el Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $el object to change the background color of a <div> tag on root level.\nSee more examples below.\nDefinition and Usage\nThe $el object represents the root DOM node of the Vue component.\nThe $el object does not exist until the Vue application is mounted.\nIf there is only one HTML root element in the <template>:\nthe $el object will be that root element.\nthe DOM can be manipulated directly using the $el object (see the example above), but it is not recommended.\nit is better to use the Vue ref attribute and other Vue functionality to change the DOM declaratively, because it leads to code that is more consistent and easier to maintain (see Example 1 below).\nIf there is more than one HTML root element in the <template>:\nthe $el object will just be a placeholder DOM text node that Vue uses internally (not the actual DOM element).\nthe DOM cannot be manipulated using the $el object when there are multiple root elements (see Example 2 below).\nNote: In Vue 3's Composition API, the $el property is not accessible in <script setup> (using the setup function).\nMore Examples\nExample 1\nUsing the ref attribute to change the background color of a <div> tag declaratively as recommended, instead of using the $el object.\nExample 2\nWith more than one element in the root of the <template>, the $el object will just be a text node representation (not the actual DOM element) of the first element of the root elements, used internally by Vue.\nWe cannot manipulate the DOM with the $el object is such cases.\nExample 3\nUsing the $el object to change the background color of a <h2> child element.\nRelated Pages\nVue Tutorial: Vue Template Refs\nVue Tutorial: Vue Methods\nVue Reference: Vue 'ref' Attribute\nVue Reference: Vue $refs Object",
      "examples": [
        "methods: { changeColor() { this.$el.style.backgroundColor = 'lightgreen'; } }",
        "<template> <div ref=\"rootDiv\"> <h2>Example $el Object</h2> <p>It is recommended, and more consistent, to use the ref attribute instead of the $el object to change the background color root DIV tag.</p> <button v-on:click=\"changeColor\">Click here</button> </div> </template> <script> export default { methods: { changeColor() { this.$refs.rootDiv.style.backgroundColor = 'lightgreen'; } } } </script>",
        "<template> <div> <h2>Example $el Object</h2> <p>We are not able to use the $el object to change the background color of the root DIV tag when there are other tags on the root level. Open browser console to see the error generated.</p> <button v-on:click=\"changeColor\">Click here</button> </div> <p>With this extra p-tag there are two tags on the root level.</p> </template> <script> export default { methods: { changeColor() { this.$el.style.backgroundColor = 'lightgreen'; } } } </script> <style> #app > div, #app > p { border: solid black 1px; padding: 10px; } </style>",
        "<template> <div> <h2>Example $el Object</h2> <p>Using the $el object to change the background color of the H2 child element.</p> <button v-on:click=\"changeColor\">Click here</button> </div> </template> <script> export default { methods: { changeColor() { this.$el.children[0].style.backgroundColor = 'lightblue'; } } } </script>",
        "$el",
        "<div>",
        "<template>",
        "ref",
        "<script setup>",
        "setup",
        "<h2>"
      ]
    },
    {
      "title": "Vue $parent Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $parent object in the child component, to change the 'text' data property in the parent component.\nSee more examples below.\nDefinition and Usage\nThe $parent object represents the Vue instance of the parent component.\nIf the $parent object is used in the root component, the value of the $parent object will be null.\nWe can use the $parent object to access the parent instance directly from a child component, to call methods, read or manipulate data properties, and so on.\nNote: Consider using props/emit or provide/inject for communication between Vue components instead, because code with these explicitly defined ways of communicating is easier to maintain.\nMore Examples\nExample\nUsing the $parent object in the child component, to refer to a method in the parent component.\nRelated Pages\nVue Tutorial: Vue Props\nVue Tutorial: Vue $emit() Method\nVue Tutorial: Vue Provide/Inject\nVue Reference: Vue $emit() Method\nVue Reference: Vue $root Object",
      "examples": [
        "<template> <div> <h3>Change Text</h3> <p>Click the button to toggle the text in the PRE tag of the parent component.</p> <button v-on:click=\"this.$parent.text='Hello!'\">Change text in parent</button> </div> </template>",
        "<template> <div> <h3>Toggle Color</h3> <p>Click the button to toggle the color in the P tag of the parent component.</p> <button v-on:click=\"this.$parent.toggleColor\">Toggle</button> <p>The 'toggleColor' method is also in the parent component.</p> </div> </template>",
        "$parent",
        "null"
      ]
    },
    {
      "title": "Vue $props Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $props object to display the received props.\nSee more examples below.\nDefinition and Usage\nThe $props object represents the props declared in the component, with the current values.\nProps in Vue is a way to pass values as attributes to child components. See the Vue Tutorial page for Props.\nThe $props object can be used to for example pass props further down to the next child component (see Example 1 below), or to for example set up a computed property based on a prop (Example 2 below).\nThe $props object is read only.\nMore Examples\nExample 1\nUsing the $props object to pass the props on to the next child component.\nExample 2\nUsing the $props object in a computed property to create a feedback message based on the weight of the bag.\nRelated Pages\nVue Tutorial: Vue Components\nVue Tutorial: Vue Computed Properties\nVue Tutorial: Vue Props\nVue Tutorial: Vue v-bind Directive",
      "examples": [
        "<template> <div> <h3>Received Props</h3> <p>This is the $props object:</p> <pre>{{ this.$props }}</pre> </div> </template>",
        "<template> <div> <h3>InfoBox.vue</h3> <p>This is the $props object that is received from App.vue and passed down to the next child component:</p> <pre>{{ this.$props }}</pre> <grand-child v-bind=\"$props\" /> </div> </template> <script> export default { props: [ 'bagOwner', 'bagWeight' ] } </script> <style scoped> div { border: solid black 1px; padding: 10px; margin-top: 20px; max-width: 370px; } </style>",
        "<template> <div> <h3>InfoBox.vue</h3> <p>The $props object is used in a computed value to create a message based on the weight of the bag:</p> <span>{{ this.bagWeightStatus }}</span> </div> </template> <script> export default { props: [ 'bagWeight' ], computed: { bagWeightStatus() { if(this.$props.bagWeight>10) { return 'Puh, this bag is heavy!' } else { return 'This bag is not so heavy.' } } } } </script> <style scoped> div { border: solid black 1px; padding: 10px; max-width: 350px; margin-top: 20px; } span { background-color: lightgreen; padding: 5px 10px; font-weight: bold; } </style>",
        "$props"
      ]
    },
    {
      "title": "Vue $refs Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $refs object inside a method to change the text inside a <p> tag.\nDefinition and Usage\nDOM elements marked with the built-in ref attribute are stored in the $refs object.\nElements inside the $refs object can be reached with the this keyword.\nThe $refs object is used to reach DOM elements to read or manipulate them in a similar way as querySelector() and getElementById() are used in plain JavaScript.\nMore Examples\nExample 1\nThe text from the first <p> tag is copied into the second <p> tag.\nExample 2\nA <p> element gets the same content as what's being written in the input field.\nExample 3\nThe button reveals the the third list element stored as an array element inside the $refs object.\nRelated Pages\nVue Tutorial: Vue Template Refs\nVue Reference: Vue 'ref' Attribute",
      "examples": [
        "methods: { changeVal() { this.$refs.pEl.innerHTML = \"Hello!\"; } }",
        "<template> <h1>Example</h1> <p ref=\"p1\">Click the button to copy this text into the paragraph below.</p> <button @click=\"transferText\">Transfer text</button> <p ref=\"p2\">...</p> </template> <script> export default { methods: { transferText() { this.$refs.p2.innerHTML = this.$refs.p1.innerHTML; } } }; </script>",
        "<template> <h1>Example</h1> <p>Start writing inside the input element, and the text will be copied into the last paragraph by the use of the '$refs' object.</p> <input ref=\"inputEl\" @input=\"getRefs\" placeholder=\"Write something..\"> <p ref=\"pEl\"></p> </template> <script> export default { methods: { getRefs() { this.$refs.pEl.innerHTML = this.$refs.inputEl.value; } } }; </script>",
        "<template> <h1>Example</h1> <p>Click the button to reveal the 3rd list element stored as an array element in the $refs object.</p> <button @click=\"getValue\">Get the 3rd list element</button><br> <ul> <li v-for=\"x in liTexts\" ref=\"liEl\">{{ x }}</li> </ul> <pre>{{ thirdEl }}</pre> </template> <script> export default { data() { return { thirdEl: ' ', liTexts: ['Apple','Banana','Kiwi','Tomato','Lichi'] } }, methods: { getValue() { this.thirdEl = this.$refs.liEl[2].innerHTML; console.log(\"this.$refs.liEl = \",this.$refs.liEl); } } }; </script> <style> pre { background-color: lightgreen; display: inline-block; } </style>",
        "$refs",
        "<p>",
        "ref",
        "this",
        "querySelector()",
        "getElementById()"
      ]
    },
    {
      "title": "Vue $root Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $root object in a child component, to change the 'text' data property in the root component of the Vue application.\nSee more examples below.\nDefinition and Usage\nThe $root object represents the Vue instance of the root component of the total Vue application.\nWhen the $root object is used in the root component, it simply refers to the instance of that component itself.\nWe can use the $root object to access the root instance directly from a child component, even far down the component tree structure, to call methods, read or manipulate data properties, and so on.\nNote: Consider using props/emit or provide/inject for communication between Vue components instead, because code with these explicitly defined ways of communicating is easier to maintain.\nMore Examples\nExample\nUsing the $root object in a child component, to change the color of a <p> tag in the root component, more than one level up in the component tree structure.\nRelated Pages\nVue Tutorial: Vue Props\nVue Tutorial: Vue $emit() Method\nVue Tutorial: Vue Provide/Inject\nVue Reference: Vue $emit() Method\nVue Reference: Vue $parent Object",
      "examples": [
        "<template> <div> <h3>Change Text</h3> <p>Click the button to toggle the text in the PRE tag of the root component.</p> <button v-on:click=\"this.$root.text='Hello!'\">Change text in root</button> </div> </template>",
        "<template> <div> <h4>Grand Child Component</h4> <p>Click the button to toggle the color of the P tag in the root component.</p> <button v-on:click=\"this.$root.color='lightgreen'\">Change color in root</button> </div> </template>",
        "$root",
        "<p>"
      ]
    },
    {
      "title": "Vue $slots Object",
      "summary": "ExampleGet your own Vue Server\nUsing the $slots object to check if the parent has provided content for the 'topSlot'.\nDefinition and Usage\nThe $slots object represents the slots passed from the parent.\nSlots passed from the parent can be seen by calling this.$slots, or by calling this.$slots.topSlot to see a specific slot named 'topSlot'.\nThe $slots object can be used to check if slots are provided by the parent component, like in the example above, or to write render functions.\nRelated Pages\nVue Tutorial: Vue Slots\nVue Tutorial: Scoped Slots\nVue Tutorial: Vue v-slot\nVue Reference: Vue v-slot Directive",
      "examples": [
        "mounted(){ if(this.$slots.topSlot){ this.slotsText = \"Content for the 'topSlot' slot is provided by the parent.\" } else { this.slotsText = \"Content for the 'topSlot' slot is NOT provided by the parent.\" } }",
        "$slots",
        "this.$slots",
        "this.$slots.topSlot"
      ]
    },
    {
      "title": "Vue $emit() Method",
      "summary": "ExampleGet your own Vue Server\nUsing the $emit() method to trigger a custom event to the parent component when the button is clicked.\nSee more examples below.\nDefinition and Usage\nThe built-in $emit() method triggers a custom event that is used to communicate up to the parent component.\nThe emits option can be used to document what the component emits. Using the emits option improves readability, but it is not required. (See example 3 below.)\nProps are used to communicate the opposite direction: from the parent component down to the child component. Read more about props in the tutorial.\nMore Examples\nExample 1\nUsing the $emit() method to send a message to the parent component, with the 'message-sent' custom event.\nExample 2\nUsing the $emit() method to send a product name and rating to the parent component.\nExample 3\nUsing the emits option to document what the component emits with the $emit() method. This not required, but it improves readability.\nRelated Pages\nVue Tutorial: Vue $emit() Method\nVue Tutorial: Vue Props\nVue Tutorial: Vue Events\nVue Tutorial: Vue v-on Directive\nVue Tutorial: Scoped Styling",
      "examples": [
        "<template> <div> <h3>ChildComp.vue</h3> <p>Click the button to trigger the custom event up to the parent component using the $emit() method.</p> <button v-on:click=\"this.$emit('custom-event')\">Trigger</button> </div> </template>",
        "<template> <div> <h3>ChildComp.vue</h3> <p>Write something, and send the message up to the parent component using the $emit() method.</p> <input type=\"text\" v-model=\"message\" placeholder=\"write something..\"> <button v-on:click=\"send\">Send</button> </div> </template> <script> export default { data() { return { message: null } }, methods: { send() { this.$emit('message-sent',this.message); } } } </script> <style scoped> div { border: solid black 1px; padding: 10px; max-width: 350px; margin-top: 20px; } input { display: block; margin-bottom: 15px; } </style>",
        "<template> <div> <h3>ChildComp.vue</h3> <p>Rate a product:</p> <input type=\"text\" v-model=\"productName\" placeholder=\"Product name..\" ref=\"inpName\"> <input type=\"number\" v-model=\"productRating\" placeholder=\"Rating 1 to 10..\"> <button v-on:click=\"send\">Register</button> </div> </template> <script> export default { data() { return { productName: null, productRating: null } }, methods: { send() { this.$emit('message-sent',this.productName,this.productRating); this.productName = null; this.productRating = null; this.$refs.inpName.focus(); } }, mounted() { this.$refs.inpName.focus(); } } </script> <style scoped> div { border: solid black 1px; padding: 10px; max-width: 350px; margin-top: 20px; } input { display: block; margin-bottom: 15px; } </style>",
        "<template> <div> <h3>ChildComp.vue</h3> <p>Click the button to trigger the custom event up to the parent component using the $emit() method.</p> <button v-on:click=\"this.$emit('custom-event')\">Trigger</button> </div> </template> <script> export default { emits: ['custom-event'] } </script> <style scoped> div { border: solid black 1px; padding: 10px; max-width: 350px; margin-top: 20px; } </style>",
        "$emit()",
        "emits"
      ]
    },
    {
      "title": "Vue $forceUpdate() Method",
      "summary": "Definition and Usage\nThe built-in $forceUpdate() method forces a re-render of the Vue application.\nNote: In normal cases, an element will be automatically included in Vue's reactivity system, and the Vue application will therefore re-render automatically when the element changes. But, in advanced cases when an element is marked explicitly as not part of the Vue reactivity system, the $forceUpdate() method can be used.\nRelated Pages\nVue Reference: Vue $nextTick() Method\nVue Reference: Vue $refs Object\nVue Reference: Vue 'key' Attribute",
      "examples": [
        "$forceUpdate()"
      ]
    },
    {
      "title": "Vue $nextTick() Method",
      "summary": "ExampleGet your own Vue Server\nUsing the $nextTick() method to wait for the DOM to update before we get the message inside the <p> tag.\nSee more examples below.\nDefinition and Usage\nThe $nextTick() method waits for the DOM to update before executing.\nWe use this.$nextTick() to wait for the DOM update cycle of the current Vue component to finish.\nIn addition to this.$nextTick() there is also a global nextTick() method that can be used to wait for the DOM to update even from outside the scope of a specific component.\nNote: In Vue, when a reactive variable is changed, the DOM is not updated immediately. Vue saves these changes instead, and applies them when the 'next tick' happens. This is to enhance performance and ensure consistency between the Vue instance and the DOM.\nMore Examples\nExample\nThe same result as in the first example can be achieved by calling the $nextTick() method with the await prefix in an asynchronous method. This causes the next lines of code to be put on hold until the 'next tick' happens.\nRelated Pages\nJavaScript Tutorial: JavaScript Async\nVue Tutorial: Vue Methods\nVue Tutorial: Vue Template Refs\nVue Tutorial: Vue v-on\nVue Tutorial: Vue Event Modifiers\nVue Reference: Vue 'ref' Attribute\nVue Reference: Vue $refs Object",
      "examples": [
        "methods: { updateMsg() { this.message = '\"Hello! This is a new message.\"'; this.results.push(this.$refs.pEl.textContent); this.$nextTick(() => { this.results.push(this.$refs.pEl.textContent + ' (using $nextTick())'); }); } }",
        "<template> <h2>Example $nextTick() Method</h2> <p>Using \"await $nextTick()\", the next lines of code will also wait until the 'next tick' happens. </p> <div> <p ref=\"messageEl\">{{ message }}</p> <button v-on:click.once=\"updateMsg\">Update Message</button> <ol> <li v-for=\"x in results\">{{ x }}</li> </ol> </div> </template> <script> export default { data() { return { message: \"Initial Message\", results: [] }; }, methods: { async updateMsg() { this.message = \"Hello! This message is now updated.\"; this.results.push(this.$refs.messageEl.textContent); await this.$nextTick(); this.results.push(this.$refs.messageEl.textContent + ' (after await $nextTick())'); } } }; </script> <style scoped> div { border: solid black 1px; padding: 10px; } </style>",
        "$nextTick()",
        "<p>",
        "this.$nextTick()",
        "nextTick()",
        "await"
      ]
    },
    {
      "title": "Vue $watch() Method",
      "summary": "ExampleGet your own Vue Server\nUsing the $watch() method to create a watcher that writes a new message every time the 'value' data property changes.\nSee more examples below.\nDefinition and Usage\nThe $watch() method is used to create watchers.\nThe $watch() method returns a stop function we can use to stop the watcher. (See Example 4)\nA watcher is set up to watch for changes in a value (first argument), and to do something when a change occurs (second argument). It is also possible define other properties for the watcher (third argument).\ndeep: Default value is 'false'. If the watcher is deep, it also reacts to changes further down in the property the watcher is set up to watch. (See Example 2)\nimmediate: Default value is 'false'. Triggers the watcher immediately after it is created. The old value will be 'undefined' the first time the watcher is triggered when 'immediate' is set to 'true'. (See Example 3)\nflush: Default value is 'pre'. Specify when to run the callback function relative to when the component is rendered. Possible values are 'pre', 'post' and 'sync'. Use this flush option with caution.\nonTrigger/onTrack: Used for debugging. Only works in development mode.\nNote: Watchers can also be created using the watch option.\nMore Examples\nExample 1\nUsing the $watch() method to write a new message with the old and new values every time the 'value' data property changes.\nExample 2\nUsing the $watch() method with the deep watch option set to 'true'. The watcher can now detect changes further inside the 'value' object.\nExample 3\nUsing the $watch() method with the immediate watch option set to 'true'. The watcher is now also triggered right after it is created.\nExample 4\nUsing the stop function returned by the $watch() method to stop the watcher.\nExample 5\nUsing a dot-delimited path string so that the $watch() method can listen to the 'country' property inside the 'value' object.\nExample 6\nUsing a function in the $watch() method to listen to changes in more than one value.\nRelated Pages\nVue Tutorial: Vue Watchers\nVue Tutorial: Vue Methods\nVue Tutorial: Vue v-on Directive\nVue Tutorial: Vue Template Refs\nVue Reference: Vue $refs Object\nJavaScript Tutorial: JS Arrow Function",
      "examples": [
        "mounted() { this.$watch('value', function() { this.results.push('$watch() method') }) }",
        "<template> <h2>Example $watch() Method</h2> <p>Drag the slider to change the value so that the $watch() method is triggered. The callback function writes a message with the new and old values.</p> <div> <p><input type=\"range\" min=\"0\" max=\"10\" v-model=\"value\"> Current value: {{ value }}</p> <ol> <li v-for=\"x in results\">{{ x }}</li> </ol> </div> </template> <script> export default { data() { return { value: 4, results: [] }; }, mounted() { this.$watch('value', function(newVal, oldVal) { this.results.push('Old value:'+oldVal+', new value: '+newVal) }) } }; </script> <style scoped> div { border: solid black 1px; padding: 10px; } </style>",
        "<template> <h2>Example $watch() Method</h2> <p>Register an extra hobby for Stuart. The hobbies are stored in an array inside the 'value' object. The $watch() method is triggered because the 'deep' option is set to 'true' so that the watcher also detects changes further inside the object.</p> <div> <p>Register an extra hobby for Stuart:</p> <p><input type=\"text\" ref=\"inpText\"></p> <button v-on:click=\"regHobby\">Register</button> <ol> <li v-for=\"x in watchMessages\">{{ x }}</li> </ol> </div> <p>Current 'value' object:</p> <pre>{{ this.value }}</pre> </template> <script> export default { data() { return { value: { owner: 'Stuart', address: 'Faraway Lane', hobbies: ['Bird watching', 'Trail running'] }, watchMessages: [] }; }, methods: { regHobby() { this.value.hobbies.push(this.$refs.inpText.value); this.$refs.inpText.value = null; this.$refs.inpText.focus(); } }, mounted() { this.$watch('value', function () { this.watchMessages.push('watcher triggered') }, { deep: true }); } }; </script> <style scoped> div { border: solid black 1px; padding: 10px; } li { background-color: lightgreen; }</style>",
        "<template> <h2>Example $watch() Method</h2> <p>With the 'immediate' option set to 'true' the watcher is also triggered right after it is created.</p> <div> <input type=\"range\" min=\"0\" max=\"10\" v-model=\"value\"> Current value: {{ value }} <p>Messages from the watcher:</p> <ol> <li v-for=\"x in watchMessages\">{{ x }}</li> </ol> </div> </template> <script> export default { data() { return { value: 4, watchMessages: [] }; }, mounted() { this.$watch('value', (newVal, oldVal) => { this.watchMessages.push('Old value: '+oldVal+' New value: '+newVal) }, { immediate: true }); } }; </script> <style scoped> div { border: solid black 1px; padding: 10px; } li:first-child { background-color: lightgreen; }</style>",
        "<template> <h2>Example $watch() Method</h2> <p>Drag the slider to see the watcher work, click the stop button, and drag the slider again to confirm that the watcher has now stopped.</p> <div> <p><input type=\"range\" min=\"0\" max=\"10\" v-model=\"value\"> Current value: {{ value }}</p> <button v-on:click=\"stopFunc\">Stop Watcher</button> <ol> <li v-for=\"x in results\">{{ x }}</li> </ol> </div> </template> <script> export default { data() { return { value: 4, results: [], stopFunc: null }; }, mounted() { this.stopFunc = this.$watch('value', function() { this.results.push('$watch() method') }) } }; </script> <style scoped> div { border: solid black 1px; padding: 10px; } </style>",
        "<template> <h2>Example $watch() Method</h2> <p>The watcher is set up to watch 'value.country' and will therefore detect when the country is changed inside the 'value' object.</p> <div> <p>Register a new country for Stuart to live in:</p> <p><input type=\"text\" v-model=\"inpVal\"></p> <button v-on:click=\"regHobby\">Register</button> <ol> <li v-for=\"x in watchMessages\">{{ x }}</li> </ol> </div> <p>Current 'value' object:</p> <pre>{{ this.value }}</pre> </template> <script> export default { data() { return { inpVal: null, value: { owner: 'Stuart', address: 'Faraway Lane', country: 'Mexico' }, watchMessages: [] }; }, methods: { regHobby() { this.value.country = this.inpVal; this.inpVal = null; } }, mounted() { this.$watch('value.country', function () { this.watchMessages.push('watcher triggered') }); } }; </script> <style scoped> div { border: solid black 1px; padding: 10px; } </style>",
        "<template> <h2>Example $watch() Method</h2> <p>Using a function as the first argument in the watcher to watch for changes in the sum of value A and value B.</p> <div> <p>Register a new country for Stuart to live in:</p> <p>Value A: <input type=\"range\" min=\"-10\" max=\"20\" v-model=\"inpValA\"> {{ inpValA }}</p> <p>Value B: <input type=\"range\" min=\"-10\" max=\"20\" v-model=\"inpValB\"> {{ inpValB }}</p> <ol> <li v-for=\"x in watchMessages\">{{ x }}</li> </ol> </div> </template> <script> export default { data() { return { inpValA: 2, inpValB: 4, watchMessages: [] }; }, mounted() { this.$watch( ()=> Number(this.inpValA) + Number(this.inpValB), function (newVal,oldVal) { this.watchMessages.push('watcher triggered. A + B = ' + newVal) } ); } }; </script> <style scoped> div { border: solid black 1px; padding: 10px; } li { background-color: lightgreen; } </style>",
        "$watch()",
        "watch",
        "deep",
        "immediate"
      ]
    },
    {
      "title": "Vue Directives",
      "summary": "Vue has a set of directives.",
      "examples": []
    },
    {
      "title": "Vue v-bind Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-bind directive to change the background color of a <div> element.\nSee more examples below.\nDefinition and Usage\nThe v-bind directive is used to bind an HTML attribute to a property in the Vue instance (Example above), or to pass props (Example 1 below).\nIf we change a Vue instance property, and that property is bound to an HTML attribute with v-bind, the HTML element will be updated with the new attribute value automatically thanks to Vue's reactivity system.\nThe shorthand for 'v-bind:' is simply ':', or '.' when used with the .prop modifier.\nThese modifiers can be used with the v-bind directive, but are often not needed:\nMore Examples\nExample 1\nUsing v-bind to send the 'img' prop, with data type boolean (true/false).\nExample 2\nUsing the 'v-bind:' shorthand ':'.\nExample 3\nUsing the .prop modifier to change the indeterminate DOM property of the checkbox.\nExample 4\nUsing the .prop modifier shorthand, and the v-bindshorthand, so that 'v-bind:indeterminate.prop' becomes '.indeterminate'.\nRelated Pages\nVue Tutorial: Vue CSS Binding\nVue Tutorial: Vue v-bind Directive\nVue Tutorial: Vue Props",
      "examples": [
        "<template> <h2>Example v-bind Directive</h2> <p>The v-bind directive connects the style attribute of the DIV element to the 'colorVal' data property.</p> <div v-bind:style=\"{ backgroundColor: colorVal }\">DIV element</div> <p>Use the input type=\"color\" box below to change the color.</p> <p><input type=\"color\" v-model=\"colorVal\"> <pre>colorVal: '{{ colorVal }}'</pre></p> </template>",
        "<template> <h2>Example v-bind Directive</h2> <p>Two props are sent to the component. We must use v-bind for the prop with 'boolean' data type.</p> <button v-on:click=\"this.img = !this.img\">Toggle 'img' prop value</button> {{ img }} <info-box turtle-text=\"Turtles can hold their breath for a long time.\" v-bind:turtle-img=\"img\" /> </template> <script> export default { data() { return { img: true } } } </script>",
        "<template> <h2>Example v-bind Directive</h2> <p>Two props are sent to the component. We must use v-bind for the prop with 'boolean' data type.</p> <button v-on:click=\"this.img = !this.img\">Toggle 'img' prop value</button> {{ img }} <info-box turtle-text=\"Turtles can hold their breath for a long time.\" :turtle-img=\"img\" /> </template> <script> export default { data() { return { img: true } } } </script>",
        "<template> <p>Using the '.prop' modifier to toggle the 'indeterminate' appearance of the checkbox:</p> <button v-on:click=\"indetVal = !indetVal\">Toggle</button> <p> <input type=\"checkbox\" v-bind:indeterminate.prop=\"indetVal\"> Checkbox </p> </template> <script> export default { data() { return { indetVal: false }; } }; </script> <style> input { margin: 20px; scale: 2; } </style>",
        "<template> <p>Using the '.prop' shorthand so that 'v-bind:indeterminate.prop' becomes '.indeterminate':</p> <button v-on:click=\"indetVal = !indetVal\">Toggle</button> <p> <input type=\"checkbox\" .indeterminate=\"indetVal\"> Checkbox </p> </template> <script> export default { data() { return { indetVal: false }; } }; </script> <style scoped> input { margin: 10px; scale: 2; } </style>",
        "v-bind",
        "<div>",
        "v-bind:",
        ":",
        ".",
        ".prop",
        ".camel",
        ".attr",
        "indeterminate",
        "v-bind:indeterminate.prop",
        ".indeterminate"
      ]
    },
    {
      "title": "Vue v-cloak Directive",
      "summary": "ExampleGet your own Vue Server\nUsing v-cloak to hide precompiled content.\nSee more examples below.\nDefinition and Usage\nThe v-cloak directive is used to hide content until compilation is finished.\nTypically, v-cloak prevents the user from seeing flickering of pre-compiled content including curly braces during the loading of the page.\nTo hide pre-compiled content, the element is marked with v-cloak, and CSS rules are defined to hide this content until compilation is finished.\nThe v-cloak directive only works for Vue code that compiles in the browser, so it is not useful when working with SFC (*.vue) files.\nMore Examples\nExample 1\nUsing v-cloak to display red text before the compilation is finished, so that we can see the pre-compilation phase more clearly.\nExample 2\nUsing the JavaScript setTimeout() function to delay the compilation by one second so that the effect from v-cloak becomes more clear.\nRelated Pages\nJavaScript Reference: Window setTimeout()",
      "examples": [
        "<div id=\"app\" v-cloak>\n{{ message }}\n</div>",
        "<!DOCTYPE html>\n<html>\n<head>\n<title>Vue v-cloak Directive</title>\n<style>\n[v-cloak] {\ncolor: red;\n}\n#app {\npadding: 10px;\nfont-size: x-large;\nbackground-color: lightgreen;\n}\n</style>\n</head>\n<body>\n\n<h1>Vue v-cloak Example</h1>\n\n<p>The v-cloak directive is used to make the text red until the compilation is complete. Refresh the page, or click the \"Run\" button, to see the pre-compilation phase better.</p>\n\n<div id=\"app\" v-cloak>\n{{ message }}\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nmessage: \"Hello World!\"\n}\n}\n})\napp.mount('#app')\n</script>\n</body>\n</html>",
        "<!DOCTYPE html>\n<html>\n<head>\n<title>Vue v-cloak Directive</title>\n<style>\n[v-cloak] {\nopacity: 0.5;\n}\n#app {\npadding: 10px;\nfont-size: x-large;\nbackground-color: lightgreen;\n}\n</style>\n</head>\n<body>\n\n<h1>Vue v-cloak Example</h1>\n\n<p>Using the JavaScript setTimeout function to delay the Vue compilation to make the pre-compilation phase even more clear.</p>\n\n<div id=\"app\" v-cloak>\n{{ message }}\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nsetTimeout(() => {\nconst app = Vue.createApp({\ndata() {\nreturn {\nmessage: \"Hello World!\"\n}\n}\n})\napp.mount('#app')\n}, 1000);\n</script>\n</body>\n</html>",
        "v-cloak",
        "setTimeout()"
      ]
    },
    {
      "title": "Vue v-for Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-for directive to create a list of mammals, based on an array:\nSee more examples below.\nDefinition and Usage\nThe v-for directive is used to render multiple elements based on a data source.\nThe v-for directive is used with a syntax \"(item, key, index) in dataSource\", where:\nThe \"item\" alias represents an element inside the \"dataSource\".\nThe \"key\" alias can be used to get the property names if the data source is an object.\nThe \"index\" alias can be used if the data source is an array or an object.\nThe \"dataSource\" must be the name of the actual data source you are looping through.\nYou can choose the names of the \"item\", \"key\" and \"index\" aliases yourself, but the order is \"item, key, index\".\nThese are the data sources that can be used by the v-for directive:\nNote: To optimize performance, Vue reuses elements created with v-for when the data source gets manipulated. This can lead strange results (explained here). To prevent Vue from reusing elements wrongfully when using v-for, you should always use the special key attribute with v-bind, to mark each element uniquely (see Example 6).\nMore Examples\nExample 1\nUsing the v-for directive to render a list of mammals, based on an array, and also picking the index of each element in the array:\nExample 2\nUsing the v-for directive to render a list of properties, picking out the property name and value for every property in an object:\nExample 3\nUsing the v-for directive to render a list based on a number:\nExample 4\nUsing the v-for directive to loop through a string of characters:\nExample 5\nUsing the v-for directive to loop through an object created with the Iterable Protocol:\nExample 6\nUsing the v-for directive to render one div element for every character in a string. It is always recommended tu use v-bind:key with the v-for directive:\nRelated Pages\nJavaScript Tutorial: JS Iterrables\nVue Tutorial: Vue v-for Directive\nVue Tutorial: Vue v-for Components\nVue Tutorial: Vue Animations with v-for\nVue Reference: Vue 'key' Attribute",
      "examples": [
        "<template> <h2>Example v-for Directive</h2> <p>Using the v-for directive to create a list of mammals based on an array.</p> <ul> <li v-for=\"x in animals\">{{ x }}</li> </ul> </template>",
        "<template> <h2>Example v-for Directive</h2> <p>Using the v-for directive to create a list of mammals, and the index of each mammal, based on an array.</p> <ul> <li v-for=\"(x, index) in animals\">On index {{ index }}: \"{{ x }}\"</li> </ul> </template> <script> export default { data() { return { animals: ['Tiger','Zebra','Wolf','Crocodile','Seal'] }; } }; </script>",
        "<template> <h2>Example v-for Directive</h2> <p>Using the v-for directive on an Object to create a list of the object properties and the respective property values.</p> <ul> <li v-for=\"(x, key) in animal\">(Property name: value) = ({{ key }}: {{ x }})</li> </ul> </template> <script> export default { data() { return { animal: { name: 'Lion', heightCM: 110, weightKG: 150 } }; } }; </script>",
        "<template> <h2>Example v-for Directive</h2> <p>Using the v-for directive with number to render a list with that number of elements.</p> <ul> <li v-for=\"(x, index) in 10\">Item: {{ x }}, index: {{ index }}</li> </ul> </template>",
        "<template> <h2>Example v-for Directive</h2> <p>Using the v-for directive to loop through the characters in a string.</p> <ul> <li v-for=\"(x, index) in 'Ice cream'\">Item: \"{{ x }}\", index: {{ index }}</li> </ul> </template>",
        "<template> <h2>Example v-for Directive</h2> <p>Using the v-for directive to render a list, based on an object created with the Iterable Protocol.</p> <ul> <li v-for=\"value in iterableObject\">{{ value }}</li> </ul> </template> <script> export default { data() { return { iterableObject: this.createIterable(['City', 'Park', 'River']) }; }, methods: { createIterable(array) { let currentIndex = -1; return { [Symbol.iterator]: function () { return { next: () => { if (currentIndex < array.length - 1) { currentIndex++; return { value: array[currentIndex], done: false }; } else { return { done: true }; } } }; } }; } } }; </script>",
        "<template> <h2>Example v-for Directive</h2> <p>Using the v-for directive with 'v-bind:key' to render DIV elements, based on a string of characters.</p> <div id=\"wrapper\"> <div v-for=\"x in text\" v-bind:key=\"x\">{{ x }}</div> </div> </template> <script> export default { data() { return { text: 'I love ice cream.' }; } }; </script> <style> #wrapper { display: flex; flex-wrap: wrap; width: 280px; } #wrapper > div { margin: 5px; padding: 5px 10px; border: solid black 1px; background-color: lightgreen; } </style>",
        "v-for",
        "\"(item, key, index) in dataSource\"",
        "\"item\"",
        "\"dataSource\"",
        "\"key\"",
        "\"index\"",
        "\"item, key, index\"",
        "Array",
        "Object",
        "number",
        "string",
        "Iterable",
        "key",
        "v-bind",
        "div",
        "v-bind:key"
      ]
    },
    {
      "title": "Vue v-html Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-html directive to output a list containing <ol> and <li> tags.\nSee more examples below.\nDefinition and Usage\nThe v-html directive is used to insert HTML tags and text into an element.\nIf you try to output HTML tags using text interpolation (using curly braces {{ }}), the result will be just a text string. See the example above.\nScoped styling defined in Single-File Components (SFCs) using <style scoped> will not affect HTML from the v-html directive. See the first example below.\nTo achieve scoped styling for HTML included with v-html in SFCs we can use CSS modules with <style module>. See the second example below.\nNote: Pages where users can somehow dictate the content that is included with v-html, are at risk of Cross-site scripting (XSS) attacks.\nMore Examples\nExample 1\nUsing scoped styling, the styling does not work for HTML included with v-html.\nThis problem is fixed in the next example.\nExample 2\nUsing CSS Modules with <style module>, instead of <style scoped>, the styling is scoped and the styling works for HTML included with v-html.\nThis problem in the previous example is now fixed.\nRelated Pages\nVue Tutorial: Text Interpolation",
      "examples": [
        "<template> <h1>Example</h1> <p>When using scoped styling, styling for HTML included with the 'v-html' directive does not work.</p> <p><a href=\"showvue.php?filename=demo_ref_v-html2_2\">See the next example</a> for how we can fix this by using CSS Modules.</p> <div v-html=\"htmlContent\" id=\"htmlContainer\"></div> </template> <script> export default { data() { return { htmlContent: \"<p>Hello from v-html</p>\" } } }; </script> <style scoped> #htmlContainer { border: dotted black 1px; width: 200px; padding: 10px; } #htmlContainer > p { background-color: coral; padding: 5px; font-weight: bolder; width: 150px; } </style>",
        "<template> <h1>Example</h1> <p>Scoped styling for HTML included with the 'v-html' directive now works by using CSS Modules with 'style module', instead of 'style scoped'.</p> <div v-html=\"htmlContent\" :id=\"$style.htmlContainer\"></div> </template> <script> export default { data() { return { htmlContent: \"<p>Hello from v-html</p>\" } } }; </script> <style module> #htmlContainer { border: dotted black 1px; width: 200px; padding: 10px; } #htmlContainer > p { background-color: coral; padding: 5px; font-weight: bolder; width: 150px; } </style>",
        "<div id=\"app\">\n<div>{{ htmlContent }}</div>\n<div v-html=\"htmlContent\"></div>\n</div>",
        "v-html",
        "<ol>",
        "<li>",
        "{{ }}",
        "<style scoped>",
        "<style module>"
      ]
    },
    {
      "title": "Vue v-if Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-if directive to create a <div> element if the condition is 'true'.\nSee more examples below.\nDefinition and Usage\nThe v-if directive is used to render an element conditionally.\nWhen v-if is used on an element, it must be followed by an expression:\nIf the expression evaluates to 'true', the element and all its content is created in the DOM.\nIf the expression evaluates to 'false' the element is destroyed.\nWhen an element is toggled using v-if:\nWe can use the built-in <Transition> component to animate when the element enters and leaves the DOM.\nLifecycle hooks such as 'mounted' and 'unmounted' are triggered.\nNote: It is not recommended to use v-if and v-for on the same tag. If both directives are used on the same tag, v-if will not have access to the variables used by v-for, because v-if has higher priority than v-for.\nDirectives for Conditional Rendering\nThis overview describes how the different Vue directives used for conditional rendering are used together.\nMore Examples\nExample 1\nUsing v-if with a data property as the conditional expression, together with v-else.\nExample 2\nUsing v-if with a comparison check as the conditional expression, together with v-else.\nExample 3\nUsing v-if together with v-else-if and v-else to display a status message based on the number of typewriters in storage.\nExample 4\nUsing v-if with a native JavaScript method as the conditional expression, together with v-else.\nExample 5\nUsing v-if to render a <div> tag when data is received from the API.\nExample 6\nUsing v-if to create a component so that the mounted lifecycle hook is triggered.\nCompOne.vue:\nApp.vue:\nExample 7\nUsing v-if to toggle a <p> element so that animations are triggered.\nRelated Pages\nVue Tutorial: Vue v-if Directive\nVue Reference: Vue v-else-if Directive\nVue Reference: Vue v-else Directive\nVue Tutorial: Vue Animations\nVue Tutorial: Vue Lifecycle Hooks",
      "examples": [
        "<div v-if=\"createImgDiv\"> <img src=\"/img_apple.svg\" alt=\"apple\"> <p>This is an apple.</p> </div>",
        "<template> <h1>Example</h1> <p>Click the button to fetch data with an HTTP request.</p> <p>Each click generates an object with a random user from <a href=\"https://random-data-api.com/\" target=\"_blank\">https://random-data-api.com/</a>.</p> <p>The robot avatars are lovingly delivered by <a href=\"http://Robohash.org\" target=\"_blank\">RoboHash</a>.</p> <button @click=\"fetchData\">Fetch data</button> <div v-if=\"data\" id=\"dataDiv\"> <img :src=\"data.avatar\" alt=\"avatar\"> <pre>{{ data.first_name + \" \" + data.last_name }}</pre> <p>\"{{ data.employment.title }}\"</p> </div> </template> <script> export default { data() { return { data: null, }; }, methods: { async fetchData() { const response = await fetch(\"https://random-data-api.com/api/v2/users\"); this.data = await response.json(); }, } }; </script> <style> #dataDiv { width: 240px; background-color: aquamarine; border: solid black 1px; margin-top: 10px; padding: 10px; } #dataDiv > img { width: 100%; } pre { font-size: larger; font-weight: bold; } </style>",
        "<template> <h2>Component</h2> <p>Right after this component is added to the DOM, the mounted() function is called and we can add code to that mounted() function. In this example, an alert popup box appears after this component is mounted.</p> <p><strong>Note:</strong> The reason that the alert is visible before the component is visible is because the alert is called before the browser gets to render the component to the screen.</p> </template> <script> export default { mounted() { alert(\"The component is mounted!\"); } } </script>",
        "<template> <h1>The 'mounted' Lifecycle Hook</h1> <button @click=\"this.activeComp = !this.activeComp\">Create component</button> <div> <comp-one v-if=\"activeComp\"></comp-one> </div> </template> <script> export default { data() { return { activeComp: false } } } </script> <style scoped> div { border: dashed black 1px; border-radius: 10px; padding: 20px; margin: 10px; width: 400px; background-color: lightgreen; } </style>",
        "<template> <h1>Add/Remove <p> Tag</h1> <button @click=\"this.exists = !this.exists\">{{btnText}}</button><br> <Transition> <p v-if=\"exists\">Hello World!</p> </Transition> </template> <script> export default { data() { return { exists: false } }, computed: { btnText() { if(this.exists) { return 'Remove'; } else { return 'Add'; } } } } </script> <style scoped> .v-enter-from { opacity: 0; translate: -100px 0; } .v-enter-to { opacity: 1; translate: 0 0; } .v-leave-from { opacity: 1; translate: 0 0; } .v-leave-to { opacity: 0; translate: 100px 0; } p { background-color: lightgreen; display: inline-block; padding: 10px; transition: all 0.5s; } </style>",
        "<p v-if=\"typewritersInStock\">\nin stock\n</p>\n\n<p v-else>\nnot in stock\n</p>",
        "<p v-if=\"typewriterCount > 0\">\nin stock\n</p>\n\n<p v-else>\nnot in stock\n</p>",
        "<p v-if=\"typewriterCount>3\">\nIn stock\n</p>\n\n<p v-else-if=\"typewriterCount>0\">\nVery few left!\n</p>\n\n<p v-else>\nNot in stock\n</p>",
        "<div id=\"app\">\n<p v-if=\"text.includes('pizza')\">The text includes the word 'pizza'</p>\n<p v-else>The word 'pizza' is not found in the text</p>\n</div>",
        "data() {\nreturn {\ntext: 'I like taco, pizza, Thai beef salad, pho soup and tagine.'\n}\n}",
        "v-if",
        "<div>",
        "<Transition>",
        "v-for",
        "v-else-if",
        "v-else",
        "mounted",
        "CompOne.vue",
        "App.vue",
        "<p>"
      ]
    },
    {
      "title": "Vue v-else-if Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-else-if directive to create a <div> element if the condition is 'true'.\nSee more examples below.\nDefinition and Usage\nThe v-else-if directive is used to render an element conditionally.\nThe v-else-if directive can only be used after an element with v-if, or after another element with v-else-if.\nWhen v-else-if is used on an element, it must be followed by an expression:\nIf the expression evaluates to 'true', the element and all its content is created in the DOM.\nIf the expression evaluates to 'false' the element is destroyed.\nWhen an element is toggled using v-else-if:\nWe can use the built-in <Transition> component to animate when the element enters and leaves the DOM.\nLifecycle hooks such as 'mounted' and 'unmounted' are triggered.\nDirectives for Conditional Rendering\nThis overview describes how the different Vue directives used for conditional rendering are used together.\nMore Examples\nExample 1\nUsing v-else-if to write \"Very few left!\" in case there are only 1, 2 or 3 typewriters left in storage.\nExample 2\nUsing v-else-if to show a certain text and image if the sentence contains 'burrito'.\nExample 3\nUsing a chain of v-else-if to flip through images, using the <Transition> component to create animations.\nApp.vue:\nRelated Pages\nVue Tutorial: Vue v-if Directive\nVue Reference: Vue v-if Directive\nVue Reference: Vue v-else Directive\nVue Tutorial: Vue Animations\nVue Tutorial: Vue Lifecycle Hooks",
      "examples": [
        "<div v-if=\"word === 'apple'\"> <img src=\"/img_apple.svg\" alt=\"apple\" /> <p>The value of the 'word' property is 'apple'.</p> </div> <div v-else-if=\"word === 'pizza'\"> <img src=\"/img_pizza.svg\" alt=\"pizza\" /> <p>The value of the 'word' property is 'pizza'</p> </div>",
        "<template> <h1>mode=\"out-in\"</h1> <p>Click the button to get a new image.</p> <p>With mode=\"out-in\", the next image is not added until the current image is removed. Another difference from the previous example, is that here we use computed prop instead of a method.</p> <button @click=\"indexNbr++\">Next image</button><br> <Transition mode=\"out-in\"> <img src=\"/img_pizza.svg\" v-if=\"imgActive === 'pizza'\"> <img src=\"/img_apple.svg\" v-else-if=\"imgActive === 'apple'\"> <img src=\"/img_cake.svg\" v-else-if=\"imgActive === 'cake'\"> <img src=\"/img_fish.svg\" v-else-if=\"imgActive === 'fish'\"> <img src=\"/img_rice.svg\" v-else-if=\"imgActive === 'rice'\"> </Transition> </template> <script> export default { data() { return { imgs: ['pizza', 'apple', 'cake', 'fish', 'rice'], indexNbr: 0 } }, computed: { imgActive() { if(this.indexNbr >= this.imgs.length) { this.indexNbr = 0; } return this.imgs[this.indexNbr]; } } } </script> <style scoped> .v-enter-active { animation: swirlAdded 0.7s; } .v-leave-active { animation: swirlAdded 0.7s reverse; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } img { width: 100px; margin: 20px; } img:hover { cursor: pointer; } </style>",
        "<p v-if=\"typewriterCount>3\">\nIn stock\n</p>\n\n<p v-else-if=\"typewriterCount>0\">\nVery few left!\n</p>\n\n<p v-else>\nNot in stock\n</p>",
        "<div id=\"app\">\n<div v-if=\"text.includes('pizza')\">\n<p>The text includes the word 'pizza'</p>\n<img src=\"img_pizza.svg\">\n</div>\n<div v-else-if=\"text.includes('burrito')\">\n<p>The text includes the word 'burrito', but not 'pizza'</p>\n<img src=\"img_burrito.svg\">\n</div>\n<p v-else>The words 'pizza' or 'burrito' are not found in the text</p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntext: 'I like taco, pizza, Thai beef salad, pho soup and tagine.'\n}\n}\n})\napp.mount('#app')\n</script>",
        "v-else-if",
        "<div>",
        "v-if",
        "<Transition>",
        "v-else",
        "App.vue"
      ]
    },
    {
      "title": "Vue v-else Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-else directive to create a <div> element when all conditions above are 'false'.\nSee more examples below.\nDefinition and Usage\nThe v-else directive is used to render an element in case all conditions above in the if statement evaluates to 'false'.\nThe v-else directive can only be used after an element with v-if or v-else-if.\nThe v-else directive is used without an expression.\nWhen v-else causes an element to toggle:\nWe can use the built-in <Transition> component to animate when the element enters and leaves the DOM.\nLifecycle hooks such as 'mounted' and 'unmounted' are triggered.\nDirectives for Conditional Rendering\nThis overview describes how the different Vue directives used for conditional rendering are used together.\nMore Examples\nExample 1\nUsing v-else to write \"Not in stock\" when the typewriter count is 0.\nExample 2\nUsing v-else to show a certain text when the sentence does not contain 'pizza' or 'burrito'.\nRelated Pages\nVue Tutorial: Vue v-if Directive\nVue Reference: Vue v-if Directive\nVue Reference: Vue v-else-if Directive\nVue Tutorial: Vue Animations\nVue Tutorial: Vue Lifecycle Hooks",
      "examples": [
        "<p v-if=\"word === 'apple'\">The word is 'apple'.</p> <p v-else-if=\"word === 'pizza'\">The word is 'pizza'</p> <div v-else> <img src=\"/img_question.svg\" alt=\"question mark\"> <p>The word is not 'apple', and it is not 'pizza'</p> </div>",
        "<p v-if=\"typewriterCount>3\">\nIn stock\n</p>\n\n<p v-else-if=\"typewriterCount>0\">\nVery few left!\n</p>\n\n<p v-else>\nNot in stock\n</p>",
        "<div id=\"app\">\n<div v-if=\"text.includes('pizza')\">\n<p>The text includes the word 'pizza'</p>\n<img src=\"img_pizza.svg\">\n</div>\n<div v-else-if=\"text.includes('burrito')\">\n<p>The text includes the word 'burrito', but not 'pizza'</p>\n<img src=\"img_burrito.svg\">\n</div>\n<p v-else>The words 'pizza' or 'burrito' are not found in the text</p>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\ntext: 'I like Thai beef salad, pho soup and tagine.'\n}\n}\n})\napp.mount('#app')\n</script>",
        "v-else",
        "<div>",
        "v-if",
        "v-else-if",
        "<Transition>"
      ]
    },
    {
      "title": "Vue v-memo Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-memo directive to rerender only when the updateProp property value changes.\nDefinition and Usage\nThe v-memo directive is used to optimize performance in Vue.\nTo optimize performance, v-memo is used together with an array of properties, and v-memo will hold back rerendering of an element, and any sub child elements, until one of these properties have changed.\nIt only makes sense to optimize performance with v-memo in rare cases when for example working with large lists created with v-for.\nIf the array provided with v-memo is empty, like tis: v-memo=\"[]\", you get the same functionality as with v-once.\nRelated Pages\nVue Tutorial: Vue v-for Directive\nVue Tutorial: Vue v-bind Directive\nVue Tutorial: Vue CSS Binding\nVue Reference: Vue v-for Directive\nVue Reference: Vue v-once Directive\nJavaScript Reference: Window setTimeout()",
      "examples": [
        "<div v-for=\"x in circle\" :style=\"{ backgroundColor: x.color }\" v-memo=\"[updateProp]\" ></div>",
        "v-memo",
        "updateProp",
        "v-for",
        "v-memo=\"[]\"",
        "v-once"
      ]
    },
    {
      "title": "Vue v-model Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-model directive to create a two-way binding between an <input> element and a data property.\nSee more examples below.\nDefinition and Usage\nThe v-model directive is used to create a two-way binding between a form input element, or between a Vue instance property and a component.\nForm Input Elements with v-model\nForm input elements that can be used with v-model are <input>, <select> and <textarea>.\nTwo-way binding with v-model on form input elements works like this:\nWhen Vue detects a change in the input value, it will update the corresponding data property accordingly. (HTML -> JavaScript)\nWhen Vue detects a change in a Vue instance property, it will update the corresponding input value accordingly. (JavaScript -> HTML)\n(See Example above, and Example 1 below.)\nComponents with v-model\nWhen v-model is used on a component, the component interface must be set up properly with props and emits to achieve the two-way binding.\nTwo-way binding with v-model on components works like this:\nWhen Vue detects a change in the parent instance property, the new value is sent as a prop to the component.\nWhen Vue detects a change in the child component, the new value is sent up to the parent as an emit event.\nWhen v-model is used on a component, the default prop name is 'modelValue', and the default emit event name is 'update:modelValue'. (See Example 2 and Example 3.)\nWhen v-model is used on a component, instead of using a Vue instance data property we can use a computed property with the get() and set() methods. (See Example 4)\nDifferent names for props and emits than the default 'modelValue' and 'update:modelValue' can be set using v-model:. (See Example 5)\nTo have more than one value connected as two-way bindings to a component, we must define each such value with its own v-model. (See Example 6)\nModifiers\nMore Examples\nExample 1\nUsing a slider (<input type=\"range\">) to change the 'inputValue' property value. The <input type=\"text\"> element automatically updates because it is bound to the 'inputValue' property with v-model.\nExample 2\nUsing v-model on the component with props and emits so that changes in the <input> element updates the parent's 'text' property.\nApp.vue:\nCompOne.vue:\nExample 3\nUsing v-model on the component to demonstrate the two-way binding more clearly. The component can update the parent 'text' property, and the component gets updated when the parent 'text' property is changed.\nApp.vue:\nCompOne.vue:\nExample 4\nUsing v-model with a computed value with get() and set() functions inside the component.\nCompOne.vue:\nExample 5\nUsing v-model:message on the component to rename the default prop name 'modelValue' to 'message'.\nApp.vue:\nCompOne.vue:\nExample 6\nUsing v-model two times on the component to create a two-way binding with two values.\nApp.vue:\nCompOne.vue:\nExample 7\nUsing the .lazy so that the user must first modify the input element, then change focus away from the input element before the property gets updated with v-model.\nExample 8\nUsing the .lazy so that the user must first modify the input element, then change focus away from the input element before the property gets updated with v-model.\nExample 9\nUsing the custom .allCapital modifier to convert all characters in the input to upper case if the .allCapital modifier is set.\nApp.vue:\nCompOne.vue:\nRelated Pages\nVue Tutorial: Vue Components\nVue Tutorial: Vue Props\nVue Tutorial: Vue $emit() Method\nVue Tutorial: Vue Computed Properties\nVue Reference: Vue $emit() Method\nVue Reference: Vue $props Object\nJavaScript Tutorial: JavaScript Object Accessors",
      "examples": [
        "<template> <h1>v-model Example</h1> <p>Write something, and see the 'inputValue' data property update automatically.</p> <input type=\"text\" v-model=\"inputValue\"> <p>inputValue property: \"{{ inputValue }}\"</p> </template>",
        "<template> <h1>v-model Example</h1> <p>Drag the slider to change the 'inputValue' data property, and see the input text field update automatically because of the two-way binding from v-model.</p> <input type=\"range\" min=\"-50\" max=\"50\" v-on:input=\"sliderChange\" value=\"4\"> <p>inputValue property: \"{{ inputValue }}\"</p> <input type=\"text\" v-model=\"inputValue\"> </template> <script> export default { data() { return { inputValue: null }; }, methods: { sliderChange(evt) { this.inputValue = evt.target.value } } } </script>",
        "<template> <h2>Example v-model Directive</h2> <p>App.vue 'text' property: \"{{ text }}\"</p> <comp-one v-model=\"text\"/> </template> <script> export default { data() { return { text: 'Say Cheese' } } } </script>",
        "<template> <div> <h3>Component</h3> <p>Write something in the text input field below to see that changes here are emitted from the component, and the parent 'text' property gets updated by the use of v-model.</p> <input :value=\"modelValue\" @input=\"$emit('update:modelValue', $event.target.value)\" /> </div> </template> <script> export default { props: ['modelValue'], emits: ['update:modelValue'] } </script> <style scoped> div { border: solid black 1px; padding: 10px; margin: 20px 0; max-width: 500px; } </style>",
        "<template> <h2>Example v-model Directive</h2> <p>App.vue 'text' property: \"<pre>{{ text }}</pre>\"</p> <button v-on:click=\"this.text = 'Hello!'\">text='Hello!'</button> <comp-one v-model=\"text\"/> </template> <script> export default { data() { return { text: 'Say Cheese' } } } </script> <style> pre { display: inline; background-color: yellow; } </style>",
        "<template> <div> <h3>Component</h3> <p>Two-way binding on component with v-model:</p> <ol> <li>The component can update the 'text' property (using text field).</li> <li>The component gets updated when the 'text' property is changed (using button).</li> </ol> <input :value=\"modelValue\" @input=\"$emit('update:modelValue', $event.target.value)\" /> </div> </template> <script> export default { props: ['modelValue'], emits: ['update:modelValue'] } </script> <style scoped> div { border: solid black 1px; padding: 10px; margin: 20px 0; max-width: 600px; } </style>",
        "<template> <div> <h3>Component</h3> <p>Two-way binding on component with v-model:</p> <ol> <li>The component can update the 'text' property (using text field).</li> <li>The component gets updated when the 'text' property is changed (using button).</li> </ol> <input v-model=\"inpVal\"/> </div> </template> <script> export default { props: ['modelValue'], emits: ['update:modelValue'], computed: { inpVal: { get() { return this.modelValue; }, set(inpVal) { this.$emit('update:modelValue',inpVal) } } } } </script> <style scoped> div { border: solid black 1px; padding: 10px; margin: 20px 0; max-width: 600px; } </style>",
        "<template> <h2>Example v-model Directive</h2> <p>App.vue 'text' property: \"<pre>{{ text }}</pre>\"</p> <button v-on:click=\"this.text = 'Hello!'\">text='Hello!'</button> <comp-one v-model:message=\"text\"/> </template> <script> export default { data() { return { text: 'Say Cheese' } } } </script> <style> pre { display: inline; background-color: yellow; } </style>",
        "<template> <div> <h3>Component</h3> <p>Two-way binding on component with v-model:</p> <ol> <li>The component can update the 'text' property (using text field).</li> <li>The component gets updated when the 'text' property is changed (using button).</li> </ol> <input :value=\"message\" @input=\"$emit('update:message', $event.target.value)\" /> </div> </template> <script> export default { props: ['message'], emits: ['update:message'] } </script> <style scoped> div { border: solid black 1px; padding: 10px; margin: 20px 0; max-width: 600px; } </style>",
        "<template> <h2>Example v-model Directive</h2> <p>Name: \"<pre>{{ name }}</pre>\"</p> <p>Height: <pre>{{ height }}</pre> cm</p> <comp-one v-model:name=\"name\" v-model:height=\"height\" /> </template> <script> export default { data() { return { name: 'Olaf', height: 120 } } } </script> <style> pre { display: inline; background-color: yellow; } </style>",
        "<template> <div> <h3>Component</h3> <p>Two inputs are bound to the component with v-model through props and emits.</p> <p> <label> Name: <input type=\"text\" :value=\"name\" @input=\"$emit('update:name', $event.target.value)\" /> </label> </p> <p> <label> Height: <input type=\"range\" :value=\"height\" @input=\"$emit('update:height', $event.target.value)\" min=\"50\" max=\"200\" /> {{ this.$props.height }} cm </label> </p> </div> </template> <script> export default { props: ['name','height'], emits: ['update:name','update:height'] } </script> <style scoped> div { border: solid black 1px; padding: 10px; margin: 20px 0; max-width: 300px; } </style>",
        "<template> <h1>v-model Example</h1> <p>Using the '.lazy' modifier, you must first write something, then click somewhere else, or use the tab key to switch focus away from the input element, before the property get updated.</p> <input type=\"text\" v-model.lazy=\"inputValue\"> <p>inputValue property: \"{{ inputValue }}\"</p> </template> <script> export default { data() { return { inputValue: null }; } } </script>",
        "<template> <h1>v-model Example</h1> <p>Using the '.trim' modifier will remove any white spaces at the start and end of the input.</p> <p>Add white spaces at the start and end in the input fields below to see the difference with or with out '.trim'.</p> <p>No '.trim': <input type=\"text\" v-model=\"inputVal1\"> \"<pre>{{ inputVal1 }}</pre>\"</p> <p>With '.trim': <input type=\"text\" v-model.trim=\"inputVal2\"> \"<pre>{{ inputVal2 }}</pre>\"</p> </template> <script> export default { data() { return { inputVal1: 'Hello', inputVal2: 'Hi' }; } } </script> <style> pre { display: inline; background-color: lightgreen; } </style>",
        "<template> <h2>Example v-model Directive</h2> <p>App.vue 'text' property: \"{{ text }}\"</p> <comp-one v-model.allCapital=\"text\"/> </template> <script> export default { data() { return { text: '' } } } </script>",
        "<template> <div> <h3>Component</h3> <p>Write something in the text input field below. Click somewhere else or use the tab key to shift focus away from the input element to see the effect of the custom 'allCapital' modifier.</p> <input :value=\"modelValue\" @change=\"this.emitVal\" /> </div> </template> <script> export default { props: { modelValue: String, modelModifiers: { // modelModifiers is an empty object initially. // Modifiers set on the component will be stored here. default: () => ({}) } }, emits: ['update:modelValue'], methods: { emitVal(e) { let value = e.target.value if (this.modelModifiers.allCapital) { value = value.toUpperCase() } this.$emit('update:modelValue', value) } } } </script> <style scoped> div { border: solid black 1px; padding: 10px; margin: 20px 0; max-width: 500px; } </style>",
        "v-model",
        "<input>",
        "<select>",
        "<textarea>",
        "props",
        "emits",
        "get()",
        "set()",
        "v-model:",
        ".lazy",
        "change",
        "input",
        ".number",
        "<input type=\"number\">",
        ".trim",
        "<input type=\"range\">",
        "<input type=\"text\">",
        "App.vue",
        "CompOne.vue",
        "v-model:message",
        ".allCapital"
      ]
    },
    {
      "title": "Vue v-on Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-on directive to change the background color of a <div> element when when a button is clicked.\nSee more examples below.\nDefinition and Usage\nThe v-on directive is placed on an element to attach an event listener.\nTo attach an event listener with v-on we need to provide the event type, and any modifier, and a method or expression that should run when that event occurs.\nIf v-on is placed on a regular HTML tag, the event types we can define to listen to are the regular events like input, click or mouseover.\nIf v-on is placed on a custom component, the event types we can define to listen to are the custom events that are emitted from that component.\nThe shorthand for v-on: is @.\nModifiers\nMore Examples\nExample 1\nUsing the .capture modifier to capture the click event in the parent element first.\nExample 2\nUsing the .stop modifier to prevent the event from propagating any further.\nExample 3\nUsing the .passive modifier to enhance performance during scrolling.\nExample 4\nUsing the .once modifier to enhance performance during scrolling.\nExample 5\nUsing the .self modifier so that the parent element only reacts to click events that happen to itself.\nExample 6\nUsing the .prevent modifier to prevent the default drop down list from appearing when right mouse button click.\nExample 7\nUsing the .left.shift modifiers to change image when the user does a left mouse button click while holding down the shift key.\nRelated Pages\nVue Tutorial: Vue Events\nVue Tutorial: Vue v-on Directive\nVue Tutorial: Vue Methods\nVue Tutorial: Vue Event Modifiers\nJavaScript Tutorial: JavaScript Events\nREMOVE ADS",
      "examples": [
        "<template> <h1>v-on Example</h1> <div v-bind:class=\"{ yelClass: bgColor }\"> <p>Click the button to change background color of this DIV box.</p> <button v-on:click=\"bgColor = !bgColor\">Click</button> <p>bgColor property: \"{{ bgColor }}\"</p> </div> </template>",
        "<template> <h1>v-on Example</h1> <p>When the '.capture' modifier is used on the parent DIV element, the event is captured first in the parent element when the child element is clicked.</p> <p>If the '.capture' modifier is removed from this code, the child element will capture the click event first. This is the default behavior, that the event bubbles up, first in child element, then to the parent.</p> <div v-on:click.capture=\"this.msg.push('parent')\" id=\"parent\"> <p>This is the parent element.</p> <div v-on:click=\"this.msg.push('child')\"> <p>This is the child element. CLICK HERE!</p> </div> </div> <p>The order of when and where the event is captured.</p> <ol> <li v-for=\"x in msg\">{{ x }}</li> </ol> </template> <script> export default { data() { return { msg: [] }; } } </script> <style scoped> div { margin: 10px; padding: 10px; border: dashed black 1px; } #parent { width: 250px; background-color: lightpink; } #parent > div { cursor: pointer; background-color: lightgreen; } </style>",
        "<template> <h1>v-on Example</h1> <p>The '.stop' modifier stops the click event from propagating any further.</p> <p>If the '.stop' modifier is removed from this code, the parent element will also capture the click event on the child element.</p> <div v-on:click=\"this.msg.push('parent')\" id=\"parent\"> <p>This is the parent element.</p> <div v-on:click.stop=\"this.msg.push('child')\"> <p>This is the child element. CLICK HERE!</p> </div> </div> <p>The order of when and where the event is captured.</p> <ol> <li v-for=\"x in msg\">{{ x }}</li> </ol> </template> <script> export default { data() { return { msg: [] }; } } </script> <style scoped> div { margin: 10px; padding: 10px; border: dashed black 1px; } #parent { width: 250px; background-color: lightpink; } #parent > div { cursor: pointer; background-color: lightgreen; } </style>",
        "<template> <h1>v-on Example</h1> <p>The '.passive' modifier sets the event handler as passive, and this can enhance performance.</p> <div v-on:scroll.passive=\"this.scrollTimes++\" id=\"parent\"> <p>Scroll here.</p> <p>Bladi-bladi-bladi</p> <p>potato potato</p> <p>Scroll-scroll-scroll</p> <p>Scroll more...</p> </div> <p>Scroll happended {{ scrollTimes }} times.</p> </template> <script> export default { data() { return { scrollTimes: 0 }; } } </script> <style scoped> div { margin: 10px; padding: 10px; border: dashed black 1px; width: 200px; height: 50px; overflow: scroll; background-color: lightcoral; } </style>",
        "<template> <h1>v-on Example</h1> <p>The '.once' modifier prevents the event from happening more than once.</p> <button v-on:click.once=\"clickTimes++\">Click</button> <p>Click event happened {{ clickTimes }} times.</p> </template> <script> export default { data() { return { clickTimes: 0 }; } } </script>",
        "<template> <h1>v-on Example</h1> <p>The '.self' modifier is set on the parent element. </p> <p>Click on the child element and see how the event propagates past the parent element because the parent click event only reacts to click on the element itself.</p> <div v-on:click=\"addMsg('grandParent')\" id=\"grandParent\"> Grandparent element <div v-on:click.self=\"addMsg('parent')\"> Parent element. <div v-on:click=\"addMsg('child')\"> Child element. CLICK HERE! </div> </div> </div> <p>The order of when and where the event is captured.</p> <ol> <li v-for=\"x in msg\">{{ x }}</li> </ol> </template> <script> export default { data() { return { msg: [] }; }, methods: { addMsg(txt) { this.msg.push(txt); } } } </script> <style scoped> div { margin: 10px; padding: 10px; border: dashed black 1px; cursor: pointer; } #grandParent { width: 250px; background-color: lightpink; } #grandParent > div { background-color: lightgreen; } #grandParent > div > div { background-color: lightskyblue; } </style>",
        "<template> <h1>v-on Example</h1> <p>The '.prevent' modifier is set to prevent the drop down menu to appear when the user does a right mouse button click.</p> <div v-on:click.right.prevent=\"changeColor\" v-bind:style=\"{ backgroundColor: 'hsl(' + bgColor + ',80%,80%)' }\"> <p>Press right mouse button here.</p> </div> </template> <script> export default { data() { return { bgColor: 0 } }, methods: { changeColor() { this.bgColor += 50 } } } </script> <style scoped> div { margin: 10px; padding: 10px; border: dashed black 1px; width: 200px; } </style>",
        "<template> <h1>v-on Example</h1> <p>Hold 'Shift' key and press left mouse button on the image:</p> <img v-on:click.left.shift=\"changeImg\" v-bind:src=\"imgUrl\"> </template> <script> export default { data() { return { imgFish: true, imgUrl: 'img_fish.svg' } }, methods: { changeImg() { this.imgFish = !this.imgFish; if (this.imgFish) { this.imgUrl = 'img_fish.svg' } else { this.imgUrl = 'img_tiger.svg' } } } } </script> <style scoped> img { width: 200px; } </style>",
        "v-on",
        "<div>",
        "input",
        "click",
        "mouseover",
        "v-on:",
        "@",
        ".capture",
        ".once",
        ".passive",
        "passive: true",
        "event.preventDefault()",
        ".prevent",
        ".stop",
        "event.stopPropagation()",
        ".self",
        ".{keyAlias}",
        "v-on:click.right",
        "v-on:keyup.s",
        "v-on:click.left.shift",
        ".left",
        ".right",
        ".middle",
        ".left.shift"
      ]
    },
    {
      "title": "Vue v-once Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-once directive to render an <img> element only once.\nDefinition and Usage\nThe v-once directive is used to only render an element once.\nBy only rendering an element once, the performance can be enhanced.\nWhen an element has the v-once directive, all its child elements also becomes static after the first render.\nHow often an element gets rendered can also be limited by the v-memo directive to gain performance.\nRelated Pages\nVue Reference: Vue v-memo Directive\nVue Tutorial: Vue v-bind Directive\nVue Tutorial: Vue v-on Directive\nVue Tutorial: Vue Methods\nVue Tutorial: Vue Lifecycle Hooks",
      "examples": [
        "<template> <h1>v-once Example</h1> <p>The image is only rendered once. Changing the image source does not have any effect.</p> <img v-once v-bind:src=\"imgUrl[imgIndex]\"> <p>Img src: '{{ imgUrl[imgIndex] }}'</p> <button v-on:click=\"changeImg\">Change image</button> </template>",
        "v-once",
        "<img>",
        "v-memo"
      ]
    },
    {
      "title": "Vue v-pre Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-pre directive to prevent compilation of a <p> element.\nDefinition and Usage\nThe v-pre directive skips compilation for this element, and all of its child elements.\nThe v-pre directive can be used to display raw Vue code, like curly braces {{ }}.\nRelated Pages\nVue Tutorial: Vue v-bind Directive\nVue Tutorial: Vue v-on Directive\nVue Tutorial: Vue Methods\nHTML Reference: HTML <pre> Tag",
      "examples": [
        "<img v-bind:src=\"imgUrl[imgIndex]\"> <p v-pre>Img src: '{{ imgUrl[imgIndex] }}' <strong>(Not compiled)</strong></p> <p>Img src: '{{ imgUrl[imgIndex] }}' <strong>(Compiled version)</strong></p> <button v-on:click=\"changeImg\">Change image</button>",
        "v-pre",
        "<p>",
        "{{ }}"
      ]
    },
    {
      "title": "Vue v-show Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-show directive to conditionally toggle the visibility of a <div> element, depending on the value of 'showDiv'.\nSee more examples below.\nDefinition and Usage\nThe v-show directive is used to conditionally toggle the visibility of an element.\nWhen the expression used by v-show evaluates to 'false', the CSS display property is set to 'none', and otherwise the CSS display property falls back to the default value.\nAn element with v-show is mounted once and remain in the DOM, only its visibility is toggled with v-show.\nv-show triggers transition classes and events when used with the built-in <Transition> component.\nLifecycle hooks like mounted/unmounted, or activated/deactivated are not triggered when the visibility of an object is toggled with v-show.\nv-show vs. v-if\nThe v-show and v-if directives are apparently quite similar, because they can both toggle an element so that it is displayed or not, but here are some differences:\nMore Examples\nExample\nThe v-show and v-if directives are used side-by-side to conditionally toggle the visibility of a <div> element.\nOpen the example, set the condition to 'false', then right-click and inspect the page to see that the element with v-show still exists in the DOM.\nExample\nA <p> element becomes visible with v-show and triggers the after-enter event.\nRelated Pages\nVue Tutorial: Vue v-show Directive\nVue Tutorial: Vue v-if Directive\nVue Tutorial: Vue Animations\nVue Reference: Vue <Transition> Component\nVue Reference: Vue v-if Directive",
      "examples": [
        "<template> <h1>JavaScript Transition Hooks</h1> <p>This code hooks into \"after-enter\" so that after the initial animation is done, a method runs that displays a red div.</p> <button @click=\"pVisible=true\">Create p-tag!</button><br> <Transition @after-enter=\"onAfterEnter\"> <p v-show=\"pVisible\" id=\"p1\">Hello World!</p> </Transition> <br> <div v-show=\"divVisible\">This appears after the \"enter-active\" phase of the transition.</div> </template> <script> export default { data() { return { pVisible: false, divVisible: false } }, methods: { onAfterEnter() { this.divVisible = true; } } } </script> <style scoped> .v-enter-active { animation: swirlAdded 1s; } @keyframes swirlAdded { from { opacity: 0; rotate: 0; scale: 0.1; } to { opacity: 1; rotate: 360deg; scale: 1; } } #p1, div { display: inline-block; padding: 10px; border: dashed black 1px; } #p1 { background-color: lightgreen; } div { background-color: lightcoral; } </style>",
        "<div v-show=\"showDiv\">This div tag can be hidden</div>",
        "<div id=\"app\">\n<div v-show=\"showDiv\">Div tag with v-show</div>\n<div v-if=\"showDiv\">Div tag with v-if</div>\n</div>\n\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\nconst app = Vue.createApp({\ndata() {\nreturn {\nshowDiv: true\n}\n}\n})\napp.mount('#app')\n</script>",
        "v-show",
        "<div>",
        "display",
        "<Transition>",
        "mounted",
        "unmounted",
        "activated",
        "deactivated",
        "v-if",
        "<template>",
        "v-else-if",
        "v-else",
        "<p>",
        "after-enter"
      ]
    },
    {
      "title": "Vue v-slot Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-slot directive to direct the 'Hello!' message to the named slot 'bottomSlot', inside the <slot-comp> component.\nSee more examples below.\nDefinition and Usage\nThe v-slot directive is used to direct content to a named slot.\nThe shorthand for v-slot: is #.\nThe v-slot directive can also be used to receive data from scoped slots, provided by using v-bind in the child component.\nv-slot can be used on components, or on the built-in <template> element.\nv-slot is used on <template> elements when we want to assign content to more than one slot in a component.\nMore examples\nExample 1\nUsing v-slot on <template> elements to assign content to two different slots in the same component.\nApp.vue:\nSlotComp.vue:\nExample 2\nUsing v-slot to direct content to the default slot.\nSlotComp.vue:\nApp.vue:\nExample 3\nUsing the v-slot: shorthand #.\nApp.vue:\nSlotComp.vue:\nExample 4\nUsing v-slot to receive data from a scoped slot.\nApp.vue:\nRelated Pages\nVue Tutorial: Vue Slots\nVue Tutorial: Scoped Slots\nVue Tutorial: Vue Components\nVue Tutorial: Vue v-slot\nVue Reference: Vue <slot> Element\nVue Reference: Vue $slots Object",
      "examples": [
        "<slot-comp v-slot:bottomSlot>'Hello!'</slot-comp>",
        "<template> <h1>App.vue</h1> <p>The component has two slots, and the template element is used to assign content to both.</p> <slot-comp> <template v-slot:topSlot> <div> <p>Tigers are beautiful!</p> <img src=\"tiger.svg\" alt=\"tiger\" width=\"100\"> </div> </template> <template v-slot:bottomSlot> <div> <p>Whales can be very big</p> </div> </template> </slot-comp> </template>",
        "<template> <hr> <h3>Component</h3> <slot name=\"topSlot\"></slot> <slot name=\"bottomSlot\"></slot> </template>",
        "<h3>Component</h3> <div> <slot></slot> </div> <div> <slot name=\"bottomSlot\"></slot> </div>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp v-slot:default>'Default slot'</slot-comp>",
        "<h1>App.vue</h1> <p>The component has two div tags with one slot in each.</p> <slot-comp #topSlot>'Hello!'</slot-comp>",
        "<h3>Component</h3> <div> <slot name=\"topSlot\"></slot> </div> <div> <slot name=\"bottomSlot\"></slot> </div>",
        "<slot-comp v-slot:\"dataFromSlot\"> <h2>{{ dataFromSlot.lclData }}</h2> </slot-comp>",
        "v-slot",
        "v-slot:",
        "#",
        "v-bind",
        "<template>",
        "App.vue",
        "SlotComp.vue"
      ]
    },
    {
      "title": "Vue v-text Directive",
      "summary": "ExampleGet your own Vue Server\nUsing the v-text directive to overwrite the existing text inside a paragraph.\nDefinition and Usage\nThe v-text directive is used to update the text in an element.\nWhen updating text in an element with the v-text directive, any existing text and child elements will be replaced by the new text.\nNote: If you want to update just a part of a text inside a tag, consider using text interpolation {{ }} instead.\nRelated Pages\nVue Tutorial: Text Interpolation",
      "examples": [
        "<div id=\"app\">\n<p v-text=\"pText\">Old text.</p>\n</div>",
        "v-text",
        "{{ }}"
      ]
    },
    {
      "title": "Vue Instance Options",
      "summary": "Options in Vue are the different options available to us on the Vue instance when using the Options API.",
      "examples": []
    },
    {
      "title": "Vue 'data' Option",
      "summary": "ExampleGet your own Vue Server\nUsing a data property inside the data option to hold a message.\nDefinition and Usage\nThe data option is a function that returns an object with all the data properties inside.\nThe object returned by the data function can be accessed with this.$data, and a specific data property 'count' can be accessed with this.$data.count, or simply this.count.\nData properties with a name that starts with $ or _ must be accessed through the this.$data object, they cannot be accessed otherwise.\nIt is possible to add new data properties after the application has started running, by using this.$data, but it is not recommended.\nRelated Pages\nVue Tutorial: Vue Introduction\nVue Reference: Vue $data Object",
      "examples": [
        "export default { data() { return { msg: 'Hello World!' }; } };",
        "data",
        "this.$data",
        "this.$data.count",
        "this.count",
        "$",
        "_"
      ]
    },
    {
      "title": "Vue 'methods' Option",
      "summary": "ExampleGet your own Vue Server\nUsing a method inside the methods option to toggle a message.\nDefinition and Usage\nThe methods option is an object with all the methods that are declared on the Vue instance.\nMethods can be called directly (without the this keyword) from the <template> of a Vue application, like for example when a method is set to run when an event happens, using the v-on directive.\nThe this keyword must be used to call a method from within the Vue instance, like when a method is called by another method for example.\nNote: Arrow functions should be avoided when declaring methods because the Vue instance cannot be reached from inside such a function using the this keyword.\nRelated Pages\nVue Tutorial: Vue Methods\nVue Tutorial: Vue v-on Directive",
      "examples": [
        "export default { data() { return { msg: 'Hello World!', showMsg: false }; }, methods: { toggleMsg() { this.showMsg = !this.showMsg; } } };",
        "methods",
        "this",
        "<template>",
        "v-on"
      ]
    },
    {
      "title": "Vue 'computed' Option",
      "summary": "ExampleGet your own Vue Server\nUsing a computed property inside the computed option to show the appropriate button text.\nDefinition and Usage\nThe computed option is an object with all the computed properties that are declared on the Vue instance.\nComputed properties are usually read-only (see the example above), but it is possible to define a computed property as an object with both a get and a set function, which means that the computed property can also be written to.\nNote: Arrow functions should be avoided when declaring computed properties because the Vue instance cannot be reached from inside such a function using the this keyword.\nRelated Pages\nVue Tutorial: Vue Computed Properties\nVue Tutorial: Vue v-on Directive",
      "examples": [
        "export default { data() { return { msg: 'Hello World!', showMsg: false }; }, computed: { btnText() { if( this.showMsg ) { return 'Hide' } else { return 'Show' } } } };",
        "computed",
        "get",
        "set",
        "this"
      ]
    },
    {
      "title": "Vue 'watch' Option",
      "summary": "ExampleGet your own Vue Server\nUsing a watcher inside the watch option to make it impossible to choose values between 20 and 70 with an <input type=\"range\">.\nDefinition and Usage\nThe watch option is an object with all the watchers that are declared on the Vue instance.\nA watcher is a function with the same name as a data property or a computed property. The watcher is called automatically whenever that property with the same name gets changed.\nWhen a watcher is called, the new and the previous values are available as arguments to the watcher function.\nA watcher can also be a dot-delimited path, such as tiger.weight, so that the watcher is only called when the weight property of the tiger object is changed.\nNote: Arrow functions should be avoided when declaring watchers because the Vue instance cannot be reached from inside such a function using the this keyword.\nWhen writing watchers using the object syntax (see the example below), these options are available:\nNote: Watchers can also be created using the $watch() method.\nMore Examples\nExample\nUsing a watcher with the object syntax.\nRelated Pages\nVue Tutorial: Vue Watchers\nVue Tutorial: Vue v-model Directive\nVue Reference: Vue $watch() Method",
      "examples": [
        "export default { data() { return { rangeVal: 4 }; }, watch: { rangeVal(val) { if( val>20 && val<70) { if(val<40){ this.rangeVal = 20; } else { this.rangeVal = 70; } } } } };",
        "<template> <h2>Example watch Option</h2> <p>The 'rangeVal' watcher is written with the object syntax, with immediate: true, so that rangeVal is moved to '70' when the page first loads:</p> <input type=\"range\" v-model=\"rangeVal\"> <p>rangeVal: <span>{{ rangeVal }}</span></p> </template> <script> export default { data() { return { rangeVal: 40 }; }, watch: { rangeVal: { handler(val) { if (val > 20 && val < 70) { if (val < 40) { this.rangeVal = 20; } else { this.rangeVal = 70; } } }, immediate: true } } }; </script> <style> span { padding: 3px; font-weight: bold; font-family: 'Courier New', Courier, monospace; background-color: lightgreen; } </style>",
        "watch",
        "<input type=\"range\">",
        "tiger.weight",
        "weight",
        "tiger",
        "this",
        "$watch()"
      ]
    },
    {
      "title": "Vue 'props' Option",
      "summary": "ExampleGet your own Vue Server\nUsing the props option to create props for the component.\nSee more examples below\nDefinition and Usage\nThe props option is an array (simple form), or an object (full form), with all the props inside.\nWhen the props option is given as an array (simple form, see the example above), the array just consists of the names of the props as strings.\nWhen the props option is given as an object (full form, see the example below), several options can be defined in addition to the prop names:\nMore Examples\nExample\nDefining props as objects with options.\nFoodItem.vue:\nApp.vue:\nRelated Pages\nVue Tutorial: Vue Props\nVue Tutorial: Vue $emit() Method\nVue Reference: Vue $props Object",
      "examples": [
        "export default { props: [ 'foodName', 'foodDesc' ] };",
        "<template> <div> <h2>{{ foodName }}</h2> <p>{{ foodDesc }}</p> </div> </template> <script> export default { props: { foodName: { type: String, required: true }, foodDesc: { type: String, required: false, default: 'This is the food description...' } } }; </script>",
        "<template> <h1>Food</h1> <p>Food description is not provided for 'Pizza' and 'Rice', so the default description is used.</p> <div id=\"wrapper\"> <food-item food-name=\"Apples\" food-desc=\"Apples are a type of fruit that grow on trees.\"/> <food-item food-name=\"Pizza\"/> <food-item food-name=\"Rice\"/> </div> </template> <style> #wrapper { display: flex; flex-wrap: wrap; } #wrapper > div { border: dashed black 1px; flex-basis: 120px; margin: 10px; padding: 10px; background-color: lightgreen; } </style>",
        "props",
        "FoodItem.vue",
        "App.vue"
      ]
    },
    {
      "title": "Vue 'emits' Option",
      "summary": "ExampleGet your own Vue Server\nUsing the emits option to declare which custom events that are emitted from the component.\nSee more examples below\nDefinition and Usage\nThe emits option is used to document what custom events a component emits.\nThe emits option is not required, which means that a component can emit events without defining them inside the emits option.\nEven though the emits option is not required, it is still recommended to have, so that other programmers can easily see what the component emits.\nWhen the emits option is given as an array, the array just consists of the names of the emits as strings. (See the example above.)\nWhen the emits option is given as an object, a property name is the name of an emit, and the value is a validator function if it has one, or 'null' if the emit does not have a validator function. (See the example below.)\nMore Examples\nExample\nUsing props as objects with options, so that the default food description is shown when it is not provided by the parent component.\nFoodItem.vue:\nApp.vue:\nRelated Pages\nVue Tutorial: Vue $emit() Method\nVue Tutorial: Vue Props\nVue Reference: Vue $props Object\nVue Reference: Vue $emit() Method",
      "examples": [
        "export default { emits: ['custom-event'], methods: { notifyParent() { this.$emit('custom-event','Hello! ') } } }",
        "<template> <div> <h2>{{ foodName }}</h2> <p>{{ foodDesc }}</p> </div> </template> <script> export default { props: { foodName: { type: String, required: true }, foodDesc: { type: String, required: false, default: 'This is the food description...' } } }; </script>",
        "<template> <h1>Food</h1> <p>Food description is not provided for 'Pizza' and 'Rice', so the default description is used.</p> <div id=\"wrapper\"> <food-item food-name=\"Apples\" food-desc=\"Apples are a type of fruit that grow on trees.\"/> <food-item food-name=\"Pizza\"/> <food-item food-name=\"Rice\"/> </div> </template> <style> #wrapper { display: flex; flex-wrap: wrap; } #wrapper > div { border: dashed black 1px; flex-basis: 120px; margin: 10px; padding: 10px; background-color: lightgreen; } </style>",
        "emits",
        "FoodItem.vue",
        "App.vue"
      ]
    },
    {
      "title": "Vue 'expose' Option",
      "summary": "ExampleGet your own Vue Server\nUsing the expose option to make a method available for the parent component to use.\nSee more examples below\nDefinition and Usage\nThe expose option is used to list which properties that are available to a parent component through template refs.\nBy default, all child component properties are available to a parent component through the use of template refs.\nThis means that if the child component has no expose option, and the parent component uses the built-in attribute ref=\"childComp\" on the child component, the parent component can access a data property 'message' in the child component with the code this.$refs.childComp.message. (See Example 1)\nBut, when using the expose option, only the properties listed in the expose option are available to the parent. (See Example 2)\nMore Examples\nExample 1\nThe expose option is not used in the child component, so all properties in the child component are available to the parent component.\nChildComp.vue:\nApp.vue:\nExample 2\nUsing the 'createMessage' method in the child component from the parent component does not work, because only the 'message' data property is listed in the expose option of the child component.\nChildComp.vue:\nApp.vue (highlighted line does not work):\nRelated Pages\nVue Tutorial: Vue Template Refs\nVue Tutorial: Vue Components\nVue Reference: Vue 'ref' Attribute\nVue Reference: Vue $refs Object",
      "examples": [
        "export default { expose: ['createMessage'], data() { return { message: ' ' } }, methods: { createMessage(msg) { this.message += msg + ' ' } } }",
        "<template> <div> <h3>ChildComp.vue</h3> <p>Message from parent component:</p> <p id=\"pEl\">{{ message }}</p> </div> </template> <script> export default { data() { return { message: ' ' } }, methods: { createAlert() { alert('This is an alert, from the child component') } } } </script> <style scoped> div { border: solid black 1px; padding: 10px; max-width: 350px; margin-top: 20px; } #pEl { background-color: lightgreen; font-family: 'Courier New', Courier, monospace; } </style>",
        "<template> <h2>Example expose Option</h2> <p>The 'expose' option is not used, so all child properties are available to the parent by default, both the 'message' data property, and the 'createAlert()' method:</p> <button v-on:click=\"{ this.$refs.childComp.message += 'Hello! '; }\">Write 'Hello!'</button> <button v-on:click=\"{ this.$refs.childComp.createAlert(); }\">Create alert</button> <child-comp ref=\"childComp\"/> </template>",
        "<template> <h2>Example expose Option</h2> <p>Only the 'message' data property is listed in the 'expose' option, so the 'createMessage' method from the child component is not available, and will not work:</p> <input type=\"text\" v-model=\"inpText\" placeholder=\"Write something\"> <button v-on:click=\"useMet\">Use exposed method</button> <child-comp ref=\"childComp\"/> </template> <script> export default { data() { return { inpText: '' } }, methods: { useMet() { this.$refs.childComp.createMessage(this.inpText); } }, mounted() { this.$refs.childComp.message = 'Initial message!'; } } </script>",
        "expose",
        "ref=\"childComp\"",
        "this.$refs.childComp.message",
        "ChildComp.vue",
        "App.vue"
      ]
    },
    {
      "title": "Vue Lifecycle Hooks",
      "summary": "Lifecycle hooks in Vue are used to run code at different stages of the Vue application's lifecycle.",
      "examples": []
    },
    {
      "title": "Vue 'beforeCreate' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the beforeCreate lifecycle hook to create an alert, write to the console, and unsuccessfully trying to change the 'text' data property.\nDefinition and Usage\nThe beforeCreate lifecycle hook is the first hook that is called during a Vue component's lifecycle.\nThe beforeCreate lifecycle hook is used to run code before the component is created.\nBecause the component is not created yet, we cannot access properties inside the component instance such as data or computed, and we cannot access component DOM elements because they are also not created yet.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'beforeCreate' Hook\nVue Reference: Vue 'created' Lifecycle Hook",
      "examples": [
        "beforeCreate(){ console.log('beforeCreate lifecycle hook'); alert('beforeCreate lifecycle hook'); this.text = 'beforeCreate lifecycle hook'; // Does not work }",
        "beforeCreate",
        "data",
        "computed"
      ]
    },
    {
      "title": "Vue 'created' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the created lifecycle hook to change the 'text' data property.\nDefinition and Usage\nThe created lifecycle hook is called after the component is initialized.\nBecause the component is initialized, we can access properties inside the component instance such as data or computed, but we cannot access component DOM elements because they are not created until the mounted hook.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'created' Hook\nVue Reference: Vue 'beforeCreate' Lifecycle Hook\nVue Reference: Vue 'mounted' Lifecycle Hook",
      "examples": [
        "export default { data() { return { text: 'initial text' } }, created() { this.text = 'The component is now created'; } }",
        "created",
        "data",
        "computed",
        "mounted"
      ]
    },
    {
      "title": "Vue 'beforeMount' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the beforeMount and mounted lifecycle hooks to demonstrate that the component's DOM elements are not available until the mounted hook.\nDefinition and Usage\nThe beforeMount lifecycle hook happens right before the component is mounted, so just before the component is added to the DOM.\nBecause the component is not mounted yet, we can access properties inside the component instance such as data or computed, but we cannot access the component's DOM elements because they are not mounted yet.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'beforeMount' Hook\nVue Tutorial: The 'mounted' Hook",
      "examples": [
        "export default { data() { return { refsObj1: '', refsObj2: '' } }, beforeMount() { this.refsObj1 = this.$refs; // The $refs object is empty at this point }, mounted() { this.refsObj2 = this.$refs; } }",
        "beforeMount",
        "mounted",
        "data",
        "computed"
      ]
    },
    {
      "title": "Vue 'mounted' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the mounted lifecycle hook to put the cursor inside the input field as soon as the component is mounted.\nDefinition and Usage\nThe mounted lifecycle hook happens after the Vue component is mounted to the DOM tree.\nBecause the component is mounted, we can access the properties that belong to the component instance such as data or computed, and we can access the component's DOM elements because they have just been mounted to the DOM.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'mounted' Hook\nVue Reference: Vue 'beforeMount' Lifecycle Hook",
      "examples": [
        "<script> export default { mounted() { this.$refs.inpName.focus(); } } </script>",
        "mounted",
        "data",
        "computed"
      ]
    },
    {
      "title": "Vue 'beforeUpdate' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the beforeUpdate lifecycle hook to count how many times an update is triggered.\nDefinition and Usage\nThe beforeUpdate lifecycle hook happens after Vue's reactive system has detected a change that requires a new rendering, but before that rendering happens.\nTo avoid an infinite loop we should always consider to use the beforeUpdate lifecycle hook instead of the updated lifecycle hook.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'beforeUpdate' Hook\nVue Tutorial: The 'updated' Hook\nVue Reference: Vue 'updated' Lifecycle Hook",
      "examples": [
        "export default { data() { return { sliderVal: 50, renderCount: 0 } }, beforeUpdate() { this.renderCount++; } }",
        "beforeUpdate",
        "updated"
      ]
    },
    {
      "title": "Vue 'updated' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the updated lifecycle hook to write a message to the console every time the DOM tree is updated.\nDefinition and Usage\nThe updated lifecycle hook happens right after the DOM tree has updated.\nIf we modify a property or do something else in the updated hook that triggers a new render, the updated hook will be called again after that new render, and we have most likely created an infinite loop.\nTo avoid an infinite loop we should always consider to use the beforeUpdate lifecycle hook instead of the updated lifecycle hook.\nThe this.$nextTick() or nextTick() functions can also be used to run code after the DOM has been updated.\nNote: In the example above, we write the render count to the console, because making changes to the view would re-activate the updated hook and create an infinite loop.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'beforeUpdate' Hook\nVue Reference: Vue 'beforeUpdate' Lifecycle Hook\nVue Reference: Vue $nextTick() Method",
      "examples": [
        "export default { data() { return { sliderVal: 50, renderCount: 0 } }, updated() { this.renderCount++; console.log('Updated ' + this.renderCount + ' times.') } }",
        "updated",
        "beforeUpdate",
        "this.$nextTick()",
        "nextTick()"
      ]
    },
    {
      "title": "Vue 'beforeUnmount' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the beforeUnmount lifecycle hook to create an alert with text taken from inside a <p> element.\nDefinition and Usage\nThe beforeUnmount lifecycle hook happens right before the component is removed from the DOM.\nWhen running code in the beforeUnmount hook, the component is still fully functional.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'beforeUnmount' Hook\nVue Reference: Vue 'mounted' Lifecycle Hook",
      "examples": [
        "<script> export default { beforeUnmount() { alert(\"beforeUnmount: The text inside the p-tag is: \" + this.$refs.pEl.innerHTML); } } </script>",
        "beforeUnmount",
        "<p>"
      ]
    },
    {
      "title": "Vue 'unmounted' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the unmounted lifecycle hook to create an alert when the component is removed from the DOM.\nDefinition and Usage\nThe unmounted lifecycle hook is called after a component is removed from the DOM.\nThis hook can for example be used to remove event listeners or to cancel timers or intervals.\nNote: In the example above, the alert box appears before we can see that the component is removed. That is because at first the component is removed from the DOM, then the alert appears, and then at last, when you click \"OK\" in the alert box, the browser renders the page without the component inside the DOM.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'unmounted' Hook\nVue Reference: Vue 'beforeUnmount' Lifecycle Hook",
      "examples": [
        "<script> export default { unmounted() { alert(\"The component is removed (unmounted)!\"); } } </script>",
        "unmounted"
      ]
    },
    {
      "title": "Vue 'errorCaptured' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the errorCaptured lifecycle hook to catch an error from a child component and create an alert to the user.\nSee more examples below.\nDefinition and Usage\nThe errorCaptured lifecycle hook is called when an error happens in a child/descendant component.\nThis hook can be used for error handling, logging, or to display the error to the user.\nWhen using the errorCaptured hook, it is important not to trigger a render of the component where the error comes from, because that will most likely cause an infinite loop.\nInformation about the error is available to us as three arguments in the errorCaptured() function:\nThe error\nThe component that triggered the error\nThe error source type\nDefault behavior for an error that occurs, is to propagate, or 'bubble up', from the component the error occurred in. An error that occurs in a component will move up to the parent component, and continue to move further up, and eventually ends up as an error message in the console.\nBy running return false; from inside the errorCaptured() function, the error will not end up in the parent component (stop propagating), and the error will also not end up as an error message in console.\nError handling can also set up using the app.config.errorHandler function.\nMore Examples\nExample 1\nUsing the errorCaptured lifecycle hook to catch an error and write information about the error to the console.\nApp.vue:\nComOne.vue:\nExample 2\nUsing the errorCaptured lifecycle hook with return false; to stop the error from propagating.\nApp.vue:\nComOne.vue:\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'errorCaptured' Hook",
      "examples": [
        "<script> export default { errorCaptured() { alert(\"An error occurred\"); } } </script>",
        "<template> <h1>The 'errorCaptured' Lifecycle Hook</h1> <p>Whenever there is an error in a child component, the errorCaptured() function is called on the parent.</p> <p>Open the browser console to see the captured error details.</p> <div> <comp-one></comp-one> </div> </template> <script> export default { errorCaptured(error,compInst,errorInfo) { console.log(\"error: \", error); console.log(\"compInst: \", compInst); console.log(\"errorInfo: \", errorInfo); } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } </style>",
        "<template> <h2>Component</h2> <p>This is the component</p> <button @click=\"generateError\">Generate Error</button> </template> <script> export default { methods: { generateError() { this.$refs.objEl.innerHTML = \"hi\"; } } } </script>",
        "<template> <h1>The 'errorCaptured' Lifecycle Hook</h1> <p>Whenever there is an error in a child component, the errorCaptured() function is called on the parent.</p> <p>Open the browser console to see the captured error details.</p> <div> <comp-one></comp-one> </div> </template> <script> export default { errorCaptured(error,compInst,errorInfo) { console.log(\"error: \", error); console.log(\"compInst: \", compInst); console.log(\"errorInfo: \", errorInfo); return false; } } </script> <style> #app > div { border: dashed black 1px; border-radius: 10px; padding: 10px; margin-top: 10px; background-color: lightgreen; } </style>",
        "errorCaptured",
        "errorCaptured()",
        "return false;",
        "app.config.errorHandler",
        "App.vue",
        "ComOne.vue"
      ]
    },
    {
      "title": "Vue 'renderTracked' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the renderTracked lifecycle hook to create an alert when the reactive component is initialized.\nDefinition and Usage\nThe renderTracked hook runs when a render function is set to track, or monitor, a reactive component.\nThe renderTracked hook usually runs when a reactive component is initialized, because that is when the Vue's automatic reactive system is set up.\nA reactive component is a component that changes.\nA render function is a function compiled by Vue that keeps track of reactive components. When a reactive component changes, the render function is triggered and re-renders the application to the screen.\nThe renderTracked hook is meant to be used in debugging, and is only available in development mode.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'renderTracked' Hook\nVue Tutorial: The 'renderTriggered' Hook\nVue Reference: Vue 'renderTriggered' Lifecycle Hook",
      "examples": [
        "export default { data() { return { counter: 0 } }, renderTracked(evt) { console.log(\"renderTracked: \",evt); alert(\"renderTracked\"); } }",
        "renderTracked"
      ]
    },
    {
      "title": "Vue 'renderTriggered' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the renderTriggered lifecycle hook to show an alert every time a render is triggered.\nDefinition and Usage\nThe renderTriggered lifecycle hook runs when a tracked reactive component changes, and therefore triggers a new render, so that the screen gets updated with the latest changes.\nThe renderTriggered hook is meant to be used in debugging, and is only available in development mode.\nA reactive component is a component that can change.\nA render function is a function compiled by Vue that keeps track of reactive components. When a reactive component changes, the render function is triggered and re-renders the application to the screen.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'renderTriggered' Hook\nVue Tutorial: The 'renderTracked' Hook\nVue Reference: Vue 'renderTracked' Lifecycle Hook",
      "examples": [
        "export default { data() { return { counter: 0 } }, renderTriggered(evt) { console.log(\"renderTriggered: \",evt) alert(\"renderTriggered\"); } }",
        "renderTriggered"
      ]
    },
    {
      "title": "Vue 'activated' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the activated lifecycle hook to log every time the activated hook get called.\nDefinition and Usage\nThe activated lifecycle hook runs when a cached component is inserted into the DOM.\nA component is cached with the use of the built-in <KeepAlive> component.\nAfter a cached component is created, it can be inserted and removed from the DOM many times, and every time such a cached component is inserted into the DOM, the activated lifecycle hook is called.\nNote: The difference between the activated and mounted hooks is that the mountedhook is not called when an already existing cached component is inserted to the DOM.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'activated' Hook\nVue Tutorial: The 'deactivated' Hook\nVue Tutorial: The 'mounted' Hook\nVue Tutorial: The 'unmounted' Hook\nVue Reference: Vue 'deactivated' Lifecycle Hook\nVue Reference: Vue 'mounted' Lifecycle Hook\nVue Reference: Vue 'unmounted' Lifecycle Hook",
      "examples": [
        "export default { mounted() { console.log(\"mounted\"); const liEl = document.createElement(\"li\"); liEl.innerHTML = \"mounted\"; this.$refs.olEl.appendChild(liEl); }, activated() { console.log(\"activated\"); const liEl = document.createElement(\"li\"); liEl.innerHTML = \"activated\"; this.$refs.olEl.appendChild(liEl); } }",
        "activated",
        "<KeepAlive>",
        "mounted"
      ]
    },
    {
      "title": "Vue 'deactivated' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the deactivated lifecycle hook to log every time the deactivated hook is called.\nDefinition and Usage\nThe deactivated lifecycle hook runs when a cached component is removed from the DOM, but not destroyed.\nA component is cached with the use of the built-in <KeepAlive> component.\nAfter a cached component is created, it can be inserted and removed from the DOM many times, and every time such a cached component is removed from the DOM (but not destroyed), the deactivated lifecycle hook is called.\nNote: The difference between the deactivated and unmounted hooks is that when a cached component is removed from the DOM (without being destroyed), only the deactivated hook is called.\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nVue Tutorial: The 'activated' Hook\nVue Tutorial: The 'deactivated' Hook\nVue Tutorial: The 'mounted' Hook\nVue Tutorial: The 'unmounted' Hook\nVue Reference: Vue 'activated' Lifecycle Hook\nVue Reference: Vue 'mounted' Lifecycle Hook\nVue Reference: Vue 'unmounted' Lifecycle Hook",
      "examples": [
        "export default { data() { return { hookLog: [] } }, deactivated() { console.log(\"deactivated\") this.hookLog.push(\"deactivated\"); } }",
        "deactivated",
        "<KeepAlive>",
        "unmounted"
      ]
    },
    {
      "title": "Vue 'serverPrefetch' Lifecycle Hook",
      "summary": "ExampleGet your own Vue Server\nUsing the serverPrefetch lifecycle hook to fetch data on the server side.\nDefinition and Usage\nThe serverPrefetch lifecycle hook only happens during server-side rendering (SSR).\nThe serverPrefetch lifecycle hook is used to for example fetch data, in case you need to do that exclusively on the server-side.\nThe serverPrefetch lifecycle hook is used as an asynchronous function, so that if it returns a promise, the server will wait with rendering the component until the promise is resolved.\nNote: In the example above, the \"Run Example\" button is missing because the example would not work as the serverPrefetch hook will only be called during server-side rendering (SSR).\nRelated Pages\nVue Tutorial: Vue Lifecycle Hooks\nJavaScript Tutorial: Asynchronous JavaScript",
      "examples": [
        "export default { data() { return { data: null, }; }, async serverPrefetch() { const response = await fetch(\"https://random-data-api.com/api/v2/users\"); this.data = await response.json(); } };",
        "serverPrefetch"
      ]
    },
    {
      "title": "Vue Examples",
      "summary": "Introduction to Vue\nThe v-bind Directive\nThe v-if Directive\nThe v-show Directive\nThe v-for Directive\nThe v-on Directive\nMethods\nEvent Modifiers\nThe v-model Directive\nComputed Properties\nWatchers\nTemplates\nSFC Pages\nComponents\nProps\nEmit\nFallthrough Attributes\nScoped Styling\nLocal Components\nSlots\nDynamic Components\nTeleport\nHTTP Requests\nTemplate Refs\nLifecycle Hooks\nProvide/Inject\nRouting\nAnimations\nAnimations with v-for\nThe Composition API",
      "examples": [
        "v-bind",
        "<div>",
        "<img>",
        "v-for",
        "class",
        "v-bind:class",
        "v-bind:style",
        "v-if",
        "v-else-if",
        "v-else",
        "v-show",
        "v-on",
        "v-on:click",
        "@",
        ".once",
        "keydown",
        ".s",
        ".ctrl",
        ".prevent",
        "v-model",
        "<input type=\"radio\">",
        "<input type=\"checkbox\">",
        "<select>",
        "<select multiple>",
        "<input type=\"file\">",
        "<input type=\"range\">",
        "<input type=\"color\">",
        "<textarea>",
        "key",
        "style",
        "$attrs",
        "scoped",
        "v-slot",
        "#",
        "<KeepAlive>",
        "<KeepAlive include=\"CompOne\">",
        "<KeepAlive exclude=\"CompOne\">",
        "<body>",
        "$refs",
        "<p>",
        "<input>",
        "<li>",
        "beforeCreate",
        "created",
        "beforeMount",
        "mounted",
        "beforeUpdate",
        "updated",
        "beforeUnmount",
        "unmounted",
        "errorCaptured",
        "renderTracked",
        "activated",
        "deactivated",
        "transition",
        "@keyframes",
        "<Transition>",
        "name",
        "after-enter",
        "enter-cancelled",
        "appear",
        "mode=\"out-in\"",
        "<TransitionGroup>"
      ]
    },
    {
      "title": "Vue Exercises",
      "summary": "You can test your Vue skills with W3Schools' Exercises.\nExercises\nWe have gathered a variety of Vue exercises (with answers) for each Vue Chapter.\nTry to solve an exercise by editing some code, or show the answer to see what you've done wrong.\nCount Your Score\nYou will get 1 point for each correct answer. Your score and total score will always be displayed.\nStart Vue Exercises\nGood luck!\nStart Vue Exercises ❯\nIf you don't know Vue, we suggest that you read our Vue Tutorial from scratch.",
      "examples": []
    },
    {
      "title": "Vue Quiz",
      "summary": "You can test your Vue skills with W3Schools' Quiz.\nThe Test\nThe test contains 25 questions and there is no time limit.\nThe test is not official, it's just a nice way to see how much you know about Vue.\nCount Your Score\nYou will get 1 point for each correct answer. At the end of the Quiz, your total score will be displayed. Maximum score is 25 points.\nStart the Quiz\nGood luck!\nStart the Vue Quiz ❯\nIf you do not know Vue, we suggest that you read our Vue Tutorial from scratch.",
      "examples": []
    },
    {
      "title": "Vue Syllabus",
      "summary": "Introduction\nThe W3Schools Vue Tutorial is comprehensive and beginner-friendly.\nIt will give you a fundamental knowledge of Vue.js framework.\nIt is designed for beginners and requires basic HTML, CSS, and JavaScript knowledge.\nThe content has been carefully made to be bite-sized, simple, and easy to understand.\nThe content has been proven by millions of users over the years. It is updated and improved frequently.\nThe syllabus outline and its sequence are structured so you can learn Vue step by step, from the introduction to building applications.\nGet Started With Vue »\nLearning Outcomes\nMaster fundamental Vue.js concepts and its reactive system architecture.\nCreate and manage Vue components using Single-File Components (SFC) architecture.\nApply Vue directives effectively (v-bind, v-if, v-for, v-model) and template syntax.\nImplement component communication and state management patterns.\nDevelop single-page applications using Vue Router.\nMaster component lifecycle hooks and their practical applications.\nUtilize Vue CLI and development tools for efficient development.\nBuild robust forms with validation and user input handling.\nDesign scalable and maintainable Vue applications.\nCreate dynamic user interfaces with animations and transitions.\nIntegrate external APIs and handle HTTP requests effectively.\nNote: Are you a teacher teaching Vue? W3Schools Academy is a toolbox of features that can help you teach. It offers classroom features such as pre-built study plans, classroom administration and much more. Read more about Academy here.\nWhich Subjects Are Vue Relevant For?\nWeb Development:\nVue is essential for modern web applications.\nFront-end Development:\nVue provides a complete framework for UI development.\nSingle Page Applications:\nVue excels at creating SPAs.\nUser Interface Design:\nVue offers powerful component-based UI development.\nProgressive Web Apps:\nVue supports building PWAs out of the box.\nInteractive Applications:\nVue enables creating dynamic user experiences.\nEnterprise Applications:\nVue scales well for large applications.\nGet Started\nActivities\nIn this tutorial we offer different activities for you to learn Vue for free:\nLessons\nExercises\nQuizzes\nSign in to Track Progress\nYou can also create a free account to track your progress.\nAs a signed-in user, you get access to features such as:\nLearning paths\nSandbox and lab environments\nAchievements\nAnd much more!\nSign Up - It's free\nOverview of the Modules\nVue HOME\nVue Intro\nVue Directives\nVue v-bind\nVue v-if\nVue v-show\nVue v-for\nVue Events\nVue v-on\nVue Methods\nVue Event Modifiers\nVue Forms\nVue v-model\nVue CSS Binding\nVue Computed Properties\nVue Watchers\nVue Templates\nVue Why, How and Setup\nVue First SFC Page\nVue Components\nVue Props\nVue v-for Components\nVue $emit()\nVue Fallthrough Attributes\nVue Scoped Styling\nVue Local Components\nVue Slots\nVue v-slot\nVue Scoped Slots\nVue Dynamic Components\nVue Teleport\nVue HTTP Request\nVue Template Refs\nVue Lifecycle Hooks\nVue Provide/Inject\nVue Routing\nVue Form Inputs\nVue Animations\nVue Animations with v-for\nVue Build\nVue Composition API\nGet Started\nSandbox and Lab Environment\nVue, like any framework, is best learned through hands-on practice.\nTry this example using our editor:\nExampleGet your own Vue Server\nIf you want to explore more and host your project, we have a feature called Spaces that allows you to build, test and run Vue applications for free.\nHere you get a secure sandbox environment called Spaces, where you can practice Vue code and test applications in real-time.\nSpaces allow you to test, build, and deploy code. This includes a W3Schools subdomain, hosting, and secure SSL certificates.\nSpaces require no installation and run directly in the browser.\nFeatures include:\nCollaboration\nFile navigator\nTerminal & log\nPackage manager\nDatabase\nEnvironment manager\nAnalytics\nCreate a Spaces Account\nVue Certification\nW3Schools offers an end-of-pathway certification program.\nHere you can take exams to get certified.\nThe Vue exam is a test that summarizes the W3Schools Vue syllabus.\nAfter passing the exam you get the \"Certified Vue Developer\" Certification.\nThere are two different types of certifications:\nNon-adaptive\nAdaptive\nThe non-adaptive is pass or no pass.\nThe adaptive certification is adaptive and graded; students will get a grade from intermediate, advanced to professional.\nBuy Certificate »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach Vue?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": [
        "<h1>\"Hello, World!\" Example</h1>\n\n<div id=\"app\">{{ message }}</div>"
      ]
    },
    {
      "title": "Vue Study Plan",
      "summary": "Introduction\nThe Vue study plan helps you teach your students Vue step-by-step.\nCreating a study plan for Vue is easy.\nYou can use a pre-built study plan or customize it.\nStudents have different skill levels. The study plans can be customized to ensure that everyone is challenged.\nSave time with pre-built teacher materials and study plans. Easily organize your class with a timeline from the introduction of Vue to the final exam.\nW3Schools Academy\nThis study plan is a feature of W3Schools Academy.\nW3Schools Academy is a platform that has everything you need to teach coding, all in one place.\nIt offers you as a teacher a toolbox of features that helps you succeed with teaching in your classroom.\nYou need to have an active subscription to access the study plan feature. There are two different subscription tiers:\nEssentials ($1.99 / month per student)\nFull Access ($5.99 / month per student)\nCalculate your price and order here.\nLearn More »\nAcademy also offer other features such as:\nManaging your classroom\nTracking of student progress and reports\nLabs, assignments, and code challenges (prebuilt challenges or create your own ones)\nAuto-grading\nTeaching materials\nCertification exams\nGet a free demo »\nTeacher Materials\nW3Schools has everything you need to teach Vue.\nThe Vue training materials is available for you to include and use in your study plan:\nW3Schools Vue Tutorial\nVue Exercises\nVue Quiz\nVue Challenges (Coding challenges)\nVue Certification Exam (End of Pathway Exam)\nVue Syllabus\nWith the Vue.js Syllabus, your students will start with the basics, like understanding directives such as v-if and v-else, and move to more advanced topics, like managing reactivity, working with components, and building dynamic applications. Each chapter includes simple examples, try-it-yourself sections, exercises, and quizzes to make learning easy, interactive, and fun.t, and move to more advanced topics, like object-oriented programming, working with classes, and managing memory using pointers. Each chapter has examples, try-it-yourself sections, exercises, and quizzes to make learning easy, interactive, and fun.\nRead more about Vue Syllabus.\nStudy Plan Overview\nThe study plan features are made to help teachers and students. They make learning easy, flexible, and fun. These features work for different types of classes, learning styles and student level.\nLearning Paths\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nInteractive Content\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTimeline and Pace\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nTrack Student Progress\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nEnd of Pathway Exam\nThe Vue study plan aligns with the Vue Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the Vue Tutorial.\nYou get reports of the students' results.\nThe Vue study plan aligns with the Vue Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the Vue Tutorial.\nYou get reports of the students' results.\nAccessibility\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nLearn More »\nSample Study Plan\nYou choose the timeline and pace of your study plans.\nSchools have different preferences.\nSome would like more intensive pace, e.g. 2 weeks, others 6 or more weeks.\nIt is completely up to you.\nFor example, this is how a 2-week Vue study plan could look like:\nWeek 1: Basic and Dynamic Rendering, Event Control\nWeek 2: Data Manipulation, Component Essentials, Lifeycle, Routing and API, Vue Certification Exam\nImage of Sample Vue study plan:\nReady to get started?\nStart with Vue Study Plans today.\nGet Started »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach Vue programming?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": []
    },
    {
      "title": "Vue.js Server Create Vue.js Server Powerful Code Editor Practice Makes Perfect kAI",
      "summary": "Coding Skills\nAI Tutor\nProjects\nSecurely\nChoose your Plan\nBy subscribing to a plan you support the W3Schools mission to make\nlearning available to everyone - no matter their background.\n$0 /Forever\nThis is for you that are beginning to explore coding and web development\nTrack your progress\nSet your goals\nBuild and host 1 static website\n100 credits/month\nAccess various AI features like W3Schools kAI coding tutor and interview preparation.\nNo support\n$14.99 /Month\nThis is for you that want to learn and reach your goals faster. Build fullstack projects, ad free experience.\nAd-free experience\nUnlimited challenges\nUnlimited practice tests\nBuild and host 15 static websites\nBuild and host 1 full stack server\nChoose from 75+ templates\n10000 credits/month\nAccess various AI features like W3Schools kAI coding tutor and interview preparation.\nCancel anytime\nFor teachers\nSpend less time on admin tasks while engaging your students. Help them learn, practice and collaborate. All in one place.\nAd-free for focused learning\nDashboard to manage your classroom\nStudy plans for structured learning\nTrack progress with insights\nInteractive code challenges and projects\nAccess to all courses and certification exams\nSpaces for building and publishing projects\n25% OFF\nYou can also buy a domain or connect an existing one.\nSave Time with Templates\nJust landed in Spaces\nLearn to code more effectively\nand intelligently with kAI - AI tutor\nHi! I'm kAI, W3Schools AI Tutor...\nFeel free to ask me any coding-related questions, and I'll do my best to assist you.\nI can help you checking your code for errors, improving your code's structure, explaining coding concepts in a clear and understandable way, and more...\nI can even create complete websites for you based on your input, so what are you waiting for?\nSuper Simple to Share\nIncluded for free in all plans\nWant custom domains?\nHow it works\nCoding Made Easy\nCloud-based\nTerminal & Log\nHow To Libraries\nDatabase\nFile Navigator\nPackage Manager\nAnalytics\nEnvironment Manager\nSave Time & Money.\nAll Your Files in One Place.\nFix Your Code Faster.\nGet Full Data Visibility.\nIncreased Control and Security.\nFind What You Need Quicker.\nGet Traffic Insights.\nGet Inspired\nFrequently Asked Questions\nWith Basic Spaces, you can build frontend websites. Whereas with Fullstack Spaces, you can build frontend and backend websites.\nBasic Spaces include HTML, CSS, and Javascript. Full Stack Spaces include everything in Basic Spaces plus PHP, Python, React.js, Vue.js, Node.js, Handlebars, and Django.\nYour subscription will be automatically renewed every month.\nYour access to all the benefits for the paid period of time will continue. However, the subscription will not be renewed automatically.\nTo subscribe W3Schools accounts for multiple users, you can contact sales@w3schools.com",
      "examples": []
    },
    {
      "title": "W3Schools Vue Certificate",
      "summary": "W3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nW3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nWho Should Consider Getting Certified?\nAny student or professional within the digital industry.\nCertifications are valuable assets to gain trust and demonstrate knowledge to your clients, current or future employers on a ever increasing competitive market.\nW3Schools is Trusted by Top Companies\nW3Schools has over two decades of experience with teaching coding online.\nOur certificates are recognized and valued by companies looking to employ skilled developers.\nSave Time and Money\nShow the world your coding skills by getting a certification.\nThe prices is a small fraction compared to the price of traditional education.\nDocument and validate your competence by getting certified!\nExam overview\nFee: 95 USD\nAchievable certification levels:\nIntermediate (40%)\nAdvanced (75%)\nProfessional (90%)\nNumber of questions:\nAdaptive, 60 on average\nRequirement to pass:\nMinimum 40% - Intermediate level\nTime limit: 60 minutes\nNumber of attempts to pass: 3\nExam deadline: None\nCertification Expiration: None\nFormat: Online, multiple choice\nRegister now »\nAdvance Faster in Your Career\nGetting a certificate proves your commitment to upgrading your skills.\nThe certificate can be added as credentials to your CV, Resume, LinkedIn profile, and so on.\nIt gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nKnowledge is power, especially in the current job market.\nDocumentation of your skills enables you to advance your career or helps you to start a new one.\nHow Does It Work?\nStudy for free at W3Schools.com\nStudy at your own speed\nTest your skills with W3Schools online quizzes\nApply for your certificate by paying an exam fee\nTake your exam online, at any time, and from any location\nGet Your Certificate and Share It With The World\nExample certificate:\nEach certificate gets a unique link that can be shared with others.\nValidate your certification with the link or QR code.\nCheck how it looks like in this Example.\nShare your certificate on Linked in the Certifications section in just one click!\nDocument Your Skills\nGetting a certificate proves your commitment to upgrade your skills, gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nGet Your Certificate »\nLooking to add multiple users?\nAre you an educator, manager or business owner looking for courses or certifications?\nWe are working with schools, companies and organizations from all over the world.\nGet courses and/or certifications for your team here.",
      "examples": []
    }
  ],
  "glossary": [
    "activated",
    "attrs",
    "backend",
    "beforecreate",
    "beforemount",
    "beforeunmount",
    "beforeupdate",
    "component",
    "computed",
    "created",
    "data",
    "deactivated",
    "el",
    "emit",
    "emits",
    "errorcaptured",
    "exercise",
    "exercises",
    "expose",
    "forceupdate",
    "free",
    "javascript",
    "keepalive",
    "methods",
    "mounted",
    "nexttick",
    "note",
    "parent",
    "programs",
    "props",
    "refs",
    "rendertracked",
    "rendertriggered",
    "report error",
    "root",
    "scaling up",
    "serverprefetch",
    "slot",
    "slots",
    "teleport",
    "template",
    "transition",
    "transitiongroup",
    "unmounted",
    "updated",
    "v-bind",
    "v-cloak",
    "v-else",
    "v-else-if",
    "v-for",
    "v-html",
    "v-if",
    "v-memo",
    "v-model",
    "v-on",
    "v-once",
    "v-pre",
    "v-show",
    "v-slot",
    "v-text",
    "vue animations",
    "vue build",
    "vue components",
    "vue directives",
    "vue emit",
    "vue events",
    "vue exercises",
    "vue forms",
    "vue history",
    "vue home",
    "vue intro",
    "vue methods",
    "vue props",
    "vue quiz",
    "vue reference",
    "vue routing",
    "vue server",
    "vue slots",
    "vue syllabus",
    "vue teleport",
    "vue templates",
    "vue v-bind",
    "vue v-for",
    "vue v-if",
    "vue v-model",
    "vue v-on",
    "vue v-show",
    "vue v-slot",
    "vue watchers",
    "w3.css",
    "w3schools spaces",
    "watch"
  ],
  "objectives": [
    "HTML",
    "CSS",
    "JavaScript"
  ]
}