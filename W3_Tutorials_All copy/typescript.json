{
  "course_name": "TypeScript",
  "description": "TypeScript is JavaScript with added syntax for types. Tip: Sign in to track your progress - it's free. Our \"Try it Yourself\" editor makes it easy to learn TypeScript. You can edit TypeScript code and view the result in your browser. Click on the \"Try it Yourself\" button to see how it works. We recommend reading this tutorial in the sequence listed in the left menu. Sign Up for Free Note: This is an optional feature. You can study at W3Schools without creating an account.",
  "course_summary": [
    {
      "title": "TypeScript Introduction",
      "summary": "TypeScript is JavaScript with added syntax for types.\nWhat is TypeScript?\nTypeScript is a syntactic superset of JavaScript which adds static typing.\nThis basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.\nTypeScript being a Syntactic Superset means it shares the same base syntax as JavaScript, but adds something to it.\nWhy should I use TypeScript?\nJavaScript is a loosely typed language.\nIt can be difficult to understand what types of data are being passed around in JavaScript.\nIn JavaScript, function parameters and variables don't have any information!\nSo developers need to look at documentation, or guess based on the implementation.\nTypeScript allows specifying the types of data being passed around within the code, and has the ability to report errors when the types don't match.\nFor example, TypeScript will report an error when passing a string into a function that expects a number.\nJavaScript will not.\nTypeScript uses compile time type checking.\nWhich means it checks if the specified types match before running the code, not while running the code.\nREMOVE ADS\nHow do I use TypeScript?\nA common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.\nThe next section shows how to get the compiler setup for a local project.\nSome popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!",
      "examples": []
    },
    {
      "title": "TypeScript Getting Started",
      "summary": "TypeScript Compiler\nTypeScript is transpiled into JavaScript using a compiler.\nTypeScript being converted into JavaScript means it runs anywhere that JavaScript runs!\nInstalling the Compiler\nTypeScript has an official compiler which can be installed through npm.\nLearn more about npm, and how to get started here: What is npm?\nWithin your npm project, run the following command to install the compiler:\nExampleGet your own TypeScript Server\nWhich should give you an output similar to:\nExample\nThe compiler is installed in the node_modules directory and can be run with: npx tsc.\nExample\nWhich should give you an output similar to:\nExample\nFollowed by a list of all the Common Commands.\nREMOVE ADS\nConfiguring the compiler\nBy default the TypeScript compiler will print a help message when run in an empty project.\nThe compiler can be configured using a tsconfig.json file.\nYou can have TypeScript create tsconfig.json with the recommended settings with:\nExample\nWhich should give you an output similar to:\nExample\nYou can learn more at TypeScript Config\nHere is an example of more things you could add to the tsconfig.json file:\nExample\nYou can open the file in an editor to add those options.\nThis will configure the TypeScript compiler to transpile TypeScript files located in the src/ directory of your project, into JavaScript files in the build/ directory.\nYour First TypeScript Program\nLet's create a simple \"Hello, World!\" program to verify your TypeScript setup.\nCreate a new file named hello.ts with the following content:\nhello.ts\nCompile your TypeScript code:\nExample\nThis will generate a hello.js file in the same directory:\nExample\nRun the compiled JavaScript:\nExample\nYou should see the output:\nExample\nNote: If you're using the tsconfig.json configuration mentioned earlier, you would place your TypeScript files in the src directory and the compiled JavaScript will appear in the build directory.",
      "examples": [
        "npm install typescript --save-dev",
        "added 1 package, and audited 2 packages in 2s\nfound 0 vulnerabilities",
        "npx tsc",
        "Version 4.5.5\ntsc: The TypeScript Compiler - Version 4.5.5",
        "npx tsc --init",
        "Created a new tsconfig.json with:\nTS\ntarget: es2016\nmodule: commonjs\nstrict: true\nesModuleInterop: true\nskipLibCheck: true\nforceConsistentCasingInFileNames: true",
        "{\n\"include\": [\"src\"],\n\"compilerOptions\": {\n\"outDir\": \"./build\"\n}\n}",
        "function greet(name: string): string {\nreturn `Hello, ${name}!`;\n}\n\nconst message: string = greet(\"World\");\nconsole.log(message);",
        "npx tsc hello.ts",
        "function greet(name) {\nreturn \"Hello, \".concat(name, \"!\");\n}\n\nconst message = greet(\"World\");\nconsole.log(message);",
        "node hello.js",
        "Hello, World!",
        "node_modules",
        "tsconfig.json",
        "src/",
        "build/",
        "hello.ts",
        "hello.js",
        "src",
        "build"
      ]
    },
    {
      "title": "TypeScript Simple Types",
      "summary": "TypeScript enhances JavaScript by adding static types.\nJavaScript and TypeScript Primitives\nThe most basic types in TypeScript are called primitives.\nThese types form the building blocks of more complex types in your applications.\nTypeScript includes all JavaScript primitives plus additional type features.\nHere are the five primitive types you'll use most often:\nBoolean\nRepresents true/false values.\nUsed for flags, toggles, and conditions.\nExampleGet your own TypeScript Server\nNumber\nRepresents both integers and floating-point numbers.\nTypeScript uses the same number type for all numeric values.\nExample\nString\nRepresents text data.\nCan use single quotes ('), double quotes (\"), or backticks (`) for template literals.\nExample\nREMOVE ADS\nBigInt (ES2020+)\nRepresents whole numbers larger than 253 - 1.\nUse the n suffix to create a bigint.\nExample\nSymbol\nCreates unique identifiers.\nUseful for creating unique property keys and constants.\nExample",
      "examples": [
        "let isActive: boolean = true;\nlet hasPermission = false; // TypeScript infers 'boolean' type",
        "let decimal: number = 6;\nlet hex: number = 0xf00d;       // Hexadecimal\nlet binary: number = 0b1010;     // Binary\nlet octal: number = 0o744;      // Octal\nlet float: number = 3.14;      // Floating point",
        "let color: string = \"blue\";\nlet fullName: string = 'John Doe';\nlet age: number = 30;\nlet sentence: string = `Hello, my name is ${fullName} and I'll be ${age + 1} next year.`;",
        "const bigNumber: bigint = 9007199254740991n;\nconst hugeNumber = BigInt(9007199254740991); // Alternative syntax",
        "const uniqueKey: symbol = Symbol('description');\nconst obj = {\n[uniqueKey]: 'This is a unique property'\n};\nconsole.log(obj[uniqueKey]); // \"This is a unique property\"",
        "n"
      ]
    },
    {
      "title": "TypeScript Explicit Types and Inference",
      "summary": "Type Annotations and Inference\nTypeScript offers two ways to work with types:\nExplicit Typing: You explicitly declare the type of a variable\nType Inference: TypeScript automatically determines the type based on the assigned value\nWhen to Use Each Approach\nUse explicit types for:\nFunction parameters and return types\nObject literals\nWhen the initial value might not be the final type\nFunction parameters and return types\nObject literals\nWhen the initial value might not be the final type\nUse type inference for:\nSimple variable declarations with immediate assignment\nWhen the type is obvious from the context\nSimple variable declarations with immediate assignment\nWhen the type is obvious from the context\nExplicit Type Annotations\nExplicit typing means you tell TypeScript exactly what type a variable should be:\nBest Practice: Use explicit types for function parameters and return types to make your code more maintainable and self-documenting.\nType Inference\nTypeScript can automatically determine (infer) the type of a variable based on its initial value:\nNote: Type inference works best when variables are initialized at declaration.\nUninitialized variables have type 'any' by default unless you enable strictNullChecks in your tsconfig.json.\nWhen Inference Shines\nWatch Out: While type inference is convenient, being explicit with types can make your code more maintainable, especially in larger codebases or public APIs.\nREMOVE ADS\nType Safety in Action\nOne of TypeScript's main benefits is catching type-related errors during development.\nLet's look at how TypeScript helps prevent common mistakes.\nType Mismatch Errors\nJavaScript vs TypeScript\nIn JavaScript, the following code would run without errors, potentially causing bugs:\nTypeScript catches these issues at compile time:\nWhen TypeScript Can't Infer Types\nWhile TypeScript's type inference is powerful, there are cases where it can't determine the correct type.\nIn these situations, TypeScript falls back to the any type, which disables type checking.\nNote: any and other Special Types are covered in more detail in the next chapter.\nUsing any disables TypeScript's type checking.\nInstead, consider these alternatives:\nUse type annotations\nCreate interfaces for complex objects\nUse type guards for runtime type checking\nEnable noImplicitAny in your tsconfig.json",
      "examples": [
        "// String\ngreeting: string = \"Hello, TypeScript!\";\n\n// Number\nuserCount: number = 42;\n\n// Boolean\nisLoading: boolean = true;\n\n// Array of numbers\nscores: number[] = [100, 95, 98];",
        "// Function with explicit parameter and return types\nfunction greet(name: string): string {\nreturn `Hello, ${name}!`;\n}\n\n// TypeScript will ensure you pass the correct argument type\ngreet(\"Alice\"); // OK\ngreet(42);     // Error: Argument of type '42' is not assignable to parameter of type 'string'",
        "// TypeScript infers 'string'\nlet username = \"alice\";\n\n// TypeScript infers 'number'\nlet score = 100;\n\n// TypeScript infers 'boolean[]'\nlet flags = [true, false, true];\n\n// TypeScript infers return type as 'number'\nfunction add(a: number, b: number) {\nreturn a + b;\n}",
        "// TypeScript infers the shape of the object\nconst user = {\nname: \"Alice\",\nage: 30,\nisAdmin: true\n};\n\n// TypeScript knows these properties exist\nconsole.log(user.name);  // OK\nconsole.log(user.email); // Error: Property 'email' does not exist",
        "let username: string = \"alice\";\nusername = 42; // Error: Type 'number' is not assignable to type 'string'",
        "let score = 100;  // TypeScript infers 'number'\nscore = \"high\";  // Error: Type 'string' is not assignable to type 'number'",
        "// This is valid JavaScript but can lead to bugs\nfunction add(a, b) {\nreturn a + b;\n}\n\nconsole.log(add(\"5\", 3)); // Returns \"53\" (string concatenation)",
        "function add(a: number, b: number): number {\nreturn a + b;\n}\n\nconsole.log(add(\"5\", 3)); // Error: Argument of type 'string' is not assignable to parameter of type 'number'",
        "// 1. JSON.parse returns 'any' because the structure isn't known at compile time\nconst data = JSON.parse('{ \"name\": \"Alice\", \"age\": 30 }');\n\n// 2. Variables declared without initialization\nlet something;  // Type is 'any'\nsomething = 'hello';\nsomething = 42;  // No error",
        "strictNullChecks",
        "any",
        "noImplicitAny",
        "tsconfig.json"
      ]
    },
    {
      "title": "TypeScript Special Types",
      "summary": "TypeScript includes several special types that have specific behaviors in the type system.\nThese types are used in various scenarios to handle cases where the type might not be known in advance or when you need to work with JavaScript primitives in a type-safe way.\nNote: These special types are part of TypeScript's type system and help make your code more type-safe and self-documenting.\nType: any\nThe any type is the most flexible type in TypeScript.\nIt essentially tells the compiler to skip type checking for a particular variable.\nWhile this can be useful in certain situations, it should be used sparingly as it bypasses TypeScript's type safety features.\nWhen to use any:\nWhen migrating JavaScript code to TypeScript\nWhen working with dynamic content where the type is unknown\nWhen you need to opt out of type checking for a specific case\nThe example below does not use any and will throw an error:\nExample without anyGet your own TypeScript Server\nSetting a variable to the special type any disables type checking:\nExample with any\nany can be a useful way to get past errors since it disables type checking, but TypeScript will not be able to provide type safety, and tools which rely on type data, such as auto completion, will not work.\nRemember, it should be avoided at \"any\" cost...\nREMOVE ADS\nType: unknown\nThe unknown type is a type-safe counterpart of any.\nIt's the type-safe way to say \"this could be anything, so you must perform some type of checking before you use it\".\nKey differences between unknown and any:\nunknown must be type-checked before use\nYou can't access properties on an unknown type without type assertion\nYou can't call or construct values of type unknown\nTypeScript will prevent unknown types from being used without proper type checking, as shown in the example below:\nExample\nWhen to use unknown:\nWhen working with data from external sources (APIs, user input, etc.)\nWhen you want to ensure type safety while still allowing flexibility\nWhen migrating from JavaScript to TypeScript in a type-safe way\nType narrowing with unknown:\nYou can narrow down the type of an unknown value using type guards:\nType: never\nThe never type represents the type of values that never occur.\nIt's used to indicate that something never happens or should never happen.\nCommon use cases for never:\nFunctions that never return (always throw an error or enter an infinite loop)\nType guards that never pass type checking\nExhaustiveness checking in discriminated unions\nExamples of never in action:\nWhen to use never:\nFor functions that will never return a value\nIn type guards that should never match\nFor exhaustive type checking in switch statements\nIn generic types to indicate certain cases are impossible\nType: undefined & null\nIn TypeScript, both undefined and null have their own types, just like string or number.\nBy default, these types can be assigned to any other type, but this can be changed with TypeScript's strict null checks.\nKey points about undefined and null:\nundefined means a variable has been declared but not assigned a value\nnull is an explicit assignment that represents no value or no object\nIn TypeScript, both have their own types: undefined and null respectively\nWith strictNullChecks enabled, you must explicitly handle these types\nBasic Usage\nOptional Parameters and Properties\nNullish Coalescing and Optional Chaining\nImportant: These types are most useful when strictNullChecks is enabled in your tsconfig.json file.\nThis ensures that null and undefined are only assignable to themselves and any.\nTo enable strict null checks, add this to your tsconfig.json:",
      "examples": [
        "let u = true;\nu = \"string\"; // Error: Type 'string' is not assignable to type 'boolean'.\nMath.round(u); // Error: Argument of type 'boolean' is not assignable to parameter of type 'number'.",
        "let v: any = true;\nv = \"string\"; // no error as it can be \"any\" type\nMath.round(v); // no error as it can be \"any\" type",
        "let w: unknown = 1;\nw = \"string\"; // no error\nw = {\nrunANonExistentMethod: () => {\nconsole.log(\"I think therefore I am\");\n}\n} as { runANonExistentMethod: () => void}\n// How can we avoid the error for the code commented out below when we don't know the type?\n// w.runANonExistentMethod(); // Error: Object is of type 'unknown'.\nif(typeof w === 'object' && w !== null) {\n(w as { runANonExistentMethod: Function }).runANonExistentMethod();\n}\n// Although we have to cast multiple times we can do a check in the if to secure our type and have a safer casting",
        "function processValue(value: unknown) {\nif (typeof value === 'string') {\n// value is now treated as string\nconsole.log(value.toUpperCase());\n} else if (Array.isArray(value)) {\n// value is now treated as any[]\nconsole.log(value.length);\n}\n}",
        "function throwError(message: string): never {\nthrow new Error(message);\n}",
        "type Shape = Circle | Square | Triangle;\n\nfunction getArea(shape: Shape): number {\nswitch (shape.kind) {\ncase 'circle':\nreturn Math.PI * shape.radius ** 2;\ncase 'square':\nreturn shape.sideLength ** 2;\ndefault:\n// TypeScript knows this should never happen\nconst _exhaustiveCheck: never = shape;\nreturn _exhaustiveCheck;\n}\n}",
        "let x: never = true; // Error: Type 'boolean' is not assignable to type 'never'.",
        "let y: undefined = undefined;\nlet z: null = null;",
        "// Optional parameter (implicitly `string | undefined`)\nfunction greet(name?: string) {\nreturn `Hello, ${name || 'stranger'}`;\n}\n\n// Optional property in an interface\ninterface User {\nname: string;\nage?: number; // Same as `number | undefined` }",
        "// Nullish coalescing (??) - only uses default if value is null or undefined\nconst value = input ?? 'default';\n\n// Optional chaining (?.) - safely access nested properties\nconst street = user?.address?.street;",
        "{\n\"compilerOptions\": {\n\"strictNullChecks\": true\n}\n}",
        "any",
        "unknown",
        "never",
        "undefined",
        "null",
        "string",
        "number",
        "strictNullChecks",
        "tsconfig.json"
      ]
    },
    {
      "title": "TypeScript Arrays",
      "summary": "TypeScript has a specific syntax for typing arrays.\nRead more about arrays in our JavaScript Array chapter.\nExampleGet your own TypeScript Server\nReadonly\nThe readonly keyword can prevent arrays from being changed.\nExample\nType Inference\nTypeScript can infer the type of an array if it has values.\nExample",
      "examples": [
        "const names: string[] = [];\nnames.push(\"Dylan\"); // no error\n// names.push(3); // Error: Argument of type 'number' is not assignable to parameter of type 'string'.",
        "const names: readonly string[] = [\"Dylan\"];\nnames.push(\"Jack\"); // Error: Property 'push' does not exist on type 'readonly string[]'.\n// try removing the readonly modifier and see if it works?",
        "const numbers = [1, 2, 3]; // inferred to type number[]\nnumbers.push(4); // no error\n// comment line below out to see the successful assignment\nnumbers.push(\"2\"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.\nlet head: number = numbers[0]; // no error",
        "readonly"
      ]
    },
    {
      "title": "TypeScript Tuples",
      "summary": "Typed Arrays\nA tuple is a typed array with a pre-defined length and types for each index.\nTuples are great because they allow each element in the array to be a known type of value.\nTo define a tuple, specify the type of each element in the array:\nExampleGet your own TypeScript Server\nAs you can see we have a number, boolean and a string.\nBut what happens if we try to set them in the wrong order:\nExample\nEven though we have a boolean, string, and number the order matters in our tuple and will throw an error.\nReadonly Tuple\nA good practice is to make your tuple readonly.\nTuples only have strongly defined types for the initial values:\nExample\nYou can see the new value.\nTuples only have strongly defined types for the initial values:\nExample\nTo learn more about access modifiers like readonly go to our section on them here: TypeScript Classes.\nIf you have ever used React before you have worked with tuples more than likely.\nuseState returns a tuple of the value and a setter function.\nconst [firstName, setFirstName] = useState('Dylan') is a common example.\nBecause of the structure we know our first value in our list will be a certain value type in this case a string and the second value a function.\nREMOVE ADS\nNamed Tuples\nNamed tuples allow us to provide context for our values at each index.\nExample\nNamed tuples provide more context for what our index values represent.\nDestructuring Tuples\nSince tuples are arrays we can also destructure them.\nExample\nTo review destructuring check it out here.",
      "examples": [
        "// define our tuple\nlet ourTuple: [number, boolean, string];\n\n// initialize correctly\nourTuple = [5, false, 'Coding God was here'];",
        "// define our tuple\nlet ourTuple: [number, boolean, string];\n\n// initialized incorrectly which throws an error\nourTuple = [false, 'Coding God was mistaken', 5];",
        "// define our tuple\nlet ourTuple: [number, boolean, string];\n// initialize correctly\nourTuple = [5, false, 'Coding God was here'];\n// We have no type safety in our tuple for indexes 3+\nourTuple.push('Something new and wrong');\nconsole.log(ourTuple);",
        "// define our readonly tuple\nconst ourReadonlyTuple: readonly [number, boolean, string] = [5, true, 'The Real Coding God'];\n// throws error as it is readonly.\nourReadonlyTuple.push('Coding God took a day off');",
        "const graph: [x: number, y: number] = [55.2, 41.3];",
        "const graph: [number, number] = [55.2, 41.3];\nconst [x, y] = graph;",
        "boolean",
        "string",
        "number",
        "readonly",
        "useState",
        "const [firstName, setFirstName] = useState('Dylan')",
        "function"
      ]
    },
    {
      "title": "TypeScript Object Types",
      "summary": "TypeScript has a specific syntax for typing objects.\nRead more about objects in our JavaScript Objects chapter.\nExampleGet your own TypeScript Server\nObject types like this can also be written separately, and even be reused, look at interfaces for more details.\nREMOVE ADS\nType Inference\nTypeScript can infer the types of properties based on their values.\nExample\nOptional Properties\nOptional properties are properties that don't have to be defined in the object definition.\nExample without an optional property\nExample with an optional property\nIndex Signatures\nIndex signatures can be used for objects without a defined list of properties.\nExample\nIndex signatures like this one can also be expressed with utility types like Record<string, number>.\nLearn more about utility types like this in our TypeScript Utility Types chapter.",
      "examples": [
        "const car: { type: string, model: string, year: number } = {\ntype: \"Toyota\",\nmodel: \"Corolla\",\nyear: 2009\n};",
        "const car = {\ntype: \"Toyota\",\n};\ncar.type = \"Ford\"; // no error\ncar.type = 2; // Error: Type 'number' is not assignable to type 'string'.",
        "const car: { type: string, mileage: number } = { // Error: Property 'mileage' is missing in type '{ type: string; }' but required in type '{ type: string; mileage: number; }'.\ntype: \"Toyota\",\n};\ncar.mileage = 2000;",
        "const car: { type: string, mileage?: number } = { // no error\ntype: \"Toyota\"\n};\ncar.mileage = 2000;",
        "const nameAgeMap: { [index: string]: number } = {};\nnameAgeMap.Jack = 25; // no error\nnameAgeMap.Mark = \"Fifty\"; // Error: Type 'string' is not assignable to type 'number'.",
        "Record<string, number>"
      ]
    },
    {
      "title": "TypeScript Enums",
      "summary": "An enum is a special \"class\" that represents a group of constants (unchangeable variables).\nEnums come in two flavors string and numeric.\nLet's start with numeric.\nNumeric Enums - Default\nBy default, enums will initialize the first value to 0 and add 1 to each additional value:\nExampleGet your own TypeScript Server\nREMOVE ADS\nNumeric Enums - Initialized\nYou can set the value of the first numeric enum and have it auto increment from that:\nExample\nNumeric Enums - Fully Initialized\nYou can assign unique number values for each enum value.\nThen the values will not be incremented automatically:\nExample\nString Enums\nEnums can also contain strings.\nThis is more common than numeric enums, because of their readability and intent.\nExample\nTechnically, you can mix and match string and numeric enum values, but it is recommended not to do so.",
      "examples": [
        "enum CardinalDirections {\nNorth,\nEast,\nSouth,\nWest\n}\nlet currentDirection = CardinalDirections.North;\n// logs 0\nconsole.log(currentDirection);\n// throws error as 'North' is not a valid enum\ncurrentDirection = 'North'; // Error: \"North\" is not assignable to type 'CardinalDirections'.",
        "enum CardinalDirections {\nNorth = 1,\nEast,\nSouth,\nWest\n}\n// logs 1\nconsole.log(CardinalDirections.North);\n// logs 4\nconsole.log(CardinalDirections.West);",
        "enum StatusCodes {\nNotFound = 404,\nSuccess = 200,\nAccepted = 202,\nBadRequest = 400\n}\n// logs 404\nconsole.log(StatusCodes.NotFound);\n// logs 200\nconsole.log(StatusCodes.Success);",
        "enum CardinalDirections {\nNorth = 'North',\nEast = \"East\",\nSouth = \"South\",\nWest = \"West\"\n};\n// logs \"North\"\nconsole.log(CardinalDirections.North);\n// logs \"West\"\nconsole.log(CardinalDirections.West);",
        "string",
        "numeric",
        "0",
        "strings"
      ]
    },
    {
      "title": "TypeScript Type Aliases and Interfaces",
      "summary": "TypeScript allows types to be defined separately from the variables that use them.\nAliases and Interfaces allows types to be easily shared between different variables/objects.\nType Aliases\nType Aliases allow defining types with a custom name (an Alias).\nType Aliases can be used for primitives like string or more complex types such as objects and arrays:\nExampleGet your own TypeScript Server\nExample: Union and Intersection Types\nInterfaces\nInterfaces are similar to type aliases, except they only apply to object types.\nExample\nExample: Interface Merging\nType vs Interface: Key Differences\nExtending: Both can be extended, but interfaces support declaration merging.\nUnions/Intersections: Only type aliases support union and intersection types.\nImplements: Classes can implement either.\nRecommendation: Use interface for objects, type for everything else.\nBest Practices:\nUse interface for defining object shapes and public APIs.\nUse type for unions, intersections, and primitives.\nFavor composition over inheritance for types.\nDocument your types and interfaces for clarity.\nCommon Pitfalls:\nUsing type when you need declaration merging (use interface).\nOvercomplicating types—keep them simple and focused.\nForgetting to update types/interfaces as code evolves.\nREMOVE ADS\nExtending Interfaces\nInterfaces can extend each other's definition.\nExtending an interface means you are creating a new interface with the same properties as the original, plus something new.\nExample",
      "examples": [
        "type CarYear = number\ntype CarType = string\ntype CarModel = string\ntype Car = {\nyear: CarYear,\ntype: CarType,\nmodel: CarModel\n}\n\nconst carYear: CarYear = 2001\nconst carType: CarType = \"Toyota\"\nconst carModel: CarModel = \"Corolla\"\nconst car: Car = {\nyear: carYear,\ntype: carType,\nmodel: carModel\n};",
        "type Animal = { name: string };\ntype Bear = Animal & { honey: boolean };\nconst bear: Bear = { name: \"Winnie\", honey: true };\n\ntype Status = \"success\" | \"error\";\nlet response: Status = \"success\";",
        "interface Rectangle {\nheight: number,\nwidth: number\n}\n\nconst rectangle: Rectangle = {\nheight: 20,\nwidth: 10\n};",
        "interface Animal { name: string; } interface Animal { age: number; } const dog: Animal = { name: \"Fido\", age: 5 };",
        "interface Rectangle {\nheight: number,\nwidth: number\n}\n\ninterface ColoredRectangle extends Rectangle {\ncolor: string\n}\n\nconst coloredRectangle: ColoredRectangle = {\nheight: 20,\nwidth: 10,\ncolor: \"red\"\n};",
        "string",
        "objects",
        "arrays",
        "object",
        "interface",
        "type"
      ]
    },
    {
      "title": "TypeScript Union Types",
      "summary": "Union types are used when a value can be more than a single type.\nSuch as when a property would be string or number.\nUnion | (OR)\nUsing the | we are saying our parameter is a string or number:\nExampleGet your own TypeScript Server\nREMOVE ADS\nUnion Type Errors\nNote: you need to know what your type is when union types are being used to avoid type errors:\nExample\nIn our example we are having an issue invoking toUpperCase() as its a string method and number doesn't have access to it.",
      "examples": [
        "function printStatusCode(code: string | number) {\nconsole.log(`My status code is ${code}.`)\n}\nprintStatusCode(404);\nprintStatusCode('404');",
        "function printStatusCode(code: string | number) {\nconsole.log(`My status code is ${code.toUpperCase()}.`) // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number'\n}",
        "string",
        "number",
        "|",
        "toUpperCase()"
      ]
    },
    {
      "title": "TypeScript Functions",
      "summary": "TypeScript has a specific syntax for typing function parameters and return values.\nRead more about functions here.\nReturn Type\nThe type of the value returned by the function can be explicitly defined.\nExampleGet your own TypeScript Server\nIf no return type is defined, TypeScript will attempt to infer it through the types of the variables or expressions returned.\nREMOVE ADS\nVoid Return Type\nThe type void can be used to indicate a function doesn't return any value.\nExample\nParameters\nFunction parameters are typed with a similar syntax as variable declarations.\nExample\nIf no parameter type is defined, TypeScript will default to using any, unless additional type information is available as shown in the Default Parameters and Type Alias sections below.\nOptional Parameters\nBy default TypeScript will assume all parameters are required, but they can be explicitly marked as optional.\nExample\nDefault Parameters\nFor parameters with default values, the default value goes after the type annotation:\nExample\nTypeScript can also infer the type from the default value.\nNamed Parameters\nTyping named parameters follows the same pattern as typing normal parameters.\nExample\nRest Parameters\nRest parameters can be typed like normal parameters, but the type must be an array as rest parameters are always arrays.\nExample\nType Alias\nFunction types can be specified separately from functions with type aliases.\nThese types are written similarly to arrow functions, read more about arrow functions here.\nExample",
      "examples": [
        "// the `: number` here specifies that this function returns a number\nfunction getTime(): number {\nreturn new Date().getTime();\n}",
        "function printHello(): void {\nconsole.log('Hello!');\n}",
        "function multiply(a: number, b: number) {\nreturn a * b;\n}",
        "// the `?` operator here marks parameter `c` as optional\nfunction add(a: number, b: number, c?: number) {\nreturn a + b + (c || 0);\n}",
        "function pow(value: number, exponent: number = 10) {\nreturn value ** exponent;\n}",
        "function divide({ dividend, divisor }: { dividend: number, divisor: number }) {\nreturn dividend / divisor;\n}",
        "function add(a: number, b: number, ...rest: number[]) {\nreturn a + b + rest.reduce((p, c) => p + c, 0);\n}",
        "type Negate = (value: number) => number;\n\n// in this function, the parameter `value` automatically gets assigned the type `number` from the type `Negate`\nconst negateFunction: Negate = (value) => value * -1;",
        "void",
        "any"
      ]
    },
    {
      "title": "TypeScript Casting",
      "summary": "There are times when working with types where it's necessary to override the type of a variable, such as when incorrect types are provided by a library.\nCasting is the process of overriding a type.\nCasting with as\nA straightforward way to cast a variable is using the as keyword, which will directly change the type of the given variable.\nExampleGet your own TypeScript Server\nCasting doesn't actually change the type of the data within the variable, for example the following code will not work as expected since the variable x still holds a number.\nTypeScript will still attempt to typecheck casts to prevent casts that don't seem correct, for example the following will throw a type error since TypeScript knows casting a string to a number doesn't make sense without converting the data:\nREMOVE ADS\nCasting with <>\nUsing <> works the same as casting with as.\nExample\nThis type of casting will not work with TSX, such as when working on React files.\nForce casting\nTo override type errors that TypeScript may throw when casting, first cast to unknown, then to the target type.\nExample",
      "examples": [
        "let x: unknown = 'hello';\nconsole.log((x as string).length);",
        "let x: unknown = 4;\nconsole.log((x as string).length); // prints undefined since numbers don't have a length",
        "console.log((4 as string).length); // Error: Conversion of type 'number' to type 'string' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.",
        "let x: unknown = 'hello';\nconsole.log((<string>x).length);",
        "let x = 'hello';\nconsole.log(((x as unknown) as number).length); // x is not actually a number so this will return undefined",
        "as",
        "x",
        "<>",
        "unknown"
      ]
    },
    {
      "title": "TypeScript Classes",
      "summary": "TypeScript adds types and visibility modifiers to JavaScript classes.\nLearn more about JavaScript classes here.\nMembers: Types\nThe members of a class (properties & methods) are typed using type annotations, similar to variables.\nExampleGet your own TypeScript Server\nREMOVE ADS\nMembers: Visibility\nClass members can also be given special modifiers that affect visibility.\nThere are three main visibility modifiers in TypeScript.\npublic - (default) allows access to the class member from anywhere\nprivate - only allows access to the class member from within the class\nprotected - allows access to the class member from itself and any classes that inherit it, which is covered in the inheritance section below\nExample\nParameter Properties\nTypeScript provides a convenient way to define class members in the constructor, by adding a visibility modifier to the parameter.\nExample\nReadonly\nSimilar to arrays, the readonly keyword can prevent class members from being changed.\nExample\nInheritance: Implements\nInterfaces (covered here) can be used to define the type a class must follow through the implements keyword.\nExample\nInheritance: Extends\nClasses can extend each other through the extends keyword.\nA class can only extend one other class.\nExample\nOverride\nWhen a class extends another class, it can replace the members of the parent class with the same name.\nNewer versions of TypeScript allow explicitly marking this with the override keyword.\nExample\nBy default the override keyword is optional when overriding a method, and only helps to prevent accidentally overriding a method that does not exist.\nUse the setting noImplicitOverride to force it to be used when overriding.\nAbstract Classes\nClasses can be written in a way that allows them to be used as a base class for other classes without having to implement all the members.\nThis is done by using the abstract keyword.\nMembers that are left unimplemented also use the abstract keyword.\nExample",
      "examples": [
        "class Person {\nname: string;\n}\n\nconst person = new Person();\nperson.name = \"Jane\";",
        "class Person {\nprivate name: string;\n\npublic constructor(name: string) {\nthis.name = name;\n}\n\npublic getName(): string {\nreturn this.name;\n}\n}\n\nconst person = new Person(\"Jane\");\nconsole.log(person.getName()); // person.name isn't accessible from outside the class since it's private",
        "class Person {\n// name is a private member variable\npublic constructor(private name: string) {}\n\npublic getName(): string {\nreturn this.name;\n}\n}\n\nconst person = new Person(\"Jane\");\nconsole.log(person.getName());",
        "class Person {\nprivate readonly name: string;\n\npublic constructor(name: string) {\n// name cannot be changed after this initial definition, which has to be either at its declaration or in the constructor.\nthis.name = name;\n}\n\npublic getName(): string {\nreturn this.name;\n}\n}\n\nconst person = new Person(\"Jane\");\nconsole.log(person.getName());",
        "interface Shape {\ngetArea: () => number;\n}\n\nclass Rectangle implements Shape {\npublic constructor(protected readonly width: number, protected readonly height: number) {}\n\npublic getArea(): number {\nreturn this.width * this.height;\n}\n}",
        "interface Shape {\ngetArea: () => number;\n}\n\nclass Rectangle implements Shape {\npublic constructor(protected readonly width: number, protected readonly height: number) {}\n\npublic getArea(): number {\nreturn this.width * this.height;\n}\n}\n\nclass Square extends Rectangle {\npublic constructor(width: number) {\nsuper(width, width);\n}\n\n// getArea gets inherited from Rectangle\n}",
        "interface Shape {\ngetArea: () => number;\n}\n\nclass Rectangle implements Shape {\n// using protected for these members allows access from classes that extend from this class, such as Square\npublic constructor(protected readonly width: number, protected readonly height: number) {}\n\npublic getArea(): number {\nreturn this.width * this.height;\n}\n\npublic toString(): string {\nreturn `Rectangle[width=${this.width}, height=${this.height}]`;\n}\n}\n\nclass Square extends Rectangle {\npublic constructor(width: number) {\nsuper(width, width);\n}\n\n// this toString replaces the toString from Rectangle\npublic override toString(): string {\nreturn `Square[width=${this.width}]`;\n}\n}",
        "abstract class Polygon {\npublic abstract getArea(): number;\n\npublic toString(): string {\nreturn `Polygon[area=${this.getArea()}]`;\n}\n}\n\nclass Rectangle extends Polygon {\npublic constructor(protected readonly width: number, protected readonly height: number) {\nsuper();\n}\n\npublic getArea(): number {\nreturn this.width * this.height;\n}\n}",
        "public",
        "private",
        "protected",
        "this",
        "readonly",
        "implements",
        "class Rectangle implements Shape, Colored {",
        "extends",
        "override",
        "noImplicitOverride",
        "abstract"
      ]
    },
    {
      "title": "TypeScript Basic Generics",
      "summary": "Generics allow creating 'type variables' which can be used to create classes, functions & type aliases that don't need to explicitly define the types that they use.\nGenerics make it easier to write reusable code.\nFunctions\nGenerics with functions help create more general functions that accurately represent the input and return types.\nExampleGet your own TypeScript Server\nTypeScript can also infer the type of the generic parameter from the function parameters.\nClasses\nGenerics can be used to create generalized classes, like Map.\nExample\nTypeScript can also infer the type of the generic parameter if it's used in a constructor parameter.\nREMOVE ADS\nType Aliases\nGenerics in type aliases allow creating types that are more reusable.\nExample\nThis also works with interfaces with the following syntax: interface Wrapped<T> {\nDefault Value\nGenerics can be assigned default values which apply if no other value is specified or inferred.\nExample\nExtends\nConstraints can be added to generics to limit what's allowed.\nThe constraints make it possible to rely on a more specific type when using the generic type.\nExample\nThis can be combined with a default value.",
      "examples": [
        "function createPair<S, T>(v1: S, v2: T): [S, T] {\nreturn [v1, v2];\n}\nconsole.log(createPair<string, number>('hello', 42)); // ['hello', 42]",
        "class NamedValue<T> {\nprivate _value: T | undefined;\n\nconstructor(private name: string) {}\n\npublic setValue(value: T) {\nthis._value = value;\n}\n\npublic getValue(): T | undefined {\nreturn this._value;\n}\n\npublic toString(): string {\nreturn `${this.name}: ${this._value}`;\n}\n}\n\nlet value = new NamedValue<number>('myNumber');\nvalue.setValue(10);\nconsole.log(value.toString()); // myNumber: 10",
        "type Wrapped<T> = { value: T };\n\nconst wrappedValue: Wrapped<number> = { value: 10 };",
        "class NamedValue<T = string> {\nprivate _value: T | undefined;\n\nconstructor(private name: string) {}\n\npublic setValue(value: T) {\nthis._value = value;\n}\n\npublic getValue(): T | undefined {\nreturn this._value;\n}\n\npublic toString(): string {\nreturn `${this.name}: ${this._value}`;\n}\n}\n\nlet value = new NamedValue('myNumber');\nvalue.setValue('myValue');\nconsole.log(value.toString()); // myNumber: myValue",
        "function createLoggedPair<S extends string | number, T extends string | number>(v1: S, v2: T): [S, T] {\nconsole.log(`creating pair: v1='${v1}', v2='${v2}'`);\nreturn [v1, v2];\n}",
        "interface Wrapped<T> {"
      ]
    },
    {
      "title": "TypeScript Utility Types",
      "summary": "TypeScript comes with a large number of types that can help with some common type manipulation, usually referred to as utility types.\nThis chapter covers the most popular utility types.\nPartial\nPartial changes all the properties in an object to be optional.\nExampleGet your own TypeScript Server\nREMOVE ADS\nRequired\nRequired changes all the properties in an object to be required.\nExample\nRecord\nRecord is a shortcut to defining an object type with a specific key type and value type.\nExample\nRecord<string, number> is equivalent to { [key: string]: number }\nOmit\nOmit removes keys from an object type.\nExample\nPick\nPick removes all but the specified keys from an object type.\nExample\nExclude\nExclude removes types from a union.\nExample\nReturnType\nReturnType extracts the return type of a function type.\nExample\nParameters\nParameters extracts the parameter types of a function type as an array.\nExample\nReadonly\nReadonly is used to create a new type where all properties are readonly, meaning they cannot be modified once assigned a value.\nKeep in mind TypeScript will prevent this at compile time, but in theory since it is compiled down to JavaScript you can still override a readonly property.\nExample",
      "examples": [
        "interface Point {\nx: number;\ny: number;\n}\n\nlet pointPart: Partial<Point> = {}; // `Partial` allows x and y to be optional\npointPart.x = 10;",
        "interface Car {\nmake: string;\nmodel: string;\nmileage?: number;\n}\n\nlet myCar: Required<Car> = {\nmake: 'Ford',\nmodel: 'Focus',\nmileage: 12000 // `Required` forces mileage to be defined\n};",
        "const nameAgeMap: Record<string, number> = {\n'Alice': 21,\n'Bob': 25\n};",
        "interface Person {\nname: string;\nage: number;\nlocation?: string;\n}\n\nconst bob: Omit<Person, 'age' | 'location'> = {\nname: 'Bob'\n// `Omit` has removed age and location from the type and they can't be defined here\n};",
        "interface Person {\nname: string;\nage: number;\nlocation?: string;\n}\n\nconst bob: Pick<Person, 'name'> = {\nname: 'Bob'\n// `Pick` has only kept name, so age and location were removed from the type and they can't be defined here\n};",
        "type Primitive = string | number | boolean\nconst value: Exclude<Primitive, string> = true; // a string cannot be used here since Exclude removed it from the type.",
        "type PointGenerator = () => { x: number; y: number; };\nconst point: ReturnType<PointGenerator> = {\nx: 10,\ny: 20\n};",
        "type PointPrinter = (p: { x: number; y: number; }) => void;\nconst point: Parameters<PointPrinter>[0] = {\nx: 10,\ny: 20\n};",
        "interface Person {\nname: string;\nage: number;\n}\nconst person: Readonly<Person> = {\nname: \"Dylan\",\nage: 35,\n};\nperson.name = 'Israel'; // prog.ts(11,8): error TS2540: Cannot assign to 'name' because it is a read-only property.",
        "Partial",
        "Required",
        "Record",
        "Record<string, number>",
        "{ [key: string]: number }",
        "Omit",
        "Pick",
        "Exclude",
        "ReturnType",
        "Parameters",
        "Readonly"
      ]
    },
    {
      "title": "TypeScript Keyof",
      "summary": "keyof is a keyword in TypeScript which is used to extract the key type from an object type.\nkeyof with explicit keys\nWhen used on an object type with explicit keys, keyof creates a union type with those keys.\nExampleGet your own TypeScript Server\nREMOVE ADS\nkeyof with index signatures\nkeyof can also be used with index signatures to extract the index type.\nExample",
      "examples": [
        "interface Person {\nname: string;\nage: number;\n}\n// `keyof Person` here creates a union type of \"name\" and \"age\", other strings will not be allowed\nfunction printPersonProperty(person: Person, property: keyof Person) {\nconsole.log(`Printing person property ${property}: \"${person[property]}\"`);\n}\nlet person = {\nname: \"Max\",\nage: 27\n};\nprintPersonProperty(person, \"name\"); // Printing person property name: \"Max\"",
        "type StringMap = { [key: string]: unknown };\n// `keyof StringMap` resolves to `string` here\nfunction createStringPair(property: keyof StringMap, value: string): StringMap {\nreturn { [property]: value };\n}",
        "keyof"
      ]
    },
    {
      "title": "TypeScript Null & Undefined",
      "summary": "TypeScript has a powerful system to deal with null or undefined values.\nBy default null and undefined handling is disabled, and can be enabled by setting strictNullChecks to true.\nThe rest of this page applies for when strictNullChecks is enabled.\nTypes\nnull and undefined are primitive types and can be used like other types, such as string.\nExampleGet your own TypeScript Server\nWhen strictNullChecks is enabled, TypeScript requires values to be set unless undefined is explicitly added to the type.\nREMOVE ADS\nOptional Chaining\nOptional chaining is a JavaScript feature that works well with TypeScript's null handling.\nIt allows accessing properties on an object that may or may not exist, using compact syntax.\nIt can be used with the ?. operator when accessing properties.\nExample\nNullish Coalescing\nNullish coalescing is another JavaScript feature that also works well with TypeScript's null handling.\nIt allows writing expressions that have a fallback specifically when dealing with null or undefined.\nThis is useful when other falsy values can occur in the expression but are still valid.\nIt can be used with the ?? operator in an expression, similar to using the && operator.\nExample\nNull Assertion\nTypeScript's inference system isn't perfect, there are times when it makes sense to ignore a value's possibility of being null or undefined.\nAn easy way to do this is to use casting, but TypeScript also provides the ! operator as a convenient shortcut.\nExample\nJust like casting, this can be unsafe and should be used with care.\nArray Bounds Handling\nEven with strictNullChecks enabled, by default TypeScript assumes array access will never return undefined (unless undefined is part of the array type).\nThe config noUncheckedIndexedAccess can be used to change this behavior.\nExample",
      "examples": [
        "let value: string | undefined | null = null;\nvalue = 'hello';\nvalue = undefined;",
        "interface House {\nsqft: number;\nyard?: {\nsqft: number;\n};\n}\nfunction printYardSize(house: House) {\nconst yardSize = house.yard?.sqft;\nif (yardSize === undefined) {\nconsole.log('No yard');\n} else {\nconsole.log(`Yard is ${yardSize} sqft`);\n}\n}\n\nlet home: House = {\nsqft: 500\n};\n\nprintYardSize(home); // Prints 'No yard'",
        "function printMileage(mileage: number | null | undefined) {\nconsole.log(`Mileage: ${mileage ?? 'Not Available'}`);\n}\n\nprintMileage(null); // Prints 'Mileage: Not Available'\nprintMileage(0); // Prints 'Mileage: 0'",
        "function getValue(): string | undefined {\nreturn 'hello';\n}\nlet value = getValue();\nconsole.log('value length: ' + value!.length);",
        "let array: number[] = [1, 2, 3];\nlet value = array[0]; // with `noUncheckedIndexedAccess` this has the type `number | undefined`",
        "null",
        "undefined",
        "strictNullChecks",
        "string",
        "?.",
        "??",
        "&&",
        "!",
        "noUncheckedIndexedAccess"
      ]
    },
    {
      "title": "TypeScript Definitely Typed",
      "summary": "NPM packages in the broad JavaScript ecosystem don't always have types available.\nSometimes the projects are no longer maintained, and other times they aren't interested in, agree with, or have time to use TypeScript.\nUsing non-typed NPM packages in TypeScript\nUsing untyped NPM packages with TypeScript is not type-safe because types are missing.\nTo help TypeScript developers use such packages, there is a community-maintained project called Definitely Typed.\nDefinitely Typed is a project that provides a central repository of TypeScript definitions for NPM packages which do not have types.\nExampleGet your own TypeScript Server\nREMOVE ADS\nUsually, no other steps are needed after installing the declaration package.\nTypeScript will automatically pick up the types when you use the package.\nEditors such as Visual Studio Code will often suggest installing packages like these when types are missing.",
      "examples": [
        "npm install --save-dev @types/jquery"
      ]
    },
    {
      "title": "TypeScript 5.x Updates",
      "summary": "TypeScript is actively maintained and updated by Microsoft.\nIn version 5.x a lot of utility and quality of life updates were made.\nThis chapter covers the most popular updates to allow stricter and more flexible type safety.\nAs a reminder these features will only be available in 5.x+\nTemplate Literal Types\nTemplate Literal Types now allows us to create more precise types using template literals.\nWe can define custom types that depend on the actual values of strings at compile time.\nExampleGet your own TypeScript Server\nREMOVE ADS\nIndex Signature Labels\nIndex Signature Labels allows us to label index signatures using computed property names.\nIt helps in providing more descriptive type information when working with dynamic objects.\nExample\n5.x also now supports native JavaScript private fields.\nThe TypeScript 'private' still works as discussed in Classes section.",
      "examples": [
        "type Color = \"red\" | \"green\" | \"blue\";\ntype HexColor<T extends Color> = `#${string}`;\n\n// Usage:\nlet myColor: HexColor<\"blue\"> = \"#0000FF\";",
        "type DynamicObject = { [key: `dynamic_${string}`]: string };\n\n// Usage:\nlet obj: DynamicObject = { dynamic_key: \"value\" };",
        "Template Literal Types",
        "Index Signature Labels"
      ]
    },
    {
      "title": "TypeScript Configuration",
      "summary": "Introduction\nThe tsconfig.json file is the heart of every TypeScript project.\nIt tells the TypeScript compiler how to process your code, which files to include, and which features to enable or disable.\nA well-configured tsconfig.json ensures a smooth developer experience and reliable builds.\nKey Concepts & Explanations\ncompilerOptions: Controls how TypeScript compiles your code (e.g., target, module, strictness).\ninclude: Files or folders to include in the compilation.\nexclude: Files or folders to exclude.\nfiles: Explicit list of files to include (rarely used with include).\nextends: Inherit options from another config file.\nreferences: Enable project references for monorepos or multi-package setups.\nStep-by-Step Examples\nMinimal tsconfig.jsonGet your own TypeScript Server\nAdvanced tsconfig.json\nTo generate a tsconfig.json file, run:\nExample\nREMOVE ADS\nReal-World Scenarios\nMonorepo: Use references and extends to share settings across packages.\nLibrary: Set declaration and outDir for type definitions.\nApp: Use strict and esModuleInterop for best compatibility.\nCommon Pitfalls & Troubleshooting\nMisconfigured include/exclude can cause files to be missed or included unexpectedly.\nPaths not resolving? Check baseUrl and paths settings.\nType errors after changing strict? Review your code for type safety.\nBest Practices\nAlways enable strict for safer code.\nUse extends to avoid duplicating config in monorepos or multiple projects.\nDo not commit build output folders (like dist) to version control.",
      "examples": [
        "{\n\"compilerOptions\": {\n\"target\": \"es6\",\n\"module\": \"commonjs\"\n},\n\"include\": [\"src/**/*\"]\n}",
        "{\n\"compilerOptions\": {\n\"target\": \"es2020\",\n\"module\": \"esnext\",\n\"strict\": true,\n\"baseUrl\": \".\",\n\"paths\": {\n\"@app/*\": [\"src/app/*\"]\n},\n\"outDir\": \"dist\",\n\"esModuleInterop\": true\n},\n\"include\": [\"src\"],\n\"exclude\": [\"node_modules\", \"dist\"]\n}",
        "tsc --init",
        "tsconfig.json",
        "include",
        "references",
        "extends",
        "declaration",
        "outDir",
        "strict",
        "esModuleInterop",
        "exclude",
        "baseUrl",
        "paths",
        "dist"
      ]
    },
    {
      "title": "TypeScript with Node.js",
      "summary": "Why Use TypeScript with Node.js?\nTypeScript brings static typing to Node.js development, providing better tooling, improved code quality, and enhanced developer experience.\nKey benefits include:\nType safety for JavaScript code\nBetter IDE support with autocompletion\nEarly error detection during development\nImproved code maintainability and documentation\nEasier refactoring\nPrerequisites: Install a recent Node.js LTS (v18+ recommended) and npm.\nVerify with node -v and npm -v.\nSetting Up a TypeScript Node.js Project\nThis section walks through creating a new Node.js project configured for TypeScript.\nNote: You write TypeScript (.ts) during development and compile it to JavaScript (.js) for Node.js to run in production.\n1. Initialize a New Project\nExampleGet your own TypeScript Server\nWhat these do:\ntypescript adds the TypeScript compiler (tsc)\n@types/node provides Node.js type definitions\nnpx tsc --init creates a tsconfig.json config file\n2. Create a Source Folder\nKeep source code in src/ and compiled output in dist/.\n3. Configure TypeScript\nEdit the generated tsconfig.json:\nExample\nOption highlights:\nrootDir/outDir: keeps source (src) separate from build output (dist).\nstrict: enables the safest type checking.\nesModuleInterop: smoother interop with CommonJS/ES modules.\nsourceMap: generate maps for debugging compiled code.\nCommonJS vs ESM: This guide uses module: \"commonjs\".\nIf you use ESM (type: \"module\" in package.json), set module: \"nodenext\" or node16, and use import/export consistently.\n4. Install Runtime and Dev Dependencies\nInstall Express for HTTP handling and helpful dev tools:\nExample\nWarning: Use ts-node and nodemon only for development.\nFor production, compile with tsc and run Node on the JS output.\nProject Structure\nKeep your project organized:\nREMOVE ADS\nBasic TypeScript Server Example\nThis example shows a minimal Express server written in TypeScript, including a typed User model and a few routes.\nsrc/server.ts\nWhat TypeScript adds here:\nTyped Request, Response, and NextFunction for Express handlers.\nA User interface to guarantee the shape of user data.\nSafer refactoring and better autocompletion with typed route params and bodies.\nUsing TypeScript with Express Middleware\nMiddleware can be strongly typed.\nYou can also extend Express types via declaration merging to store authenticated user data on the request.\nsrc/middleware/auth.ts\nUse the middleware in routes\nTypeScript with Database (TypeORM Example)\nYou can use ORMs like TypeORM with TypeScript decorators to map classes to tables.\nBefore you start:\nInstall packages: npm install typeorm reflect-metadata pg (use pg for PostgreSQL).\nEnable in tsconfig.json when using decorators:\n{ \"compilerOptions\": { \"experimentalDecorators\": true, \"emitDecoratorMetadata\": true } }\nImport reflect-metadata once at app startup.\nsrc/entity/User.ts\nsrc/config/database.ts\nInitialize the Data Source before starting the server\nDevelopment Workflow\n1. Add scripts to package.json\nExample\nNote: The test script is optional and assumes Jest is set up.\nIf you are not using Jest, you can omit it.\n2. Run in development mode\nExample\n3. Build for production\nExample\nDebugging with Source Maps\nWith sourceMap enabled in tsconfig.json, you can debug compiled code and map back to your .ts files.\nTip: Most IDEs (including VS Code) support TypeScript debugging with breakpoints when source maps are enabled.\nBest Practices\nAlways define types for function parameters and return values\nUse interfaces for object shapes\nEnable strict mode in tsconfig.json\nUse type guards for runtime type checking\nLeverage TypeScript's utility types (Partial, Pick, Omit, etc.)\nKeep your type definitions in .d.ts files\nUse enums or const assertions for fixed sets of values\nDocument complex types with JSDoc comments\nPrefer environment variables for secrets and config; validate them at startup.\nUse ts-node/nodemon only in dev; compile for prod.\nConsider ESLint + Prettier with @typescript-eslint for consistent code quality.",
      "examples": [
        "mkdir my-ts-node-app\ncd my-ts-node-app\nnpm init -y\nnpm install typescript @types/node --save-dev\nnpx tsc --init",
        "mkdir src\n# later add files like: src/server.ts, src/middleware/auth.ts",
        "{\n\"compilerOptions\": {\n\"target\": \"ES2020\",\n\"module\": \"commonjs\",\n\"outDir\": \"./dist\",\n\"rootDir\": \"./src\",\n\"strict\": true,\n\"esModuleInterop\": true,\n\"skipLibCheck\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"moduleResolution\": \"node\",\n\"resolveJsonModule\": true,\n\"sourceMap\": true\n},\n\"include\": [\"src/**/*\"],\n\"exclude\": [\"node_modules\"]\n}",
        "npm install express body-parser\nnpm install --save-dev ts-node nodemon @types/express",
        "my-ts-node-app/\nsrc/\nserver.ts\nmiddleware/\nauth.ts\nentity/\nUser.ts\nconfig/\ndatabase.ts\ndist/\nnode_modules/\npackage.json\ntsconfig.json",
        "import express, { Request, Response, NextFunction } from 'express';\nimport { json } from 'body-parser';\n\ninterface User {\nid: number;\nusername: string;\nemail: string;\n}\n\n// Initialize Express app\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(json());\n\n// In-memory database\nconst users: User[] = [\n{ id: 1, username: 'user1', email: 'user1@example.com' },\n{ id: 2, username: 'user2', email: 'user2@example.com' }\n];\n\n// Routes\napp.get('/api/users', (req: Request, res: Response) => {\nres.json(users);\n});\n\napp.get('/api/users/:id', (req: Request, res: Response) => {\nconst user = users.find(u => u.id === parseInt(req.params.id));\nif (!user) return res.status(404).json({ message: 'User not found' });\nres.json(user);\n});\n\napp.post('/api/users', (req: Request, res: Response) => {\nconst { username, email } = req.body;\n\nif (!username || !email) {\nreturn res.status(400).json({ message: 'Username and email are required' });\n}\n\nconst newUser: User = {\nid: users.length + 1,\nusername,\nemail\n};\n\nusers.push(newUser);\nres.status(201).json(newUser);\n});\n\n// Error handling middleware\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\nconsole.error(err.stack);\nres.status(500).json({ message: 'Something went wrong!' });\n});\n\n// Start server\napp.listen(PORT, () => {\nconsole.log(`Server is running on http://localhost:${PORT}`);\n});",
        "import { Request, Response, NextFunction } from 'express';\n\n// Extend the Express Request type to include custom properties\ndeclare global {\nnamespace Express {\ninterface Request {\nuser?: { id: number; role: string };\n}\n}\n}\n\nexport const authenticate = (req: Request, res: Response, next: NextFunction) => {\nconst token = req.header('Authorization')?.replace('Bearer ', '');\n\nif (!token) {\nreturn res.status(401).json({ message: 'No token provided' });\n}\n\ntry {\n// In a real app, verify the JWT token here\nconst decoded = { id: 1, role: 'admin' }; // Mock decoded token\nreq.user = decoded;\nnext();\n} catch (error) {\nres.status(401).json({ message: 'Invalid token' });\n}\n};\n\nexport const authorize = (roles: string[]) => {\nreturn (req: Request, res: Response, next: NextFunction) => {\nif (!req.user) {\nreturn res.status(401).json({ message: 'Not authenticated' });\n}\n\nif (!roles.includes(req.user.role)) {\nreturn res.status(403).json({ message: 'Not authorized' });\n}\n\nnext();\n};\n};",
        "// src/server.ts\nimport { authenticate, authorize } from './middleware/auth';\n\napp.get('/api/admin', authenticate, authorize(['admin']), (req, res) => {\nres.json({ message: `Hello admin ${req.user?.id}` });\n});",
        "import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';\n\n@Entity('users')\nexport class User {\n@PrimaryGeneratedColumn()\nid: number;\n\n@Column({ unique: true })\nusername: string;\n\n@Column({ unique: true })\nemail: string;\n\n@Column({ select: false })\npassword: string;\n\n@Column({ default: 'user' })\nrole: string;\n\n@CreateDateColumn()\ncreatedAt: Date;\n\n@UpdateDateColumn()\nupdatedAt: Date;\n}",
        "import 'reflect-metadata';\nimport { DataSource } from 'typeorm';\nimport { User } from '../entity/User';\n\nexport const AppDataSource = new DataSource({\ntype: 'postgres',\nhost: process.env.DB_HOST || 'localhost',\nport: parseInt(process.env.DB_PORT || '5432'),\nusername: process.env.DB_USERNAME || 'postgres',\npassword: process.env.DB_PASSWORD || 'postgres',\ndatabase: process.env.DB_NAME || 'mydb',\nsynchronize: process.env.NODE_ENV !== 'production',\nlogging: false,\nentities: [User],\nmigrations: [],\nsubscribers: [],\n});",
        "// src/server.ts\nimport { AppDataSource } from './config/database';\n\nAppDataSource.initialize()\n.then(() => {\napp.listen(PORT, () => console.log(`Server running on http://localhost:${PORT}`));\n})\n.catch((err) => {\nconsole.error('DB init error', err);\nprocess.exit(1);\n});",
        "{\n\"scripts\": {\n\"build\": \"tsc\",\n\"start\": \"node dist/server.js\",\n\"dev\": \"nodemon --exec ts-node src/server.ts\",\n\"watch\": \"tsc -w\",\n\"test\": \"jest --config jest.config.js\"\n}\n}",
        "npm run dev",
        "npm run build\nnpm start",
        "node --enable-source-maps dist/server.js",
        "node -v",
        "npm -v",
        ".ts",
        ".js",
        "typescript",
        "tsc",
        "@types/node",
        "npx tsc --init",
        "tsconfig.json",
        "src/",
        "dist/",
        "rootDir",
        "outDir",
        "src",
        "dist",
        "strict",
        "esModuleInterop",
        "sourceMap",
        "module: \"commonjs\"",
        "type: \"module\"",
        "package.json",
        "module: \"nodenext\"",
        "node16",
        "import",
        "export",
        "ts-node",
        "nodemon",
        "User",
        "Request",
        "Response",
        "NextFunction",
        "npm install typeorm reflect-metadata pg",
        "pg",
        "reflect-metadata",
        "test",
        "@typescript-eslint"
      ]
    },
    {
      "title": "TypeScript with React",
      "summary": "Why Use TypeScript with React?\nTypeScript enhances React with:\nType safety for props, state, and context\nBetter IDE autocompletion and refactoring\nEarly error detection during development\nNote: This tutorial assumes basic knowledge of React.\nIf you're new to React, consider checking out our React Tutorial first.\nGetting Started\nCreate a new React + TypeScript app with Vite:\nExampleGet your own TypeScript Server\nYour tsconfig.json should include these recommended compiler options:\nExample\nNote: Keep strict enabled for best type safety.\nThe shown options work well with Vite and Create React App.\nComponent Typing\nDefine props with TypeScript and use them in a functional component:\nExample\nREMOVE ADS\nCommon Patterns\nType-Safe Events\nType event handlers for inputs and buttons:\nExample\nTyping State with useState\nUse explicit types for numbers, unions, and nullable values:\nExample\nuseRef with DOM Elements\nType refs to DOM nodes to access properties safely:\nExample\nChildren Typing\nAccept children with the React.ReactNode type:\nExample\nFetch Helpers with Generics\nUse generics to type API responses:\nExample\nMinimal Context and Custom Hook\nProvide a small, typed context and a helper hook:\nExample\nVite TypeScript types: Add Vite's ambient types to avoid missing definitions.\nExample\nAlternatively, add to tsconfig.json:\nExample\nAbout React.FC: Prefer directly typed function components.\nReact.FC is optional; it implicitly adds children but isn't required.\nOptional baseUrl and paths: These can simplify imports if supported by your bundler.\nExample\nConfigure only if your tooling (e.g., Vite, tsconfig-paths) is set up for path aliases.",
      "examples": [
        "npm create vite@latest my-app -- --template react-ts\ncd my-app\nnpm install\nnpm run dev",
        "{\n\"compilerOptions\": {\n\"target\": \"ES2020\",\n\"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n\"module\": \"ESNext\",\n\"moduleResolution\": \"Node\",\n\"jsx\": \"react-jsx\",\n\"strict\": true,\n\"skipLibCheck\": true,\n\"noEmit\": true,\n\"resolveJsonModule\": true,\n\"allowSyntheticDefaultImports\": true,\n\"esModuleInterop\": true,\n\"forceConsistentCasingInFileNames\": true\n},\n\"include\": [\"src\"]\n}",
        "// Greeting.tsx\ntype GreetingProps = {\nname: string;\nage?: number;\n};\n\nexport function Greeting({ name, age }: GreetingProps) {\nreturn (\n<div>\n<h2>Hello, {name}!</h2>\n{age !== undefined && <p>You are {age} years old</p>}\n</div>\n);\n}",
        "// Input change\nfunction NameInput() {\nfunction handleChange(e: React.ChangeEvent<HTMLInputElement>) {\nconsole.log(e.target.value);\n}\nreturn <input onChange={handleChange} />;\n}\n\n// Button click\nfunction SaveButton() {\nfunction handleClick(e: React.MouseEvent<HTMLButtonElement>) {\ne.preventDefault();\n}\nreturn <button onClick={handleClick}>Save</button>;\n}",
        "const [count, setCount] = React.useState<number>(0);\nconst [status, setStatus] = React.useState<'idle' | 'loading' | 'error'>('idle');\n\ntype User = { id: string; name: string };\nconst [user, setUser] = React.useState<User | null>(null);",
        "function FocusInput() {\nconst inputRef = React.useRef<HTMLInputElement>(null);\nreturn <input ref={inputRef} onFocus={() => inputRef.current?.select()} />;\n}",
        "type CardProps = { title: string; children?: React.ReactNode };\nfunction Card({ title, children }: CardProps) {\nreturn (\n<div>\n<h2>{title}</h2>\n{children}\n</div>\n);\n}",
        "async function fetchJson<T>(url: string): Promise<T> {\nconst res = await fetch(url);\nif (!res.ok) throw new Error('Network error');\nreturn res.json() as Promise<T>;\n}\n\n// Usage inside an async function/component effect\nasync function loadPosts() {\ntype Post = { id: number; title: string };\nconst posts = await fetchJson<Post[]>(\"/api/posts\");\nconsole.log(posts);\n}",
        "type Theme = 'light' | 'dark';\nconst ThemeContext = React.createContext<{ theme: Theme; toggle(): void } | null>(null);\n\nfunction ThemeProvider({ children }: { children: React.ReactNode }) {\nconst [theme, setTheme] = React.useState<Theme>('light');\nconst value = { theme, toggle: () => setTheme(t => (t === 'light' ? 'dark' : 'light')) };\nreturn <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;\n}\n\nfunction useTheme() {\nconst ctx = React.useContext(ThemeContext);\nif (!ctx) throw new Error('useTheme must be used within ThemeProvider');\nreturn ctx;\n}",
        "// src/vite-env.d.ts\n/// <reference types=\"vite/client\" />",
        "{\n\"compilerOptions\": {\n\"types\": [\"vite/client\"]\n}\n}",
        "{\n\"compilerOptions\": {\n\"baseUrl\": \".\",\n\"paths\": {\n\"@/*\": [\"src/*\"]\n\n}\n}\n}",
        "tsconfig.json",
        "strict",
        "React.ReactNode",
        "React.FC",
        "children",
        "baseUrl",
        "paths"
      ]
    },
    {
      "title": "TypeScript Tooling",
      "summary": "TypeScript Development Ecosystem\nTypeScript's tooling ecosystem is one of its greatest strengths, providing developers with powerful tools for every stage of development:\nCode Quality\nESLint with TypeScript support\nType checking and linting\nCode style enforcement\nDevelopment\nVS Code integration\nDebugging tools\nHot Module Replacement (HMR)\nBuild & Deploy\nBundlers (Vite, Webpack, Parcel)\nModule bundling\nProduction optimization\nLinting with ESLint\nInstallation\nInstall ESLint and the official TypeScript plugin/parser so ESLint can understand TypeScript syntax and rules.\nExampleGet your own TypeScript Server\nConfiguration\nThis configuration enables recommended ESLint rules for TypeScript, connects ESLint to your tsconfig for type-aware linting, and tweaks a few common rules.\nExample\nNPM Scripts\nAdd scripts to run linting and a type-only check.\nUse lint:fix to auto-fix simple issues.\nExample\nREMOVE ADS\nCode Formatting with Prettier\nPrettier enforces a consistent code style across your team.\nCombine it with ESLint to avoid formatting-related lint errors.\nInstallation\nInstall Prettier plus ESLint plugins that disable conflicting rules and surface formatting issues via ESLint.\nExample\nConfiguration\nDefine your Prettier preferences in .prettierrc and ignore generated folders in .prettierignore.\nExample\nIntegrate with ESLint\nExtend plugin:prettier/recommended so formatting problems are reported as ESLint issues.\nExample\nExample: Integrate Prettier with ESLint\nModern Build Tools\nVite is the recommended choice for fast dev server and modern builds.\nWebpack remains common and highly configurable.\nVite (Recommended)\nCreate a new React + TypeScript project using Vite.\nIt starts a dev server with HMR for rapid feedback.\nExample\nWebpack Configuration\nIf you choose Webpack, this minimal setup transpiles TypeScript, handles CSS, and serves your app with webpack-dev-server.\nExample\nTypeScript Configuration\nA strict tsconfig.json that targets modern browsers.\nThe optional baseUrl and paths help with absolute imports like @/components/Button.\nExample\nDevelopment Environment Setup\nConfigure your editor to surface lint errors, format on save, and debug efficiently.\nVS Code Extensions\nRecommended extensions for VS Code:\nTypeScript + Webpack Problem Matchers - For better error reporting\nESLint - Integrates ESLint into VS Code\nPrettier - Code formatter - For consistent code formatting\nPath IntelliSense - Autocomplete filenames\nError Lens - Show errors inline\nVS Code Settings\nUse Prettier as the default formatter, fix ESLint issues on save, and prefer non-relative import paths.\nExample\nDebugging Configuration\nLaunch Chrome against your dev server and run Node-based test debugging directly from VS Code.\nExample\nTesting Setup\nJest with Testing Library is a popular setup for testing React + TypeScript apps.\nJest + Testing Library\nInstall Jest, TypeScript support, and React Testing Library utilities for DOM assertions and user interactions.\nExample\nJest Configuration\nConfigure Jest to use ts-jest, map CSS modules, and resolve alias paths like @/.\nExample\nExample Test\nA simple component test that verifies rendering and click behavior using Testing Library.\nExample\nBest Practices\nDevelopment Workflow\nUse npm run dev for development with hot reloading\nRun npm run type-check to verify TypeScript types\nUse npm run lint to check for linting errors\nRun npm run build to create production build\nPerformance Optimization\nUse code splitting with dynamic imports\nEnable tree-shaking in production builds\nUse React.memo and useMemo for expensive computations\nLazy load non-critical components\nCommon Pitfalls\nTypeScript configuration: Ensure strict mode is enabled\nESLint + Prettier conflicts: Use eslint-config-prettier to disable conflicting rules\nSlow builds: Consider using Vite or esbuild for faster development\nMissing type definitions: Install @types packages for all dependencies\nDebugging issues: Ensure source maps are properly configured\nRecommended Tools\nBundlers: Vite, Webpack, Parcel\nTesting: Jest, React Testing Library, Cypress\nLinting/Formatting: ESLint, Prettier, Stylelint\nDocumentation: TypeDoc, Storybook\nPerformance: Web Vitals, Lighthouse",
      "examples": [
        "# Install ESLint with TypeScript support\nnpm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin",
        "// .eslintrc.json\n{\n\"root\": true,\n\"parser\": \"@typescript-eslint/parser\",\n\"plugins\": [\"@typescript-eslint\"],\n\"extends\": [\n\"eslint:recommended\",\n\"plugin:@typescript-eslint/recommended\",\n\"plugin:@typescript-eslint/recommended-requiring-type-checking\"\n],\n\"parserOptions\": {\n\"project\": \"./tsconfig.json\",\n\"ecmaVersion\": 2020,\n\"sourceType\": \"module\"\n},\n\"rules\": {\n\"@typescript-eslint/explicit-function-return-type\": \"warn\",\n\"@typescript-eslint/no-explicit-any\": \"warn\",\n\"@typescript-eslint/no-unused-vars\": [\"error\", { \"argsIgnorePattern\": \"^_\" }]\n}\n}",
        "// package.json\n{\n\"scripts\": {\n\"lint\": \"eslint . --ext .ts,.tsx\",\n\"lint:fix\": \"eslint . --ext .ts,.tsx --fix\",\n\"type-check\": \"tsc --noEmit\"\n}\n}",
        "# Install Prettier and related packages\nnpm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier",
        "// .prettierrc\n{\n\"semi\": true,\n\"singleQuote\": true,\n\"tabWidth\": 2,\n\"printWidth\": 100,\n\"trailingComma\": \"es5\",\n\"bracketSpacing\": true,\n\"arrowParens\": \"avoid\"\n}\n\n// .prettierignore\nnode_modules\nbuild\ndist\n.next\n.vscode",
        "// .eslintrc.json\n{\n\"extends\": [\n// ... other configs\n\"plugin:prettier/recommended\" // Must be last in the array\n]\n}",
        "npm install --save-dev eslint-config-prettier eslint-plugin-prettier\n# In your .eslintrc.js or .eslintrc.json, add:\n{\n\"extends\": [\"plugin:prettier/recommended\"]\n}",
        "# Create a new project with React + TypeScript\nnpm create vite@latest my-app -- --template react-ts\n\n# Navigate to project directory\ncd my-app\n\n# Install dependencies\nnpm install\n\n# Start development server\nnpm run dev",
        "// webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\nentry: './src/index.tsx',\nmodule: {\nrules: [\n{\ntest: /\\.(ts|tsx)$/,\nuse: 'ts-loader',\nexclude: /node_modules/,\n},\n{\ntest: /\\.css$/,\nuse: ['style-loader', 'css-loader'],\n},\n],\n},\nresolve: {\nextensions: ['.tsx', '.ts', '.js'],\n},\noutput: {\nfilename: 'bundle.js',\npath: path.resolve(__dirname, 'dist'),\n},\nplugins: [\nnew HtmlWebpackPlugin({\ntemplate: './public/index.html',\n}),\n],\ndevServer: {\nstatic: path.join(__dirname, 'dist'),\ncompress: true,\nport: 3000,\nhot: true,\n},\n};",
        "// tsconfig.json\n{\n\"compilerOptions\": {\n\"target\": \"es2020\",\n\"module\": \"esnext\",\n\"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n\"allowJs\": true,\n\"skipLibCheck\": true,\n\"esModuleInterop\": true,\n\"allowSyntheticDefaultImports\": true,\n\"strict\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"moduleResolution\": \"node\",\n\"resolveJsonModule\": true,\n\"isolatedModules\": true,\n\"noEmit\": true,\n\"jsx\": \"react-jsx\",\n\"baseUrl\": \".\",\n\"paths\": {\n\"@/*\": [\"src/*\"]\n}\n},\n\"include\": [\"src\"],\n\"exclude\": [\"node_modules\"]\n}",
        "// .vscode/settings.json\n{\n\"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n\"editor.formatOnSave\": true,\n\"editor.codeActionsOnSave\": {\n\"source.fixAll.eslint\": true,\n\"source.organizeImports\": true\n},\n\"eslint.validate\": [\"javascript\", \"javascriptreact\", \"typescript\", \"typescriptreact\"],\n\"typescript.tsdk\": \"node_modules/typescript/lib\",\n\"typescript.preferences.importModuleSpecifier\": \"non-relative\"\n}",
        "// .vscode/launch.json\n{\n\"version\": \"0.2.0\",\n\"configurations\": [\n{\n\"type\": \"chrome\",\n\"request\": \"launch\",\n\"name\": \"Launch Chrome against localhost\",\n\"url\": \"http://localhost:3000\",\n\"webRoot\": \"${workspaceFolder}\",\n\"sourceMaps\": true,\n\"sourceMapPathOverrides\": {\n\"webpack:///./~/*\": \"${workspaceFolder}/node_modules/*\",\n\"webpack:///./*\": \"${workspaceFolder}/src/*\"\n}\n},\n{\n\"type\": \"node\",\n\"request\": \"launch\",\n\"name\": \"Debug Tests\",\n\"runtimeExecutable\": \"${workspaceRoot}/node_modules/.bin/jest\",\n\"args\": [\"--runInBand\", \"--watchAll=false\"],\n\"console\": \"integratedTerminal\",\n\"internalConsoleOptions\": \"neverOpen\",\n\"sourceMaps\": true\n}\n]\n}",
        "# Install testing dependencies\nnpm install --save-dev jest @types/jest ts-jest @testing-library/react @testing-library/jest-dom @testing-library/user-event",
        "// jest.config.js\nmodule.exports = {\npreset: 'ts-jest',\ntestEnvironment: 'jsdom',\nsetupFilesAfterEnv: ['@testing-library/jest-dom'],\nmoduleNameMapper: {\n'^@/(.*)$': '\n/src/$1'\n,\n'\\\\\\.(css|less|scss|sass)$': 'identity-obj-proxy',\n},\ntransform: {\n'^.+\\\\\\.tsx?$': 'ts-jest',\n},\ntestMatch: ['**/__tests__/**/*.test.(ts|tsx)'],\n};",
        "// src/__tests__/Button.test.tsx\nimport React from 'react';\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport '@testing-library/jest-dom';\nimport Button from '../components/Button';\n\ndescribe('Button', () => {\nit('renders button with correct text', () => {\nrender(<Button>Click me</Button>);\nexpect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument();\n});\n\nit('calls onClick when clicked', () => {\nconst handleClick = jest.fn();\nrender(<Button onClick={handleClick}>Click me</Button>);\n\nfireEvent.click(screen.getByRole('button'));\nexpect(handleClick).toHaveBeenCalledTimes(1);\n});\n});",
        "lint:fix",
        ".prettierrc",
        ".prettierignore",
        "plugin:prettier/recommended",
        "webpack-dev-server",
        "tsconfig.json",
        "baseUrl",
        "paths",
        "@/components/Button",
        "ts-jest",
        "@/",
        "npm run dev",
        "npm run type-check",
        "npm run lint",
        "npm run build",
        "React.memo",
        "useMemo",
        "strict",
        "eslint-config-prettier",
        "@types"
      ]
    },
    {
      "title": "TypeScript Advanced Types",
      "summary": "Advanced TypeScript Types\nTypeScript's advanced type system allows you to model complex type relationships with precision.\nThese features are particularly useful for building robust, maintainable applications with excellent type safety.\nKey Advanced Type Features\nMapped Types: Transform properties of existing types\nConditional Types: Create types based on conditions\nTemplate Literal Types: Build types using string templates\nUtility Types: Built-in type helpers for common transformations\nRecursive Types: Self-referential types for tree-like structures\nType Guards & Type Predicates: Runtime type checking\nType Inference: Advanced pattern matching with infer\nMapped Types\nMapped types allow you to create new types by transforming properties of existing types.\nBasic Mapped Type\nTransform every property of an object type into a new type using a single template.\nExampleGet your own TypeScript Server\nMapped Type Modifiers\nAdd or remove property modifiers like readonly and ? across all keys.\nExample\nKey Remapping\nRename or filter keys while mapping using as, string helpers, and conditional checks.\nExample\nREMOVE ADS\nConditional Types\nConditional types allow you to define types that depend on a condition.\nBasic Conditional Types\nSelect between types based on a condition checked at the type level.\nExample\nInfer Keyword\nCapture a part of a type within a conditional type by introducing a new type variable with infer.\nExample\nDistributed Conditional Types\nUnderstand how conditionals distribute over unions versus when they are wrapped to prevent distribution.\nExample\nTemplate Literal Types\nTemplate literal types allow you to build types using template literal syntax.\nBasic Template Literal Types\nConstrain strings to specific patterns using template literals and unions.\nExample\nString Manipulation Types\nApply built-in helpers to transform string literal types (uppercasing, capitalizing, etc.).\nExample\nAdvanced Patterns\nCompose templates with inference and key remapping to extract metadata and generate APIs.\nExample\nUtility Types\nTypeScript provides several built-in utility types for common type transformations.\nCommon Utility Types\nUse built-ins like Partial, Pick, and Omit for common transformations.\nExample\nAdvanced Utility Types\nExclude or extract members from unions and create custom mapped helpers.\nExample\nRecursive Types\nRecursive types are useful for modeling tree-like data structures where a type can reference itself.\nBasic Recursive Type\nModel self-referential structures like trees and nested JSON.\nExample\nAdvanced Recursive Types\nExpress linked lists, directory trees, and recursive state machines.\nExample\nBest Practices\nWhen to Use Advanced Types\nUse mapped types when you need to transform multiple properties of an object type\nUse conditional types when your type depends on another type\nUse template literal types for string manipulation and pattern matching\nUse utility types for common transformations (prefer built-in ones when possible)\nUse recursive types for tree-like or nested data structures\nPerformance Considerations\nDeeply nested recursive types can slow down the TypeScript compiler\nVery large union types (100+ members) can cause performance issues\nUse type aliases to break down complex types\nCommon Pitfalls\nType Inference Issues\nConditional types distribute over union types, which can be surprising\nType inference with infer works differently in different contexts\nSome utility types don't work well with any or unknown\nMaintainability\nOverusing complex types can make code hard to understand\nDocument complex type transformations with comments\nConsider using type assertions or helper functions for very complex types",
      "examples": [
        "// Convert all properties to boolean\ntype Flags<T> = {\n[K in keyof T]: boolean;\n};\n\ninterface User {\nid: number;\nname: string;\nemail: string;\n}\n\ntype UserFlags = Flags<User>;\n// Equivalent to:\n// {\n//   id: boolean;\n//   name: boolean;\n//   email: boolean;\n// }",
        "// Make all properties optional\ninterface Todo {\ntitle: string;\ndescription: string;\ncompleted: boolean;\n}\n\ntype OptionalTodo = {\n[K in keyof Todo]?: Todo[K];\n};\n\n// Remove 'readonly' and '?' modifiers\ntype Concrete<T> = {\n-readonly [K in keyof T]-?: T[K];\n};\n\n// Add 'readonly' and 'required' to all properties\ntype ReadonlyRequired<T> = {\n+readonly [K in keyof T]-?: T[K];\n};",
        "// Add prefix to all property names\ntype Getters<T> = {\n[K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// {\n//   getId: () => number;\n//   getName: () => string;\n//   getEmail: () => string;\n// }\n\n// Filter out properties\ntype MethodsOnly<T> = {\n[K in keyof T as T[K] extends Function ? K : never]: T[K];\n};",
        "type IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>;    // true\ntype B = IsString<number>;    // false\ntype C = IsString<'hello'>;    // true\ntype D = IsString<string | number>; // boolean\n\n// Extract array element type\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\ntype Numbers = ArrayElement<number[]>; // number",
        "// Get return type of a function\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n\n// Get parameter types as a tuple\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\n\n// Get constructor parameter types\ntype ConstructorParameters<T extends new (...args: any) => any> =\nT extends new (...args: infer P) => any ? P : never;\n\n// Get instance type from a constructor\ntype InstanceType<T extends new (...args: any) => any> =\nT extends new (...args: any) => infer R ? R : any;",
        "// Without distribution\ntype ToArrayNonDist<T> = T extends any ? T[] : never;\ntype StrOrNumArr = ToArrayNonDist<string | number>; // (string | number)[]\n\n// With distribution\ntype ToArray<T> = [T] extends [any] ? T[] : never;\ntype StrOrNumArr2 = ToArray<string | number>; // string[] | number[]\n\n// Filter out non-string types\ntype FilterStrings<T> = T extends string ? T : never;\ntype Letters = FilterStrings<'a' | 'b' | 1 | 2 | 'c'>; // 'a' | 'b' | 'c'",
        "type Greeting = `Hello, ${string}`;\n\nconst validGreeting: Greeting = 'Hello, World!';\nconst invalidGreeting: Greeting = 'Hi there!'; // Error\n\n// With unions\ntype Color = 'red' | 'green' | 'blue';\ntype Size = 'small' | 'medium' | 'large';\n\ntype Style = `${Color}-${Size}`;\n// 'red-small' | 'red-medium' | 'red-large' |\n// 'green-small' | 'green-medium' | 'green-large' |\n// 'blue-small' | 'blue-medium' | 'blue-large'",
        "// Built-in string manipulation types\ntype T1 = Uppercase<'hello'>;  // 'HELLO'\ntype T2 = Lowercase<'WORLD'>;  // 'world'\ntype T3 = Capitalize<'typescript'>;  // 'Typescript'\ntype T4 = Uncapitalize<'TypeScript'>;  // 'typeScript'\n\n// Create an event handler type\ntype EventType = 'click' | 'change' | 'keydown';\ntype EventHandler = `on${Capitalize<EventType>}`;\n// 'onClick' | 'onChange' | 'onKeydown'",
        "// Extract route parameters\ntype ExtractRouteParams<T> =\nT extends `${string}:${infer Param}/${infer Rest}`\n? { [K in Param | keyof ExtractRouteParams<`${Rest}`>]: string }\n: T extends `${string}:${infer Param}`\n? { [K in Param]: string }\n: {};\n\ntype Params = ExtractRouteParams<'/users/:userId/posts/:postId'>;\n// { userId: string; postId: string; }\n\n// Create a type-safe event emitter\ntype EventMap = {\nclick: { x: number; y: number };\nchange: string;\nkeydown: { key: string; code: number };\n};\n\ntype EventHandlers = {\n[K in keyof EventMap as `on${Capitalize<K>}`]: (event: EventMap[K]) => void;\n};",
        "// Basic types\ninterface User {\nid: number;\nname: string;\nemail: string;\ncreatedAt: Date;\n}\n\n// Make all properties optional\ntype PartialUser = Partial<User>;\n\n// make all properties required\ntype RequiredUser = Required<PartialUser>;\n\n// make all properties read-only\ntype ReadonlyUser = Readonly<User>;\n\n// pick specific properties\ntype UserPreview = Pick<User, 'id' | 'name'>;\n\n// omit specific properties\ntype UserWithoutEmail = Omit<User, 'email'>;\n\n// extract property types\ntype UserId = User['id']; // number\ntype UserKeys = keyof User; // 'id' | 'name' | 'email' | 'createdAt'",
        "// Create a type that excludes null and undefined\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n// Exclude types from a union\ntype Numbers = 1 | 2 | 3 | 'a' | 'b';\ntype JustNumbers = Exclude<Numbers, string>; // 1 | 2 | 3\n\n// Extract types from a union\ntype JustStrings = Extract<Numbers, string>; // 'a' | 'b'\n\n// Get the type that is not in the second type\ntype A = { a: string; b: number; c: boolean };\ntype B = { a: string; b: number };\ntype C = Omit<A, keyof B>; // { c: boolean }\n\n// Create a type with all properties as mutable\ntype Mutable<T> = {\n-readonly [K in keyof T]: T[K];\n};",
        "// Simple binary tree\ntype BinaryTree<T> = {\nvalue: T;\nleft?: BinaryTree<T>;\nright?: BinaryTree<T>;\n};\n\n// JSON-like data structure\ntype JSONValue =\n| string\n| number\n| boolean\n| null\n| JSONValue[]\n| { [key: string]: JSONValue };\n\n// Nested comments\ntype Comment = {\nid: number;\ncontent: string;\nreplies: Comment[];\ncreatedAt: Date;\n};",
        "// Type for a linked list\ntype LinkedList<T> = {\nvalue: T;\nnext: LinkedList<T> | null;\n};\n\n// Type for a directory structure\ntype File = {\ntype: 'file';\nname: string;\nsize: number;\n};\n\ntype Directory = {\ntype: 'directory';\nname: string;\nchildren: (File | Directory)[];\n};\n\n// Type for a state machine\ntype State = {\nvalue: string;\ntransitions: {\n[event: string]: State;\n};\n};\n\n// Type for a recursive function\ntype RecursiveFunction<T> = (x: T | RecursiveFunction<T>) => void;",
        "infer",
        "readonly",
        "?",
        "as",
        "Partial",
        "Pick",
        "Omit",
        "any",
        "unknown"
      ]
    },
    {
      "title": "TypeScript Type Guards",
      "summary": "Understanding Type Guards in TypeScript\nTypeScript Type Guards are powerful constructs that allow you to narrow down the type of a variable within a specific scope.\nThey help TypeScript understand and enforce type safety by providing explicit checks that determine the specific type of a variable at runtime.\nWhy Use Type Guards?\nType Safety: Ensure operations are only performed on appropriate types\nCode Clarity: Make type checking explicit and self-documenting\nBetter Tooling: Get accurate IntelliSense and code completion\nError Prevention: Catch type-related errors at compile time\nRuntime Safety: Add an extra layer of type checking at runtime\nType Guard Patterns\ntypeof type guards\ninstanceof type guards\nUser-defined type guards with type predicates\nDiscriminated unions with literal types\nin operator type guards\nType assertion functions\ntypeof Type Guards\nThe typeof operator is a built-in type guard that checks the type of a primitive value at runtime.\nIt's particularly useful for narrowing primitive types like strings, numbers, booleans, etc.\nBasic Usage\nUse typeof checks to narrow primitive unions inside conditional branches.\nExampleGet your own TypeScript Server\nIn the above example, TypeScript understands the type of value in different branches of the if statement.\nREMOVE ADS\ninstanceof Type Guards\nThe instanceof operator checks if an object is an instance of a specific class or constructor function.\nIt's useful for narrowing types with custom classes or built-in objects.\nClass-based Type Guarding\nNarrow unions of class instances by checking the constructor with instanceof.\nExample\nUser-Defined Type Guards\nFor more complex type checking, you can create custom type guard functions using type predicates.\nThese are functions that return a type predicate in the form parameterName is Type.\nType Predicate Functions\nReturn a predicate like value is Type so TypeScript narrows on the true branch.\nExample\nThe function signature vehicle is Car is a type predicate that tells TypeScript to narrow the type when the function returns true.\nDiscriminated Unions\nDiscriminated unions (also known as tagged unions) use a common property (the discriminant) to distinguish between different object types in a union.\nThis pattern is particularly powerful when combined with type guards.\nBasic Discriminated Union\nUse a shared literal property (like kind) to switch and narrow to the exact variant.\nExample\nThe kind property is used as a discriminant to determine the type of the shape.\nThe in Operator\nThe in operator checks for the existence of a property on an object.\nIt's particularly useful for narrowing union types where different types have distinct properties.\nProperty Existence Checking\nNarrow union members by testing whether a distinguishing property exists.\nExample\nType Assertion Functions\nType assertion functions are a special kind of type guard that can throw an error if the type assertion fails.\nThey're useful for validating data at runtime.\nAssertion Functions\nEncode runtime checks that narrow types and throw on invalid input.\nExample\nBest Practices\nWhen to Use Each Type Guard\nUse typeof for primitive types (string, number, boolean, etc.)\nUse instanceof for class instances and built-in objects\nUse user-defined type guards for complex validation logic\nUse discriminated unions for related types with a common discriminant\nUse the in operator for checking property existence\nUse type assertion functions for runtime validation with errors\nPerformance Considerations\ntypeof and instanceof are very fast\nAvoid complex logic in user-defined type guards when performance is critical\nConsider using type predicates for expensive checks that are used multiple times",
      "examples": [
        "// Simple type guard with typeof\nfunction formatValue(value: string | number): string {\nif (typeof value === 'string') {\n// TypeScript knows value is string here\nreturn value.trim().toUpperCase();\n} else {\n// TypeScript knows value is number here\nreturn value.toFixed(2);\n}\n}\n\n// Example usage\nconst result1 = formatValue('  hello  ');  // \"HELLO\"\nconst result2 = formatValue(42.1234);      // \"42.12\"",
        "class Bird {\nfly() {\nconsole.log(\"Flying...\");\n}\n}\n\nclass Fish {\nswim() {\nconsole.log(\"Swimming...\");\n}\n}\n\nfunction move(animal: Bird | Fish) {\nif (animal instanceof Bird) {\n// TypeScript knows animal is Bird here\nanimal.fly();\n} else {\n// TypeScript knows animal is Fish here\nanimal.swim();\n}\n}",
        "interface Car {\nmake: string;\nmodel: string;\nyear: number;\n}\n\ninterface Motorcycle {\nmake: string;\nmodel: string;\nyear: number;\ntype: \"sport\" | \"cruiser\";\n}\n\n// Type predicate function\nfunction isCar(vehicle: Car | Motorcycle): vehicle is Car {\nreturn (vehicle as Motorcycle).type === undefined;\n}\n\nfunction displayVehicleInfo(vehicle: Car | Motorcycle) {\nconsole.log(`Make: ${vehicle.make}, Model: ${vehicle.model}, Year: ${vehicle.year}`);\n\nif (isCar(vehicle)) {\n// TypeScript knows vehicle is Car here\nconsole.log(\"This is a car\");\n} else {\n// TypeScript knows vehicle is Motorcycle here\nconsole.log(`This is a ${vehicle.type} motorcycle`);\n}\n}",
        "interface Circle {\nkind: \"circle\";\nradius: number;\n}\n\ninterface Square {\nkind: \"square\";\nsideLength: number;\n}\n\ntype Shape = Circle | Square;\n\nfunction calculateArea(shape: Shape) {\nswitch (shape.kind) {\ncase \"circle\":\n// TypeScript knows shape is Circle here\nreturn Math.PI * shape.radius ** 2;\ncase \"square\":\n// TypeScript knows shape is Square here\nreturn shape.sideLength ** 2;\n}\n}",
        "interface Dog {\nbark(): void;\n}\n\ninterface Cat {\nmeow(): void;\n}\n\nfunction makeSound(animal: Dog | Cat) {\nif (\"bark\" in animal) {\n// TypeScript knows animal is Dog here\nanimal.bark();\n} else {\n// TypeScript knows animal is Cat here\nanimal.meow();\n}\n}",
        "// Type assertion function\nfunction assertIsString(value: unknown): asserts value is string {\nif (typeof value !== 'string') {\nthrow new Error('Value is not a string');\n}\n}\n\n// Type assertion function with custom error\nfunction assert(condition: unknown, message: string): asserts condition {\nif (!condition) {\nthrow new Error(message);\n}\n}\n\n// Usage\nfunction processInput(input: unknown) {\nassertIsString(input);\n// input is now typed as string\nconsole.log(input.toUpperCase());\n}\n\n// With custom error\nfunction processNumber(value: unknown): number {\nassert(typeof value === 'number', 'Value must be a number');\n// value is now typed as number\nreturn value * 2;\n}",
        "typeof",
        "instanceof",
        "in",
        "value",
        "if",
        "parameterName is Type",
        "value is Type",
        "vehicle is Car",
        "kind"
      ]
    },
    {
      "title": "TypeScript Conditional Types",
      "summary": "Understanding Conditional Types in TypeScript\nConditional types in TypeScript enable you to create types that depend on other types, similar to how if-else statements work in JavaScript.\nThey're a powerful feature that allows for sophisticated type transformations and type-level programming.\nKey Concepts\nType-level logic: Perform conditional checks on types\nType inference: Extract and manipulate types using infer\nComposition: Combine with other TypeScript features\nUtility types: Build powerful type utilities\nCommon Use Cases\nType-safe function overloading\nAPI response type transformations\nComplex type validations\nBuilding reusable type utilities\nAdvanced type inference\nBasic Conditional Type Syntax\nConditional types use the form T extends U ? X : Y, which means:\n\"if type T extends (or is assignable to) type U, use type X, otherwise use type Y\".\nExampleGet your own TypeScript Server\nREMOVE ADS\nConditional Types with Unions\nDistributive Conditional Types\nConditional types are particularly useful with union types, where they're automatically distributed over union members:\nExample\nType Inference with infer\nExtracting Types from Complex Structures\nThe infer keyword allows you to declare a type variable within the condition part of a conditional type and then use it in the true branch of the condition:\nExample\nBuilt-in Conditional Types\nStandard Library Utilities\nTypeScript includes several built-in conditional types in its standard library:\nExample\nAdvanced Patterns and Techniques\nRecursive Conditional Types\nConditional types can be used recursively to create complex type transformations:\nExample\nType-Level If-Else Chains\nChain multiple conditions together for complex type logic:\nExample\nConditional types are powerful when creating generic utilities and type-safe libraries:\nExample\nBest Practices\nDo:\nUse conditional types for complex type transformations\nCombine with infer for type extraction\nCreate reusable type utilities\nDocument complex conditional types\nTest edge cases in your type definitions\nDon't:\nOveruse complex conditional types when simple types would suffice\nCreate deeply nested conditional types that are hard to understand\nForget about performance implications with very complex types\nUse conditional types for runtime logic\nPerformance Considerations\nDeeply nested conditional types can increase compile times\nConsider using type aliases for intermediate results\nBe mindful of TypeScript's recursion depth limits",
      "examples": [
        "type IsString<T> = T extends string ? true : false;\n\n// Usage examples\ntype Result1 = IsString<string>; // true\ntype Result2 = IsString<number>; // false\ntype Result3 = IsString<\"hello\">; // true (literal types extend their base types)\n\n// We can use this with variables too\nlet a: IsString<string>; // a has type 'true'\nlet b: IsString<number>; // b has type 'false'",
        "type ToArray<T> = T extends any ? T[] : never;\n\n// When used with a union type, it applies to each member of the union\ntype StringOrNumberArray = ToArray<string | number>;\n// This becomes ToArray<string> | ToArray<number>\n// Which becomes string[] | number[]\n\n// We can also extract specific types from a union\ntype ExtractString<T> = T extends string ? T : never;\ntype StringsOnly = ExtractString<string | number | boolean | \"hello\">;\n// Result: string | \"hello\"",
        "// Extract the return type of a function type\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\n// Examples\nfunction greet() { return \"Hello, world!\"; }\nfunction getNumber() { return 42; }\n\ntype GreetReturnType = ReturnType<typeof greet>; // string\ntype NumberReturnType = ReturnType<typeof getNumber>; // number\n\n// Extract element type from array\ntype ElementType<T> = T extends (infer U)[] ? U : never;\ntype NumberArrayElement = ElementType<number[]>; // number\ntype StringArrayElement = ElementType<string[]>; // string",
        "// Extract<T, U> - Extracts types from T that are assignable to U\ntype OnlyStrings = Extract<string | number | boolean, string>; // string\n\n// Exclude<T, U> - Excludes types from T that are assignable to U\ntype NoStrings = Exclude<string | number | boolean, string>; // number | boolean\n\n// NonNullable<T> - Removes null and undefined from T\ntype NotNull = NonNullable<string | null | undefined>; // string\n\n// Parameters<T> - Extracts parameter types from a function type\ntype Params = Parameters<(a: string, b: number) => void>; // [string, number]\n\n// ReturnType<T> - Extracts the return type from a function type\ntype Return = ReturnType<() => string>; // string",
        "// Deeply unwrap Promise types\ntype UnwrapPromise<T> = T extends Promise<infer U> ? UnwrapPromise<U> : T;\n\n// Examples\ntype A = UnwrapPromise<Promise<string>>; // string\ntype B = UnwrapPromise<Promise<Promise<number>>>; // number\ntype C = UnwrapPromise<boolean>; // boolean",
        "type TypeName<T> =\nT extends string ? \"string\" :\nT extends number ? \"number\" :\nT extends boolean ? \"boolean\" :\nT extends undefined ? \"undefined\" :\nT extends Function ? \"function\" :\n\"object\";\n\n// Usage\ntype T0 = TypeName<string>; // \"string\"\ntype T1 = TypeName<42>; // \"number\"\ntype T2 = TypeName<true>; // \"boolean\"\ntype T3 = TypeName<() => void>; // \"function\"\ntype T4 = TypeName<Date[]>; // \"object\"",
        "// A function that returns different types based on input type\nfunction processValue<T>(value: T): T extends string\n? string\n: T extends number\n? number\n: T extends boolean\n? boolean\n: never {\n\nif (typeof value === \"string\") {\nreturn value.toUpperCase() as any; // Type assertion needed due to limitations\n} else if (typeof value === \"number\") {\nreturn (value * 2) as any;\n} else if (typeof value === \"boolean\") {\nreturn (!value) as any;\n} else {\nthrow new Error(\"Unsupported type\");\n}\n}\n\n// Usage\nconst stringResult = processValue(\"hello\"); // Returns \"HELLO\" (type is string)\nconst numberResult = processValue(10); // Returns 20 (type is number)\nconst boolResult = processValue(true); // Returns false (type is boolean)",
        "infer",
        "T extends U ? X : Y",
        "T",
        "U",
        "X",
        "Y"
      ]
    },
    {
      "title": "TypeScript Mapped Types",
      "summary": "Mapped types in TypeScript allow you to create new types by transforming properties of existing types.\nMapped types = transform every property of a type\nCommon ones: Partial, Readonly, Pick, Omit, Record\nExampleGet your own TypeScript Server\nREMOVE ADS\nBasic Mapped Type Syntax\nCore Syntax\nMapped types use the syntax { [P in K]: T } where:\nP is the property name being iterated\nK is a union of property names to iterate over\nT is the resulting type for each property\nExample\nBuilt-in Mapped Types\nStandard Library Utilities\nTypeScript includes several useful built-in mapped types:\nPartial<T>: make all props optional\nReadonly<T>: make all props readonly\nPick<T, K>: select a subset of keys\nOmit<T, K>: remove keys\nRecord<K, V>: map keys to a value type\nExample\nCreating Custom Mapped Types\nBasic Custom Mappers\nYou can create your own mapped types to transform types in specific ways:\nExample\nModifying Property Modifiers\nAdding and Removing Modifiers\nMapped types also allow you to add or remove property modifiers like readonly and ? (optional):\nExample\nAdvanced Mapped Types\nCombining with Conditional Types\nMapped types become even more powerful when combined with conditional types:\nExample\nKey Takeaways\nMapped types let you transform every property of a type in a consistent way.\nKey Concepts\nType Transformation: Modify property types in bulk\nProperty Modifiers: Add or remove readonly and ? modifiers\nKey Remapping: Rename or filter properties using as clauses\nComposition: Combine with other TypeScript features\nCommon Use Cases\nCreating read-only versions of types\nMaking all properties optional or required\nTransforming property types (e.g., to nullable or readonly)\nFiltering properties based on their types\nCreating type-safe utility functions",
      "examples": [
        "// Small example\ntype Person = { name: string; age: number };\ntype PartialPerson = { [P in keyof Person]?: Person[P] };\ntype ReadonlyPerson = { readonly [P in keyof Person]: Person[P] };",
        "// Define an object type\ninterface Person {\nname: string;\nage: number;\nemail: string;\n}\n\n// Create a mapped type that makes all properties optional\ntype PartialPerson = {\n[P in keyof Person]?: Person[P];\n};\n\n// Usage\nconst partialPerson: PartialPerson = {\nname: \"John\"\n// age and email are optional\n};\n\n// Create a mapped type that makes all properties readonly\ntype ReadonlyPerson = {\nreadonly [P in keyof Person]: Person[P];\n};\n\n// Usage\nconst readonlyPerson: ReadonlyPerson = {\nname: \"Alice\",\nage: 30,\nemail: \"alice@example.com\"\n};\n\n// readonlyPerson.age = 31; // Error: Cannot assign to 'age' because it is a read-only property",
        "interface User {\nid: number;\nname: string;\nemail: string;\nisAdmin: boolean;\n}\n\n// Partial<T> - Makes all properties optional\ntype PartialUser = Partial<User>;\n// Equivalent to: { id?: number; name?: string; email?: string; isAdmin?: boolean; }\n\n// Required<T> - Makes all properties required\ntype RequiredUser = Required<Partial<User>>;\n// Equivalent to: { id: number; name: string; email: string; isAdmin: boolean; }\n\n// Readonly<T> - Makes all properties readonly\ntype ReadonlyUser = Readonly<User>;\n// Equivalent to: { readonly id: number; readonly name: string; ... }\n\n// Pick<T, K> - Creates a type with a subset of properties from T\ntype UserCredentials = Pick<User, \"email\" | \"id\">;\n// Equivalent to: { email: string; id: number; }\n\n// Omit<T, K> - Creates a type by removing specified properties from T\ntype PublicUser = Omit<User, \"id\" | \"isAdmin\">;\n// Equivalent to: { name: string; email: string; }\n\n// Record<K, T> - Creates a type with specified keys and value types\ntype UserRoles = Record<\"admin\" | \"user\" | \"guest\", string>;\n// Equivalent to: { admin: string; user: string; guest: string; }",
        "// Base interface\ninterface Product {\nid: number;\nname: string;\nprice: number;\ninStock: boolean;\n}\n\n// Create a mapped type to convert all properties to string type\ntype StringifyProperties<T> = {\n[P in keyof T]: string;\n};\n\n// Usage\ntype StringProduct = StringifyProperties<Product>;\n// Equivalent to: { id: string; name: string; price: string; inStock: string; }\n\n// Create a mapped type that adds validation functions for each property\ntype Validator<T> = {\n[P in keyof T]: (value: T[P]) => boolean;\n};\n\n// Usage\nconst productValidator: Validator<Product> = {\nid: (id) => id > 0,\nname: (name) => name.length > 0,\nprice: (price) => price >= 0,\ninStock: (inStock) => typeof inStock === \"boolean\"\n};",
        "// Base interface with some readonly and optional properties\ninterface Configuration {\nreadonly apiKey: string;\nreadonly apiUrl: string;\ntimeout?: number;\nretries?: number;\n}\n\n// Remove readonly modifier from all properties\ntype Mutable<T> = {\n-readonly [P in keyof T]: T[P];\n};\n\n// Usage\ntype MutableConfig = Mutable<Configuration>;\n// Equivalent to: { apiKey: string; apiUrl: string; timeout?: number; retries?: number; }\n\n// Make all optional properties required\ntype RequiredProps<T> = {\n[P in keyof T]-?: T[P];\n};\n\n// Usage\ntype RequiredConfig = RequiredProps<Configuration>;\n// Equivalent to: { readonly apiKey: string; readonly apiUrl: string; timeout: number; retries: number; }",
        "// Base interface\ninterface ApiResponse {\ndata: unknown;\nstatus: number;\nmessage: string;\ntimestamp: number;\n}\n\n// Conditional mapped type: Convert each numeric property to a formatted string\ntype FormattedResponse<T> = {\n[P in keyof T]: T[P] extends number ? string : T[P];\n};\n\n// Usage\ntype FormattedApiResponse = FormattedResponse<ApiResponse>;\n// Equivalent to: { data: unknown; status: string; message: string; timestamp: string; }\n\n// Another example: Filter for only string properties\ntype StringPropsOnly<T> = {\n[P in keyof T as T[P] extends string ? P : never]: T[P];\n};\n\n// Usage\ntype ApiResponseStringProps = StringPropsOnly<ApiResponse>;\n// Equivalent to: { message: string; }",
        "Partial",
        "Readonly",
        "Pick",
        "Omit",
        "Record",
        "{ [P in K]: T }",
        "P",
        "K",
        "T",
        "Partial<T>",
        "Readonly<T>",
        "Pick<T, K>",
        "Omit<T, K>",
        "Record<K, V>",
        "readonly",
        "?",
        "as"
      ]
    },
    {
      "title": "TypeScript Type Inference",
      "summary": "Understanding Type Inference in TypeScript\nType inference is TypeScript's ability to automatically determine and assign types to variables, function returns, and expressions based on their usage and context, without requiring explicit type annotations.\nThis powerful feature reduces verbosity while maintaining type safety.\nKey Concepts\nType inference: Automatic type detection from assigned values\nContextual typing: Types inferred from surrounding context\nBest common type: Algorithm for finding a compatible type\nWidening/Narrowing: Types expand or get constrained by usage\nWhen it happens: variable init, returns, default params, callbacks, literals\nExampleGet your own TypeScript Server\nREMOVE ADS\nFunction Return Type Inference\nTypeScript can infer the return type of a function based on its return statements:\nExample\nContextual Typing\nTypeScript can infer types based on the context in which expressions occur:\nExample\nType Inference in Object Literals\nWhen working with object literals, TypeScript infers the types of properties:\nExample\nAdvanced Patterns\nConst Assertions\nExample\nType Guards and Control Flow Analysis\nExample\nBest Practices\nHere are some best practices for working with TypeScript's type inference:\nExample\nWhen to Use Explicit Types\nWhile type inference is powerful, there are situations where explicit type annotations are recommended:\nRecommended for Explicit Types\nPublic API Contracts: Function parameters and return types in library code\nComplex Types: When the inferred type is too broad or complex\nDocumentation: To make the code more self-documenting\nType Safety: When you need to enforce specific constraints\nEmpty Collections: Empty arrays or objects that will be populated later\nPerformance Considerations\nExample",
      "examples": [
        "// TypeScript infers these variable types\nlet name = \"Alice\"; // inferred as string\nlet age = 30; // inferred as number\nlet isActive = true; // inferred as boolean\nlet numbers = [1, 2, 3]; // inferred as number[]\nlet mixed = [1, \"two\", true]; // inferred as (string | number | boolean)[]\n\n// Using the inferred types\nname.toUpperCase(); // Works because name is inferred as string\nage.toFixed(2); // Works because age is inferred as number\n// name.toFixed(2); // Error: Property 'toFixed' does not exist on type 'string'",
        "// Return type is inferred as string\nfunction greet(name: string) {\nreturn `Hello, ${name}!`;\n}\n\n// Return type is inferred as number\nfunction add(a: number, b: number) {\nreturn a + b;\n}\n\n// Return type is inferred as string | number\nfunction getValue(key: string) {\nif (key === \"name\") {\nreturn \"Alice\";\n} else {\nreturn 42;\n}\n}\n// Using the inferred return types\nlet greeting = greet(\"Bob\"); // inferred as string\nlet sum = add(5, 3); // inferred as number\nlet value = getValue(\"age\"); // inferred as string | number",
        "// The type of the callback parameter is inferred from the array method context\nconst names = [\"Alice\", \"Bob\", \"Charlie\"];\n\n// Parameter 'name' is inferred as string\nnames.forEach(name => {\nconsole.log(name.toUpperCase());\n});\n\n// Parameter 'name' is inferred as string, and the return type is inferred as number\nconst nameLengths = names.map(name => {\nreturn name.length;\n});\n\n// nameLengths is inferred as number[]\n\n// Parameter types in event handlers are also inferred\ndocument.addEventListener(\"click\", event => {\n// 'event' is inferred as MouseEvent\nconsole.log(event.clientX, event.clientY);\n});",
        "// TypeScript infers the type of this object\nconst user = {\nid: 1,\nname: \"Alice\",\nemail: \"alice@example.com\",\nactive: true,\ndetails: {\nage: 30,\naddress: {\ncity: \"New York\",\ncountry: \"USA\"\n}\n}\n};\n\n// Accessing inferred properties\nconsole.log(user.name.toUpperCase());\nconsole.log(user.details.age.toFixed(0));\nconsole.log(user.details.address.city.toLowerCase());\n\n// Type errors would be caught\n// console.log(user.age); // Error: Property 'age' does not exist on type '...'\n// console.log(user.details.name); // Error: Property 'name' does not exist on type '...'\n// console.log(user.details.address.zip); // Error: Property 'zip' does not exist on type '...'",
        "// Regular type inference (widens to string)\nlet name = \"Alice\";  // type: string\n\n// Const assertion (narrows to literal type)\nconst nameConst = \"Alice\" as const;  // type: \"Alice\"\n\n// With objects\nconst user = {\nid: 1,\nname: \"Alice\",\nroles: [\"admin\", \"user\"] as const  // readonly tuple\n} as const;\n\n// user.name = \"Bob\";  // Error: Cannot assign to 'name' because it is a read-only property",
        "function processValue(value: string | number) {\n// Type is narrowed to string in this block\nif (typeof value === \"string\") {\nconsole.log(value.toUpperCase());\n}\n// Type is narrowed to number here\nelse {\nconsole.log(value.toFixed(2));\n}\n}\n\n// Discriminated unions\ninterface Circle { kind: \"circle\"; radius: number; }\ninterface Square { kind: \"square\"; size: number; }\ntype Shape = Circle | Square;\n\nfunction area(shape: Shape) {\n// Type is narrowed based on 'kind' property\nswitch (shape.kind) {\ncase \"circle\":\nreturn Math.PI * shape.radius ** 2;\ncase \"square\":\nreturn shape.size ** 2;\n}\n}",
        "// 1. Let TypeScript infer simple types\nlet message = \"Hello\"; // Good: no need for explicit type here\n\n// 2. Provide explicit types for function parameters\nfunction formatName(firstName: string, lastName: string) {\nreturn `${firstName} ${lastName}`;\n}\n\n// 3. Consider adding return type annotations for complex functions\nfunction processData(input: string[]): { count: number; items: string[] } {\nreturn {\ncount: input.length,\nitems: input.map(item => item.trim())\n};\n}\n\n// 4. Use explicit type annotations for empty arrays or objects\nconst emptyArray: string[] = []; // Without annotation, inferred as any[]\nconst configOptions: Record<string, unknown> = {}; // Without annotation, inferred as {}\n\n// 5. Use type assertions when TypeScript cannot infer correctly\nconst canvas = document.getElementById(\"main-canvas\") as HTMLCanvasElement;",
        "// Good: Explicit type for complex return values\nfunction processData(input: string[]): { results: string[]; count: number } {\nreturn {\nresults: input.map(processItem),\ncount: input.length\n};\n}\n\n// Good: Explicit type for empty arrays\nconst items: Array<{ id: number; name: string }> = [];\n\n// Good: Explicit type for configuration objects\nconst config: {\napiUrl: string;\nretries: number;\ntimeout: number;\n} = {\napiUrl: \"https://api.example.com\",\nretries: 3,\ntimeout: 5000\n};"
      ]
    },
    {
      "title": "TypeScript Literal Types",
      "summary": "Understanding Literal Types in TypeScript\nLiteral types in TypeScript allow you to specify exact values that variables can hold, providing more precision than broader types like string or number.\nThey are the building blocks for creating precise and type-safe applications.\nKey Concepts\nString Literals: Exact string values like \"success\" | \"error\"\nNumeric Literals: Specific numbers like 1 | 2 | 3\nBoolean Literals: Either true or false\nTemplate Literal Types: String literal types built using template string syntax\nCommon Use Cases\nDefining specific sets of allowed values\nCreating discriminated unions\nType-safe event handling\nAPI response typing\nConfiguration objects\nString Literal Types\nA string literal type represents a specific string value:\nExampleGet your own TypeScript Server\nREMOVE ADS\nNumeric Literal Types\nSimilar to string literals, numeric literal types represent specific numeric values:\nExample\nBoolean Literal Types\nBoolean literal types are less commonly used since there are only two boolean values, but they can be useful in specific scenarios:\nExample\nLiteral Types with Objects\nLiteral types can be combined with object types to create very specific shapes:\nExample\nTemplate Literal Types\nTypeScript 4.1+ introduced template literal types, which allow you to create new string literal types by combining existing ones using template string syntax:\nExample\nBest Practices\nDo's and Don'ts\nUse literal types for fixed sets of values (enums, configuration options)\nCombine with union types for better type safety\nUse template literal types for string pattern matching\nLeverage type inference when possible\nDocument the meaning of literal types\nOveruse literal types when a more general type would be better\nCreate extremely large union types that hurt performance\nUse string literals when an enum would be more appropriate\nPerformance Considerations\nType Checking Performance\nLarge union types can slow down type checking\nComplex template literal types can increase compilation time\nConsider using type aliases for complex literal types\nBe mindful of TypeScript's recursion depth limits",
      "examples": [
        "// A variable with a string literal type\nlet direction: \"north\" | \"south\" | \"east\" | \"west\";\n\n// Valid assignments\ndirection = \"north\";\ndirection = \"south\";\n\n// Invalid assignments would cause errors\n// direction = \"northeast\"; // Error: Type '\"northeast\"' is not assignable to type '\"north\" | \"south\" | \"east\" | \"west\"'\n// direction = \"up\"; // Error: Type '\"up\"' is not assignable to type '\"north\" | \"south\" | \"east\" | \"west\"'\n\n// Using string literal types in functions\nfunction move(direction: \"north\" | \"south\" | \"east\" | \"west\") {\nconsole.log(`Moving ${direction}`);\n}\n\nmove(\"east\"); // Valid\n// move(\"up\"); // Error: Argument of type '\"up\"' is not assignable to parameter of type...",
        "// A variable with a numeric literal type\nlet diceRoll: 1 | 2 | 3 | 4 | 5 | 6;\n\n// Valid assignments\ndiceRoll = 1;\ndiceRoll = 6;\n\n// Invalid assignments would cause errors\n// diceRoll = 0; // Error: Type '0' is not assignable to type '1 | 2 | 3 | 4 | 5 | 6'\n// diceRoll = 7; // Error: Type '7' is not assignable to type '1 | 2 | 3 | 4 | 5 | 6'\n// diceRoll = 2.5; // Error: Type '2.5' is not assignable to type '1 | 2 | 3 | 4 | 5 | 6'\n\n// Using numeric literal types in functions\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\nreturn Math.floor(Math.random() * 6) + 1 as 1 | 2 | 3 | 4 | 5 | 6;\n}\n\nconst result = rollDice();\nconsole.log(`You rolled a ${result}`);",
        "// A type that can only be the literal value 'true'\ntype YesOnly = true;\n\n// A function that must return true\nfunction alwaysSucceed(): true {\n// Always returns the literal value 'true'\nreturn true;\n}\n\n// Boolean literal combined with other types\ntype SuccessFlag = true | \"success\" | 1;\ntype FailureFlag = false | \"failure\" | 0;\n\nfunction processResult(result: SuccessFlag | FailureFlag) {\nif (result === true || result === \"success\" || result === 1) {\nconsole.log(\"Operation succeeded\");\n} else {\nconsole.log(\"Operation failed\");\n}\n}\n\nprocessResult(true); // \"Operation succeeded\"\nprocessResult(\"success\"); // \"Operation succeeded\"\nprocessResult(1); // \"Operation succeeded\"\nprocessResult(false); // \"Operation failed\"",
        "// Object with literal property values\ntype HTTPSuccess = {\nstatus: 200 | 201 | 204;\nstatusText: \"OK\" | \"Created\" | \"No Content\";\ndata: any;\n};\n\ntype HTTPError = {\nstatus: 400 | 401 | 403 | 404 | 500;\nstatusText: \"Bad Request\" | \"Unauthorized\" | \"Forbidden\" | \"Not Found\" | \"Internal Server Error\";\nerror: string;\n};\n\ntype HTTPResponse = HTTPSuccess | HTTPError;\n\nfunction handleResponse(response: HTTPResponse) {\nif (response.status >= 200 && response.status < 300) {\nconsole.log(`Success: ${response.statusText}`);\nconsole.log(response.data);\n} else {\nconsole.log(`Error ${response.status}: ${response.statusText}`);\nconsole.log(`Message: ${response.error}`);\n}\n}\n\n// Example usage\nconst successResponse: HTTPSuccess = {\nstatus: 200,\nstatusText: \"OK\",\ndata: { username: \"john_doe\", email: \"john@example.com\" }\n};\n\nconst errorResponse: HTTPError = {\nstatus: 404,\nstatusText: \"Not Found\",\nerror: \"User not found in database\"\n};\n\nhandleResponse(successResponse);\nhandleResponse(errorResponse);",
        "// Basic template literals\ntype Direction = \"north\" | \"south\" | \"east\" | \"west\";\ntype Distance = \"1km\" | \"5km\" | \"10km\";\n\n// Using template literals to combine them\ntype DirectionAndDistance = `${Direction}-${Distance}`;\n// \"north-1km\" | \"north-5km\" | \"north-10km\" | \"south-1km\" | ...\n\nlet route: DirectionAndDistance;\nroute = \"north-5km\"; // Valid\nroute = \"west-10km\"; // Valid\n// route = \"north-2km\"; // Error\n// route = \"5km-north\"; // Error\n\n// Advanced string manipulation\ntype EventType = \"click\" | \"hover\" | \"scroll\";\ntype EventTarget = \"button\" | \"link\" | \"div\";\ntype EventName = `on${Capitalize<EventType>}${Capitalize<EventTarget>}`;\n// \"onClickButton\" | \"onClickLink\" | \"onClickDiv\" | ...\n\n// Dynamic property access\ntype User = {\nid: number;\nname: string;\nemail: string;\ncreatedAt: Date;\n};\n\ntype GetterName<T> = `get${Capitalize<string & keyof T>}`;\ntype UserGetters = {\n[K in keyof User as GetterName<User>]: () => User[K];\n};\n// { getId: () => number; getName: () => string; ... }\n\n// String pattern matching\ntype ExtractRouteParams<T extends string> =\nT extends `${string}:${infer Param}/${infer Rest}`\n? Param | ExtractRouteParams<Rest>\n: T extends `${string}:${infer Param}`\n? Param\n: never;\n\ntype Params = ExtractRouteParams<\"/users/:userId/posts/:postId\">; // \"userId\" | \"postId\"\n\n// CSS units and values\ntype CssUnit = 'px' | 'em' | 'rem' | '%' | 'vh' | 'vw';\ntype CssValue = `${number}${CssUnit}`;\n\nlet width: CssValue = '100px'; // Valid\nlet height: CssValue = '50%'; // Valid\n// let margin: CssValue = '10'; // Error\n// let padding: CssValue = '2ex'; // Error\n\n// API versioning\ntype ApiVersion = 'v1' | 'v2' | 'v3';\ntype Endpoint = 'users' | 'products' | 'orders';\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\n\ntype ApiUrl = `https://api.example.com/${ApiVersion}/${Endpoint}`;\n\n// Complex example: Dynamic SQL query builder\ntype Table = 'users' | 'products' | 'orders';\ntype Column<T extends Table> =\nT extends 'users' ? 'id' | 'name' | 'email' | 'created_at' :\nT extends 'products' ? 'id' | 'name' | 'price' | 'in_stock' :\nT extends 'orders' ? 'id' | 'user_id' | 'total' | 'status' : never;\n\ntype WhereCondition<T extends Table> = {\n[K in Column<T>]?: {\nequals?: any;\nnotEquals?: any;\nin?: any[];\n};\n};\n\nfunction query<T extends Table>(\ntable: T,\nwhere?: WhereCondition<T>\n): `SELECT * FROM ${T}${string}` {\n// Implementation would build the query\nreturn `SELECT * FROM ${table}` as const;\n}\n\n// Usage\nconst userQuery = query('users', {\nname: { equals: 'John' },\ncreated_at: { in: ['2023-01-01', '2023-12-31'] }\n});\n// Type: \"SELECT * FROM users WHERE ...\"",
        "string",
        "number",
        "\"success\" | \"error\"",
        "1 | 2 | 3",
        "true",
        "false"
      ]
    },
    {
      "title": "TypeScript Namespaces",
      "summary": "Understanding TypeScript Namespaces\nTypeScript namespaces (previously known as \"internal modules\") provide a powerful way to organize code and prevent naming conflicts by creating a container for related functionality.\nThey help in structuring large codebases and managing scope in a clean, maintainable way.\nKey Concepts\nLogical Grouping: Organize related code into named containers\nScope Management: Control the visibility of code elements\nName Collision Prevention: Avoid conflicts between similarly named components\nCode Organization: Structure large applications in a hierarchical manner\nWhen to Use Namespaces\nOrganizing code in large legacy applications\nWorking with global libraries\nWhen migrating from older JavaScript codebases\nWhen working with code that needs to be available globally\nNote: While namespaces are still fully supported in TypeScript, modern applications typically use ES modules (import/export) for better modularity and tree-shaking support.\nHowever, understanding namespaces is valuable for maintaining legacy codebases and certain library development scenarios.\nBasic Namespace Syntax\nCreating and Using Namespaces\nA namespace is defined using the namespace keyword:\nExampleGet your own TypeScript Server\nREMOVE ADS\nAdvanced Namespace Features\nNested Namespaces\nNamespaces can be nested to create hierarchical organization:\nExample\nNamespace Aliases\nYou can create aliases for namespaces or their members to make long names more manageable:\nExample\nWorking with Multi-file Namespaces\nSplitting Namespaces Across Files\nLarge applications often require splitting code across multiple files.\nTypeScript namespaces can be split across files and combined at compile time using reference comments:\nUsing Reference Comments\nReference comments help TypeScript understand the relationship between files:\nvalidators.ts file:\nExample\nletters-validator.ts file (extends Validation namespace):\nExample\nzipcode-validator.ts file:\nExample\nmain.ts file:\nExample\nTo compile these files into a single JavaScript file, use:\nExample\nNamespaces vs. Modules\nKey Differences\nUnderstanding when to use namespaces versus modules is crucial for TypeScript development:\nModules are the preferred way to organize code in modern TypeScript applications\nNamespaces are still useful for specific scenarios like declaration merging or working with legacy code\nModules have better tooling support and tree-shaking capabilities\nNamespaces can be useful for creating global libraries\nHere's a comparison of when to use namespaces versus ES modules:\nComparison Table\nAdvanced Namespace Patterns\nExample\nNamespaces with Generics\nExample\nBest Practices\nNamespace Best Practices\nUse meaningful, hierarchical namespace names\nExport only what's needed from namespaces\nUse /// <reference /> for ordering in multi-file namespaces\nConsider using modules for new projects\nUse const enums within namespaces for better performance\nDocument your namespaces with JSDoc comments\nCreate overly deep namespace hierarchies (more than 2-3 levels)\nPollute the global scope unnecessarily\nMix namespaces and modules in the same project without a clear strategy\nUse namespaces for small applications - prefer modules\nPerformance Considerations\nLarge namespaces can increase bundle size\nConsider code splitting for large applications\nBe mindful of circular dependencies in complex namespace structures\nUse const enum for better performance with constant values\nMigrating from Namespaces to Modules\nExample\nMigration Steps\nConvert each namespace to a module file\nReplace export with ES module exports\nUpdate imports to use ES module syntax\nConfigure your build system to handle modules\nUpdate tests to work with the new module structure\nConsider using a bundler like webpack or Rollup\nUpdate your tsconfig.json to use \"module\": \"ESNext\"\nMigration Tools\nts-migrate - Automated migration tool from Facebook\ntslint with no-namespace rule to detect namespaces\nTypeScript's built-in refactoring tools",
      "examples": [
        "namespace Validation {\n// Everything inside this block belongs to the Validation namespace\n\n// Export things you want to make available outside the namespace\nexport interface StringValidator {\nisValid(s: string): boolean;\n}\n\n// This is private to the namespace (not exported)\nconst lettersRegexp = /^[A-Za-z]+$/;\n\n// Exported class - available outside the namespace\nexport class LettersValidator implements StringValidator {\nisValid(s: string): boolean {\nreturn lettersRegexp.test(s);\n}\n}\n\n// Another exported class\nexport class ZipCodeValidator implements StringValidator {\nisValid(s: string): boolean {\nreturn /^[0-9]+$/.test(s) && s.length === 5;\n}\n}\n}\n\n// Using the namespace members\nlet letterValidator = new Validation.LettersValidator();\nlet zipCodeValidator = new Validation.ZipCodeValidator();\n\nconsole.log(letterValidator.isValid(\"Hello\")); // true\nconsole.log(letterValidator.isValid(\"Hello123\")); // false\n\nconsole.log(zipCodeValidator.isValid(\"12345\")); // true\nconsole.log(zipCodeValidator.isValid(\"1234\")); // false - wrong length",
        "namespace App {\nexport namespace Utils {\nexport function log(msg: string): void {\nconsole.log(`[LOG]: ${msg}`);\n}\n\nexport function error(msg: string): void {\nconsole.error(`[ERROR]: ${msg}`);\n}\n}\n\nexport namespace Models {\nexport interface User {\nid: number;\nname: string;\nemail: string;\n}\n\nexport class UserService {\ngetUser(id: number): User {\nreturn { id, name: \"John Doe\", email: \"john@example.com\" };\n}\n}\n}\n}\n\n// Using nested namespaces\nApp.Utils.log(\"Application starting\");\n\nconst userService = new App.Models.UserService();\nconst user = userService.getUser(1);\n\nApp.Utils.log(`User loaded: ${user.name}`);\n\n// This would be a type error in TypeScript\n// App.log(\"directly accessing log\"); // Error - log is not a direct member of App",
        "namespace VeryLongNamespace {\nexport namespace DeeplyNested {\nexport namespace Components {\nexport class Button {\ndisplay(): void {\nconsole.log(\"Button displayed\");\n}\n}\nexport class TextField {\ndisplay(): void {\nconsole.log(\"TextField displayed\");\n}\n}\n}\n}\n}\n\n// Without alias - very verbose\nconst button1 = new VeryLongNamespace.DeeplyNested.Components.Button();\nbutton1.display();\n\n// With namespace alias\nimport Components = VeryLongNamespace.DeeplyNested.Components;\nconst button2 = new Components.Button();\nbutton2.display();\n\n// With specific member alias\nimport Button = VeryLongNamespace.DeeplyNested.Components.Button;\nconst button3 = new Button();\nbutton3.display();",
        "namespace Validation {\nexport interface StringValidator {\nisValid(s: string): boolean;\n}\n}",
        "/// <reference path=\"validators.ts\" />\nnamespace Validation {\nconst lettersRegexp = /^[A-Za-z]+$/;\n\nexport class LettersValidator implements StringValidator {\nisValid(s: string): boolean {\nreturn lettersRegexp.test(s);\n}\n}\n}",
        "/// <reference path=\"validators.ts\" />\nnamespace Validation {\nconst zipCodeRegexp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\nisValid(s: string): boolean {\nreturn zipCodeRegexp.test(s) && s.length === 5;\n}\n}\n}",
        "/// <reference path=\"validators.ts\" />\n/// <reference path=\"letters-validator.ts\" />\n/// <reference path=\"zipcode-validator.ts\" />\n\n// Now you can use the validators from multiple files\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"letters\"] = new Validation.LettersValidator();\nvalidators[\"zipcode\"] = new Validation.ZipCodeValidator();\n\n// Some samples to validate\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validate each\nstrings.forEach(s => {\nfor (let name in validators) {\nconsole.log(`\"${s}\" - ${validators[name].isValid(s) ? \"matches\" : \"does not match\"} ${name}`);\n}\n});",
        "tsc --outFile sample.js main.ts",
        "// Original namespace\ndeclare namespace Express {\ninterface Request {\nuser?: { id: number; name: string };\n}\ninterface Response {\njson(data: any): void;\n}\n}\n\n// Later in your application (e.g., in a .d.ts file)\ndeclare namespace Express {\n// Augment the Request interface\ninterface Request {\n// Add custom properties\nrequestTime?: number;\n// Add methods\nlog(message: string): void;\n}\n\n// Add new types\ninterface UserSession {\nuserId: number;\nexpires: Date;\n}\n}\n\n// Usage in your application\nconst app = express();\n\napp.use((req: Express.Request, res: Express.Response, next) => {\n// Augmented properties and methods are available\nreq.requestTime = Date.now();\nreq.log('Request started');\nnext();\n});",
        "// Generic namespace example\nnamespace DataStorage {\nexport interface Repository<T> {\ngetAll(): T[];\ngetById(id: number): T | undefined;\nadd(item: T): void;\nupdate(id: number, item: T): boolean;\ndelete(id: number): boolean;\n}\n\n// Concrete implementation\nexport class InMemoryRepository<T> implements Repository<T> {\nprivate items: T[] = [];\n\ngetAll(): T[] {\nreturn [...this.items];\n}\n\ngetById(id: number): T | undefined {\nreturn this.items[id];\n}\n\nadd(item: T): void {\nthis.items.push(item);\n}\n\nupdate(id: number, item: T): boolean {\nif (id >= 0 && id < this.items.length) {\nthis.items[id] = item;\nreturn true;\n}\nreturn false;\n}\n\ndelete(id: number): boolean {\nif (id >= 0 && id < this.items.length) {\nthis.items.splice(id, 1);\nreturn true;\n}\nreturn false;\n}\n}\n}\n\n// Usage\ninterface User {\nid: number;\nname: string;\nemail: string;\n}\n\nconst userRepo = new DataStorage.InMemoryRepository<User>();\nuserRepo.add({ id: 1, name: 'John Doe', email: 'john@example.com' });\nconst allUsers = userRepo.getAll();",
        "// Before: Using namespaces\nnamespace MyApp {\nexport namespace Services {\nexport class UserService {\ngetUser(id: number) { /* ... */ }\n}\n}\n}\n\n// After: Using ES modules\n// services/UserService.ts\nexport class UserService {\ngetUser(id: number) { /* ... */ }\n}\n\n// app.ts\nimport { UserService } from './services/UserService';\nconst userService = new UserService();",
        "namespace",
        "MyNS.Member",
        "import",
        "export",
        "--outFile",
        "/// <reference />",
        "const enum",
        "tsconfig.json",
        "\"module\": \"ESNext\"",
        "ts-migrate",
        "tslint",
        "no-namespace"
      ]
    },
    {
      "title": "TypeScript Index Signatures",
      "summary": "Understanding Index Signatures in TypeScript\nIndex signatures in TypeScript provide a powerful way to define types for objects with dynamic property names while maintaining type safety.\nThey allow you to specify the types of values that can be accessed via bracket notation (obj[key]), even when the exact property names aren't known in advance.\nKey Concepts\nDynamic Property Access: Handle objects with arbitrary property names\nType Safety: Ensure consistent value types across dynamic properties\nFlexible Data Structures: Model dictionaries, maps, and other dynamic data\nRuntime Safety: Catch type-related errors at compile time\nBasic Index Signatures\nString Index Signatures\nIndex signatures in TypeScript allow you to define types for objects where you don't know the property names in advance, but you do know the shape of the values.\nAn index signature defines the types for properties accessed via an index like obj[key].\nExampleGet your own TypeScript Server\nThe index signature syntax uses brackets [key: type] to describe the types of the property names (or keys) that are allowed, followed by the type of values these properties can have.\nREMOVE ADS\nNumber Index Signatures\nTypeScript supports both string and number index signatures:\nExample\nNote: In JavaScript, all object keys are stored as strings, even numeric ones.\nHowever, TypeScript makes a distinction to help catch logical errors when using arrays vs objects.\nAdvanced Index Signature Patterns\nMixed Property Types\nYou can combine index signatures with explicit property declarations:\nExample\nImportant: When combining explicit properties with an index signature, the types of explicit properties must be assignable to the index signature's value type.\nReadOnly Index Signatures\nYou can make index signatures read-only to prevent modification after creation:\nExample\nFor constraining key sets and transforming shapes, see Mapped Types.\nReal-World Examples\nAPI Response Handling\nExample\nBest Practices\nDo's and Don'ts\nUse index signatures for collections with dynamic keys\nCombine with explicit properties for known fields\nKeep value types specific (avoid any)\nUse readonly when mutation isn't needed\nPrefer fixed interfaces when keys are known\nForget that all properties must conform to the index signature type\nReinvent mapped types—use the dedicated page for transformations\nCommon Pitfalls\nProperty Name Conflicts\nIndex Signatures vs. Record<K, T>\nUse an index signature for flexible/dynamic keys and when mixing with other properties.\nUse Record<K, T> for concise simple mappings.\nConclusion\nUse index signatures when keys are dynamic but value shapes are consistent.\nCombine with explicit properties where possible, and see Mapped Types and Utility Types for advanced transformations.",
      "examples": [
        "// This interface represents an object with string keys and string values\ninterface StringDictionary {\n[key: string]: string;\n}\n\n// Creating a compliant object\nconst names: StringDictionary = {\nfirstName: \"Alice\",\nlastName: \"Smith\",\n\"100\": \"One Hundred\"\n};\n\n// Accessing properties\nconsole.log(names[\"firstName\"]); // \"Alice\"\nconsole.log(names[\"lastName\"]); // \"Smith\"\nconsole.log(names[\"100\"]); // \"One Hundred\"\n\n// Adding new properties dynamically\nnames[\"age\"] = \"30\";\n\n// This would cause an error\n// names[\"age\"] = 30; // Error: Type 'number' is not assignable to type 'string'",
        "// Object with number indexes\ninterface NumberDictionary {\n[index: number]: any;\n}\n\nconst scores: NumberDictionary = {\n0: \"Zero\",\n1: 100,\n2: true\n};\n\nconsole.log(scores[0]); // \"Zero\"\nconsole.log(scores[1]); // 100\nconsole.log(scores[2]); // true\n\n// Adding a complex object\nscores[3] = { passed: true };",
        "interface UserInfo {\nname: string; // Required property with specific name\nage: number;  // Required property with specific name\n[key: string]: string | number; // All other properties must be string or number\n}\n\nconst user: UserInfo = {\nname: \"Alice\", // Required\nage: 30,      // Required\naddress: \"123 Main St\", // Optional\nzipCode: 12345 // Optional\n};\n\n// This would cause an error\n// const invalidUser: UserInfo = {\n//  name: \"Bob\",\n//  age: \"thirty\", // Error: Type 'string' is not assignable to type 'number'\n//  isAdmin: true  // Error: Type 'boolean' is not assignable to type 'string | number'\n// };",
        "interface ReadOnlyStringArray {\nreadonly [index: number]: string;\n}\n\nconst names: ReadOnlyStringArray = [\"Alice\", \"Bob\", \"Charlie\"];\n\nconsole.log(names[0]); // \"Alice\"\n\n// This would cause an error\n// names[0] = \"Andrew\"; // Error: Index signature in type 'ReadOnlyStringArray' only permits reading",
        "// Type for API responses with dynamic keys\ninterface ApiResponse<T> {\ndata: {\n[resourceType: string]: T[];  // e.g., { \"users\": User[], \"posts\": Post[] }\n};\nmeta: {\npage: number;\ntotal: number;\n[key: string]: any;  // Allow additional metadata\n};\n}\n\n// Example usage with a users API\ninterface User {\nid: number;\nname: string;\nemail: string;\n}\n\n// Mock API response\nconst apiResponse: ApiResponse<User> = {\ndata: {\nusers: [\n{ id: 1, name: \"Alice\", email: \"alice@example.com\" },\n{ id: 2, name: \"Bob\", email: \"bob@example.com\" }\n]\n},\nmeta: {\npage: 1,\ntotal: 2,\ntimestamp: \"2023-01-01T00:00:00Z\"\n}\n};\n\n// Accessing the data\nconst users = apiResponse.data.users;\nconsole.log(users[0].name);  // \"Alice\"",
        "interface ConflictingTypes {\n[key: string]: number;\nname: string; // Error: not assignable to string index type 'number'\n}\n\ninterface FixedTypes {\n[key: string]: number | string;\nname: string;  // OK\nage: number;   // OK\n}",
        "// Index signature\ninterface StringMap {\n[key: string]: string;\n}\n\n// Record\ntype StringRecord = Record<string, string>;",
        "obj[key]",
        "[key: type]",
        "any",
        "readonly",
        "Record<K, T>"
      ]
    },
    {
      "title": "TypeScript Declaration Merging",
      "summary": "Understanding Declaration Merging\nDeclaration merging is a powerful TypeScript feature that allows you to combine multiple declarations with the same name into a single definition.\nThis enables you to build up complex types incrementally and extend existing types in a type-safe manner.\nKey Benefits\nProgressive Enhancement: Build types incrementally across multiple declarations\nExtensibility: Add new members to existing types without modifying original definitions\nOrganization: Split large type definitions into logical groupings\nCompatibility: Extend third-party type definitions when needed\nCommon Use Cases\nExtending built-in types and third-party library types\nAdding type information for JavaScript libraries\nOrganizing large interfaces across multiple files\nCreating fluent APIs with method chaining\nImplementing the module augmentation pattern\nInterface Merging\nInterfaces with the same name are automatically merged:\nExampleGet your own TypeScript Server\nREMOVE ADS\nFunction Overloads with Merging\nYou can define multiple function declarations that later merge when implemented:\nExample\nNamespace Merging\nNamespaces with the same name are merged:\nExample\nClass and Interface Merging\nA class declaration can merge with an interface of the same name:\nExample\nEnum Merging\nEnum declarations with the same name are merged:\nExample\nModule Augmentation\nYou can extend existing modules or libraries by declaring additional types and functionality:\nExample\nBest Practices\nThere are some rules to consider when using declaration merging:\nOrder matters for function overloads: The implementation signature should be the most general\nNon-function members must be compatible: If two interfaces declare a property with the same name, the types must be identical or compatible\nLater interfaces take precedence: If conflicts exist in merged interfaces, the last declaration wins\nPrivate and protected members: Classes can't merge if they have private or protected members with the same name but different types\nNamespace exports: Only exported declarations are visible outside the namespace after merging\nPerformance Considerations\nCompilation Time: Excessive declaration merging can increase compilation time\nType Checking: Complex merged types may impact IDE performance\nBundle Size: Declaration merging doesn't affect runtime performance or bundle size\nKeep merged interfaces focused and cohesive\nAvoid deep nesting in merged types\nUse type aliases for simple type combinations instead of merging",
      "examples": [
        "// First declaration\ninterface Person {\nname: string;\nage: number;\n}\n\n// Second declaration with the same name\ninterface Person {\naddress: string;\nemail: string;\n}\n\n// TypeScript merges them into:\n// interface Person {\n// name: string;\n// age: number;\n// address: string;\n// email: string;\n// }\n\nconst person: Person = {\nname: \"John\",\nage: 30,\naddress: \"123 Main St\",\nemail: \"john@example.com\"\n};\n\nconsole.log(person);",
        "// Function overloads\nfunction processValue(value: string): string;\nfunction processValue(value: number): number;\nfunction processValue(value: boolean): boolean;\n\n// Implementation that handles all overloads\nfunction processValue(value: string | number | boolean): string | number | boolean {\nif (typeof value === \"string\") {\nreturn value.toUpperCase();\n} else if (typeof value === \"number\") {\nreturn value * 2;\n} else {\nreturn !value;\n}\n}\n\n// Using the function with different types\nconsole.log(processValue(\"hello\")); // \"HELLO\"\nconsole.log(processValue(10)); // 20\nconsole.log(processValue(true)); // false",
        "namespace Validation {\nexport interface StringValidator {\nisValid(s: string): boolean;\n}\n}\n\nnamespace Validation {\nexport interface NumberValidator {\nisValid(n: number): boolean;\n}\n\nexport class ZipCodeValidator implements StringValidator {\nisValid(s: string): boolean {\nreturn s.length === 5 && /^\\d+$/.test(s);\n}\n}\n}\n\n// After merging:\n// namespace Validation {\n// export interface StringValidator { isValid(s: string): boolean; }\n// export interface NumberValidator { isValid(n: number): boolean; }\n// export class ZipCodeValidator implements StringValidator { ... }\n// }\n\n// Using the merged namespace\nconst zipValidator = new Validation.ZipCodeValidator();\n\nconsole.log(zipValidator.isValid(\"12345\")); // true\nconsole.log(zipValidator.isValid(\"1234\")); // false\nconsole.log(zipValidator.isValid(\"abcde\")); // false",
        "// Interface declaration\ninterface Cart {\ncalculateTotal(): number;\n}\n\n// Class declaration with same name\nclass Cart {\nitems: { name: string; price: number }[] = [];\n\naddItem(name: string, price: number): void {\nthis.items.push({ name, price });\n}\n\n// Must implement the interface method\ncalculateTotal(): number {\nreturn this.items.reduce((sum, item) => sum + item.price, 0);\n}\n}\n\n// Using the merged class and interface\nconst cart = new Cart();\ncart.addItem(\"Book\", 15.99);\ncart.addItem(\"Coffee Mug\", 8.99);\n\nconsole.log(`Total: $${cart.calculateTotal().toFixed(2)}`);",
        "// First part of the enum\nenum Direction {\nNorth,\nSouth\n}\n\n// Second part of the enum\nenum Direction {\nEast = 2,\nWest = 3\n}\n\n// After merging:\n// enum Direction {\n// North = 0,\n// South = 1,\n// East = 2,\n// West = 3\n// }\n\nconsole.log(Direction.North); // 0\nconsole.log(Direction.South); // 1\nconsole.log(Direction.East); // 2\nconsole.log(Direction.West); // 3\n\n// Can also access by value\nconsole.log(Direction[0]); // \"North\"\nconsole.log(Direction[2]); // \"East\"",
        "// Original library definition\n// Imagine this comes from a third-party library\ndeclare namespace LibraryModule {\nexport interface User {\nid: number;\nname: string;\n}\nexport function getUser(id: number): User;\n}\n\n// Augmenting with additional functionality (your code)\ndeclare namespace LibraryModule {\n// Add new interface\nexport interface UserPreferences {\ntheme: string;\nnotifications: boolean;\n}\n\n// Add new property to existing interface\nexport interface User {\npreferences?: UserPreferences;\n}\n\n// Add new function\nexport function getUserPreferences(userId: number): UserPreferences;\n}\n\n// Using the augmented module\nconst user = LibraryModule.getUser(123);\nconsole.log(user.preferences?.theme);\n\nconst prefs = LibraryModule.getUserPreferences(123);\nconsole.log(prefs.notifications);",
        "type"
      ]
    },
    {
      "title": "TypeScript Async Programming",
      "summary": "TypeScript enhances JavaScript's asynchronous capabilities with static typing, making your async code more predictable and maintainable.\nThis guide covers everything from basic async/await to advanced patterns.\nThis tutorial assumes basic knowledge of JavaScript Promises and asynchronous programming.\nIf you're new to these concepts, check out our JavaScript Async tutorial first.\nPromises in TypeScript\nTypeScript enhances JavaScript Promises with type safety through generics.\nA Promise<T> represents an asynchronous operation that will complete with a value of type T or fail with a reason of type any.\nKey Points:\nPromise<T> - Generic type where T is the type of the resolved value\nPromise<void> - For Promises that don't return a value\nPromise<never> - For Promises that never resolve (rare)\nBasic Promise ExampleGet your own TypeScript Server\nTypeScript tracks these states through the type system, ensuring you handle both success and error cases properly.\nThe type parameter in Promise<T> tells TypeScript what type the Promise will resolve to, allowing for better type checking and IDE support.\nAsync/Await with TypeScript\nTypeScript's async/await syntax provides a cleaner way to work with Promises, making asynchronous code look and behave more like synchronous code while maintaining type safety.\nReadability: Sequential code that's easier to follow\nError Handling: Use try/catch for both sync and async errors\nDebugging: Easier to debug with synchronous-like stack traces\nType Safety: Full TypeScript type inference and checking\nBasic Async/Await Example\nAll async functions in TypeScript return a Promise.\nThe return type is automatically wrapped in a Promise:\nParallel Execution with Promise.all\nRun multiple async operations in parallel and wait for all to complete:\nNote: All async functions in TypeScript return a Promise.\nThe type parameter of the Promise corresponds to the return type you declare after the Promise keyword.\nREMOVE ADS\nTyping Callbacks for Async Operations\nFor traditional callback-based asynchronous code, TypeScript helps ensure proper typing of the callback parameters:\nExample\nPromise Combinations\nTypeScript provides powerful utility types and methods for working with multiple Promises.\nThese methods help you manage concurrent operations and handle their results in a type-safe way.\nPromise.all() - Waits for all promises to resolve\nPromise.race() - Returns the first settled promise\nPromise.allSettled() - Waits for all to settle (success or failure)\nPromise.any() - Returns the first fulfilled promise\nPromise.all - Parallel Execution\nRun multiple promises in parallel and wait for all to complete.\nFails fast if any promise rejects.\nPromise.race - First to Settle\nUseful for timeouts or getting the first successful response from multiple sources.\nPromise.allSettled - Handle All Results\nWhen you want to wait for all promises to complete, regardless of success or failure.\nWarning: When using Promise.all with an array of promises that have different types, TypeScript will infer the result type as an array of the union of all possible types.\nFor more precise typing, you may need to use type assertions or define the expected structure.\nError Handling in Async Code\nTypeScript provides powerful tools for type-safe error handling in asynchronous code.\nLet's explore different patterns and best practices.\nTry/Catch Blocks: For handling errors in async/await\nError Boundaries: For React components\nResult Types: Functional approach with success/failure\nError Subclassing: For domain-specific errors\nCustom Error Classes\nCreate domain-specific error types for better error handling:\nConsider these patterns for robust error handling:\nError Boundaries in React for component-level error handling\nResult Objects instead of throwing exceptions for expected cases\nGlobal Error Handler for uncaught exceptions\nError Logging to capture and report errors\nAsync Iteration with TypeScript\nTypeScript supports async iterators and async generators with proper typing:\nExample",
      "examples": [
        "// Create a typed Promise that resolves to a string\nconst fetchGreeting = (): Promise<string> => {\nreturn new Promise((resolve, reject) => {\nsetTimeout(() => {\nconst success = Math.random() > 0.5;\nif (success) {\nresolve(\"Hello, TypeScript!\");\n} else {\nreject(new Error(\"Failed to fetch greeting\"));\n}\n}, 1000);\n});\n};\n\n// Using the Promise with proper type inference\nfetchGreeting()\n.then((greeting) => {\n// TypeScript knows 'greeting' is a string\nconsole.log(greeting.toUpperCase());\n})\n.catch((error: Error) => {\nconsole.error(\"Error:\", error.message);\n});",
        "// Define types for our API response\ninterface User {\nid: number;\nname: string;\nemail: string;\nrole: 'admin' | 'user' | 'guest';\n}\n\n// Function that returns a Promise of User array\nasync function fetchUsers(): Promise<User[]> {\nconsole.log('Fetching users...');\n// Simulate API call\nawait new Promise(resolve => setTimeout(resolve, 1000));\nreturn [\n{ id: 1, name: 'Alice', email: 'alice@example.com', role: 'admin' },\n{ id: 2, name: 'Bob', email: 'bob@example.com', role: 'user' }\n];\n}\n\n// Async function to process users\nasync function processUsers() {\ntry {\n// TypeScript knows users is User[]\nconst users = await fetchUsers();\nconsole.log(`Fetched ${users.length} users`);\n\n// Type-safe property access\nconst adminEmails = users\n.filter(user => user.role === 'admin')\n.map(user => user.email);\n\nconsole.log('Admin emails:', adminEmails);\nreturn users;\n} catch (error) {\nif (error instanceof Error) {\nconsole.error('Failed to process users:', error.message);\n} else {\nconsole.error('An unknown error occurred');\n}\nthrow error; // Re-throw to let caller handle\n}\n}\n\n// Execute the async function\nprocessUsers()\n.then(users => console.log('Processing complete'))\n.catch(err => console.error('Processing failed:', err));",
        "async function getString(): string { } // Error: must return Promise\nasync function getString(): Promise<string> { } // Correct",
        "interface Product {\nid: number;\nname: string;\nprice: number;\n}\n\nasync function fetchProduct(id: number): Promise<Product> {\nconsole.log(`Fetching product ${id}...`);\nawait new Promise(resolve => setTimeout(resolve, Math.random() * 1000));\nreturn { id, name: `Product ${id}`, price: Math.floor(Math.random() * 100) };\n}\n\nasync function fetchMultipleProducts() {\ntry {\n// Start all fetches in parallel\nconst [product1, product2, product3] = await Promise.all([\nfetchProduct(1),\nfetchProduct(2),\nfetchProduct(3)\n]);\n\nconst total = [product1, product2, product3]\n.reduce((sum, product) => sum + product.price, 0);\nconsole.log(`Total price: $${total.toFixed(2)}`);\n} catch (error) {\nconsole.error('Error fetching products:', error);\n}\n}\n\nfetchMultipleProducts();",
        "// Define a type for the callback\ntype FetchCallback = (error: Error | null, data?: string) => void;\n\n// Function that takes a typed callback\nfunction fetchDataWithCallback(url: string, callback: FetchCallback): void {\n// Simulate async operation\nsetTimeout(() => {\ntry {\n// Simulate successful response\ncallback(null, \"Response data\");\n} catch (error) {\ncallback(error instanceof Error ? error : new Error('Unknown error'));\n}\n}, 1000);\n}\n\n// Using the callback function\nfetchDataWithCallback('https://api.example.com', (error, data) => {\nif (error) {\nconsole.error('Error:', error.message);\nreturn;\n}\n\n// TypeScript knows data is a string (or undefined)\nif (data) {\nconsole.log(data.toUpperCase());\n}\n});",
        "// Different types of promises\nconst fetchUser = (id: number): Promise<{ id: number; name: string }> =>\nPromise.resolve({ id, name: `User ${id}` });\n\nconst fetchPosts = (userId: number): Promise<Array<{ id: number; title: string }>> =>\nPromise.resolve([     { id: 1, title: 'Post 1' },\n{ id: 2, title: 'Post 2' }\n]);\n\nconst fetchStats = (userId: number): Promise<{ views: number; likes: number }> =>\nPromise.resolve({ views: 100, likes: 25 });\n\n// Run all in parallel\nasync function loadUserDashboard(userId: number) {\ntry {\nconst [user, posts, stats] = await Promise.all([\nfetchUser(userId),\nfetchPosts(userId),\nfetchStats(userId)\n]);\n\n// TypeScript knows the types of user, posts, and stats\nconsole.log(`User: ${user.name}`);\nconsole.log(`Posts: ${posts.length}`);\nconsole.log(`Likes: ${stats.likes}`);\n\nreturn { user, posts, stats };\n} catch (error) {\nconsole.error('Failed to load dashboard:', error);\nthrow error;\n}\n}\n\n// Execute with a user ID\nloadUserDashboard(1);",
        "// Helper function for timeout\nconst timeout = (ms: number): Promise<never> =>\nnew Promise((_, reject) =>\nsetTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms)\n);\n\n// Simulate API call with timeout\nasync function fetchWithTimeout<T>(\npromise: Promise<T>,\ntimeoutMs: number = 5000\n): Promise<T> {\nreturn Promise.race([\npromise,\ntimeout(timeoutMs).then(() => {\nthrow new Error(`Request timed out after ${timeoutMs}ms`);\n}),\n]);\n}\n\n// Usage example\nasync function fetchUserData() {\ntry {\nconst response = await fetchWithTimeout(\nfetch('https://api.example.com/user/1'),\n3000 // 3 second timeout\n);\nconst data = await response.json();\nreturn data;\n} catch (error) {\nconsole.error('Error:', (error as Error).message);\nthrow error;\n}\n}",
        "// Simulate multiple API calls with different outcomes\nconst fetchData = async (id: number) => {\n// Randomly fail some requests\nif (Math.random() > 0.7) {\nthrow new Error(`Failed to fetch data for ID ${id}`);\n}\nreturn { id, data: `Data for ${id}` };\n};\n\n// Process multiple items with individual error handling\nasync function processBatch(ids: number[]) {\nconst promises = ids.map(id =>\nfetchData(id)\n.then(value => ({ status: 'fulfilled' as const, value }))\n.catch(reason => ({ status: 'rejected' as const, reason }))\n);\n\n// Wait for all to complete\nconst results = await Promise.allSettled(promises);\n\n// Process results\nconst successful = results\n.filter((result): result is PromiseFulfilledResult<{ status: 'fulfilled', value: any }> =>\nresult.status === 'fulfilled' &&\nresult.value.status === 'fulfilled'\n)\n.map(r => r.value.value);\n\nconst failed = results\n.filter((result): result is PromiseRejectedResult |\nPromiseFulfilledResult<{ status: 'rejected', reason: any }> => {\nif (result.status === 'rejected') return true;\nreturn result.value.status === 'rejected';\n});\n\nconsole.log(`Successfully processed: ${successful.length}`);\nconsole.log(`Failed: ${failed.length}`);\n\nreturn { successful, failed };\n}\n\n// Process a batch of IDs\nprocessBatch([1, 2, 3, 4, 5]);",
        "// Base error class for our application\nclass AppError extends Error {\nconstructor(\nmessage: string,\npublic readonly code: string,\npublic readonly details?: unknown\n) {\nsuper(message);\nthis.name = this.constructor.name;\nError.captureStackTrace?.(this, this.constructor);\n}\n}\n\n// Specific error types\nclass NetworkError extends AppError {\nconstructor(message: string, details?: unknown) {\nsuper(message, 'NETWORK_ERROR', details);\n}\n}\n\nclass ValidationError extends AppError {\nconstructor(\npublic readonly field: string,\nmessage: string\n) {\nsuper(message, 'VALIDATION_ERROR', { field });\n}\n}\n\nclass NotFoundError extends AppError {\nconstructor(resource: string, id: string | number) {\nsuper(\n`${resource} with ID ${id} not found`,\n'NOT_FOUND',\n{ resource, id }\n);\n}\n}\n\n// Usage example\nasync function fetchUserData(userId: string): Promise<{ id: string; name: string }> {\ntry {\n// Simulate API call\nconst response = await fetch(`/api/users/${userId}`);\n\nif (!response.ok) {\nif (response.status === 404) {\nthrow new NotFoundError('User', userId);\n} else if (response.status >= 500) {\nthrow new NetworkError('Server error', { status: response.status });\n} else {\nthrow new Error(`HTTP error! status: ${response.status}`);\n}\n}\n\nconst data = await response.json();\n\n// Validate response data\nif (!data.name) {\nthrow new ValidationError('name', 'Name is required');\n}\n\nreturn data;\n} catch (error) {\nif (error instanceof AppError) {\n// Already one of our custom errors\nthrow error;\n}\n// Wrap unexpected errors\nthrow new AppError(\n'Failed to fetch user data',\n'UNEXPECTED_ERROR',\n{ cause: error }\n);\n}\n}\n\n// Error handling in the application\nasync function displayUserProfile(userId: string) {\ntry {\nconst user = await fetchUserData(userId);\nconsole.log('User profile:', user);\n} catch (error) {\nif (error instanceof NetworkError) {\nconsole.error('Network issue:', error.message);\n// Show retry UI\n} else if (error instanceof ValidationError) {\nconsole.error('Validation failed:', error.message);\n// Highlight the invalid field\n} else if (error instanceof NotFoundError) {\nconsole.error('Not found:', error.message);\n// Show 404 page\n} else {\nconsole.error('Unexpected error:', error);\n// Show generic error message\n}\n}\n}\n\n// Execute with example data\ndisplayUserProfile('123');",
        "// Async generator function\nasync function* generateNumbers(): AsyncGenerator<number, void, unknown> {\nlet i = 0;\nwhile (i < 5) {\n// Simulate async operation\nawait new Promise(resolve => setTimeout(resolve, 1000));\nyield i++;\n}\n}\n\n// Using the async generator\nasync function consumeNumbers() {\nfor await (const num of generateNumbers()) {\n// TypeScript knows num is a number\nconsole.log(num * 2);\n}\n}",
        "Promise<T>",
        "T",
        "any",
        "Promise<void>",
        "Promise<never>",
        "async/await",
        "Promise.all()",
        "Promise.race()",
        "Promise.allSettled()",
        "Promise.any()",
        "Promise.all"
      ]
    },
    {
      "title": "TypeScript Decorators",
      "summary": "Decorators are a powerful TypeScript feature that allow you to add metadata and modify classes and their members at design time.\nThey are widely used in frameworks like Angular and NestJS for dependency injection, routing, and more.\nEnabling Decorators\nTo use decorators in TypeScript, you need to enable them in your tsconfig.json:\ntsconfig.jsonGet your own TypeScript Server\nNote: The emitDecoratorMetadata option enables experimental support for emitting type metadata for decorators, which is used by libraries like TypeORM and class-validator.\nTypes of Decorators\nTypeScript supports several types of decorators that can be applied to different declarations:\nClass Decorators\nClass decorators are applied to the constructor of a class and can be used to observe, modify, or replace a class definition.\nThey are called when the class is declared, not when instances are created.\nBasic Class Decorator\nThis simple decorator logs when a class is defined:\nREMOVE ADS\nClass Decorator with Constructor Modification\nThis example shows how to modify a class by adding properties and methods:\nSealed Class Decorator\nThis decorator prevents new properties from being added to a class and marks all existing properties as non-configurable:\nClass decorators are called when the class is declared, not when instances are created\nThey receive the class constructor as their only parameter\nThey can return a new constructor function to replace the original class\nThey are executed bottom-up (the innermost decorator runs first)\nThey can be used for logging, sealing, freezing, or adding metadata\nMethod Decorators\nMethod decorators are applied to method definitions and can be used to observe, modify, or replace method definitions.\nThey receive three parameters:\ntarget: The prototype of the class (for instance methods) or the constructor function (for static methods)\npropertyKey: The name of the method\ndescriptor: The property descriptor for the method\nMethod Timing Decorator\nThis decorator measures and logs the execution time of a method:\nMethod Authorization Decorator\nThis example shows how to implement role-based access control using method decorators:\nDeprecation Warning Decorator\nThis decorator adds a deprecation warning to a method that will be removed in a future version:\nMethod decorators are called when the method is defined, not when it's called\nThey can modify the method's behavior by wrapping it with additional logic\nThey can be used for cross-cutting concerns like logging, validation, and authorization\nThey receive the method's property descriptor which allows modifying the method's behavior\nThey must return a property descriptor or undefined (if not modifying the descriptor)\nProperty Decorators\nProperty decorators are applied to property declarations and can be used to observe, modify, or replace property definitions.\nThey receive two parameters:\ntarget: The prototype of the class (for instance properties) or the constructor function (for static properties)\npropertyKey: The name of the property\nFormatted Property Decorator\nThis decorator automatically formats a property when it's set:\nLogging Property Decorator\nThis decorator logs property access and changes:\nRequired Property Decorator\nThis decorator enforces that a property must be set:\nProperty decorators are called when the property is defined, not when it's accessed\nThey don't receive a property descriptor like method decorators do\nTo modify property behavior, you need to use Object.defineProperty\nThey're often used for metadata reflection or to modify property access\nThey can be combined with other decorators for more complex behaviors\nParameter Decorators\nParameter decorators are applied to parameter declarations in a constructor or method.\nThey receive three parameters:\ntarget: The prototype of the class (for instance methods) or the constructor function (for static methods)\npropertyKey: The name of the method (or undefined for constructor parameters)\nparameterIndex: The ordinal index of the parameter in the function's parameter list\nParameter Validation Decorator\nThis decorator validates method parameters:\nParameter decorators are called when the method is defined, not when it's called\nThey're often used with method decorators to implement cross-cutting concerns\nThey can be used with the reflect-metadata library to store and retrieve metadata\nThey're commonly used in dependency injection frameworks\nThey receive the parameter index, which can be used to access the parameter value at runtime\nDecorator Factories\nDecorator factories are functions that return a decorator function.\nThey allow you to configure decorators by passing parameters.\nThis makes your decorators more flexible and reusable.\nConfigurable Logging Decorator\nThis example shows how to create a configurable logging decorator that can be customized with different log levels:\nOrder of Evaluation\nThis example shows the order of evaluation for multiple decorators:\nWhen multiple decorators are applied to a declaration, they are evaluated in the following order:\nParameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each instance member.\nParameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each static member.\nParameter Decorators are applied for the constructor.\nClass Decorators are applied for the class.\nReal-World Examples\nAPI Controller with Decorators\nThis example shows how decorators can be used to create a simple API controller similar to those in NestJS or Express:\nBest Practices\nFollow these best practices when working with decorators:\nKeep decorators focused: Each decorator should have a single responsibility.\nDocument behavior: Clearly document what your decorators do and any side effects they might have.\nUse decorator factories: Make decorators configurable using factories for better reusability.\nConsider performance: Be mindful of performance implications, especially with decorators that add runtime overhead.\nType safety: Use TypeScript's type system to make decorators type-safe when possible.\nError handling: Implement proper error handling within decorators.\nTesting: Write unit tests for your decorators to ensure they work as expected.\nMetadata: Use reflect-metadata for more advanced scenarios requiring runtime type information.\nCommon Pitfalls\nAvoid these common mistakes when working with decorators:\nForgetting to enable decorators: Ensure experimentalDecorators is enabled in tsconfig.json.\nIncorrect decorator signature: Each decorator type has a specific signature. Using the wrong parameters can lead to runtime errors.\nDecorator evaluation order: Decorators are evaluated from bottom to top for each declaration.\nProperty initialization: Property decorators run before instance properties are initialized.\nMetadata reflection: Forgetting to import reflect-metadata when using decorator metadata.\nPerformance overhead: Be cautious with decorators that add significant runtime overhead in performance-critical code.\nBrowser compatibility: Decorators are a stage 3 proposal and may require transpilation for older browsers.\nExample: Property Decorator\nExample: Parameter Decorator\nEnable decorators by adding this to your tsconfig.json:\nExample\nWhere are decorators used?\nAngular: For components, services, modules, etc.\nNestJS: For controllers, providers, routes, etc.",
      "examples": [
        "{\n\"compilerOptions\": {\n\"target\": \"ES2020\",\n\"module\": \"commonjs\",\n\"experimentalDecorators\": true,\n\"emitDecoratorMetadata\": true,\n\"strictPropertyInitialization\": false\n},\n\"include\": [\"src/**/*.ts\"]\n}",
        "class=\"code-comment\">// A simple class decorator that logs class definition\nfunction logClass(constructor: Function) {\nconsole.log(`Class ${constructor.name} was defined at ${new Date().toISOString()}`);\n}\n\nclass=\"code-comment\">// Applying the decorator\n@logClass\nclass UserService {\ngetUsers() {\nreturn ['Alice', 'Bob', 'Charlie'];\n}\n}\n\nclass=\"code-comment\">// Output when the file is loaded: \"Class UserService was defined at [timestamp]\"",
        "class=\"code-comment\">// A decorator that adds a version property and logs instantiation\nfunction versioned(version: string) {\nreturn function (constructor: Function) {\nclass=\"code-comment\">// Add a static property\nconstructor.prototype.version = version;\nclass=\"code-comment\">// Store the original constructor\nconst original = constructor;\nclass=\"code-comment\">// Create a new constructor that wraps the original\nconst newConstructor: any = function (...args: any[]) {\nconsole.log(`Creating instance of ${original.name} v${version}`);\nreturn new original(...args);\n};\nclass=\"code-comment\">// Copy prototype so instanceof works\nnewConstructor.prototype = original.prototype;\nreturn newConstructor;\n};\n}\n\nclass=\"code-comment\">// Applying the decorator with a version\n@versioned('1.0.0')\nclass ApiClient {\nfetchData() {\nconsole.log('Fetching data...');\n}\n}\n\nconst client = new ApiClient();\nconsole.log((client as any).version); class=\"code-comment\">// Outputs: 1.0.0\nclient.fetchData();",
        "function sealed(constructor: Function) {\nconsole.log(`Sealing ${constructor.name}...`);\nObject.seal(constructor);\nObject.seal(constructor.prototype);\n}\n\n@sealed\nclass Greeter {\ngreeting: string;\nconstructor(message: string) {\nthis.greeting = message;\n}\ngreet() {\nreturn `Hello, ${this.greeting}`;\n}\n}\n\nclass=\"code-comment\">// This will throw an error in strict mode\n// Greeter.prototype.newMethod = function() {}; // Error: Cannot add property newMethod",
        "class=\"code-comment\">// Method decorator to measure execution time\nfunction measureTime(   target: any,   propertyKey: string,   descriptor: PropertyDescriptor ) {\nconst originalMethod = descriptor.value;\ndescriptor.value = function (...args: any[]) {\nconst start = performance.now();\nconst result = originalMethod.apply(this, args);\nconst end = performance.now();\nconsole.log(`${propertyKey} executed in ${(end - start).toFixed(2)}ms`);\nreturn result;\n};\nreturn descriptor;\n}\n\nclass=\"code-comment\">// Using the decorator\nclass DataProcessor {\n@measureTime\nprocessData(data: number[]): number[] {\nclass=\"code-comment\">// Simulate processing time\nfor (let i = 0; i < 100000000; i++) { /* processing */ }\nreturn data.map(x => x * 2);\n}\n}\n\nclass=\"code-comment\">// When called, it will log the execution time\nconst processor = new DataProcessor();\nprocessor.processData([1, 2, 3, 4, 5]);",
        "class=\"code-comment\">// User roles\ntype UserRole = 'admin' | 'editor' | 'viewer';\n\nclass=\"code-comment\">// Current user context (simplified)\nconst currentUser = {   id: 1,   name: 'John Doe',   roles: ['viewer'] as UserRole[] };\n\nclass=\"code-comment\">// Decorator factory for role-based access control\nfunction AllowedRoles(...allowedRoles: UserRole[]) {\nreturn function (\ntarget: any,\npropertyKey: string,\ndescriptor: PropertyDescriptor\n) {\nconst originalMethod = descriptor.value;\ndescriptor.value = function (...args: any[]) {\nconst hasPermission = allowedRoles.some(role =>\ncurrentUser.roles.includes(role)       );\nif (!hasPermission) {\nthrow new Error(\n`User ${currentUser.name} is not authorized to call ${propertyKey}`\n);\n}\nreturn originalMethod.apply(this, args);\n};\nreturn descriptor;\n};\n}\n\nclass=\"code-comment\">// Using the decorator\nclass DocumentService {\n@AllowedRoles('admin', 'editor')\ndeleteDocument(id: string) {\nconsole.log(`Document ${id} deleted`);\n}\n@AllowedRoles('admin', 'editor', 'viewer')\nviewDocument(id: string) {\nconsole.log(`Viewing document ${id}`);\n}\n}\n\nclass=\"code-comment\">// Usage\nconst docService = new DocumentService();\ntry {\ndocService.viewDocument('doc123'); class=\"code-comment\">// Works - viewer role is allowed\ndocService.deleteDocument('doc123'); class=\"code-comment\">// Throws error - viewer cannot delete\n} catch (error) {\nconsole.error(error.message);\n}\nclass=\"code-comment\">// Change user role to admin\ncurrentUser.roles = ['admin'];\ndocService.deleteDocument('doc123'); class=\"code-comment\">// Now works - admin can delete",
        "function deprecated(message: string) {   return function (     target: any,     propertyKey: string,     descriptor: PropertyDescriptor   ) {     const originalMethod = descriptor.value;     descriptor.value = function (...args: any[]) {       console.warn(`Warning: ${propertyKey} is deprecated. ${message}`);       return originalMethod.apply(this, args);     };     return descriptor;   }; }\n\nclass PaymentService {   @deprecated('Use processPaymentV2 instead')   processPayment(amount: number, currency: string) {     console.log(`Processing payment of ${amount} ${currency}`);   }   processPaymentV2(amount: number, currency: string) {     console.log(`Processing payment v2 of ${amount} ${currency}`);   } }\n\nconst payment = new PaymentService();\npayment.processPayment(100, 'USD'); class=\"code-comment\">// Shows deprecation warning\npayment.processPaymentV2(100, 'USD'); class=\"code-comment\">// No warning",
        "class=\"code-comment\">// Property decorator to format a string property\nfunction format(formatString: string) {\nreturn function (target: any, propertyKey: string) {\nlet value: string;\nconst getter = () => value;\nconst setter = (newVal: string) => {\nvalue = formatString.replace('{}', newVal);\n};\nObject.defineProperty(target, propertyKey, {\nget: getter,\nset: setter,\nenumerable: true,\nconfigurable: true\n});\n};\n}\n\nclass Greeter {\n@format('Hello, {}!')\ngreeting: string;\n}\n\nconst greeter = new Greeter();\ngreeter.greeting = 'World';\nconsole.log(greeter.greeting); class=\"code-comment\">// Outputs: Hello, World!",
        "function logProperty(target: any, propertyKey: string) {\nlet value: any;\nconst getter = function() {\nconsole.log(`Getting ${propertyKey}: ${value}`);\nreturn value;\n};\n\nconst setter = function(newVal: any) {\nconsole.log(`Setting ${propertyKey} from ${value} to ${newVal}`);\nvalue = newVal;\n};\n\nObject.defineProperty(target, propertyKey, {\nget: getter,\nset: setter,\nenumerable: true,\nconfigurable: true\n});\n}\n\nclass Product {\n@logProperty\nname: string;\n@logProperty\nprice: number;\n\nconstructor(name: string, price: number) {\nthis.name = name;\nthis.price = price;\n}\n}\n\nconst product = new Product('Laptop', 999.99);\nproduct.price = 899.99; class=\"code-comment\">// Logs: Setting price from 999.99 to 899.99\nconsole.log(product.name); class=\"code-comment\">// Logs: Getting name: Laptop",
        "function required(target: any, propertyKey: string) {\nlet value: any;\n\nconst getter = function() {\nif (value === undefined) {\nthrow new Error(`Property ${propertyKey} is required`);\n}\nreturn value;\n};\n\nconst setter = function(newVal: any) {\nvalue = newVal;\n};\n\nObject.defineProperty(target, propertyKey, {\nget: getter,\nset: setter,\nenumerable: true,\nconfigurable: true\n});\n}\n\nclass User {\n@required\nusername: string;\n@required\nemail: string;\nage?: number;\n\nconstructor(username: string, email: string) {\nthis.username = username;\nthis.email = email;\n}\n}\n\nconst user1 = new User('johndoe', 'john@example.com'); class=\"code-comment\">// Works\n// const user2 = new User(undefined, 'test@example.com'); // Throws error: Property username is required\n// const user2 = new User('johndoe', undefined); // Throws error: Property email is required",
        "function validateParam(type: 'string' | 'number' | 'boolean') {\nreturn function (target: any, propertyKey: string | symbol, parameterIndex: number) {\nconst existingValidations: any[] = Reflect.getOwnMetadata('validations', target, propertyKey) || [];\nexistingValidations.push({ index: parameterIndex, type });\nReflect.defineMetadata('validations', existingValidations, target, propertyKey);\n};\n}\n\nfunction validate(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\nconst originalMethod = descriptor.value;\ndescriptor.value = function (...args: any[]) {\nconst validations: Array<{index: number, type: string}> =\nReflect.getOwnMetadata('validations', target, propertyKey) || [];\n\nfor (const validation of validations) {\nconst { index, type } = validation;\nconst param = args[index];\nlet isValid = false;\n\nswitch (type) {\ncase 'string':\nisValid = typeof param === 'string' && param.length > 0;\nbreak;\ncase 'number':\nisValid = typeof param === 'number' && !isNaN(param);\nbreak;\ncase 'boolean':\nisValid = typeof param === 'boolean';\n}\n\nif (!isValid) {\nthrow new Error(`Parameter at index ${index} failed ${type} validation`);\n}\n}\n\nreturn originalMethod.apply(this, args);\n};\nreturn descriptor;\n}\n\nclass UserService {\n@validate\ncreateUser(\n@validateParam('string') name: string,\n@validateParam('number') age: number,\n@validateParam('boolean') isActive: boolean\n) {\nconsole.log(`Creating user: ${name}, ${age}, ${isActive}`);\n}\n}\n\nconst service = new UserService();\nservice.createUser('John', 30, true); class=\"code-comment\">// Works\n// service.createUser('', 30, true); // Throws error: Parameter at index 0 failed string validation\n// service.createUser('John', 'thirty', true); // Throws error: Parameter at index 1 failed number validation",
        "class=\"code-comment\">// Decorator factory that accepts configuration\nfunction logWithConfig(config: { level: 'log' | 'warn' | 'error', message?: string }) {\nreturn function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\nconst originalMethod = descriptor.value;\ndescriptor.value = function (...args: any[]) {\nconst { level = 'log', message = 'Executing method' } = config;\nconsole[level](`${message}: ${propertyKey}`, { arguments: args });\nconst result = originalMethod.apply(this, args);\nconsole[level](`${propertyKey} completed`);\nreturn result;\n};\nreturn descriptor;\n};\n}\n\nclass PaymentService {\n@logWithConfig({ level: 'log', message: 'Processing payment' })\nprocessPayment(amount: number) {\nconsole.log(`Processing payment of $${amount}`);\n}\n}",
        "function first() {\nconsole.log('first(): factory evaluated');\nreturn function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\nconsole.log('first(): called');\n};\n}\n\nfunction second() {\nconsole.log('second(): factory evaluated');\nreturn function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\nconsole.log('second(): called');\n};\n}\n\nclass ExampleClass {\n@first()\n@second()\nmethod() {}\n}\n\n// Output:\n// second(): factory evaluated\n// first(): factory evaluated\n// first(): called\n// second(): called",
        "class=\"code-comment\">// Simple decorator implementations (simplified for example)\nconst ROUTES: any[] = [];\n\nfunction Controller(prefix: string = '') {\nreturn function (constructor: Function) {\nconstructor.prototype.prefix = prefix;\n};\n}\n\nfunction Get(path: string = '') {\nreturn function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\nROUTES.push({\nmethod: 'get',\npath,\nhandler: descriptor.value,\ntarget: target.constructor\n});\n};\n}\n\nclass=\"code-comment\">// Using the decorators\n@Controller('/users')\nclass UserController {\n@Get('/')\ngetAllUsers() {\nreturn { users: [{ id: 1, name: 'John' }] };\n}\n\n@Get('/:id')\ngetUserById(id: string) {\nreturn { id, name: 'John' };\n}\n}\n\nclass=\"code-comment\">// Simulate route registration\nfunction registerRoutes() {\nROUTES.forEach(route => {\nconst prefix = route.target.prototype.prefix || '';\nconsole.log(`Registered ${route.method.toUpperCase()} ${prefix}${route.path}`);\n});\n}\n\nregisterRoutes();\n// Output:\n// Registered GET /users\n// Registered GET /users/:id",
        "function readonly(target: any, propertyKey: string) {\nObject.defineProperty(target, propertyKey, {\nwritable: false\n});\n}\n\nclass Person {\n@readonly\nname = \"John\";\n}",
        "function logParameter(target: any, propertyKey: string, parameterIndex: number) {\nconsole.log(`Parameter in ${propertyKey} at index ${parameterIndex}`);\n}\n\nclass Demo {\ngreet(@logParameter message: string) {\nreturn message;\n}\n}",
        "{\n\"compilerOptions\": {\n\"experimentalDecorators\": true\n}\n}",
        "tsconfig.json",
        "emitDecoratorMetadata",
        "(constructor: Function) => void",
        "(target: any, propertyKey: string, descriptor: PropertyDescriptor) => void",
        "(target: any, propertyKey: string) => void",
        "(target: any, propertyKey: string, parameterIndex: number) => void",
        "target",
        "propertyKey",
        "descriptor",
        "Object.defineProperty",
        "parameterIndex",
        "reflect-metadata",
        "experimentalDecorators"
      ]
    },
    {
      "title": "TypeScript in JavaScript Projects (JSDoc)",
      "summary": "JSDoc with TypeScript allows you to add type checking to JavaScript files without converting them to .ts.\nThis is perfect for gradual migration or when you want type safety in JavaScript projects.\nGetting Started\nTo enable TypeScript checking in JavaScript files, you need to:\nCreate a tsconfig.json file (if you don't have one)\nEnable checkJs or use // @ts-check in individual files\nExample: JSDoc for Type SafetyGet your own TypeScript Server\nREMOVE ADS\nObjects and Interfaces\nInline Object Types\nUsing @typedef for Complex Types\nExtending Types\nFunction Types\nFunction Declarations\nFunction Expressions and Callbacks\nFunction Overloads\nAdvanced Types\nUnion and Intersection Types\nMapped and Conditional Types\nType Imports\nImporting Types from Other Files\nCreating Declaration Files\nCreate a types.d.ts file in your project:\nThen use it in your JavaScript files:\nBest Practices\nFollow these best practices when using JSDoc with TypeScript:\nEnable // @ts-check at the top of files where you want type checking\nUse @typedef for complex types that are used in multiple places\nDocument all function parameters and return types\nUse @template for generic functions and types\nCreate declaration files (.d.ts) for third-party libraries without types\nUse @ts-expect-error instead of @ts-ignore when you expect an error\nCommon Pitfalls\nWatch out for these common issues:\nMissing // @ts-check: Type checking won't work without it\nIncorrect JSDoc syntax: A single typo can disable type checking\nType conflicts: When types from different sources don't match\nInference issues: Sometimes TypeScript can't infer types correctly\nPerformance: Large JavaScript files with complex types can be slow to check\nConclusion\nUsing JSDoc with TypeScript provides a powerful way to add type safety to your JavaScript projects without the need to convert files to TypeScript.\nThis approach is particularly useful for:\nGradually migrating JavaScript codebases to TypeScript\nAdding type checking to existing JavaScript projects\nWorking in environments where .ts files aren't supported\nDocumenting JavaScript code with type information\nBy following the patterns and best practices outlined in this tutorial, you can enjoy many of the benefits of TypeScript while continuing to work with JavaScript.\nRemember: While JSDoc provides excellent type checking, for new projects or complete migrations, consider using .ts files for the best TypeScript experience.\nReady to try TypeScript with JSDoc?\nStart by adding // @ts-check to your JavaScript files and gradually add type annotations using JSDoc.\nThe TypeScript compiler will help you catch errors before they reach production!",
      "examples": [
        "// @ts-check\n\n/**\n* Adds two numbers.\n* @param {number} a\n* @param {number} b\n* @returns {number}\n*/\nfunction add(a, b) {\nreturn a + b;\n}",
        "// @ts-check\n\n/**\n* @param {{ firstName: string, lastName: string, age?: number }} person\n*/\nfunction greet(person) {\nreturn `Hello, ${person.firstName} ${person.lastName}`;\n}\n\ngreet({ firstName: 'John', lastName: 'Doe' }); // OK\ngreet({ firstName: 'Jane' }); // Error: Property 'lastName' is missing",
        "// @ts-check\n\n/**\n* @typedef {Object} User\n* @property {number} id - The user ID\n* @property {string} username - The username\n* @property {string} [email] - Optional email address\n* @property {('admin'|'user'|'guest')} role - User role\n* @property {() => string} getFullName - Method that returns full name\n*/\n\n/** @type {User} */\nconst currentUser = {\nid: 1,\nusername: 'johndoe',\nrole: 'admin',\ngetFullName() {\nreturn 'John Doe';\n}\n};\n\n// TypeScript will provide autocomplete for User properties\nconsole.log(currentUser.role);",
        "// @ts-check\n\n/** @typedef {{ x: number, y: number }} Point */\n\n/**\n* @typedef {Point & { z: number }} Point3D\n*/\n\n/** @type {Point3D} */\nconst point3d = { x: 1, y: 2, z: 3 };\n\n// @ts-expect-error - missing z property\nconst point2d = { x: 1, y: 2 };",
        "// @ts-check\n\n/**\n* Calculates the area of a rectangle\n* @param {number} width - The width of the rectangle\n* @param {number} height - The height of the rectangle\n* @returns {number} The calculated area\n*/\nfunction calculateArea(width, height) {\nreturn width * height;\n}\n\n// TypeScript knows the parameter and return types\nconst area = calculateArea(10, 20);",
        "// @ts-check\n\n/**\n* @callback StringProcessor\n* @param {string} input\n* @returns {string}\n*/\n\n/**\n* @type {StringProcessor}\n*/\nconst toUpperCase = (str) => str.toUpperCase();\n\n/**\n* @param {string[]} strings\n* @param {StringProcessor} processor\n* @returns {string[]}\n*/\nfunction processStrings(strings, processor) {\nreturn strings.map(processor);\n}\n\nconst result = processStrings(['hello', 'world'], toUpperCase);\n// result will be ['HELLO', 'WORLD']",
        "// @ts-check\n\n/**\n* @overload\n* @param {string} a\n* @param {string} b\n* @returns {string}\n*/\n/**\n* @overload\n* @param {number} a\n* @param {number} b\n* @returns {number}\n*/\n/**\n* @param {string | number} a\n* @param {string | number} b\n* @returns {string | number}\n*/\nfunction add(a, b) {\nif (typeof a === 'string' || typeof b === 'string') {\nreturn String(a) + String(b);\n}\nreturn a + b;\n}\n\nconst strResult = add('Hello, ', 'World!'); // string\nconst numResult = add(10, 20); // number",
        "// @ts-check\n\n/** @typedef {{ name: string, age: number }} Person */\n/** @typedef {Person & { employeeId: string }} Employee */\n/** @typedef {Person | { guestId: string, visitDate: Date }} Visitor */\n\n/** @type {Employee} */\nconst employee = {\nname: 'Alice',\nage: 30,\nemployeeId: 'E123'\n};\n\n/** @type {Visitor} */\nconst guest = {\nguestId: 'G456',\nvisitDate: new Date()\n};\n\n/**\n* @param {Visitor} visitor\n* @returns {string}\n*/\nfunction getVisitorId(visitor) {\nif ('guestId' in visitor) {\nreturn visitor.guestId; // TypeScript knows this is a guest\n}\nreturn visitor.name; // TypeScript knows this is a Person\n}",
        "// @ts-check\n\n/** * @template T * @typedef {[K in keyof T]: T[K] extends Function ? K : never}[keyof T] MethodNames */\n\n/** * @template T * @typedef {{ *   [K in keyof T as `get${'<' }Capitalize<string & K>{'>'}`]: () => T[K] * }} Getters */\n\n/** @type {Getters<{ name: string, age: number }> } */\nconst userGetters = {\ngetName: () => 'John',\ngetAge: () => 30\n};\n\n// TypeScript enforces the return types\nconst name = userGetters.getName(); // string\nconst age = userGetters.getAge(); // number",
        "// @ts-check\n\n// Importing types from TypeScript files\n/** @typedef {import('./types').User} User */\n\n// Importing types from node_modules\n/** @typedef {import('express').Request} ExpressRequest */\n\n// Importing with renaming\n/** @typedef {import('./api').default as ApiClient} ApiClient */",
        "// types.d.ts\ndeclare module 'my-module' {\nexport interface Config {\napiKey: string;\ntimeout?: number;\nretries?: number;\n}\n\nexport function initialize(config: Config): void;\nexport function fetchData<T = any>(url: string): Promise<T>;\n}",
        "// @ts-check\n\n/** @type {import('my-module').Config} */\nconst config = {\napiKey: '12345',\ntimeout: 5000\n};\n\n// TypeScript will provide autocomplete and type checking\nimport { initialize } from 'my-module';\ninitialize(config);",
        ".ts",
        "tsconfig.json",
        "checkJs",
        "// @ts-check",
        "types.d.ts",
        "@typedef",
        "@template",
        ".d.ts",
        "@ts-expect-error",
        "@ts-ignore"
      ]
    },
    {
      "title": "TypeScript Migration Guide",
      "summary": "Migrating from JavaScript to TypeScript can significantly improve your codebase's maintainability and developer experience.\nThis guide will walk you through the process step by step.\nPreparation Phase\nAssess Your Codebase\nBefore starting the migration:\nIdentify the size and complexity of your codebase\nDocument the build process and dependencies\nCheck for any existing type definitions (.d.ts files)\nIdentify critical paths that need special attention\nSet Up Version ControlGet your own TypeScript Server\nEnsure you have a clean git repository or equivalent:\nConfiguration\nInstall TypeScript\nCreate tsconfig.json\nCreate a basic tsconfig.json to start with:\nNote: Adjust the target based on your minimum supported environments.\nMigration Approaches\nGradual Migration\nMigrate one file at a time while keeping the rest as JavaScript.\nBest for: Large codebases, minimal disruption\nAll-at-Once Migration\nRename all .js files to .ts and fix errors.\nBest for: Small to medium projects, greenfield projects\nFor large projects, we strongly recommend the gradual migration approach to minimize disruption and make the process more manageable.\nStep-by-Step Migration\nStart with Configuration\nCreate a basic tsconfig.json with these recommended settings:\nEnable Type Checking for JavaScript\nAdd // @ts-check to the top of your JavaScript files to enable type checking:\nNote: You can disable type checking for specific lines using // @ts-ignore.\nRename Files to .ts\nStart with non-critical files and rename them from .js to .ts:\nAdd Type Annotations\nGradually add type annotations to your code:\nUpdate Build and Test Scripts\nModify your package.json to include TypeScript compilation:\nNote: Make sure to update your test configuration to work with TypeScript files.\nMigration Tools\nts-migrate\nAutomated tool for migrating JavaScript to TypeScript\nGitHub Repository\nTypeStat\nConverts JavaScript to TypeScript with type safety\nGitHub Repository\n@types Packages\nInstall type definitions for your dependencies\nTypeSearch\nBest Practices for TypeScript Migration\nStart Small and Iterate\nBegin with utility functions and non-UI components\nMigrate one file or module at a time\nCommit after each successful migration step\nLeverage TypeScript Features\nExample\nHandle Third-Party Libraries\nInstall @types packages for your dependencies\nCreate declaration files for libraries without types\nUse declare module for global type extensions\nCommon Challenges and Solutions\nDynamic Properties\nProblem: JavaScript often uses objects as dictionaries.\nExample\nSolution: Use index signatures or type assertions.\nExample\nHandling this Context\nProblem: this binding issues in callbacks.\nExample\nSolution: Use arrow functions or bind this.\nExample\nConclusion\nMigrating from JavaScript to TypeScript is a significant but rewarding investment in your codebase.\nBy following this guide, you can make the transition smoothly and incrementally.\nStart with a solid tsconfig.json configuration\nUse allowJs and checkJs for gradual migration\nLeverage TypeScript's type system to catch errors early\nUpdate your build and test processes to support TypeScript\nAddress common challenges with the patterns shown above\nRemember that migration is a process, not an event.\nIt's okay to have a mixed codebase during the transition period.\nThe important thing is to keep making progress while maintaining code quality.\nReady to Start Your Migration?\nBegin by setting up TypeScript in your project and gradually adding type annotations.\nThe TypeScript compiler will guide you through the process of making your code more robust and maintainable.\nFor more information, check out the official TypeScript migration guide.",
      "examples": [
        "# Create a new branch for the migration\ngit checkout -b typescript-migration\n\n# Commit your current state\ngit add .\ngit commit -m \"Pre-TypeScript migration state\"",
        "# Install TypeScript as a dev dependency\nnpm install --save-dev typescript @types/node",
        "{\n\"compilerOptions\": {\n\"target\": \"ES2020\",\n\"module\": \"commonjs\",\n\"strict\": true,\n\"esModuleInterop\": true,\n\"skipLibCheck\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"outDir\": \"./dist\",\n\"rootDir\": \"./src\"\n},\n\"include\": [\"src/**/*\"],\n\"exclude\": [\"node_modules\"]\n}",
        "{\n\"compilerOptions\": {\n\"allowJs\": true,\n\"checkJs\": true\n}\n}",
        "# Rename all JS files to TS\nfind src -name \"*.js\" -exec sh -c 'mv \"$0\" \"${0%.js}.ts\"' {} \\;",
        "{\n\"compilerOptions\": {\n\"target\": \"ES2020\",\n\"module\": \"commonjs\",\n\"strict\": true,\n\"esModuleInterop\": true,\n\"skipLibCheck\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"outDir\": \"./dist\",\n\"rootDir\": \"./src\",\n\"allowJs\": true,\n\"checkJs\": true,\n\"noEmit\": true\n},\n\"include\": [\"src/**/*\"],\n\"exclude\": [\"node_modules\", \"dist\"]\n}",
        "// @ts-check\n\n/** @type {string} */\nconst name = 'John';\n\n// TypeScript will catch this error\nname = 42; // Error: Type '42' is not assignable to type 'string'",
        "# Rename a single file\nmv src/utils/helpers.js src/utils/helpers.ts\n\n# Or rename all files in a directory (use with caution)\nfind src/utils -name \"*.js\" -exec sh -c 'mv \"$0\" \"${0%.js}.ts\"' {} \\;",
        "// Before\nfunction add(a, b) {\nreturn a + b;\n}\n\n// After\nfunction add(a: number, b: number): number {\nreturn a + b;\n}\n\n// With interface\ninterface User {\nid: number;\nname: string;\nemail?: string;\n}\n\nfunction getUser(id: number): User {\nreturn { id, name: 'John Doe' };\n}",
        "{\n\"scripts\": {\n\"build\": \"tsc\",\n\"dev\": \"tsc --watch\",\n\"test\": \"jest\"\n}\n}",
        "npx ts-migrate-full .",
        "npx typestat --init",
        "npm install --save-dev @types/react @types/node",
        "// Use type inference where possible\nconst name = 'John'; // TypeScript infers 'string'\nconst age = 30; // TypeScript infers 'number'\n\n// Use union types for flexibility\ntype Status = 'active' | 'inactive' | 'pending';\n\n// Use type guards for runtime checks\nfunction isString(value: any): value is string {\nreturn typeof value === 'string';\n}",
        "// Before\nconst user = {};\nuser.name = 'John'; // Error: Property 'name' does not exist",
        "// Option 1: Index signature\ninterface User {\n[key: string]: any;\n}\nconst user: User = {};\nuser.name = 'John'; // OK\n\n// Option 2: Type assertion\nconst user = {} as { name: string };\nuser.name = 'John'; // OK",
        "class Counter {\ncount = 0;\nincrement() {\nsetTimeout(function() {\nthis.count++; // Error: 'this' is not defined\n}, 1000);\n}\n}",
        "// Solution 1: Arrow function\nsetTimeout(() => {\nthis.count++; // 'this' is lexically scoped\n}, 1000);\n\n// Solution 2: Bind 'this'\nsetTimeout(function(this: Counter) {\nthis.count++;\n}.bind(this), 1000);",
        ".d.ts",
        "tsconfig.json",
        "target",
        ".js",
        ".ts",
        "// @ts-check",
        "// @ts-ignore",
        "package.json",
        "@types",
        "declare module",
        "this",
        "allowJs",
        "checkJs"
      ]
    },
    {
      "title": "TypeScript Error Handling",
      "summary": "Robust error handling is crucial for building reliable TypeScript applications.\nThis guide covers everything from basic try/catch to advanced error handling patterns.\nBasic Error Handling\nTry/Catch BlocksGet your own TypeScript Server\nThe foundation of error handling in TypeScript:\nIn TypeScript 4.0 and later, the unknown type is the default type for catch variables. Always narrow the type before accessing properties.\nCustom Error Classes\nCreating Custom Error Classes\nExtend the built-in Error class to create domain-specific errors:\nType Guards for Errors\nType Predicates for Error Handling\nCreate type guards to safely work with different error types:\nFor more complex error handling, consider using a type assertion function:\nAsync Error Handling\nHandling Async/Await Errors\nProper error handling in async/await code requires wrapping await calls in try/catch blocks:\nAlways handle promise rejections to prevent unhandled promise rejection warnings:\nError Boundaries in React\nReact Error Boundary Component\nCreate an Error Boundary to catch JavaScript errors in React component trees:\nBest Practices\nAlways Handle Errors\nNever leave catch blocks empty.\nAt minimum, log the error:\nUse Specific Error Types\nCreate custom error classes for different error scenarios:\nHandle Errors at the Right Level\nHandle errors where you have enough context to recover or provide a good user experience:\nCommon Pitfalls\nAlways handle promise rejections to prevent unhandled promise rejection warnings:\nIn TypeScript 4.0+, caught errors are of type unknown:\nAvoid silently catching and ignoring errors without proper handling:\nSummary\nEffective error handling in TypeScript involves:\nUsing try/catch blocks for synchronous code\nHandling promise rejections with .catch() or try/catch with async/await\nCreating custom error classes for domain-specific errors\nUsing type guards to safely work with error objects\nHandling errors at the appropriate level in your application\nProviding meaningful error messages to users\nBy following these practices, you can build more robust and maintainable TypeScript applications.",
      "examples": [
        "function divide(a: number, b: number): number {\nif (b === 0) {\nthrow new Error('Division by zero');\n}\nreturn a / b;\n}\n\ntry {\nconst result = divide(10, 0);\nconsole.log(result);\n} catch (error) {\nconsole.error('An error occurred:', error.message);\n}",
        "class ValidationError extends Error {\nconstructor(message: string, public field?: string) {\nsuper(message);\nthis.name = 'ValidationError';\n// Restore prototype chain\nObject.setPrototypeOf(this, ValidationError.prototype);\n}\n}\n\nclass DatabaseError extends Error {\nconstructor(message: string, public code: number) {\nsuper(message);\nthis.name = 'DatabaseError';\nObject.setPrototypeOf(this, DatabaseError.prototype);\n}\n}\n\n// Usage\nfunction validateUser(user: any) {\nif (!user.name) {\nthrow new ValidationError('Name is required', 'name');\n}\nif (!user.email.includes('@')) {\nthrow new ValidationError('Invalid email format', 'email');\n}\n}",
        "// Type guards\nfunction isErrorWithMessage(error: unknown): error is { message: string } {\nreturn (\ntypeof error === 'object' &&\nerror !== null &&\n'message' in error &&\ntypeof (error as Record\n\"\"\n>).message === 'string'\n);\n}\n\nfunction isValidationError(error: unknown): error is ValidationError {\nreturn error instanceof ValidationError;\n}\n\n// Usage in catch block\ntry {\nvalidateUser({});\n} catch (error: unknown) {\nif (isValidationError(error)) {\nconsole.error(`Validation error in ${error.field}: ${error.message}`);\n} else if (isErrorWithMessage(error)) {\nconsole.error('An error occurred:', error.message);\n} else {\nconsole.error('An unknown error occurred');\n}\n}",
        "function assertIsError(error: unknown): asserts error is Error {\nif (!(error instanceof Error)) {\nthrow new Error('Caught value is not an Error instance');\n}\n}\n\ntry {\n// ...\n} catch (error) {\nassertIsError(error);\nconsole.error((error as Error).message); // TypeScript now knows error is Error\n}",
        "interface User {\nid: number;\nname: string;\nemail: string;\n}\n\n// Using async/await with try/catch\nasync function fetchUser(userId: number): Promise\n{\ntry {\nconst response = await fetch(`/api/users/${userId}`);\nif (!response.ok) {\nthrow new Error(`HTTP error! status: ${response.status}`);\n}\nreturn await response.json() as User;\n} catch (error) {\nif (error instanceof Error) {\nconsole.error('Failed to fetch user:', error.message);\n}\nthrow error; // Re-throw to allow caller to handle\n}\n}\n\n// Using Promise.catch() for error handling\nfunction fetchUserPosts(userId: number): Promise\n{\nreturn fetch(`/api/users/${userId}/posts`)\n.then(response => {\nif (!response.ok) {\nthrow new Error(`HTTP error! status: ${response.status}`);\n}\nreturn response.json();\n})\n.catch(error => {\nconsole.error('Failed to fetch posts:', error);\nreturn []; // Return empty array as fallback\n});\n}",
        "// Bad: Unhandled promise rejection\nfetchData().then(data => console.log(data));\n\n// Good: Handle both success and error cases\nfetchData()\n.then(data => console.log('Success:', data))\n.catch(error => console.error('Error:', error));\n\n// Or use void for intentionally ignored errors\nvoid fetchData().catch(console.error);",
        "import React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface ErrorBoundaryProps {\nchildren: ReactNode;\nfallback?: ReactNode;\n}\n\ninterface ErrorBoundaryState {\nhasError: boolean;\nerror?: Error;\n}\n\nclass ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\npublic state: ErrorBoundaryState = {\nhasError: false\n};\n\npublic static getDerivedStateFromError(error: Error): ErrorBoundaryState {\nreturn { hasError: true, error };\n}\n\npublic componentDidCatch(error: Error, errorInfo: ErrorInfo) {\nconsole.error('Uncaught error:', error, errorInfo);\n// Log to error reporting service\n}\n\npublic render() {\nif (this.state.hasError) {\nreturn this.props.fallback || (\n<div className=\"error-boundary\">\n<h2>Something went wrong</h2>\n<p>{this.state.error?.message}</p>\n<button onClick={() => this.setState({ hasError: false })}>\nTry again\n</button>\n</div>\n);\n}\n\nreturn this.props.children;\n}\n}\n\n// Usage\nfunction App() {\nreturn (\n<ErrorBoundary fallback={<div>Oops! Something broke.</div>}>\n<MyComponent />\n</ErrorBoundary>\n);\n}",
        "// Bad: Silent failure\ntry { /* ... */ } catch { /* empty */ }\n\n// Good: At least log the error\ntry { /* ... */ } catch (error) {\nconsole.error('Operation failed:', error);\n}",
        "class NetworkError extends Error {\nconstructor(public status: number, message: string) {\nsuper(message);\nthis.name = 'NetworkError';\n}\n}\n\nclass ValidationError extends Error {\nconstructor(public field: string, message: string) {\nsuper(message);\nthis.name = 'ValidationError';\n}\n}",
        "// In a data access layer\nasync function getUser(id: string): Promise\n{\nconst response = await fetch(`/api/users/${id}`);\nif (!response.ok) {\nthrow new NetworkError(response.status, 'Failed to fetch user');\n}\nreturn response.json();\n}\n\n// In a UI component\nasync function loadUser() {\ntry {\nconst user = await getUser('123');\nsetUser(user);\n} catch (error) {\nif (error instanceof NetworkError) {\nif (error.status === 404) {\nshowError('User not found');\n} else {\nshowError('Network error. Please try again later.');\n}\n} else {\nshowError('An unexpected error occurred');\n}\n}\n}",
        "// Bad: Unhandled promise rejection\nfetchData();\n\n// Good: Handle the rejection\nfetchData().catch(console.error);",
        "// Bad: Error is of type 'unknown'\ntry { /* ... */ } catch (error) {\nconsole.log(error.message); // Error: Property 'message' does not exist on type 'unknown'\n}\n\n// Good: Narrow the type\ntry { /* ... */ } catch (error) {\nif (error instanceof Error) {\nconsole.log(error.message); // OK\n}\n}",
        "// Bad: Error is silently ignored\nfunction saveData(data: Data) {\ntry {\ndatabase.save(data);\n} catch {\n// Ignore\n}\n}\n\n// Better: Log the error and/or notify the user\nfunction saveData(data: Data) {\ntry {\ndatabase.save(data);\n} catch (error) {\nconsole.error('Failed to save data:', error);\nshowError('Failed to save data. Please try again.');\n}\n}",
        "unknown",
        "Error",
        "try/catch",
        ".catch()",
        "async/await"
      ]
    },
    {
      "title": "TypeScript Best Practices",
      "summary": "This guide covers essential TypeScript best practices to help you write clean, maintainable, and type-safe code. Following these practices will improve code quality and developer experience.\nProject Configuration\nEnable Strict ModeGet your own TypeScript Server\nAlways enable strict mode in your tsconfig.json for maximum type safety:\nConsider enabling these additional strict checks for better code quality:\nType System Best Practices\nUse Type Inference Where Possible\nLet TypeScript infer types when the type is obvious from the assignment:\nPrecise Type Annotations\nBe explicit with types for public APIs and function parameters:\nInterfaces vs. Type Aliases\nKnow when to use interface vs type:\nPrefer more specific types over any:\nCode Organization\nModule Organization\nOrganize code into logical modules with clear responsibilities:\nFile Naming Conventions\nFollow consistent file naming patterns:\nBest Practices\nDocument your types and interfaces.\nPrefer composition over inheritance for types.\nKeep tsconfig.json strict and up-to-date.\nRefactor code to use more specific types as the codebase evolves.\nFunctions and Methods\nFunction Parameters and Return Types\nWrite clear and type-safe functions with proper parameter and return types:\nBe mindful of function complexity and responsibilities:\nAsync/Await Patterns\nProper Async/Await Usage\nHandle asynchronous operations effectively with proper error handling:\nFlatten your async/await code to avoid callback hell:\nTesting and Quality\nWriting Testable Code\nDesign your code with testability in mind by using dependency injection and pure functions:\nTest your types to ensure they work as expected using type assertions and utilities:\nPerformance Considerations\nType-Only Imports and Exports\nUse type-only imports and exports to reduce bundle size and improve tree-shaking:\nBe mindful of complex types that can impact compilation time:\nUse const Assertions for Literal Types\nImprove type inference and performance with const assertions:\nCommon Mistakes to Avoid\nOverusing the any Type\nAvoid using `any` as it defeats TypeScript's type checking:\nNot Using Strict Mode\nAlways enable strict mode in your `tsconfig.json`:\nIgnoring Type Inference\nLet TypeScript infer types when possible:\nNot Using Type Guards\nUse type guards to narrow types safely:\nNot Handling null and undefined\nAlways handle potential `null` or `undefined` values:",
      "examples": [
        "// tsconfig.json\n{\n\"compilerOptions\": {\n/* Enable all strict type-checking options */\n\"strict\": true,\n/* Additional recommended settings */\n\"target\": \"ES2020\",\n\"module\": \"commonjs\",\n\"moduleResolution\": \"node\",\n\"esModuleInterop\": true,\n\"skipLibCheck\": true,\n\"forceConsistentCasingInFileNames\": true\n}\n}",
        "{\n\"compilerOptions\": {\n/* Additional strict checks */\n\"noImplicitAny\": true,\n\"strictNullChecks\": true,\n\"strictFunctionTypes\": true,\n\"strictBindCallApply\": true,\n\"strictPropertyInitialization\": true,\n\"noImplicitThis\": true,\n\"alwaysStrict\": true\n}\n}",
        "// Bad: Redundant type annotation\nconst name: string = 'John';\n\n// Good: Let TypeScript infer the type\nconst name = 'John';\n\n// Bad: Redundant return type\nfunction add(a: number, b: number): number {\nreturn a + b;\n}\n\n// Good: Let TypeScript infer return type\nfunction add(a: number, b: number) {\nreturn a + b;\n}",
        "// Bad: No type information\nfunction processUser(user) {\nreturn user.name.toUpperCase();\n}\n\n// Good: Explicit parameter and return types\ninterface User {\nid: number;\nname: string;\nemail?: string; // Optional property\n}\n\nfunction processUser(user: User): string {\nreturn user.name.toUpperCase();\n}",
        "// Use interface for object shapes that can be extended/implemented\ninterface User {\nid: number;\nname: string;\n}\n\n// Extending an interface\ninterface AdminUser extends User {\npermissions: string[];\n}\n\n// Use type for unions, tuples, or mapped types\ntype UserRole = 'admin' | 'editor' | 'viewer';\n\n// Union types\ntype UserId = number | string;\n\n// Mapped types\ntype ReadonlyUser = Readonly<User>;\n\n// Tuple types\ntype Point = [number, number];",
        "// Bad: Loses type safety\nfunction logValue(value: any) {\nconsole.log(value.toUpperCase()); // No error until runtime\n}\n\n// Better: Use generic type parameter\nfunction logValue<T>(value: T) {\nconsole.log(String(value)); // Safer, but still not ideal\n}\n\n// Best: Be specific about expected types\nfunction logString(value: string) {\nconsole.log(value.toUpperCase()); // Type-safe\n}\n\n// When you need to accept any value but still be type-safe\nfunction logUnknown(value: unknown) {\nif (typeof value === 'string') {\nconsole.log(value.toUpperCase());\n} else {\nconsole.log(String(value));\n}\n}",
        "// user/user.model.ts\nexport interface User {\nid: string;\nname: string;\nemail: string;\n}\n\n// user/user.service.ts\nimport { User } from './user.model';\n\nexport class UserService {\nprivate users: User[] = [];\n\naddUser(user: User) {\nthis.users.push(user);\n}\n\ngetUser(id: string): User | undefined {\nreturn this.users.find(user => user.id === id);\n}\n}\n\n// user/index.ts (barrel file)\nexport * from './user.model';\nexport * from './user.service';",
        "// Good\nuser.service.ts // Service classes\nuser.model.ts // Type definitions\nuser.controller.ts // Controllers\nuser.component.ts // Components\nuser.utils.ts // Utility functions\nuser.test.ts // Test files\n\n// Bad\nUserService.ts // Avoid PascalCase for file names\nuser_service.ts // Avoid snake_case\nuserService.ts // Avoid camelCase for file names",
        "// Bad: No type information\nfunction process(user, notify) {\nnotify(user.name);\n}\n\n// Good: Explicit parameter and return types\nfunction processUser(\nuser: User,\nnotify: (message: string) => void\n): void {\nnotify(`Processing user: ${user.name}`);\n}\n\n// Use default parameters instead of conditionals\nfunction createUser(\nname: string,\nrole: UserRole = 'viewer',\nisActive: boolean = true\n): User {\nreturn { name, role, isActive };\n}\n\n// Use rest parameters for variable arguments\nfunction sum(...numbers: number[]): number {\nreturn numbers.reduce((total, num) => total + num, 0);\n}",
        "// Bad: Too many responsibilities\nfunction processUserData(userData: any) {\n// Validation\nif (!userData || !userData.name) throw new Error('Invalid user data');\n\n// Data transformation\nconst processedData = {\n...userData,\nname: userData.name.trim(),\ncreatedAt: new Date()\n};\n\n// Side effect\nsaveToDatabase(processedData);\n\n// Notification\nsendNotification(processedData.email, 'Profile updated');\n\nreturn processedData;\n}\n\n// Better: Split into smaller, focused functions\nfunction validateUserData(data: unknown): UserData {\nif (!data || typeof data !== 'object') {\nthrow new Error('Invalid user data');\n}\nreturn data as UserData;\n}\n\nfunction processUserData(userData: UserData): ProcessedUserData {\nreturn {\n...userData,\nname: userData.name.trim(),\ncreatedAt: new Date()\n};\n}",
        "// Bad: Not handling errors\nasync function fetchData() {\nconst response = await fetch('/api/data');\nreturn response.json();\n}\n\n// Good: Proper error handling\nasync function fetchData<T>(url: string): Promise<T> {\ntry {\nconst response = await fetch(url);\nif (!response.ok) {\nthrow new Error(`HTTP error! status: ${response.status}`);\n}\nreturn await response.json() as T;\n} catch (error) {\nconsole.error('Failed to fetch data:', error);\nthrow error; // Re-throw to allow caller to handle\n}\n}\n\n// Better: Use Promise.all for parallel operations\nasync function fetchMultipleData<T>(urls: string[]): Promise<T[]> {\ntry {\nconst promises = urls.map(url => fetchData<T>(url));\nreturn await Promise.all(promises);\n} catch (error) {\nconsole.error('One or more requests failed:', error);\nthrow error;\n}\n}\n\n// Example usage\ninterface User {\nid: string;\nname: string;\nemail: string;\n}\n\n// Fetch user data with proper typing\nasync function getUserData(userId: string): Promise<User> {\nreturn fetchData<User>(`/api/users/${userId}`);\n}",
        "// Bad: Nested async/await (callback hell)\nasync function processUser(userId: string) {\nconst user = await getUser(userId);\nif (user) {\nconst orders = await getOrders(user.id);\nif (orders.length > 0) {\nconst latestOrder = orders[0];\nconst items = await getOrderItems(latestOrder.id);\nreturn { user, latestOrder, items };\n}\n}\nreturn null;\n}\n\n// Better: Flatten the async/await chain\nasync function processUser(userId: string) {\nconst user = await getUser(userId);\nif (!user) return null;\n\nconst orders = await getOrders(user.id);\nif (orders.length === 0) return { user, latestOrder: null, items: [] };\n\nconst latestOrder = orders[0];\nconst items = await getOrderItems(latestOrder.id);\n\nreturn { user, latestOrder, items };\n}\n\n// Best: Use Promise.all for independent async operations\nasync function processUser(userId: string) {\nconst [user, orders] = await Promise.all([\ngetUser(userId),\ngetOrders(userId)\n]);\n\nif (!user) return null;\nif (orders.length === 0) return { user, latestOrder: null, items: [] };\n\nconst latestOrder = orders[0];\nconst items = await getOrderItems(latestOrder.id);\n\nreturn { user, latestOrder, items };\n}",
        "// Bad: Hard to test due to direct dependencies\nclass PaymentProcessor {\nasync processPayment(amount: number) {\nconst paymentGateway = new PaymentGateway();\nreturn paymentGateway.charge(amount);\n}\n}\n\n// Better: Use dependency injection\ninterface PaymentGateway {\ncharge(amount: number): Promise<boolean>;\n}\n\nclass PaymentProcessor {\nconstructor(private paymentGateway: PaymentGateway) {}\n\nasync processPayment(amount: number): Promise<boolean> {\nif (amount <= 0) {\nthrow new Error('Amount must be greater than zero');\n}\nreturn this.paymentGateway.charge(amount);\n}\n}\n\n// Test example with Jest\ndescribe('PaymentProcessor', () => {\nlet processor: PaymentProcessor;\nlet mockGateway: jest.Mocked<PaymentGateway>;\n\nbeforeEach(() => {\nmockGateway = {\ncharge: jest.fn()\n};\nprocessor = new PaymentProcessor(mockGateway);\n});\n\nit('should process a valid payment', async () => {\nmockGateway.charge.mockResolvedValue(true);\nconst result = await processor.processPayment(100);\nexpect(result).toBe(true);\nexpect(mockGateway.charge).toHaveBeenCalledWith(100);\n});\n\nit('should throw for invalid amount', async () => {\nawait expect(processor.processPayment(-50))\n.rejects\ntoThrow('Amount must be greater than zero');\n});\n});",
        "// Using @ts-expect-error to test for type errors\n// @ts-expect-error - Should not allow negative values\nconst invalidUser: User = { id: -1, name: 'Test' };\n\n// Using type assertions in tests\nfunction assertIsString(value: unknown): asserts value is string {\nif (typeof value !== 'string') {\nthrow new Error('Not a string');\n}\n}\n\n// Using utility types for testing\ntype IsString<T> = T extends string ? true : false;\ntype Test1 = IsString<string>; // true\ntype Test2 = IsString<number>; // false\n\n// Using tsd for type testing (install with: npm install --save-dev tsd)\n/*\nimport { expectType } from 'tsd';\n\nconst user = { id: 1, name: 'John' };\nexpectType<{ id: number; name: string }>(user);\nexpectType<string>(user.name);\n*/",
        "// Bad: Imports both type and value\nimport { User, fetchUser } from './api';\n\n// Good: Separate type and value imports\nimport type { User } from './api';\nimport { fetchUser } from './api';\n\n// Even better: Use type-only imports when possible\nimport type { User, UserSettings } from './types';\n\n// Type-only export\nexport type { User };\n\n// Runtime export\nexport { fetchUser };\n\n// In tsconfig.json, enable \"isolatedModules\": true\n// to ensure type-only imports are properly handled",
        "// Bad: Deeply nested mapped types can be slow\ntype DeepPartial<T> = {\n[P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n// Better: Use built-in utility types when possible\ntype User = {\nid: string;\nprofile: {\nname: string;\nemail: string;\n};\npreferences?: {\nnotifications: boolean;\n};\n};\n\n// Instead of DeepPartial<User>, use Partial with type assertions\nconst updateUser = (updates: Partial<User>) => {\n// Implementation\n};\n\n// For complex types, consider using interfaces\ninterface UserProfile {\nname: string;\nemail: string;\n}\n\ninterface UserPreferences {\nnotifications: boolean;\n}\n\ninterface User {\nid: string;\nprofile: UserProfile;\npreferences?: UserPreferences;\n}",
        "// Without const assertion (wider type)\nconst colors = ['red', 'green', 'blue'];\n// Type: string[]\n\n// With const assertion (narrower, more precise type)\nconst colors = ['red', 'green', 'blue'] as const;\n// Type: readonly [\"red\", \"green\", \"blue\"]\n\n// Extract union type from const array\ntype Color = typeof colors[number]; // \"red\" | \"green\" | \"blue\"\n\n// Objects with const assertions\nconst config = {\napiUrl: 'https://api.example.com',\ntimeout: 5000,\nfeatures: ['auth', 'notifications'],\n} as const;\n\n// Type is:\n// {\n// readonly apiUrl: \"https://api.example.com\";\n// readonly timeout: 5000;\n// readonly features: readonly [\"auth\", \"notifications\"];\n// }",
        "// Bad: Loses all type safety\nfunction process(data: any) {\nreturn data.map(item => item.name);\n}\n\n// Better: Use generics for type safety\nfunction process<T extends { name: string }>(items: T[]) {\nreturn items.map(item => item.name);\n}\n\n// Best: Use specific types when possible\ninterface User {\nname: string;\nage: number;\n}\n\nfunction processUsers(users: User[]) {\nreturn users.map(user => user.name);\n}",
        "// tsconfig.json\n{\n\"compilerOptions\": {\n\"strict\": true,\n/* Additional strictness flags */\n\"noImplicitAny\": true,\n\"strictNullChecks\": true,\n\"strictFunctionTypes\": true,\n\"strictBindCallApply\": true,\n\"strictPropertyInitialization\": true,\n\"noImplicitThis\": true,\n\"alwaysStrict\": true\n}\n}",
        "// Redundant type annotation\nconst name: string = 'John';\n\n// Let TypeScript infer the type\nconst name = 'John'; // TypeScript knows it's a string\n\n// Redundant return type\nfunction add(a: number, b: number): number {\nreturn a + b;\n}\n\n// Let TypeScript infer the return type\nfunction add(a: number, b: number) {\nreturn a + b; // TypeScript infers number\n}",
        "// Without type guard\nfunction process(input: string | number) {\nreturn input.toUpperCase(); // Error: toUpperCase doesn't exist on number\n}\n\n// With type guard\nfunction isString(value: unknown): value is string {\nreturn typeof value === 'string';\n}\n\nfunction process(input: string | number) {\nif (isString(input)) {\nreturn input.toUpperCase(); // TypeScript knows input is string here\n} else {\nreturn input.toFixed(2); // TypeScript knows input is number here\n}\n}\n\n// Built-in type guards\nif (typeof value === 'string') { /* value is string */ }\nif (value instanceof Date) { /* value is Date */ }\nif ('id' in user) { /* user has id property */ }",
        "// Bad: Potential runtime error\nfunction getLength(str: string | null) {\nreturn str.length; // Error: Object is possibly 'null'\n}\n\n// Good: Null check\nfunction getLength(str: string | null) {\nif (str === null) return 0;\nreturn str.length;\n}\n\n// Better: Use optional chaining and nullish coalescing\nfunction getLength(str: string | null) {\nreturn str?.length ?? 0;\n}\n\n// For arrays\nconst names: string[] | undefined = [];\nconst count = names?.length ?? 0; // Safely handle undefined\n\n// For object properties\ninterface User {\nprofile?: {\nname?: string;\n};\n}\n\nconst user: User = {};\nconst name = user.profile?.name ?? 'Anonymous';",
        "strict",
        "tsconfig.json",
        "interface",
        "type",
        "any",
        "null",
        "undefined"
      ]
    },
    {
      "title": "TypeScript Online Editor",
      "summary": "TypeScript Editor\nWith our online TypeScript editor, you can edit TypeScript code, and view the result in your browser.\nExample\nClick on the \"Try it Yourself\" button to see how it works.\nPublish Your Code\nIf you want to create your own website or build TypeScript applications, check out W3Schools Spaces.\nW3Schools Spaces is a website-building tool that enables you to create and share your own website, as well as develop and host your TypeScript applications within a Node.js environment.\nYou have full control over the website's appearance and functionality by editing the code directly in your web browser.\nThe tool is user-friendly and requires no setup, making it easy to use.\nThe code editor is packed with features to help you achieve more:\nTemplates: Start from scratch or use a template\nCloud-based: no installations required. You only need your browser\nTerminal & Log: debug and troubleshoot your code easily\nFile Navigator: switch between files inside the code editor\nAnd much more!\nLearn Faster\nPractice is key to mastering coding, and the best way to put your TypeScript knowledge into practice is by getting practical with code.\nUse W3Schools Spaces to build, test and deploy code.\nThe code editor lets you write and practice different types of computer languages.\nIt includes TypeScript, and you can use it for other languages too.\nNew languages are added all the time:\nIf you don't know TypeScript, we suggest that you read our TypeScript Tutorial from scratch.\nIf you don't know Node.js, we suggest that you read our Node.js Tutorial from scratch.\nBuild Powerful Websites\nYou can also use the code editor in W3School Spaces to build frontend or full-stack websites from scratch.\nOr you can use the 60+ templates available and save time:\nCreate your Spaces account today and explore them all!\nShare It With The World\nHost and publish your websites in no time with W3School Spaces.\nW3Schools subdomain and SSL certificate are included for free with W3School Spaces.\nAn SSL certificate makes your website safe and secure.\nIt also helps people trust your website and makes it easier to find it online.\nWant a custom domain for your website?\nYou can buy a domain or transfer an existing one and connect it to your space.\nHow Does It Work?\nGet started in a few clicks with W3School Spaces.",
      "examples": [
        "console.log('Hello World!');",
        "Hello World!"
      ]
    },
    {
      "title": "TypeScript Exercises",
      "summary": "Exercises\nTest your TypeScript skills with exercises from all categories:\nIntroduction\nGet Started\nSimple Types\nExplicit Types and Inference\nSpecial Types\nArrays\nTuples\nObject Types\nEnums\nAliases & Interfaces\nUnion Types\nFunctions\nCasting\nClasses\nBasic Generics\nUtility Types\nKeyof\nNull\nDefinitely Typed\nTypeScript 5 Updates\nConfiguration\nNode.js\nReact\nTooling\nAdvanced Types\nType Guards\nConditional Types\nMapped Types\nType Inference\nLiteral Types\nNamespaces\nIndex Signatures\nDeclaration Merging\nAsync\nDecorators\nJSDoc\nMigration\nError Handling\nBest Practices\nLog in to track your progress\nIf you haven't already, sign up to become a W3Schooler, and get points for every exercise you complete.\nAs a logged on W3Schools user you will have access to many features like having your own web page, track your learning progress, receive personal guided paths, and more.\nThe Exercise\nThe exercises are a mix of \"multiple choice\" and \"fill in the blanks\" questions. There are between 2 and 5 questions in each category. The answer can be found in the corresponding tutorial chapter. If you're stuck, or answer wrong, you can try again or hit the \"Show Answer\" button to see the correct answer.\nIf you don't know TypeScript, we suggest that you read our TypeScript Tutorial from scratch.",
      "examples": []
    },
    {
      "title": "TypeScript Quiz",
      "summary": "You can test your TypeScript skills with W3Schools' Quiz.\nThe Test\nThe test contains 25 questions and there is no time limit.\nThe test is not official, it's just a nice way to see how much you know, or don't know, about TypeScript.\nCount Your Score\nYou will get 1 point for each correct answer.\nAt the end of the Quiz, your total score will be displayed. Maximum score is 25 points.\nStart the Quiz\nGood luck!\nStart the TypeScript Quiz ❯\nIf you don't know TypeScript, we suggest that you read our TypeScript Tutorial from scratch.",
      "examples": []
    },
    {
      "title": "TypeScript Syllabus",
      "summary": "Introduction\nThe W3Schools TypeScript Tutorial is comprehensive and beginner-friendly.\nIt will give you a fundamental knowledge of TypeScript.\nIt is designed for beginners and requires only basic JavaScript knowledge.\nThe content has been carefully made to be bite-sized, simple, and easy to understand.\nThe content has been proven by millions of users over the years. It is updated and improved frequently.\nThe syllabus outline and its sequence are structured so you can learn TypeScript step by step, from the introduction to advanced features.\nGet Started With TypeScript »\nLearning Outcomes\nLearn what TypeScript is and how to get started\nWork with simple types (string, number, boolean)\nUse special types (any, void, never, undefined, null)\nCreate and work with arrays and tuples\nDefine object types and enums\nUse type aliases and interfaces\nWork with union types and functions\nUnderstand type casting and classes\nUse basic generics and utility types\nNote: Are you a teacher teaching TypeScript? W3Schools Academy is a toolbox of features that can help you teach. It offers classroom features such as pre-built study plans, classroom administration and much more. Read more about Academy here.\nWhich Subjects Are TypeScript Relevant For?\nWeb Development:\nTypeScript enhances JavaScript development with static typing.\nFront-end Development:\nTypeScript is widely used in Angular and other frameworks.\nBack-end Development:\nTypeScript can be used with Node.js for server-side code.\nApplication Development:\nTypeScript supports building large-scale applications.\nEnterprise Software:\nTypeScript provides better tooling and maintainability.\nAPI Development:\nTypeScript offers strong typing for API contracts.\nFull-stack Development:\nTypeScript enables type safety across the stack.\nGet Started\nActivities\nIn this tutorial we offer different activities for you to learn TypeScript for free:\nLessons\nExercises\nQuizzes\nSign in to Track Progress\nYou can also create a free account to track your progress.\nAs a signed-in user, you get access to features such as:\nLearning paths\nSandbox and lab environments\nAchievements\nAnd much more!\nSign Up - It's free\nOverview of the Modules\nTS HOME\nTS Introduction\nTS Get Started\nTS Simple Types\nTS Special Types\nTS Arrays\nTS Tuples\nTS Object Types\nTS Enums\nTS Aliases & Interfaces\nTS Union Types\nTS Functions\nTS Casting\nTS Classes\nTS Basic Generics\nTS Utility Types\nTS Keyof\nTS Null\nTS Definitely Typed\nTS 5 Updates\nGet Started\nSandbox and Lab Environment\nTypeScript, like any programming language, is best learned through hands-on practice.\nTry this example using our editor:\nExampleGet your own TypeScript Server\nIf you want to explore more and host your project, we have a feature called Spaces that allows you to build, test and run TypeScript applications for free.\nHere you get a secure sandbox environment called Spaces, where you can practice TypeScript code and test projects in real-time.\nSpaces allow you to test, build, and deploy code. This includes a W3Schools subdomain, hosting, and secure SSL certificates.\nSpaces require no installation and run directly in the browser.\nFeatures include:\nCollaboration\nFile navigator\nTerminal & log\nPackage manager\nDatabase\nEnvironment manager\nAnalytics\nCreate a Spaces Account\nTypeScript Certification\nW3Schools offers an end-of-pathway certification program.\nHere you can take exams to get certified.\nThe TypeScript exam is a test that summarizes the W3Schools TypeScript syllabus.\nAfter passing the exam you get the \"Certified TypeScript Developer\" Certification.\nThere are two different types of certifications:\nNon-adaptive\nAdaptive\nThe non-adaptive is pass or no pass.\nThe adaptive certification exam is adaptive and graded; students will get a grade from intermediate, advanced to professional.\nBuy Certificate »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach TypeScript?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": [
        "console.log('Hello World!');"
      ]
    },
    {
      "title": "TypeScript Study Plan",
      "summary": "Introduction\nThe TypeScript study plan helps you teach your students TypeScript step-by-step.\nCreating a study plan for TypeScript is easy.\nYou can use a pre-built study plan or customize it.\nStudents have different skill levels. The study plans can be customized to ensure that everyone is challenged.\nSave time with pre-built teacher materials and study plans. Easily organize your class with a timeline from the introduction of TypeScript to the final exam.\nW3Schools Academy\nThis study plan is a feature of W3Schools Academy.\nW3Schools Academy is a platform that has everything you need to teach coding, all in one place.\nIt offers you as a teacher a toolbox of features that helps you succeed with teaching in your classroom.\nYou need to have an active subscription to access the study plan feature. There are two different subscription tiers:\nEssentials ($1.99 / month per student)\nFull Access ($5.99 / month per student)\nCalculate your price and order here.\nLearn More »\nAcademy also offer other features such as:\nManaging your classroom\nTracking of student progress and reports\nLabs, assignments, and code challenges (prebuilt challenges or create your own ones)\nAuto-grading\nTeaching materials\nCertification exams\nGet a free demo »\nTeacher Materials\nW3Schools has everything you need to teach TypeScript.\nThe TypeScript training materials is available for you to include and use in your study plan:\nW3Schools TypeScript Tutorial\nTypeScript Exercises\nTypeScript Quiz\nTypeScript Challenges (Coding challenges)\nTypeScript Certification Exam (End of Pathway Exam)\nTypeScript Syllabus\nWith the TypeScript Syllabus, your students will start with the basics, like understanding types, variables, and interfaces, and move to more advanced topics, like working with classes, generics, and modules. Each chapter includes examples, try-it-yourself sections, exercises, and quizzes to make learning easy, interactive, and fun.\nRead more about TypeScript Syllabus.\nStudy Plan Overview\nThe study plan features are made to help teachers and students. They make learning easy, flexible, and fun. These features work for different types of classes, learning styles and student level.\nLearning Paths\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nInteractive Content\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTimeline and Pace\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nTrack Student Progress\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nEnd of Pathway Exam\nThe TypeScript study plan aligns with the TypeScript Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the TypeScript Tutorial.\nYou get reports of the students' results.\nThe TypeScript study plan aligns with the TypeScript Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the TypeScript Tutorial.\nYou get reports of the students' results.\nAccessibility\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nLearn More »\nSample Study Plan\nYou choose the timeline and pace of your study plans.\nSchools have different preferences.\nSome would like more intensive pace, e.g. 3 weeks, others 12 or more weeks.\nIt is completely up to you.\nFor example, this is how a 3-week TypeScript study plan could look like:\nWeek 1: Essentials\nWeek 2: Syntax and Variables, Functions\nWeek 3: Arrays, Tuples, Object-oriented programming, TypeScript Certification Exam\nImage of Sample TypeScript study plan:\nReady to get started?\nStart with TypeScript Study Plans today.\nGet Started »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach TypeScript programming?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": []
    },
    {
      "title": "TypeScript Certificate",
      "summary": "W3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nW3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nWho Should Consider Getting Certified?\nAny student or professional within the digital industry.\nCertifications are valuable assets to gain trust and demonstrate knowledge to your clients, current or future employers on a ever increasing competitive market.\nW3Schools is Trusted by Top Companies\nW3Schools has over two decades of experience with teaching coding online.\nOur certificates are recognized and valued by companies looking to employ skilled developers.\nSave Time and Money\nShow the world your coding skills by getting a certification.\nThe prices is a small fraction compared to the price of traditional education.\nDocument and validate your competence by getting certified!\nExam overview\nFee: 95 USD\nAchievable certification levels:\nIntermediate (40%)\nAdvanced (75%)\nProfessional (90%)\nNumber of questions:\nAdaptive, 60 on average\nRequirement to pass:\nMinimum 40% - Intermediate level\nTime limit: 60 minutes\nNumber of attempts to pass: 3\nExam deadline: None\nCertification Expiration: None\nFormat: Online, multiple choice\nRegister now »\nAdvance Faster in Your Career\nGetting a certificate proves your commitment to upgrading your skills.\nThe certificate can be added as credentials to your CV, Resume, LinkedIn profile, and so on.\nIt gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nKnowledge is power, especially in the current job market.\nDocumentation of your skills enables you to advance your career or helps you to start a new one.\nHow Does It Work?\nStudy for free at W3Schools.com\nStudy at your own speed\nTest your skills with W3Schools online quizzes\nApply for your certificate by paying an exam fee\nTake your exam online, at any time, and from any location\nGet Your Certificate and Share It With The World\nExample certificate:\nEach certificate gets a unique link that can be shared with others.\nValidate your certification with the link or QR code.\nCheck how it looks like in this Example.\nShare your certificate on Linked in the Certifications section in just one click!\nDocument Your Skills\nGetting a certificate proves your commitment to upgrade your skills, gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nGet Your Certificate »\nLooking to add multiple users?\nAre you an educator, manager or business owner looking for courses or certifications?\nWe are working with schools, companies and organizations from all over the world.\nGet courses and/or certifications for your team here.",
      "examples": []
    }
  ],
  "glossary": [
    "backend",
    "exercises",
    "free",
    "javascript",
    "note",
    "programs",
    "report error",
    "ts arrays",
    "ts casting",
    "ts classes",
    "ts configuration",
    "ts decorators",
    "ts editor",
    "ts enums",
    "ts exercises",
    "ts functions",
    "ts home",
    "ts keyof",
    "ts migration",
    "ts namespaces",
    "ts null",
    "ts quiz",
    "ts syllabus",
    "ts tooling",
    "ts tuples",
    "typescript exercises",
    "w3.css",
    "w3schools spaces"
  ],
  "objectives": [
    "View your completed tutorials, exercises, and quizzes",
    "Keep an eye on your progress and daily streaks",
    "Set goals and create learning paths",
    "Create your own personal website"
  ]
}