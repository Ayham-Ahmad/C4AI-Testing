{
  "course_name": "C",
  "course_url": "https://www.w3schools.com/c/index.php",
  "description": "C is a general-purpose programming language that has been widely used for over 50 years. C is very powerful; it has been used to develop operating systems, databases, applications, etc. Tip: Sign in to track your progress - it's free. Our \"Try it Yourself\" editor makes it easy to learn C. You can edit code and view the result in your browser: Click on the \"Try it Yourself\" button to see how it works. We recommend reading this tutorial, in the sequence listed in the left menu. Many chapters in this tutorial end with an exercise where you can check your level of knowledge. See all C Exercises REMOVE ADS Learn by taking a quiz! The quiz will give you a signal of how much you know about C. Start C Quiz Learn by examples! This tutorial supplements all explanations with clarifying examples. See All C Examples Sign Up for Free Note: This is an optional feature. You can study at W3Schools without creating an account.",
  "course_summary": [
    {
      "title": "C Tutorial",
      "summary": "Learn C\nC is a general-purpose programming language that has been widely used for over 50 years.\nC is very powerful; it has been used to develop operating systems, databases, applications, etc.\nTip: Sign in to track your progress - it's free.\nExamples in Each Chapter\nOur \"Try it Yourself\" editor makes it easy to learn C. You can edit code and view the result in your browser:\nExample\nClick on the \"Try it Yourself\" button to see how it works.\nWe recommend reading this tutorial, in the sequence listed in the left menu.\nC Exercises\nMany chapters in this tutorial end with an exercise where you can check your level of knowledge.\nSee all C Exercises\nREMOVE ADS\nC Quiz\nLearn by taking a quiz! The quiz will give you a signal of how much you know about C.\nStart C Quiz\nLearn by Examples\nLearn by examples! This tutorial supplements all explanations with clarifying examples.\nSee All C Examples\nTrack Your Progress\nView your completed tutorials, exercises, and quizzes\nKeep an eye on your progress and daily streaks\nSet goals and create learning paths\nCreate your own personal website\nSign Up for Free\nNote: This is an optional feature. You can study at W3Schools without creating an account.\nC Reference\nYou will also find complete keyword and function references:",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\");\nreturn 0;\n}"
      ]
    },
    {
      "title": "C Introduction",
      "summary": "What is C?\nC is a general-purpose programming language created by Dennis Ritchie at the Bell Laboratories in 1972.\nIt is a very popular language, despite being old. The main reason for its popularity is because it is a fundamental language in the field of computer science.\nC is strongly associated with UNIX, as it was developed to write the UNIX operating system.\nWhy Learn C?\nIt is one of the most popular programming languages in the world\nIf you know C, you will have no problem learning other popular programming languages such as Java, Python, C++, C#, etc, as the syntax is similar\nIf you know C, you will understand how computer memory works\nC is very fast, compared to other programming languages, like Java and Python\nC is very versatile; it can be used in both applications and technologies\nDifference between C and C++\nC++ was developed as an extension of C, and both languages have almost the same syntax\nThe main difference between C and C++ is that C++ supports classes and objects, while C does not.\nGet Started\nThis tutorial will teach you the basics of C.\nWhen you are finished with this tutorial, you will be able to write C programs and create real-life examples.\nIt is not necessary to have any prior programming experience.",
      "examples": []
    },
    {
      "title": "C Get Started",
      "summary": "Get Started With C\nAt W3Schools, you can try C without installing anything.\nOur Online C Editor runs directly in your browser, and shows both the code and the result:\nCode:\nResult:\nThis editor will be used in the entire tutorial to demonstrate the different aspects of C.\nInstall C\nIf you want to run C on your own computer, you need two things:\nA text editor, like Notepad, to write C code\nA compiler, like GCC, to translate the C code into a language that the computer will understand\nThere are many text editors and compilers to choose from. In the next steps, we will show you how to use an IDE that includes both.\nInstall IDE\nAn IDE (Integrated Development Environment) is used to edit AND compile the code.\nPopular IDE's include Code::Blocks, Eclipse, and Visual Studio. These are all free, and they can be used to both edit and debug C code.\nNote: Web-based IDE's can work as well, but functionality is limited.\nWe will use Code::Blocks in our tutorial, which we believe is a good place to start.\nYou can find the latest version of Codeblocks at http://www.codeblocks.org/. Download the mingw-setup.exe file, which will install the text editor with a compiler.\nC Quickstart\nLet's create our first C file.\nOpen Codeblocks and go to File > New > Empty File.\nWrite the following C code and save the file as myfirstprogram.c (File > Save File as):\nDon't worry if you don't understand the code above - we will discuss it in detail in later chapters. For now, focus on how to run the code.\nIn Codeblocks, it should look like this:\nThen, go to Build > Build and Run to run (execute) the program. The result will look something to this:\nCongratulations! You have now written and executed your first C program.",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\");\nreturn 0;\n}",
        "Hello World!",
        "mingw-setup.exe",
        "myfirstprogram.c",
        "Hello World!\nProcess returned 0 (0x0) execution time : 0.011 s\nPress any key to continue."
      ]
    },
    {
      "title": "C Syntax",
      "summary": "Syntax\nYou have already seen the following code a couple of times in the first chapters. Let's break it down to understand it better:\nExample\nExample explained\nLine 1: #include <stdio.h> is a header file library that lets us work with input and output functions, such as printf() (used in line 4). Header files add functionality to C programs.\nDon't worry if you don't understand how  #include <stdio.h> works. Just think of it as something that (almost) always appears in your program.\nLine 2: A blank line. C ignores white space. But we use it to make the code more readable.\nLine 3: Another thing that always appear in a C program is main(). This is called a function. Any code inside its curly brackets {} will be executed.\nLine 4: printf() is a function used to output/print text to the screen. In our example, it will output \"Hello World!\".\nNote that: Every C statement ends with a semicolon ;\nNote: The body of int main() could also been written as:\nint main(){printf(\"Hello World!\");return 0;}\nRemember: The compiler ignores white spaces. However, multiple lines makes the code more readable.\nLine 5: return 0 ends the main() function.\nLine 6: Do not forget to add the closing curly bracket } to actually end the main function.",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\");\nreturn 0;\n}",
        "#include <stdio.h>",
        "printf()",
        "main()",
        "{}",
        ";",
        "int main()",
        "int main(){printf(\"Hello World!\");return 0;}",
        "return 0",
        "}"
      ]
    },
    {
      "title": "C Statements",
      "summary": "Statements\nA computer program is a list of \"instructions\" to be \"executed\" by a computer.\nIn a programming language, these programming instructions are called statements.\nThe following statement \"instructs\" the compiler to print the text \"Hello World\" to the screen:\nExample\nIt is important that you end the statement with a semicolon ;\nIf you forget the semicolon (;), an error will occur and the program will not run:\nExample\nMany Statements\nMost C programs contain many statements.\nThe statements are executed, one by one, in the same order as they are written:\nExample\nFrom the example above, we have three statements:\nprintf(\"Hello World!\");\nprintf(\"Have a good day!\");\nreturn 0;\nThe first statement is executed first (print \"Hello World!\" to the screen).\nThen the second statement is executed (print \"Have a good day!\" to the screen).\nAnd at last, the third statement is executed (end the C program successfully).\nYou will learn more about statements while reading this tutorial. For now, just remember to always end them with a semicolon to avoid any errors.\nComing up: The next chapter will teach you how to control the output and how to insert new lines to make it more readable.",
      "examples": [
        "printf(\"Hello World!\");",
        "printf(\"Hello World!\")",
        "printf(\"Hello World!\");\nprintf(\"Have a good day!\");\nreturn 0;",
        ";",
        "error: expected ';' before 'return'",
        "printf(\"Have a good day!\");",
        "return 0;"
      ]
    },
    {
      "title": "C Output (Print Text)",
      "summary": "Output (Print Text)\nTo output values or print text in C, you can use the printf() function:\nExample\nDouble Quotes\nWhen you are working with text, it must be wrapped inside double quotations marks \"\".\nIf you forget the double quotes, an error occurs:\nExample\nMany printf Functions\nYou can use as many printf() functions as you want. However, note that it does not insert a new line at the end of the output:\nExample",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\");\nreturn 0;\n}",
        "printf(\"This sentence will work!\");",
        "printf(This sentence will produce an error.);",
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\");\nprintf(\"I am learning C.\");\nprintf(\"And it is awesome!\");\nreturn 0;\n}",
        "printf()",
        "\"\"",
        "printf"
      ]
    },
    {
      "title": "C New Lines",
      "summary": "New Lines\nTo insert a new line, you can use the \\n character:\nExample\nYou can also output multiple lines with a single printf() function. However, this could make the code harder to read:\nExample\nTip: Two \\n characters after each other will create a blank line:\nExample\nThe newline character (\\n) is called an escape sequence, and it forces the cursor to change its position to the beginning of the next line on the screen. This results in a new line.\nExamples of other valid escape sequences are:",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\\n\");\nprintf(\"I am learning C.\");\nreturn 0;\n}",
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\\nI am learning C.\\nAnd it is awesome!\");\nreturn 0;\n}",
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\\n\\n\");\nprintf(\"I am learning C.\");\nreturn 0;\n}",
        "\\n",
        "printf()"
      ]
    },
    {
      "title": "C Comments",
      "summary": "Comments in C\nComments can be used to explain code, and to make it more readable. It can also be used to prevent execution when testing alternative code.\nComments can be singled-lined or multi-lined.\nSingle-line Comments\nSingle-line comments start with two forward slashes (//).\nAny text between // and the end of the line is ignored by the compiler (will not be executed).\nThis example uses a single-line comment before a line of code:\nExample\nThis example uses a single-line comment at the end of a line of code:\nExample\nC Multi-line Comments\nMulti-line comments start with /* and ends with */.\nAny text between /* and */ will be ignored by the compiler:\nExample\nIt is up to you which you want to use. Normally, we use // for short comments, and /* */ for longer.\nGood to know: Before version C99 (released in 1999), you could only use multi-line comments in C.",
      "examples": [
        "// This is a comment\nprintf(\"Hello World!\");",
        "printf(\"Hello World!\"); // This is a comment",
        "/* The code below will print the words Hello World!\nto the screen, and it is amazing */\nprintf(\"Hello World!\");",
        "//",
        "/*",
        "*/",
        "/* */"
      ]
    },
    {
      "title": "C Variables",
      "summary": "Variables\nVariables are containers for storing data values, like numbers and characters.\nIn C, there are different types of variables (defined with different keywords), for example:\nint - stores integers (whole numbers), without decimals, such as 123 or -123\nfloat - stores floating point numbers, with decimals, such as 19.99 or -19.99\nchar - stores single characters, such as 'a' or 'B'. Characters are surrounded by single quotes\nDeclaring (Creating) Variables\nTo create a variable, specify the type and assign it a value:\nSyntax\nWhere type is one of C types (such as int), and variableName is the name of the variable (such as x or myName). The equal sign is used to assign a value to the variable.\nSo, to create a variable that should store a number, look at the following example:\nExample\nCreate a variable called myNum of type int and assign the value 15 to it:\nYou can also declare a variable without assigning the value, and assign the value later:\nExample\nOutput Variables\nYou learned from the output chapter that you can output values/print text with the printf() function:\nExample\nIn many other programming languages (like Python, Java, and C++), you would normally use a print function to display the value of a variable. However, this is not possible in C:\nExample\nTo output variables in C, you must get familiar with something called \"format specifiers\", which you will learn about in the next chapter.",
      "examples": [
        "type variableName = value;",
        "int myNum = 15;",
        "// Declare a variable\nint myNum;\n\n// Assign a value to the variable\nmyNum = 15;",
        "printf(\"Hello World!\");",
        "int myNum = 15;\nprintf(myNum);  // Nothing happens",
        "int",
        "123",
        "-123",
        "float",
        "19.99",
        "-19.99",
        "char",
        "'a'",
        "'B'",
        "printf()"
      ]
    },
    {
      "title": "C Format Specifiers",
      "summary": "Format Specifiers\nFormat specifiers are used together with the printf() function to tell the compiler what type of data the variable is storing. It is basically a placeholder for the variable value.\nA format specifier starts with a percentage sign %, followed by a character.\nFor example, to output the value of an int variable, use the format specifier %d surrounded by double quotes (\"\"), inside the printf() function:\nExample\nTo print other types, use %c for char and %f for float:\nExample\nTo combine both text and a variable, separate them with a comma inside the printf() function:\nExample\nTo print different types in a single printf() function, you can use the following:\nExample\nYou will learn more about Data Types in a later chapter.\nPrint Values Without Variables\nYou can also just print a value without storing it in a variable, as long as you use the correct format specifier:\nExample\nHowever, it is more sustainable to use variables as they are saved for later and can be re-used whenever.",
      "examples": [
        "int myNum = 15;\nprintf(\"%d\", myNum);  // Outputs 15",
        "// Create variables\nint myNum = 15;            // Integer (whole number)\nfloat myFloatNum = 5.99;   // Floating point number\nchar myLetter = 'D';       // Character\n\n// Print variables\nprintf(\"%d\\n\", myNum);\nprintf(\"%f\\n\", myFloatNum);\nprintf(\"%c\\n\", myLetter);",
        "int myNum = 15;\nprintf(\"My favorite number is: %d\", myNum);",
        "int myNum = 15;\nchar myLetter = 'D';\nprintf(\"My number is %d and my letter is %c\", myNum, myLetter);",
        "printf(\"My favorite number is: %d\", 15);\nprintf(\"My favorite letter is: %c\", 'D');",
        "printf()",
        "%",
        "int",
        "%d",
        "\"\"",
        "%c",
        "char",
        "%f",
        "float"
      ]
    },
    {
      "title": "C Variable Values",
      "summary": "Change Variable Values\nIf you assign a new value to an existing variable, it will overwrite the previous value:\nExample\nYou can also assign the value of one variable to another:\nExample\nOr copy values to empty variables:\nExample\nAdd Variables Together\nTo add a variable to another variable, you can use the + operator:\nExample",
      "examples": [
        "int myNum = 15;  // myNum is 15\nmyNum = 10;  // Now myNum is 10",
        "int myNum = 15;\n\nint myOtherNum = 23;\n\n// Assign the value of myOtherNum (23) to myNum\nmyNum = myOtherNum;\n\n// myNum is now 23, instead of 15\nprintf(\"%d\", myNum);",
        "// Create a variable and assign the value 15 to it\nint myNum = 15;\n\n// Declare a variable without assigning it a value\nint myOtherNum;\n\n// Assign the value of myNum to myOtherNum\nmyOtherNum = myNum;\n\n// myOtherNum now has 15 as a value\nprintf(\"%d\", myOtherNum);",
        "int x = 5;\nint y = 6;\nint sum = x + y;\nprintf(\"%d\", sum);",
        "+"
      ]
    },
    {
      "title": "C Declare Multiple Variables",
      "summary": "Declare Multiple Variables\nTo declare more than one variable of the same type, use a comma-separated list:\nExample\nYou can also assign the same value to multiple variables of the same type:\nExample",
      "examples": [
        "int x = 5, y = 6, z = 50;\nprintf(\"%d\", x + y + z);",
        "int x, y, z;\nx = y = z = 50;\nprintf(\"%d\", x + y + z);"
      ]
    },
    {
      "title": "C Variable Names (Identifiers)",
      "summary": "C Variable Names\nAll C variables must be identified with unique names.\nThese unique names are called identifiers.\nIdentifiers can be short names (like x and y) or more descriptive names (age, sum, totalVolume).\nNote: It is recommended to use descriptive names in order to create understandable and maintainable code:\nExample\nThe general rules for naming variables are:\nNames can contain letters, digits and underscores\nNames must begin with a letter or an underscore (_)\nNames are case-sensitive (myVar and myvar are different variables)\nNames cannot contain whitespaces or special characters like !, #, %, etc.\nReserved words (such as int) cannot be used as names",
      "examples": [
        "// Good variable name\nint minutesPerHour = 60;\n\n// OK, but not so easy to understand what m actually is\nint m = 60;",
        "myVar",
        "myvar",
        "int"
      ]
    },
    {
      "title": "C Variables - Examples",
      "summary": "Real-Life Example\nOften in our examples, we simplify variable names to match their data type (myInt or myNum for int types, myChar for char types, and so on). This is done to avoid confusion.\nHowever, for a practical example of using variables, we have created a program that stores different data about a college student:\nExample\nCalculate the Area of a Rectangle\nIn this real-life example, we create a program to calculate the area of a rectangle (by multiplying the length and width):\nExample",
      "examples": [
        "// Student data\nint studentID = 15;\nint studentAge = 23;\nfloat studentFee = 75.25;\nchar studentGrade = 'B';\n\n// Print variables\nprintf(\"Student id: %d\\n\", studentID);\nprintf(\"Student age: %d\\n\", studentAge);\nprintf(\"Student fee: %f\\n\", studentFee);\nprintf(\"Student grade: %c\", studentGrade);",
        "// Create integer variables\nint length = 4;\nint width = 6;\nint area;\n\n// Calculate the area of a rectangle\narea = length * width;\n\n// Print the variables\nprintf(\"Length is: %d\\n\", length);\nprintf(\"Width is: %d\\n\", width);\nprintf(\"Area of the rectangle is: %d\", area);",
        "int",
        "char"
      ]
    },
    {
      "title": "C Data Types",
      "summary": "Data Types\nAs explained in the Variables chapter, a variable in C must be a specified data type, and you must use a format specifier inside the printf() function to display it:\nExample\nBasic Data Types\nThe data type specifies the size and type of information the variable will store.\nIn this tutorial, we will focus on the most basic ones:\nBasic Format Specifiers\nThere are different format specifiers for each data type. Here are some of them:\nNote: It is important that you use the correct format specifier for the specified data type. If not, the program may produce errors or even crash.",
      "examples": [
        "// Create variables\nint myNum = 5;             // Integer (whole number)\nfloat myFloatNum = 5.99;   // Floating point number\nchar myLetter = 'D';       // Character\n\n// Print variables\nprintf(\"%d\\n\", myNum);\nprintf(\"%f\\n\", myFloatNum);\nprintf(\"%c\\n\", myLetter);",
        "printf()",
        "int",
        "1",
        "float",
        "1.99",
        "double",
        "char",
        "'A'",
        "%d",
        "%i",
        "%f",
        "%F",
        "%lf",
        "%c",
        "%s"
      ]
    },
    {
      "title": "C Character Data Types",
      "summary": "The char Type\nThe char data type is used to store a single character.\nThe character must be surrounded by single quotes, like 'A' or 'c', and we use the %c format specifier to print it:\nExample\nAlternatively, if you are familiar with ASCII, you can use ASCII values to display certain characters. Note that these values are not surrounded by quotes (''), as they are numbers:\nExample\nTip: A list of all ASCII values can be found in our ASCII Table Reference.\nNotes on Characters\nIf you try to store more than a single character, it will only print the last character:\nExample\nNote: Don't use the char type for storing multiple characters, as it may produce errors.\nTo store multiple characters (or whole words), use strings (which you will learn more about in a later chapter):\nExample\nFor now, just know that we use strings for storing multiple characters/text, and the char type for single characters.",
      "examples": [
        "char myGrade = 'A';\nprintf(\"%c\", myGrade);",
        "char a = 65, b = 66, c = 67;\nprintf(\"%c\", a);\nprintf(\"%c\", b);\nprintf(\"%c\", c);",
        "char myText = 'Hello';\nprintf(\"%c\", myText);",
        "char myText[] = \"Hello\";\nprintf(\"%s\", myText);",
        "char",
        "%c",
        "''"
      ]
    },
    {
      "title": "C Numeric Data Types",
      "summary": "Numeric Types\nUse int when you need to store a whole number without decimals, like 35 or 1000, and float or double when you need a floating point number (with decimals), like 9.99 or 3.14515.\nint\nfloat\ndouble\nfloat vs. double\nThe precision of a floating point value indicates how many digits the value can have after the decimal point. The precision of float is six or seven decimal digits, while double variables have a precision of about 15 digits. Therefore, it is often safer to use double for most calculations - but note that it takes up twice as much memory as float (8 bytes vs. 4 bytes).\nScientific Numbers\nIn C, you can write very large or very small floating-point numbers using scientific notation.\nThis is done using the letter e (or E), which stands for \"times 10 to the power of\".\nFor example, 35e3 means 35 × 10³ = 35000.\nThis is useful for writing numbers in a shorter way. Especially when working with scientific values or large-scale data.\nExample",
      "examples": [
        "int myNum = 1000;\nprintf(\"%d\", myNum);",
        "float myNum = 5.75;\nprintf(\"%f\", myNum);",
        "double myNum = 19.99;\nprintf(\"%lf\", myNum);",
        "float f1 = 35e3;   // 35 * 10^3 = 35000\ndouble d1 = 12E4;  // 12 * 10^4 = 120000\n\nprintf(\"%f\\n\", f1);\nprintf(\"%lf\", d1);",
        "int",
        "float",
        "double",
        "e",
        "E",
        "35e3"
      ]
    },
    {
      "title": "C Decimal Precision",
      "summary": "Set Decimal Precision\nYou have probably already noticed that if you print a floating point number, the output will show many digits after the decimal point:\nExample\nIf you want to remove the extra zeros (set decimal precision), you can use a dot (.) followed by a number that specifies how many digits that should be shown after the decimal point:\nExample",
      "examples": [
        "float myFloatNum = 3.5;\ndouble myDoubleNum = 19.99;\n\nprintf(\"%f\\n\", myFloatNum); // Outputs 3.500000\nprintf(\"%lf\", myDoubleNum); // Outputs 19.990000",
        "float myFloatNum = 3.5;\n\nprintf(\"%f\\n\", myFloatNum);   // Default will show 6 digits after the decimal point\nprintf(\"%.1f\\n\", myFloatNum); // Only show 1 digit\nprintf(\"%.2f\\n\", myFloatNum); // Only show 2 digits\nprintf(\"%.4f\", myFloatNum);   // Only show 4 digits",
        "."
      ]
    },
    {
      "title": "C The sizeof Operator",
      "summary": "Get the Memory Size\nWe introduced in the data types chapter that the memory size of a variable varies depending on the type:\nThe memory size refers to how much space a type occupies in the computer's memory.\nTo actually get the size (in bytes) of a data type or variable, use the sizeof operator:\nExample\nNote that we use the %zu format specifier to print the result, instead of %d. This is because the compiler expects the sizeof operator to return a value of type size_t, which is an unsigned integer type. On some computers it might work with %d, but it is safer and more portable to use %zu, which is specifically designed for printing size_t values.\nKnowing the size of data types helps you understand how much memory your program uses. This is important when writing larger programs or working with limited memory, because it can affect both performance and efficiency.\nFor example, the size of a char type is 1 byte. Which means if you have an array of 1000 char values, it will occupy 1000 bytes (1 KB) of memory.\nUsing the right data type for the right purpose will save memory and improve the performance of your program.\nYou will learn more about the sizeof operator later in this tutorial, and how to use it in different scenarios.",
      "examples": [
        "int myInt;\nfloat myFloat;\ndouble myDouble;\nchar myChar;\n\nprintf(\"%zu\\n\", sizeof(myInt));\nprintf(\"%zu\\n\", sizeof(myFloat));\nprintf(\"%zu\\n\", sizeof(myDouble));\nprintf(\"%zu\\n\", sizeof(myChar));",
        "int",
        "float",
        "double",
        "char",
        "sizeof",
        "%zu",
        "%d",
        "size_t"
      ]
    },
    {
      "title": "C Data Types Examples",
      "summary": "Real-Life Example\nHere's a real-life example of using different data types, to calculate and output the total cost of a number of items:\nExample",
      "examples": [
        "// Create variables of different data types\nint items = 50;\nfloat cost_per_item = 9.99;\nfloat total_cost = items * cost_per_item;\nchar currency = '$';\n\n// Print variables\nprintf(\"Number of items: %d\\n\", items);\nprintf(\"Cost per item: %.2f %c\\n\", cost_per_item, currency);\nprintf(\"Total cost = %.2f %c\\n\", total_cost, currency);"
      ]
    },
    {
      "title": "C Type Conversion",
      "summary": "Type Conversion\nSometimes, you have to convert the value of one data type to another type. This is known as type conversion.\nFor example, if you try to divide two integers, 5 by 2, you would expect the result to be 2.5. But since we are working with integers (and not floating-point values), the following example will just output 2:\nExample\nTo get the right result, you need to know how type conversion works.\nThere are two types of conversion in C:\nImplicit Conversion (automatically)\nExplicit Conversion (manually)\nImplicit Conversion\nImplicit conversion is done automatically by the compiler when you assign a value of one type to another.\nFor example, if you assign an int value to a float type:\nExample\nAs you can see, the compiler automatically converts the int value 9 to a float value of 9.000000.\nThis can be risky, as you might lose control over specific values in certain situations.\nEspecially if it was the other way around - the following example automatically converts the float value 9.99 to an int value of 9:\nExample\nWhat happened to .99? We might want that data in our program! So be careful. It is important that you know how the compiler work in these situations, to avoid unexpected results.\nAs another example, if you divide two integers: 5 by 2, you know that the sum is 2.5. And as you know from the beginning of this page, if you store the sum as an integer, the result will only display the number 2. Therefore, it would be better to store the sum as a float or a double, right?\nExample\nWhy is the result 2.00000 and not 2.5? Well, it is because 5 and 2 are still integers in the division. In this case, you need to manually convert the integer values to floating-point values. (see below).\nExplicit Conversion\nExplicit conversion is done manually by placing the type in parentheses () in front of the value.\nConsidering our problem from the example above, we can now get the right result:\nExample\nYou can also place the type in front of a variable:\nExample\nAnd since you learned about \"decimal precision\" in the previous chapter, you could make the output even cleaner by removing the extra zeros (if you like):\nExample\nReal-Life Example\nHere's a real-life example of data types and type conversion where we create a program to calculate the percentage of a user's score in relation to the maximum score in a game:\nExample",
      "examples": [
        "int x = 5;\nint y = 2;\nint sum = 5 / 2;\n\nprintf(\"%d\", sum); // Outputs 2",
        "// Automatic conversion: int to float\nfloat myFloat = 9;\n\nprintf(\"%f\", myFloat); // 9.000000",
        "// Automatic conversion: float to int\nint myInt = 9.99;\n\nprintf(\"%d\", myInt); // 9",
        "float sum = 5 / 2;\n\nprintf(\"%f\", sum); // 2.000000",
        "// Manual conversion: int to float\nfloat sum = (float) 5 / 2;\n\nprintf(\"%f\", sum); // 2.500000",
        "int num1 = 5;\nint num2 = 2;\nfloat sum = (float) num1 / num2;\n\nprintf(\"%f\", sum); // 2.500000",
        "int num1 = 5;\nint num2 = 2;\nfloat sum = (float) num1 / num2;\n\nprintf(\"%.1f\", sum); // 2.5",
        "// Set the maximum possible score in the game to 500\nint maxScore = 500;\n\n// The actual score of the user\nint userScore = 423;\n\n/* Calculate the percantage of the user's score in relation to the maximum available score.\nConvert userScore to float to make sure that the division is accurate */\nfloat percentage = (float) userScore / maxScore * 100.0;\n\n// Print the percentage\nprintf(\"User's percentage is %.2f\", percentage);",
        "5",
        "2",
        "2.5",
        "int",
        "float",
        "9",
        "9.000000",
        "9.99",
        ".99",
        "double",
        "2.00000",
        "()"
      ]
    },
    {
      "title": "C Constants",
      "summary": "Constants\nIf you don't want others (or yourself) to change existing variable values, you can use the const keyword.\nThis will declare the variable as \"constant\", which means unchangeable and read-only:\nExample\nYou should always declare the variable as constant when you have values that are unlikely to change:\nExample\nNotes On Constants\nWhen you declare a constant variable, it must be assigned with a value:\nExample\nLike this:\nThis however, will not work:\nGood Practice\nAnother thing about constant variables, is that it is considered good practice to declare them with uppercase.\nIt is not required, but useful for code readability and common for C programmers:\nExample",
      "examples": [
        "const int myNum = 15;  // myNum will always be 15\nmyNum = 10;  // error: assignment of read-only variable 'myNum'",
        "const int minutesPerHour = 60;",
        "const int minutesPerHour;\nminutesPerHour = 60; // error",
        "const int BIRTHYEAR = 1980;",
        "const"
      ]
    },
    {
      "title": "C Operators",
      "summary": "Operators\nOperators are used to perform operations on variables and values.\nIn the example below, we use the + operator to add together two values:\nExample\nAlthough the + operator is often used to add together two values, like in the example above, it can also be used to add together a variable and a value, or a variable and another variable:\nExample\nC divides the operators into the following groups:\nArithmetic operators\nAssignment operators\nComparison operators\nLogical operators\nBitwise operators",
      "examples": [
        "int myNum = 100 + 50;",
        "int sum1 = 100 + 50;        // 150 (100 + 50)\nint sum2 = sum1 + 250;      // 400 (150 + 250)\nint sum3 = sum2 + sum2;     // 800 (400 + 400)",
        "+"
      ]
    },
    {
      "title": "C Arithmetic Operators",
      "summary": "Arithmetic Operators\nArithmetic operators are used to perform common mathematical operations.\nHere is an example using different arithmetic operators in one example:\nExample\nTry it Yourself »\nNote: When dividing two integers in C, the result will also be an integer. For example, 10 / 3 gives 3. If you want a decimal result, use float or double values, like 10.0 / 3.\nExample\nTry it Yourself »\nIncrementing and Decrementing\nIncrementing and decrementing are very common in programming, especially when working with counters, loops, and arrays (which you will learn more about in later chapters).\nThe ++ operator increases a value by 1, while the -- operator decreases a value by 1:\nExample\nTry it Yourself »\nImagine you are building a program to count how many people enter and leave a room. You can use ++ to increase the counter when someone enters, and -- to decrease it when someone leaves:\nExample\nTry it Yourself »",
      "examples": [
        "int x = 10; int y = 3; printf(\"%d\\n\", x + y); // 13 printf(\"%d\\n\", x - y); // 7 printf(\"%d\\n\", x * y); // 30 printf(\"%d\\n\", x / y); // 3 printf(\"%d\\n\", x % y); // 1 int z = 5; ++z; printf(\"%d\\n\", z); // 6 --z; printf(\"%d\\n\", z); // 5",
        "int a = 10; int b = 3; printf(\"%d\\n\", a / b); // Integer division, result is 3 double c = 10.0; double d = 3.0; printf(\"%f\\n\", c / d); // Decimal division, result is 3.333...",
        "int x = 5; ++x; // Increment x by 1 printf(\"%d\\n\", x); // 6 --x; // Decrement x by 1 printf(\"%d\\n\", x); // 5",
        "int peopleInRoom = 0; // 3 people enter peopleInRoom++; peopleInRoom++; peopleInRoom++; printf(\"%d\\n\", peopleInRoom); // 3 // 1 person leaves peopleInRoom--; printf(\"%d\\n\", peopleInRoom); // 2",
        "10 / 3",
        "3",
        "float",
        "double",
        "10.0 / 3",
        "++",
        "--"
      ]
    },
    {
      "title": "C Assignment Operators",
      "summary": "Assignment Operators\nAssignment operators are used to assign values to variables.\nIn the example below, we use the assignment operator (=) to assign the value 10 to a variable called x:\nExample\nThe addition assignment operator (+=) adds a value to a variable:\nExample\nA list of all assignment operators:\nNote: Most assignment operators are just shorter ways of writing code. For example, x += 5 is the same as x = x + 5, but shorter and often easier to read.\nReal-Life Example: Tracking Savings\nAssignment operators can also be used in real-life scenarios. For example, you can use the += operator to keep track of savings when you add money to an account:\nExample",
      "examples": [
        "int savings = 100; savings += 50; // add 50 to savings printf(\"Total savings: %d\\n\", savings);",
        "int x = 10;",
        "int x = 10;\nx += 5;",
        "=",
        "+=",
        "x += 5",
        "x = x + 5"
      ]
    },
    {
      "title": "C Comparison Operators",
      "summary": "Comparison Operators\nComparison operators are used to compare two values (or variables). This is important in programming, because it helps us to find answers and make decisions.\nThe return value of a comparison is either 1 or 0, which means true (1) or false (0). These values are known as Boolean values, and you will learn more about them in the Booleans and If..Else chapter.\nIn the following example, we use the greater than operator (>) to find out if 5 is greater than 3:\nExample\nA list of all comparison operators:\nReal-Life Examples\nComparison operators are often used in real-world conditions, such as checking if a person is old enough to vote:\nExample\nTry it Yourself »\nAnother common use is checking if a password is long enough:\nExample\nTry it Yourself »",
      "examples": [
        "int age = 18; printf(\"%d\\n\", age >= 18); // 1 (true), old enough to vote printf(\"%d\\n\", age < 18); // 0 (false), not old enough",
        "int passwordLength = 5; printf(\"%d\\n\", passwordLength >= 8); // 0 (false), too short printf(\"%d\\n\", passwordLength < 8); // 1 (true), needs more characters",
        "int x = 5;\nint y = 3;\nprintf(\"%d\", x > y); // returns 1 (true) because 5 is greater than 3",
        "1",
        "0",
        ">"
      ]
    },
    {
      "title": "C Logical Operators",
      "summary": "Logical Operators\nAs with comparison operators, you can also test for true or false values with logical operators.\nLogical operators are used to determine the logic between variables or values, by combining multiple conditions:\nReal-Life Example: Login Check\nThe example below shows how logical operators can be used in a real situation, e.g. when checking login status and access rights:\nExample\nResult:\nTry it Yourself »",
      "examples": [
        "bool isLoggedIn = true; bool isAdmin = false; printf(\"Regular user: %s\\n\", (isLoggedIn && !isAdmin) ? \"true\" : \"false\"); printf(\"Has access: %s\\n\", (isLoggedIn || isAdmin) ? \"true\" : \"false\"); printf(\"Not logged in: %s\\n\", (!isLoggedIn) ? \"true\" : \"false\");",
        "Regular user: true\nHas access: true\nNot logged in: false"
      ]
    },
    {
      "title": "C Operator Precedence",
      "summary": "Operator Precedence\nWhen a calculation contains more than one operator, C follows order of operations rules to decide which part to calculate first.\nFor example, multiplication happens before addition:\nExample\nTry it Yourself »\nWhy Does This Happen?\nIn 2 + 3 * 4, the multiplication is done first, so the answer is 14.\nIf you want the addition to happen first, you must use parentheses: (2 + 3) * 4, which gives 20.\nTip: Always use parentheses ( ) if you want to make sure the calculation is done in the order you expect. It also makes your code easier to read.\nOrder of Operations\nHere are some common operators in C, from highest to lowest priority:\n() - Parentheses\n*, /, % - Multiplication, Division, Modulus\n+, - - Addition, Subtraction\n>, <, >=, <= - Comparison\n==, != - Equality\n&& - Logical AND\n|| - Logical OR\n= - Assignment\nAnother Example\nSubtraction and addition are done from left to right, unless you add parentheses:\nExample\nTry it Yourself »\nRemember: Parentheses always come first. Use them to control the order of your calculations.",
      "examples": [
        "int result1 = 2 + 3 * 4; // 2 + 12 = 14 int result2 = (2 + 3) * 4; // 5 * 4 = 20 printf(\"%d\\n\", result1); printf(\"%d\\n\", result2);",
        "int result1 = 10 - 2 + 5; // (10 - 2) + 5 = 13 int result2 = 10 - (2 + 5); // 10 - 7 = 3 printf(\"%d\\n\", result1); printf(\"%d\\n\", result2);",
        "2 + 3 * 4",
        "14",
        "(2 + 3) * 4",
        "20",
        "( )",
        "()",
        "*",
        "/",
        "%",
        "+",
        "-",
        ">",
        "<",
        ">=",
        "<=",
        "==",
        "!=",
        "&&",
        "||",
        "="
      ]
    },
    {
      "title": "C Booleans",
      "summary": "Booleans\nVery often, in programming, you will need a data type that can only have one of two values, like:\nYES / NO\nON / OFF\nTRUE / FALSE\nFor this, C has a bool data type, which is known as booleans.\nBooleans represent one of two values: true or false.\nBoolean Variables\nIn C, the bool type is not a built-in data type, like int or char.\nIt was introduced in C99, and you must import the following header file to use it:\nA boolean variable is declared with the bool keyword and can take the values true or false:\nBefore trying to print the boolean variables, you should know that boolean values are returned as integers:\n1 (or any other number that is not 0) represents true\n0 represents false\nTherefore, you must use the %d format specifier to print a boolean value:\nExample\nHowever, it is more common to return a boolean value by comparing values and variables.\nComparing Values and Variables\nComparing values are useful in programming, because it helps us to find answers and make decisions.\nFor example, you can use a comparison operator, such as the greater than (>) operator, to compare two values:\nExample\nFrom the example above, you can see that the return value is a boolean value (1).\nYou can also compare two variables:\nExample\nIn the example below, we use the equal to (==) operator to compare different values:\nExample\nYou are not limited to only compare numbers. You can also compare boolean variables, or even special structures, like arrays (which you will learn more about in a later chapter):\nExample\nRemember to include the <stdbool.h> header file when working with bool variables.",
      "examples": [
        "#include <stdbool.h>",
        "bool isProgrammingFun = true;\nbool isFishTasty = false;",
        "// Create boolean variables\nbool isProgrammingFun = true;\nbool isFishTasty = false;\n\n// Return boolean values\nprintf(\"%d\", isProgrammingFun);   // Returns 1 (true)\nprintf(\"%d\", isFishTasty);        // Returns 0 (false)",
        "printf(\"%d\", 10 > 9);  // Returns 1 (true) because 10 is greater than 9",
        "int x = 10;\nint y = 9;\nprintf(\"%d\", x > y);",
        "printf(\"%d\", 10 == 10); // Returns 1 (true), because 10 is equal to 10\nprintf(\"%d\", 10 == 15); // Returns 0 (false), because 10 is not equal to 15\nprintf(\"%d\", 5 == 55);  // Returns 0 (false) because 5 is not equal to 55",
        "bool isHamburgerTasty = true;\nbool isPizzaTasty = true;\n\n// Find out if both hamburger and pizza is tasty\nprintf(\"%d\", isHamburgerTasty == isPizzaTasty);",
        "bool",
        "true",
        "false",
        "int",
        "char",
        "1",
        "0",
        "%d",
        ">",
        "==",
        "<stdbool.h>"
      ]
    },
    {
      "title": "C Boolean Examples",
      "summary": "Real Life Example\nLet's think of a \"real life example\" where we need to find out if a person is old enough to vote.\nIn the example below, we use the >= comparison operator to find out if the age (25) is greater than OR equal to the voting age limit, which is set to 18:\nExample\nCool, right? An even better approach (since we are on a roll now), would be to wrap the code above in an if...else statement, so we can perform different actions depending on the result:\nExample\nOutput \"Old enough to vote!\" if myAge is greater than or equal to 18. Otherwise output \"Not old enough to vote.\":\nBooleans are the basis for all comparisons and conditions.\nYou will learn more about conditions (if...else) in the next chapter.",
      "examples": [
        "int myAge = 25;\nint votingAge = 18;\n\nprintf(\"%d\", myAge >= votingAge); // Returns 1 (true), meaning 25 year olds are allowed to vote!",
        "int myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\nprintf(\"Old enough to vote!\");\n} else {\nprintf(\"Not old enough to vote.\");\n}",
        ">=",
        "25",
        "18",
        "if...else",
        "myAge"
      ]
    },
    {
      "title": "C If ... Else",
      "summary": "Conditions and If Statements\nYou already know that C supports familiar comparison conditions from mathematics, such as:\nLess than: a < b\nLess than or equal to: a <= b\nGreater than: a > b\nGreater than or equal to: a >= b\nEqual to a == b\nNot Equal to: a != b\nYou can use these conditions to perform different actions for different decisions.\nC has the following conditional statements:\nUse if to specify a block of code to be executed, if a specified condition is true\nUse else to specify a block of code to be executed, if the same condition is false\nUse else if to specify a new condition to test, if the first condition is false\nUse switch to specify many alternative blocks of code to be executed\nThe if Statement\nUse the if statement to specify a block of code to be executed if a condition is true.\nSyntax\nNote that if is in lowercase letters. Uppercase letters (If or IF) will generate an error.\nIn the example below, we test two values to find out if 20 is greater than 18. If the condition is true, print some text:\nExample\nWe can also test variables:\nExample\nIn the example above we use two variables, x and y, to test whether x is greater than y (using the > operator). As x is 20, and y is 18, and we know that 20 is greater than 18, we print to the screen that \"x is greater than y\".",
      "examples": [
        "if (condition) {\n// block of code to be executed if the condition is true\n}",
        "if (20 > 18) {\nprintf(\"20 is greater than 18\");\n}",
        "int x = 20;\nint y = 18;\nif (x > y) {\nprintf(\"x is greater than y\");\n}",
        "if",
        "true",
        "else",
        "false",
        "else if",
        "switch",
        ">"
      ]
    },
    {
      "title": "C Else",
      "summary": "The else Statement\nUse the else statement to specify a block of code to be executed if the condition is false.\nSyntax\nExample\nIn the example above, time (20) is greater than 18, so the condition is false. Because of this, we move on to the else condition and print to the screen \"Good evening\". If the time was less than 18, the program would print \"Good day\".",
      "examples": [
        "if (condition) {\n// block of code to be executed if the condition is true\n} else {\n// block of code to be executed if the condition is false\n}",
        "int time = 20;\nif (time < 18) {\nprintf(\"Good day.\");\n} else {\nprintf(\"Good evening.\");\n}\n// Outputs \"Good evening.\"",
        "else",
        "false"
      ]
    },
    {
      "title": "C Else If",
      "summary": "The else if Statement\nUse the else if statement to specify a new condition if the first condition is false.\nSyntax\nExample\nIn the example above, time (22) is greater than 10, so the first condition is false. The next condition, in the else if statement, is also false, so we move on to the else condition since condition1 and condition2 is both false - and print to the screen \"Good evening\".\nHowever, if the time was 14, our program would print \"Good day.\"",
      "examples": [
        "if (condition1) {\n// block of code to be executed if condition1 is true\n} else if (condition2) {\n// block of code to be executed if the condition1 is false and condition2 is true\n} else {\n// block of code to be executed if the condition1 is false and condition2 is false\n}",
        "int time = 22;\nif (time < 10) {\nprintf(\"Good morning.\");\n} else if (time < 20) {\nprintf(\"Good day.\");\n} else {\nprintf(\"Good evening.\");\n}\n// Outputs \"Good evening.\"",
        "else if",
        "false",
        "else"
      ]
    },
    {
      "title": "C Short Hand If Else",
      "summary": "Short Hand If...Else (Ternary Operator)\nThere is also a short-hand if else, which is known as the ternary operator because it consists of three operands. It can be used to replace multiple lines of code with a single line. It is often used to replace simple if else statements:\nSyntax\nInstead of writing:\nExample\nYou can simply write:\nExample\nIt is completely up to you if you want to use the traditional if...else statement or the ternary operator.",
      "examples": [
        "variable = (condition) ? expressionTrue : expressionFalse;",
        "int time = 20;\nif (time < 18) {\nprintf(\"Good day.\");\n} else {\nprintf(\"Good evening.\");\n}",
        "int time = 20;\n(time < 18) ? printf(\"Good day.\") : printf(\"Good evening.\");"
      ]
    },
    {
      "title": "C If ... Else Examples",
      "summary": "Real-Life Examples\nThis example shows how you can use if..else to \"open a door\" if the user enters the correct code:\nExample\nThis example shows how you can use if..else to find out if a number is positive or negative:\nExample\nFind out if a person is old enough to vote:\nExample\nFind out if a number is even or odd:\nExample",
      "examples": [
        "int doorCode = 1337;\n\nif (doorCode == 1337) {\nprintf(\"Correct code.\\nThe door is now open.\");\n} else {\nprintf(\"Wrong code.\\nThe door remains closed.\");\n}",
        "int myNum = 10; // Is this a positive or negative number?\n\nif (myNum > 0) {\nprintf(\"The value is a positive number.\");\n} else if (myNum < 0) {\nprintf(\"The value is a negative number.\");\n} else {\nprintf(\"The value is 0.\");\n}",
        "int myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\nprintf(\"Old enough to vote!\");\n} else {\nprintf(\"Not old enough to vote.\");\n}",
        "int myNum = 5;\n\nif (myNum % 2 == 0) {\nprintf(\"%d is even.\\n\", myNum);\n} else {\nprintf(\"%d is odd.\\n\", myNum);\n}",
        "if..else"
      ]
    },
    {
      "title": "C Switch",
      "summary": "Switch Statement\nInstead of writing many if..else statements, you can use the switch statement.\nThe switch statement selects one of many code blocks to be executed:\nSyntax\nThis is how it works:\nThe switch expression is evaluated once\nThe value of the expression is compared with the values of each case\nIf there is a match, the associated block of code is executed\nThe break statement breaks out of the switch block and stops the execution\nThe default statement is optional, and specifies some code to run if there is no case match\nThe example below uses the weekday number to calculate the weekday name:\nExample\nThe break Keyword\nWhen C reaches a break keyword, it breaks out of the switch block.\nThis will stop the execution of more code and case testing inside the block.\nWhen a match is found, and the job is done, it's time for a break. There is no need for more testing.\nA break can save a lot of execution time because it \"ignores\" the execution of all the rest of the code in the switch block.\nThe default Keyword\nThe default keyword specifies some code to run if there is no case match:\nExample\nNote: The default keyword must be used as the last statement in the switch, and it does not need a break.",
      "examples": [
        "switch (expression) {\ncase x:\n// code block\nbreak;\ncase y:\n// code block\nbreak;\ndefault:\n// code block\n}",
        "int day = 4;\n\nswitch (day) {\ncase 1:\nprintf(\"Monday\");\nbreak;\ncase 2:\nprintf(\"Tuesday\");\nbreak;\ncase 3:\nprintf(\"Wednesday\");\nbreak;\ncase 4:\nprintf(\"Thursday\");\nbreak;\ncase 5:\nprintf(\"Friday\");\nbreak;\ncase 6:\nprintf(\"Saturday\");\nbreak;\ncase 7:\nprintf(\"Sunday\");\nbreak;\n}\n\n// Outputs \"Thursday\" (day 4)",
        "int day = 4;\n\nswitch (day) {\ncase 6:\nprintf(\"Today is Saturday\");\nbreak;\ncase 7:\nprintf(\"Today is Sunday\");\nbreak;\ndefault:\nprintf(\"Looking forward to the Weekend\");\n}\n\n// Outputs \"Looking forward to the Weekend\"",
        "if..else",
        "switch",
        "case",
        "break",
        "default"
      ]
    },
    {
      "title": "C While Loop",
      "summary": "Loops\nLoops can execute a block of code as long as a specified condition is reached.\nLoops are handy because they save time, reduce errors, and they make code more readable.\nWhile Loop\nThe while loop loops through a block of code as long as a specified condition is true:\nSyntax\nIn the example below, the code in the loop will run, over and over again, as long as a variable (i) is less than 5:\nExample\nNote: Do not forget to increase the variable used in the condition (i++), otherwise the loop will never end!\nDo you wonder why we use the letter i as a variable name? It's a counter variable and a common choice in simple loops because it's short, traditional, and stands for 'index' or 'iterator'.\nCountdown Example\nThis example counts down from 3 to 1 and then displays \"Happy New Year!!\" at the end:\nExample",
      "examples": [
        "while (condition) {\n// code block to be executed\n}",
        "int i = 0;\n\nwhile (i < 5) {\nprintf(\"%d\\n\", i);\ni++;\n}",
        "int countdown = 3;\n\nwhile (countdown > 0) {\nprintf(\"%d\\n\", countdown);\ncountdown--;\n}\nprintf(\"Happy New Year!!\\n\");",
        "while",
        "true",
        "i",
        "i++"
      ]
    },
    {
      "title": "C Do/While Loop",
      "summary": "The Do/While Loop\nThe do/while loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is true, then it will repeat the loop as long as the condition is true.\nSyntax\nThe example below uses a do/while loop. The loop will always be executed at least once, even if the condition is false, because the code block is executed before the condition is tested:\nExample\nDo not forget to increase the variable used in the condition, otherwise the loop will never end!\nCondition is False from the Start\nIn the example above, the condition i < 5 was true at the beginning, so the loop executed multiple times. But what if the condition is false right from the start?\nIn the example below, the variable i starts at 10, so the condition i < 5 is false immediately - yet the do/while loop still runs once:\nExample\nEven if the condition is false from the start, the code block will still execute one time:\nSummary\nThe do/while loop always runs at least once, even if the condition is already false. This is different from a regular while loop, which would skip the loop entirely if the condition is false at the start.\nThis behavior makes do/while useful when you want to ensure something happens at least once, like showing a message or asking for user input.\nPractical Example: User Input\nThis example keeps asking the user to enter a positive number. The loop stops when the user enters 0 or a negative number:\nExample\nNote: You will learn more about the scanf() function and user input in a later chapter.",
      "examples": [
        "do {\n// code block to be executed\n}\nwhile (condition);",
        "int i = 0;\n\ndo {\nprintf(\"%d\\n\", i);\ni++;\n}\nwhile (i < 5);",
        "int i = 10;\n\ndo {\nprintf(\"i is %d\\n\", i);\ni++;\n} while (i < 5);",
        "int number;\n\ndo {\nprintf(\"Enter a positive number: \");\nscanf(\"%d\", &number);\n} while (number > 0);",
        "do/while",
        "while",
        "i < 5",
        "i",
        "10",
        "scanf()"
      ]
    },
    {
      "title": "C While Loop Examples",
      "summary": "Real-Life Examples\nTo demonstrate a practical example of the while loop, we have created a simple \"countdown\" program:\nExample\nIn this example, we create a program that only print even numbers between 0 and 10 (inclusive):\nExample\nIn this example we use a while loop to reverse some numbers:\nExample\nTo demonstrate a practical example of the while loop combined with an if else statement, let's say we play a game of Yatzy:\nExample\nPrint \"Yatzy!\" If the dice number is 6:\nIf the loop passes the values ranging from 1 to 5, it prints \"No Yatzy\". Whenever it passes the value 6, it prints \"Yatzy!\".",
      "examples": [
        "int countdown = 3;\n\nwhile (countdown > 0) {\nprintf(\"%d\\n\", countdown);\ncountdown--;\n}\n\nprintf(\"Happy New Year!!\\n\");",
        "int i = 0;\n\nwhile (i <= 10) {\nprintf(\"%d\\n\", i);\ni += 2;\n}",
        "// A variable with some specific numbers\nint numbers = 12345;\n\n// A variable to store the reversed number\nint revNumbers = 0;\n\n// Reverse and reorder the numbers\nwhile (numbers) {\n// Get the last number of 'numbers' and add it to 'revNumber'\nrevNumbers = revNumbers * 10 + numbers % 10;\n// Remove the last number of 'numbers'\nnumbers /= 10;\n}",
        "int dice = 1;\n\nwhile (dice <= 6) {\nif (dice < 6) {\nprintf(\"No Yatzy\\n\");\n} else {\nprintf(\"Yatzy!\\n\");\n}\ndice = dice + 1;\n}"
      ]
    },
    {
      "title": "C For Loop",
      "summary": "For Loop\nWhen you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop:\nSyntax\nExpression 1 is executed (one time) before the execution of the code block.\nExpression 2 defines the condition for executing the code block.\nExpression 3 is executed (every time) after the code block has been executed.\nPrint Numbers\nThe example below will print the numbers 0 to 4:\nExample\nExample explained\nStatement 1 sets a variable before the loop starts: int i = 0\nStatement 2 defines the condition for the loop to run: i < 5. If the condition is true, the loop will start over again, if it is false, the loop will end.\nStatement 3 increases a value each time the code block in the loop has been executed: i++\nPrint Even Numbers\nThis example prints even values between 0 and 10:\nExample\nSum of Numbers\nThis example calculates the sum of numbers from 1 to 5:\nExample\nCountdown\nThis example prints a countdown from 5 to 1:\nExample",
      "examples": [
        "for (expression 1; expression 2; expression 3) {\n// code block to be executed\n}",
        "int i;\n\nfor (i = 0; i < 5; i++) {\nprintf(\"%d\\n\", i);\n}",
        "int i;\n\nfor (i = 0; i <= 10; i = i + 2) {\nprintf(\"%d\\n\", i);\n}",
        "int sum = 0;\nint i;\n\nfor (i = 1; i <= 5; i++) {\nsum = sum + i;\n}\n\nprintf(\"Sum is %d\", sum);",
        "int i;\n\nfor (i = 5; i > 0; i--) {\nprintf(\"%d\\n\", i);\n}",
        "for",
        "while",
        "int i = 0",
        "i < 5",
        "i++"
      ]
    },
    {
      "title": "C Nested Loops",
      "summary": "Nested Loops\nIt is also possible to place a loop inside another loop. This is called a nested loop.\nThe \"inner loop\" will be executed one time for each iteration of the \"outer loop\":\nExample\nMultiplication Table Example\nThis example uses nested loops to print a simple multiplication table (1 to 3):\nExample\nResult\nNested loops are useful when working with tables, matrices, or multi-dimensional data structures.",
      "examples": [
        "int i, j;\n\n// Outer loop\nfor (i = 1; i <= 2; ++i) {\nprintf(\"Outer: %d\\n\", i);  // Executes 2 times\n\n// Inner loop\nfor (j = 1; j <= 3; ++j) {\nprintf(\" Inner: %d\\n\", j);  // Executes 6 times (2 * 3)\n}\n}",
        "int i, j;\n\nfor (i = 1; i <= 3; i++) {\nfor (j = 1; j <= 3; j++) {\nprintf(\"%d \", i * j);\n}\nprintf(\"\\n\");\n}",
        "1 2 3\n2 4 6\n3 6 9"
      ]
    },
    {
      "title": "C For Loop Examples",
      "summary": "Real-Life Examples\nTo demonstrate a practical example of the for loop, let's create a program that counts to 100 by tens:\nExample\nIn this example, we create a program that only print even numbers between 0 and 10 (inclusive):\nExample\nHere we only print odd numbers:\nExample\nIn this example we print the powers of 2 up to 512:\nExample\nAnd in this example, we create a program that prints the multiplication table for a specified number:\nExample",
      "examples": [
        "for (i = 0; i <= 100; i += 10) {\nprintf(\"%d\\n\", i);\n}",
        "for (i = 0; i <= 10; i = i + 2) {\nprintf(\"%d\\n\", i);\n}",
        "for (i = 1; i < 10; i = i + 2) {\nprintf(\"%d\\n\", i);\n}",
        "for (i = 2; i <= 512; i *= 2) {\nprintf(\"%d\\n\", i);\n}",
        "int number = 2;\nint i;\n\n// Print the multiplication table for the number 2\nfor (i = 1; i <= 10; i++) {\nprintf(\"%d x %d = %d\\n\", number, i, number * i);\n}\n\nreturn 0;"
      ]
    },
    {
      "title": "C Break and Continue",
      "summary": "Break\nYou have already seen the break statement used in an earlier chapter of this tutorial. It was used to \"jump out\" of a switch statement.\nThe break statement can also be used to jump out of a loop.\nThis example jumps out of the for loop when i is equal to 4:\nExample\nContinue\nThe continue statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.\nThis example skips the value of 4:\nExample\nBreak and Continue in While Loop\nYou can also use break and continue in while loops:\nBreak Example\nContinue Example",
      "examples": [
        "int i;\n\nfor (i = 0; i < 10; i++) {\nif (i == 4) {\nbreak;\n}\nprintf(\"%d\\n\", i);\n}",
        "int i;\n\nfor (i = 0; i < 10; i++) {\nif (i == 4) {\ncontinue;\n}\nprintf(\"%d\\n\", i);\n}",
        "int i = 0;\n\nwhile (i < 10) {\nif (i == 4) {\nbreak;\n}\nprintf(\"%d\\n\", i);\ni++;\n}",
        "int i = 0;\n\nwhile (i < 10) {\nif (i == 4) {\ni++;\ncontinue;\n}\nprintf(\"%d\\n\", i);\ni++;\n}",
        "break",
        "switch",
        "i",
        "continue"
      ]
    },
    {
      "title": "C Arrays",
      "summary": "Arrays\nArrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.\nTo create an array, define the data type (like int) and specify the name of the array followed by square brackets [].\nTo insert values to it, use a comma-separated list inside curly braces, and make sure all values are of the same data type:\nWe have now created a variable that holds an array of four integers.\nAccess the Elements of an Array\nTo access an array element, refer to its index number.\nArray indexes start with 0: [0] is the first element. [1] is the second element, etc.\nThis statement accesses the value of the first element [0] in myNumbers:\nExample\nChange an Array Element\nTo change the value of a specific element, refer to the index number:\nExample\nExample\nREMOVE ADS\nLoop Through an Array\nYou can loop through the array elements with the for loop.\nThe following example outputs all elements in the myNumbers array:\nExample\nSet Array Size\nAnother common way to create arrays, is to specify the size of the array, and add elements later:\nExample\nUsing this method, you should know the number of array elements in advance, in order for the program to store enough memory.\nYou are not able to change the size of the array after creation.\nAvoid Mixing Data Types\nIt is important to note that all elements in an array must be of the same data type.\nThis means you cannot mix different types of values, like integers and floating point numbers, in the same array:\nExample\nIn the example above, the values 3.15 and 5.99 will be truncated to 3 and 5. In some cases it might also result in an error, so it is important to always make sure that the elements in the array are of the same type.",
      "examples": [
        "int myNumbers[] = {25, 50, 75, 100};",
        "int myNumbers[] = {25, 50, 75, 100};\nprintf(\"%d\", myNumbers[0]);\n\n// Outputs 25",
        "myNumbers[0] = 33;",
        "int myNumbers[] = {25, 50, 75, 100};\nmyNumbers[0] = 33;\n\nprintf(\"%d\", myNumbers[0]);\n\n// Now outputs 33 instead of 25",
        "int myNumbers[] = {25, 50, 75, 100};\nint i;\n\nfor (i = 0; i < 4; i++) {\nprintf(\"%d\\n\", myNumbers[i]);\n}",
        "// Declare an array of four integers:\nint myNumbers[4];\n\n// Add elements\nmyNumbers[0] = 25;\nmyNumbers[1] = 50;\nmyNumbers[2] = 75;\nmyNumbers[3] = 100;",
        "int myArray[] = {25, 50, 75, 3.15, 5.99};",
        "int",
        "myNumbers",
        "for",
        "3.15",
        "5.99",
        "3",
        "5"
      ]
    },
    {
      "title": "C Array Size",
      "summary": "Get Array Size or Length\nTo get the size of an array, you can use the sizeof operator:\nExample\nWhy did the result show 20 instead of 5, when the array contains 5 elements?\n- It is because the sizeof operator returns the size of a type in bytes.\nYou learned from the Data Types chapter that an int type is usually 4 bytes, so from the example above, 4 x 5 (4 bytes x 5 elements) = 20 bytes.\nKnowing the memory size of an array is great when you are working with larger programs that require good memory management.\nBut when you just want to find out how many elements an array has, you can use the following formula (which divides the size of the array by the size of the first element in the array):\nExample\nMaking Better Loops\nIn the array loops section in the previous chapter, we wrote the size of the array in the loop condition (i < 4). This is not ideal, since it will only work for arrays of a specified size.\nHowever, by using the sizeof formula from the example above, we can now make loops that work for arrays of any size, which is more sustainable.\nInstead of writing:\nExample\nIt is better to write:\nExample",
      "examples": [
        "int myNumbers[] = {10, 25, 50, 75, 100};\nprintf(\"%zu\", sizeof(myNumbers)); // Prints 20",
        "int myNumbers[] = {10, 25, 50, 75, 100};\nint length = sizeof(myNumbers) / sizeof(myNumbers[0]);\n\nprintf(\"%d\", length);  // Prints 5",
        "int myNumbers[] = {25, 50, 75, 100};\nint i;\n\nfor (i = 0; i < 4; i++) {\nprintf(\"%d\\n\", myNumbers[i]);\n}",
        "int myNumbers[] = {25, 50, 75, 100};\nint length = sizeof(myNumbers) / sizeof(myNumbers[0]);\nint i;\n\nfor (i = 0; i < length; i++) {\nprintf(\"%d\\n\", myNumbers[i]);\n}",
        "sizeof",
        "20",
        "5",
        "int",
        "i < 4"
      ]
    },
    {
      "title": "C Arrays - Real-Life Examples",
      "summary": "Real-Life Example\nTo demonstrate a practical example of using arrays, let's create a program that calculates the average of different ages:\nExample\nAnd in this example, we create a program that finds the lowest age among different ages:\nExample",
      "examples": [
        "// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\nint i;\n\n// Get the length of the array\nint length = sizeof(ages) / sizeof(ages[0]);\n\n// Loop through the elements of the array\nfor (i = 0; i < length; i++) {\nsum += ages[i];\n}\n\n// Calculate the average by dividing the sum by the length\navg = sum / length;\n\n// Print the average\nprintf(\"The average age is: %.2f\", avg);",
        "// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nint i;\n\n// Get the length of the array\nint length = sizeof(ages) / sizeof(ages[0]);\n\n// Create a variable and assign the first array element of ages to it\nint lowestAge = ages[0];\n\n// Loop through the elements of the ages array to find the lowest age\nfor (i = 0; i < length; i++) {\nif (lowestAge > ages[i]) {\nlowestAge = ages[i];\n}\n}"
      ]
    },
    {
      "title": "C Multidimensional Arrays",
      "summary": "Multidimensional Arrays\nIn the previous chapter, you learned about arrays, which is also known as single dimension arrays. These are great, and something you will use a lot while programming in C. However, if you want to store data as a tabular form, like a table with rows and columns, you need to get familiar with multidimensional arrays.\nA multidimensional array is basically an array of arrays.\nArrays can have any number of dimensions. In this chapter, we will introduce the most common; two-dimensional arrays (2D).\nTwo-Dimensional Arrays\nA 2D array is also known as a matrix (a table of rows and columns).\nTo create a 2D array of integers, take a look at the following example:\nThe first dimension represents the number of rows [2], while the second dimension represents the number of columns [3]. The values are placed in row-order, and can be visualized like this:\nAccess the Elements of a 2D Array\nTo access an element of a two-dimensional array, you must specify the index number of both the row and column.\nThis statement accesses the value of the element in the first row (0) and third column (2) of the matrix array.\nExample\nRemember that: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.\nREMOVE ADS\nChange Elements in a 2D Array\nTo change the value of an element, refer to the index number of the element in each of the dimensions:\nThe following example will change the value of the element in the first row (0) and first column (0):\nExample\nLoop Through a 2D Array\nTo loop through a multi-dimensional array, you need one loop for each of the array's dimensions.\nThe following example outputs all elements in the matrix array:\nExample\nThree-Dimensional Arrays\nYou can also declare arrays with more than two dimensions:\nExample\nTry it Yourself »\nThis creates a 3D array with:\n2 blocks (first index)\n4 rows per block (second index)\n3 columns per row (third index)\nWhen to Use Multidimensional Arrays\nMultidimensional arrays are useful when your data is arranged in rows and columns, like a table, grid, or matrix.\nEach extra dimension adds another level of structure:\n2D arrays (like int scores[3][4]) are great for storing things like scores, game boards, or spreadsheets\n3D arrays (like int cube[2][3][4]) can represent more complex structures like a set of tables or levels in a game",
      "examples": [
        "// A 3D array with 2 blocks, each with 4 rows and 3 columns int example[2][4][3];",
        "int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };",
        "int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };\n\nprintf(\"%d\", matrix[0][2]);  // Outputs 2",
        "int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };\nmatrix[0][0] = 9;\n\nprintf(\"%d\", matrix[0][0]);  // Now outputs 9 instead of 1",
        "int matrix[2][3] = { {1, 4, 2}, {3, 6, 8} };\n\nint i, j;\nfor (i = 0; i < 2; i++) {\nfor (j = 0; j < 3; j++) {\nprintf(\"%d\\n\", matrix[i][j]);\n}\n}",
        "2",
        "4",
        "3",
        "int scores[3][4]",
        "int cube[2][3][4]"
      ]
    },
    {
      "title": "C Strings",
      "summary": "Strings\nStrings are used for storing text/characters.\nFor example, \"Hello World\" is a string of characters.\nUnlike many other programming languages, C does not have a String type to easily create string variables. Instead, you must use the char type and create an array of characters to make a string in C:\nNote that you have to use double quotes (\"\").\nTo output the string, you can use the printf() function together with the format specifier %s to tell C that we are now working with strings:\nExample\nAccess Strings\nSince strings are actually arrays in C, you can access a string by referring to its index number inside square brackets [].\nThis example prints the first character (0) in greetings:\nExample\nNote that we have to use the %c format specifier to print a single character.\nModify Strings\nTo change the value of a specific character in a string, refer to the index number, and use single quotes:\nExample\nREMOVE ADS\nLoop Through a String\nYou can also loop through the characters of a string, using a for loop:\nExample\nAnd like we specified in the arrays chapter, you can also use the sizeof formula (instead of manually write the size of the array in the loop condition (i < 5)) to make the loop more sustainable:\nExample\nAnother Way Of Creating Strings\nIn the examples above, we used a \"string literal\" to create a string variable. This is the easiest way to create a string in C.\nYou should also note that you can create a string with a set of characters. This example will produce the same result as the example in the beginning of this page:\nExample\nWhy do we include the \\0 character at the end? This is known as the \"null terminating character\", and must be included when creating strings using this method. It tells C that this is the end of the string.\nDifferences\nThe difference between the two ways of creating strings, is that the first method is easier to write, and you do not have to include the \\0 character, as C will do it for you.\nYou should note that the size of both arrays is the same: They both have 13 characters (space also counts as a character by the way), including the \\0 character:\nExample\nReal-Life Example\nUse strings to create a simple welcome message:\nExample",
      "examples": [
        "char greetings[] = \"Hello World!\";",
        "char greetings[] = \"Hello World!\";\nprintf(\"%s\", greetings);",
        "char greetings[] = \"Hello World!\";\nprintf(\"%c\", greetings[0]);",
        "char greetings[] = \"Hello World!\";\ngreetings[0] = 'J';\nprintf(\"%s\", greetings);\n// Outputs Jello World! instead of Hello World!",
        "char carName[] = \"Volvo\";\nint i;\n\nfor (i = 0; i < 5; ++i) {\nprintf(\"%c\\n\", carName[i]);\n}",
        "char carName[] = \"Volvo\";\nint length = sizeof(carName) / sizeof(carName[0]);\nint i;\n\nfor (i = 0; i < length; ++i) {\nprintf(\"%c\\n\", carName[i]);\n}",
        "char greetings[] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!', '\\0'};\nprintf(\"%s\", greetings);",
        "char greetings[] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!', '\\0'};\nchar greetings2[] = \"Hello World!\";\n\nprintf(\"%zu\\n\", sizeof(greetings));   // Outputs 13\nprintf(\"%zu\\n\", sizeof(greetings2));  // Outputs 13",
        "char message[] = \"Good to see you,\";\nchar fname[] = \"John\";\n\nprintf(\"%s %s!\", message, fname);",
        "char",
        "\"\"",
        "printf()",
        "%s",
        "[]",
        "%c",
        "for",
        "(i < 5)",
        "\\0"
      ]
    },
    {
      "title": "C Special Characters",
      "summary": "Strings - Special Characters\nBecause strings must be written within quotes, C will misunderstand this string, and generate an error:\nThe solution to avoid this problem, is to use the backslash escape character.\nThe backslash (\\) escape character turns special characters into string characters:\nThe sequence \\\"  inserts a double quote in a string:\nExample\nThe sequence \\'  inserts a single quote in a string:\nExample\nThe sequence \\\\  inserts a single backslash in a string:\nExample\nOther popular escape characters in C are:",
      "examples": [
        "char txt[] = \"We are the so-called \"Vikings\" from the north.\";",
        "char txt[] = \"We are the so-called \\\"Vikings\\\" from the north.\";",
        "char txt[] = \"It\\'s alright.\";",
        "char txt[] = \"The character \\\\ is called backslash.\";",
        "\\",
        "\\\"",
        "\\'",
        "\\\\"
      ]
    },
    {
      "title": "C String Functions",
      "summary": "String Functions\nC also has many useful string functions, which can be used to perform certain operations on strings.\nTo use them, you must include the <string.h> header file in your program:\nString Length\nFor example, to get the length of a string, you can use the strlen() function:\nExample\nIn the Strings chapter, we used sizeof to get the size of a string/array. Note that sizeof and strlen behaves differently, as sizeof also includes the \\0 character when counting:\nExample\nIt is also important that you know that sizeof will always return the memory size (in bytes), and not the actual string length:\nExample\nConcatenate Strings\nTo concatenate (combine) two strings, you can use the strcat() function:\nExample\nNote that the size of str1 should be large enough to store the result of the two strings combined (20 in our example).\nREMOVE ADS\nCopy Strings\nTo copy the value of one string to another, you can use the strcpy() function:\nExample\nNote that the size of str2 should be large enough to store the copied string (20 in our example).\nCompare Strings\nTo compare two strings, you can use the strcmp() function.\nIt returns 0 if the two strings are equal, otherwise a value that is not 0:\nExample\nComplete String Reference\nFor a complete reference of string functions, go to our C <string.h> Library Reference.",
      "examples": [
        "#include <string.h>",
        "char alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nprintf(\"%zu\", strlen(alphabet));",
        "char alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nprintf(\"%zu\\n\", strlen(alphabet));   // 26\nprintf(\"%zu\\n\", sizeof(alphabet));   // 27",
        "char alphabet[50] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nprintf(\"%zu\\n\", strlen(alphabet));   // 26\nprintf(\"%zu\\n\", sizeof(alphabet));   // 50",
        "char str1[20] = \"Hello \";\nchar str2[] = \"World!\";\n\n// Concatenate str2 to str1 (result is stored in str1)\nstrcat(str1, str2);\n\n// Print str1\nprintf(\"%s\", str1);",
        "char str1[20] = \"Hello World!\";\nchar str2[20];\n\n// Copy str1 to str2\nstrcpy(str2, str1);\n\n// Print str2\nprintf(\"%s\", str2);",
        "char str1[] = \"Hello\";\nchar str2[] = \"Hello\";\nchar str3[] = \"Hi\";\n\n// Compare str1 and str2, and print the result\nprintf(\"%d\\n\", strcmp(str1, str2));  // Returns 0 (the strings are equal)\n\n// Compare str1 and str3, and print the result\nprintf(\"%d\\n\", strcmp(str1, str3));  // Returns -4 (the strings are not equal)",
        "<string.h>",
        "strlen()",
        "sizeof",
        "strlen",
        "\\0",
        "strcat()",
        "str1",
        "strcpy()",
        "str2",
        "strcmp()",
        "0"
      ]
    },
    {
      "title": "C User Input",
      "summary": "User Input\nYou have already learned that printf() is used to output values in C.\nTo get user input, you can use the scanf() function:\nExample\nOutput a number entered by the user:\nThe scanf() function takes two arguments: the format specifier of the variable (%d in the example above) and the reference operator (&myNum), which stores the memory address of the variable.\nTip: You will learn more about memory addresses and functions in the next chapter.\nMultiple Inputs\nThe scanf() function also allow multiple inputs (an integer and a character in the following example):\nExample\nTake String Input\nYou can also get a string entered by the user:\nExample\nOutput the name of a user:\nNote: When working with strings in scanf(), you must specify the size of the string/array (we used a very high number, 30 in our example, but at least then we are certain it will store enough characters for the first name), and you don't have to use the reference operator (&).\nHowever, the scanf() function has some limitations: it considers space (whitespace, tabs, etc) as a terminating character, which means that it can only display a single word (even if you type many words). For example:\nExample\nFrom the example above, you would expect the program to print \"John Doe\", but it only prints \"John\".\nThat's why, when working with strings, we often use the fgets() function to read a line of text. Note that you must include the following arguments: the name of the string variable, sizeof(string_name), and stdin:\nExample\nUse the scanf() function to get a single word as input, and use fgets() for multiple words.",
      "examples": [
        "// Create an integer variable that will store the number we get from the user\nint myNum;\n\n// Ask the user to type a number\nprintf(\"Type a number: \\n\");\n\n// Get and save the number the user types\nscanf(\"%d\", &myNum);\n\n// Output the number the user typed\nprintf(\"Your number is: %d\", myNum);",
        "// Create an int and a char variable\nint myNum;\nchar myChar;\n\n// Ask the user to type a number AND a character\nprintf(\"Type a number AND a character and press enter: \\n\");\n\n// Get and save the number AND character the user types\nscanf(\"%d %c\", &myNum, &myChar);\n\n// Print the number\nprintf(\"Your number is: %d\\n\", myNum);\n\n// Print the character\nprintf(\"Your character is: %c\\n\", myChar);",
        "// Create a string\nchar firstName[30];\n\n// Ask the user to input some text\nprintf(\"Enter your first name: \\n\");\n\n// Get and save the text\nscanf(\"%s\", firstName);\n\n// Output the text\nprintf(\"Hello %s\", firstName);",
        "char fullName[30];\n\nprintf(\"Type your full name: \\n\");\nscanf(\"%s\", &fullName);\n\nprintf(\"Hello %s\", fullName);\n\n// Type your full name: John Doe\n// Hello John",
        "char fullName[30];\n\nprintf(\"Type your full name: \\n\");\nfgets(fullName, sizeof(fullName), stdin);\n\nprintf(\"Hello %s\", fullName);\n\n// Type your full name: John Doe\n// Hello John Doe",
        "printf()",
        "scanf()",
        "%d",
        "&myNum",
        "&",
        "fgets()",
        "sizeof",
        "stdin"
      ]
    },
    {
      "title": "C Memory Address",
      "summary": "Memory Address\nWhen a variable is created in C, a memory address is assigned to the variable.\nThe memory address is the location of where the variable is stored on the computer.\nWhen we assign a value to the variable, it is stored in this memory address.\nTo access it, use the reference operator (&), and the result represents where the variable is stored:\nExample\nNote: The memory address is in hexadecimal form (0x..). You will probably not get the same result in your program, as this depends on where the variable is stored on your computer.\nYou should also note that &myAge is often called a \"pointer\". A pointer basically stores the memory address of a variable as its value. To print pointer values, we use the %p format specifier.\nYou will learn much more about pointers in the next chapter.\nPointers are important in C, because they allow us to manipulate the data in the computer's memory - this can reduce the code and improve the performance.\nPointers are one of the things that make C stand out from other programming languages, like Python and Java.",
      "examples": [
        "int myAge = 43;\nprintf(\"%p\", &myAge); // Outputs 0x7ffe5367e044",
        "&",
        "&myAge",
        "%p"
      ]
    },
    {
      "title": "C Pointers",
      "summary": "Creating Pointers\nYou learned from the previous chapter, that we can get the memory address of a variable with the reference operator &:\nExample\nA pointer is a variable that stores the memory address of another variable as its value.\nA pointer variable points to a data type (like int) of the same type, and is created with the * operator.\nThe address of the variable you are working with is assigned to the pointer:\nExample\nCreate a pointer variable with the name ptr, that points to an int variable (myAge). Note that the type of the pointer has to match the type of the variable you're working with (int in our example).\nUse the & operator to store the memory address of the myAge variable, and assign it to the pointer.\nNow, ptr holds the value of myAge's memory address.\nDereference\nIn the example above, we used the pointer variable to get the memory address of a variable (used together with the & reference operator).\nYou can also get the value of the variable the pointer points to, by using the * operator (the dereference operator):\nExample\nNote that the * sign can be confusing here, as it does two different things in our code:\nWhen used in declaration (int* ptr), it creates a pointer variable.\nWhen not used in declaration, it act as a dereference operator.\nGood To Know: There are two ways to declare pointer variables in C:\nNotes on Pointers\nPointers are one of the things that make C stand out from other programming languages, like Python and Java.\nThey are important in C, because they allow us to manipulate the data in the computer's memory. This can reduce the code and improve the performance. If you are familiar with data structures like lists, trees and graphs, you should know that pointers are especially useful for implementing those. And sometimes you even have to use pointers, for example when working with files and memory management.\nBut be careful; pointers must be handled with care, since it is possible to damage data stored in other memory addresses.",
      "examples": [
        "int myAge = 43; // an int variable\n\nprintf(\"%d\", myAge);  // Outputs the value of myAge (43)\nprintf(\"%p\", &myAge); // Outputs the memory address of myAge (0x7ffe5367e044)",
        "int myAge = 43;     // An int variable\nint* ptr = &myAge;  // A pointer variable, with the name ptr, that stores the address of myAge\n\n// Output the value of myAge (43)\nprintf(\"%d\\n\", myAge);\n\n// Output the memory address of myAge (0x7ffe5367e044)\nprintf(\"%p\\n\", &myAge);\n\n// Output the memory address of myAge with the pointer (0x7ffe5367e044)\nprintf(\"%p\\n\", ptr);",
        "int myAge = 43;     // Variable declaration\nint* ptr = &myAge;  // Pointer declaration\n\n// Reference: Output the memory address of myAge with the pointer (0x7ffe5367e044)\nprintf(\"%p\\n\", ptr);\n\n// Dereference: Output the value of myAge with the pointer (43)\nprintf(\"%d\\n\", *ptr);",
        "int* myNum;\nint *myNum;",
        "&",
        "int",
        "*",
        "ptr",
        "myAge",
        "int* ptr"
      ]
    },
    {
      "title": "C Pointers and Arrays",
      "summary": "Pointers & Arrays\nYou can also use pointers to access arrays.\nConsider the following array of integers:\nExample\nYou learned from the arrays chapter that you can loop through the array elements with a for loop:\nExample\nResult:\nInstead of printing the value of each array element, let's print the memory address of each array element:\nExample\nResult:\nNote that the last number of each of the elements' memory address is different, with an addition of 4.\nIt is because the size of an int type is typically 4 bytes, remember:\nExample\nResult:\nSo from the \"memory address example\" above, you can see that the compiler reserves 4 bytes of memory for each array element, which means that the entire array takes up 16 bytes (4 * 4) of memory storage:\nExample\nResult:\nHow Are Pointers Related to Arrays\nOk, so what's the relationship between pointers and arrays? Well, in C, the name of an array, is actually a pointer to the first element of the array.\nConfused? Let's try to understand this better, and use our \"memory address example\" above again.\nThe memory address of the first element is the same as the name of the array:\nExample\nResult:\nThis basically means that we can work with arrays through pointers!\nHow? Since myNumbers is a pointer to the first element in myNumbers, you can use the * operator to access it:\nExample\nResult:\nTo access the rest of the elements in myNumbers, you can increment the pointer/array (+1, +2, etc):\nExample\nResult:\nOr loop through it:\nExample\nResult:\nIt is also possible to change the value of array elements with pointers:\nExample\nResult:\nThis way of working with arrays might seem a bit excessive. Especially with simple arrays like in the examples above. However, for large arrays, it can be much more efficient to access and manipulate arrays with pointers.\nIt is also considered faster and easier to access two-dimensional arrays with pointers.\nAnd since strings are actually arrays, you can also use pointers to access strings.\nFor now, it's great that you know how this works. But like we specified in the previous chapter; pointers must be handled with care, since it is possible to overwrite other data stored in memory.",
      "examples": [
        "int myNumbers[4] = {25, 50, 75, 100};",
        "int myNumbers[4] = {25, 50, 75, 100};\nint i;\n\nfor (i = 0; i < 4; i++) {\nprintf(\"%d\\n\", myNumbers[i]);\n}",
        "int myNumbers[4] = {25, 50, 75, 100};\nint i;\n\nfor (i = 0; i < 4; i++) {\nprintf(\"%p\\n\", &myNumbers[i]);\n}",
        "// Create an int variable\nint myInt;\n\n// Get the memory size of an int\nprintf(\"%zu\", sizeof(myInt));",
        "int myNumbers[4] = {25, 50, 75, 100};\n\n// Get the size of the myNumbers array\nprintf(\"%zu\", sizeof(myNumbers));",
        "int myNumbers[4] = {25, 50, 75, 100};\n\n// Get the memory address of the myNumbers array\nprintf(\"%p\\n\", myNumbers);\n\n// Get the memory address of the first array element\nprintf(\"%p\\n\", &myNumbers[0]);",
        "int myNumbers[4] = {25, 50, 75, 100};\n\n// Get the value of the first element in myNumbers\nprintf(\"%d\", *myNumbers);",
        "int myNumbers[4] = {25, 50, 75, 100};\n\n// Get the value of the second element in myNumbers\nprintf(\"%d\\n\", *(myNumbers + 1));\n\n// Get the value of the third element in myNumbers\nprintf(\"%d\", *(myNumbers + 2));\n\n// and so on..",
        "int myNumbers[4] = {25, 50, 75, 100};\nint *ptr = myNumbers;\nint i;\n\nfor (i = 0; i < 4; i++) {\nprintf(\"%d\\n\", *(ptr + i));\n}",
        "int myNumbers[4] = {25, 50, 75, 100};\n\n// Change the value of the first element to 13\n*myNumbers = 13;\n\n// Change the value of the second element to 17\n*(myNumbers +1) = 17;\n\n// Get the value of the first element\nprintf(\"%d\\n\", *myNumbers);\n\n// Get the value of the second element\nprintf(\"%d\\n\", *(myNumbers + 1));",
        "for",
        "25\n50\n75\n100",
        "0x7ffe70f9d8f0\n0x7ffe70f9d8f4\n0x7ffe70f9d8f8\n0x7ffe70f9d8fc",
        "int",
        "4",
        "16",
        "0x7ffe70f9d8f0\n0x7ffe70f9d8f0",
        "*",
        "25",
        "50\n75",
        "13\n17"
      ]
    },
    {
      "title": "C Functions",
      "summary": "Functions\nA function is a block of code which only runs when it is called.\nYou can pass data, known as parameters, into a function.\nFunctions are used to perform certain actions, and they are important for reusing code: Define the code once, and use it many times.\nPredefined Functions\nSo it turns out you already know what a function is. You have been using it the whole time while studying this tutorial!\nFor example, main() is a function, which is used to execute code, and printf() is a function; used to output/print text to the screen:\nExample\nCreate a Function\nTo create (often referred to as declare) your own function, specify the name of the function, followed by parentheses () and curly brackets {}:\nSyntax\nmyFunction() is the name of the function\nvoid means that the function does not have a return value. You will learn more about return values later in the next chapter\nInside the function (the body), add code that defines what the function should do\nCall a Function\nDeclared functions are not executed immediately. They are \"saved for later use\", and will be executed when they are called.\nTo call a function, write the function's name followed by two parentheses () and a semicolon ;\nIn the following example, myFunction() is used to print a text (the action), when it is called:\nExample\nInside main, call myFunction():\nA function can be called multiple times:\nExample\nCalculate the Sum of Numbers\nYou can put almost whatever you want inside a function. The purpose of the function is to save the code, and execute it when you need it.\nLike in the example below, we have created a function to calculate the sum of two numbers. Whenever you are ready to execute the function (and perform the calculation), you just call it:\nExample\nThis was just an example to demonstrate a simple function with different statements in C. The real power of a function is revealed in the next chapter, when we pass \"parameters\" to it. This allows the function to calculate the sum of any numbers, instead of being limited to the fixed values 5 and 10.",
      "examples": [
        "int main() {\nprintf(\"Hello World!\");\nreturn 0;\n}",
        "void myFunction() {\n// code to be executed\n}",
        "// Create a function\nvoid myFunction() {\nprintf(\"I just got executed!\");\n}\n\nint main() {\nmyFunction(); // call the function\nreturn 0;\n}\n\n// Outputs \"I just got executed!\"",
        "void myFunction() {\nprintf(\"I just got executed!\");\n}\n\nint main() {\nmyFunction();\nmyFunction();\nmyFunction();\nreturn 0;\n}\n\n// I just got executed!\n// I just got executed!\n// I just got executed!",
        "void calculateSum() {\nint x = 5;\nint y = 10;\nint sum = x + y;\nprintf(\"The sum of x + y is: %d\", sum);\n}\n\nint main() {\ncalculateSum();  // call the function\nreturn 0;\n}\n\n// Outputs The sum of x + y is: 15",
        "main()",
        "printf()",
        "()",
        "{}",
        "myFunction()",
        "void",
        ";",
        "main",
        "5",
        "10"
      ]
    },
    {
      "title": "C Function Parameters",
      "summary": "Parameters and Arguments\nInformation can be passed to functions as a parameter. Parameters act as variables inside the function.\nParameters are specified after the function name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma:\nSyntax\nIn the example below, the function takes a string of characters with name as parameter. When the function is called, we pass along a name, which is used inside the function to print \"Hello\" and the name of each person:\nExample\nWhen a parameter is passed to the function, it is called an argument. So, from the example above: name is a parameter, while Liam, Jenny and Anja are arguments.\nMultiple Parameters\nInside the function, you can add as many parameters as you want:\nExample\nIf we consider the \"Calculate the Sum of Numbers\" example from the previous page, we can make a more sustainable program by using function parameters:\nExample\nNote that when you are working with multiple parameters, the function call must have the same number of arguments as there are parameters, and the arguments must be passed in the same order.\nREMOVE ADS\nPass Arrays as Function Parameters\nYou can also pass arrays to a function:\nExample\nThe function (myFunction) takes an array as its parameter (int myNumbers[5]), and loops through the array elements with the for loop.\nWhen the function is called inside main(), we pass along the myNumbers array, which outputs the array elements.\nNote that when you call the function, you only need to use the name of the array when passing it as an argument myFunction(myNumbers). However, the full declaration of the array is needed in the function parameter (int myNumbers[5]).\nReturn Values\nThe void keyword, used in the previous examples, indicates that the function should not return a value. If you want the function to return a value, you can use a data type (such as int or float, etc.) instead of void, and use the return keyword inside the function:\nExample\nThis example returns the sum of a function with two parameters:\nExample\nYou can also store the result in a variable:\nExample\nIf we consider the \"Calculate the Sum of Numbers\" example one more time, we can use return instead and store the results in different variables. This will make the program even more flexible and easier to control:\nExample\nTip: If you have many \"result variables\", it is better to store the results in an array:\nExample\nReal-Life Example\nTo demonstrate a practical example of using functions, let's create a program that converts a value from fahrenheit to celsius:\nExample",
      "examples": [
        "returnType functionName(parameter1, parameter2, parameter3) {\n// code to be executed\n}",
        "void myFunction(char name[]) {\nprintf(\"Hello %s\\n\", name);\n}\n\nint main() {\nmyFunction(\"Liam\");\nmyFunction(\"Jenny\");\nmyFunction(\"Anja\");\nreturn 0;\n}\n\n// Hello Liam\n// Hello Jenny\n// Hello Anja",
        "void myFunction(char name[], int age) {\nprintf(\"Hello %s. You are %d years old.\\n\", name, age);\n}\n\nint main() {\nmyFunction(\"Liam\", 3);\nmyFunction(\"Jenny\", 14);\nmyFunction(\"Anja\", 30);\nreturn 0;\n}\n\n// Hello Liam. You are 3 years old.\n// Hello Jenny. You are 14 years old.\n// Hello Anja. You are 30 years old.",
        "void calculateSum(int x, int y) {\nint sum = x + y;\nprintf(\"The sum of %d + %d is: %d\\n\", x, y, sum);\n}\n\nint main() {\ncalculateSum(5, 3);\ncalculateSum(8, 2);\ncalculateSum(15, 15);\nreturn 0;\n}",
        "void myFunction(int myNumbers[5]) {\nfor (int i = 0; i < 5; i++) {\nprintf(\"%d\\n\", myNumbers[i]);\n}\n}\n\nint main() {\nint myNumbers[5] = {10, 20, 30, 40, 50};\nmyFunction(myNumbers);\nreturn 0;\n}",
        "int myFunction(int x) {\nreturn 5 + x;\n}\n\nint main() {\nprintf(\"Result is: %d\", myFunction(3));\nreturn 0;\n}\n\n// Outputs 8 (5 + 3)",
        "int myFunction(int x, int y) {\nreturn x + y;\n}\n\nint main() {\nprintf(\"Result is: %d\", myFunction(5, 3));\nreturn 0;\n}\n\n// Outputs 8 (5 + 3)",
        "int myFunction(int x, int y) {\nreturn x + y;\n}\n\nint main() {\nint result = myFunction(5, 3);\nprintf(\"Result is = %d\", result);\nreturn 0;\n}\n// Outputs 8 (5 + 3)",
        "int calculateSum(int x, int y) {\nreturn x + y;\n}\n\nint main() {\nint result1 = calculateSum(5, 3);\nint result2 = calculateSum(8, 2);\nint result3 = calculateSum(15, 15);\n\nprintf(\"Result1 is: %d\\n\", result1);\nprintf(\"Result2 is: %d\\n\", result2);\nprintf(\"Result3 is: %d\\n\", result3);\n\nreturn 0;\n}",
        "int calculateSum(int x, int y) {\nreturn x + y;\n}\n\nint main() {\n// Create an array\nint resultArr[6];\n\n// Call the function with different arguments and store the results in the array\nresultArr[0] = calculateSum(5, 3);\nresultArr[1] = calculateSum(8, 2);\nresultArr[2] = calculateSum(15, 15);\nresultArr[3] = calculateSum(9, 1);\nresultArr[4] = calculateSum(7, 7);\nresultArr[5] = calculateSum(1, 1);\n\nfor (int i = 0; i < 6; i++) {\nprintf(\"Result%d is = %d\\n\", i + 1, resultArr[i]);\n}\n\nreturn 0;\n}",
        "// Function to convert Fahrenheit to Celsius\nfloat toCelsius(float fahrenheit) {\nreturn (5.0 / 9.0) * (fahrenheit - 32.0);\n}\n\nint main() {\n// Set a fahrenheit value\nfloat f_value = 98.8;\n\n// Call the function with the fahrenheit value\nfloat result = toCelsius(f_value);\n\n// Print the fahrenheit value\nprintf(\"Fahrenheit: %.2f\\n\", f_value);\n\n// Print the result\nprintf(\"Convert Fahrenheit to Celsius: %.2f\\n\", result);\n\nreturn 0;\n}",
        "name",
        "Liam",
        "Jenny",
        "Anja",
        "myFunction",
        "int myNumbers[5]",
        "for",
        "main()",
        "myNumbers",
        "myFunction(myNumbers)",
        "void",
        "int",
        "float",
        "return"
      ]
    },
    {
      "title": "C Variable Scope",
      "summary": "Scope\nNow that you understand how functions work, it is important to learn how variables act inside and outside of functions.\nIn C, variables are only accessible inside the region they are created. This is called scope.\nLocal Scope\nA variable created inside a function belongs to the local scope of that function, and can only be used inside that function:\nExample\nA local variable cannot be used outside the function it belongs to.\nIf you try to access it outside the function, an error occurs:\nExample\nGlobal Scope\nA variable created outside of a function, is called a global variable and belongs to the global scope.\nGlobal variables are available from within any scope, global and local:\nExample\nA variable created outside of a function is global and can therefore be used by anyone:\nNaming Variables\nIf you operate with the same variable name inside and outside of a function, C will treat them as two separate variables; One available in the global scope (outside the function) and one available in the local scope (inside the function):\nExample\nThe function will print the local x, and then the code will print the global x:\nHowever, you should avoid using the same variable name for both globally and locally variables as it can lead to errors and confusion.\nIn general, you should be careful with global variables, since they can be accessed and modified from any function:\nExample\nChange the value of x from myFunction:\nConclusion\nTo sum up, use local variables (with good variable names) as much as you can. This will make your code easier to maintain and better to understand. However, you may find global variables when working on existing C programs or while collaborating with others. Therefore, it is good to understand how the scope works and how to use it effectively to make sure your code is clear and functional.",
      "examples": [
        "void myFunction() {\n// Local variable that belongs to myFunction\nint x = 5;\n\n// Print the variable x\nprintf(\"%d\", x);\n}\n\nint main() {\nmyFunction();\nreturn 0;\n}",
        "void myFunction() {\n// Local variable that belongs to myFunction\nint x = 5;\n}\n\nint main() {\nmyFunction();\n\n// Print the variable x in the main function\nprintf(\"%d\", x);\nreturn 0;\n}",
        "// Global variable x\nint x = 5;\n\nvoid myFunction() {\n// We can use x here\nprintf(\"%d\", x);\n}\n\nint main() {\nmyFunction();\n\n// We can also use x here\nprintf(\"%d\", x);\nreturn 0;\n}",
        "// Global variable x\nint x = 5;\n\nvoid myFunction() {\n// Local variable with the same name as the global variable (x)\nint x = 22;\nprintf(\"%d\\n\", x); // Refers to the local variable x\n}\n\nint main() {\nmyFunction();\n\nprintf(\"%d\\n\", x); // Refers to the global variable x\nreturn 0;\n}",
        "// Global variable\nint x = 5;\n\nvoid myFunction() {\nprintf(\"%d\\n\", ++x); // Increment the value of x by 1 and print it\n}\n\nint main() {\nmyFunction();\n\nprintf(\"%d\\n\", x); // Print the global variable x\nreturn 0;\n}\n\n// The value of x is now 6 (no longer 5)",
        "x",
        "myFunction"
      ]
    },
    {
      "title": "C Function Declaration and Definition",
      "summary": "Function Declaration and Definition\nYou have already learned from the previous chapters that you can create and call a function in the following way:\nExample\nA function consist of two parts:\nDeclaration: the function's name, return type, and parameters (if any)\nDefinition: the body of the function (code to be executed)\nFor code optimization, it is recommended to separate the declaration and the definition of the function.\nYou will often see C programs that have function declaration above main(), and function definition below main().\nThis will make the code better organized and easier to read:\nExample\nWhat About Parameters\nIf we use the example from the function parameters chapter regarding parameters and return values:\nExample\nIt is considered good practice to write it like this instead:\nExample\nFunctions Calling Other Functions\nAs long as you declare functions first, it is also possible to use functions to call other functions:\nExample\nUse one function to call another function:",
      "examples": [
        "// Create a function\nvoid myFunction() {\nprintf(\"I just got executed!\");\n}\n\nint main() {\nmyFunction(); // call the function\nreturn 0;\n}",
        "void myFunction() { // declaration\n// the body of the function (definition)\n}",
        "// Function declaration\nvoid myFunction();\n\n// The main method\nint main() {\nmyFunction();  // call the function\nreturn 0;\n}\n\n// Function definition\nvoid myFunction() {\nprintf(\"I just got executed!\");\n}",
        "int myFunction(int x, int y) {\nreturn x + y;\n}\n\nint main() {\nint result = myFunction(5, 3);\nprintf(\"Result is = %d\", result);\nreturn 0;\n}\n// Outputs 8 (5 + 3)",
        "// Function declaration\nint myFunction(int x, int y);\n\n// The main method\nint main() {\nint result = myFunction(5, 3); // call the function\nprintf(\"Result is = %d\", result);\nreturn 0;\n}\n\n// Function definition\nint myFunction(int x, int y) {\nreturn x + y;\n}",
        "// Declare two functions, myFunction and myOtherFunction\nvoid myFunction();\nvoid myOtherFunction();\n\nint main() {\nmyFunction(); // call myFunction (from main)\nreturn 0;\n}\n\n// Define myFunction\nvoid myFunction() {\nprintf(\"Some text in myFunction\\n\");\nmyOtherFunction(); // call myOtherFunction (from myFunction)\n}\n\n// Define myOtherFunction\nvoid myOtherFunction() {\nprintf(\"Hey! Some text in myOtherFunction\\n\");\n}",
        "main()"
      ]
    },
    {
      "title": "C Recursion",
      "summary": "Recursion\nRecursion is the technique of making a function call itself. This technique provides a way to break complicated problems down into simple problems which are easier to solve.\nRecursion may be a bit difficult to understand. The best way to figure out how it works is to experiment with it.\nRecursion Example\nAdding two numbers together is easy to do, but adding a range of numbers is more complicated. In the following example, recursion is used to add a range of numbers together by breaking it down into the simple task of adding two numbers:\nExample\nExample Explained\nWhen the sum() function is called, it adds parameter k to the sum of all numbers smaller than k and returns the result. When k becomes 0, the function just returns 0. When running, the program follows these steps:\nSince the function does not call itself when k is 0, the program stops there and returns the result.\nThe developer should be very careful with recursion as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly, recursion can be a very efficient and mathematically-elegant approach to programming.",
      "examples": [
        "int sum(int k);\n\nint main() {\nint result = sum(10);\nprintf(\"%d\", result);\nreturn 0;\n}\n\nint sum(int k) {\nif (k > 0) {\nreturn k + sum(k - 1);\n} else {\nreturn 0;\n}\n}",
        "sum()",
        "k"
      ]
    },
    {
      "title": "C Math Functions",
      "summary": "Math Functions\nThere is also a list of math functions available, that allows you to perform mathematical tasks on numbers.\nTo use them, you must include the math.h header file in your program:\nSquare Root\nTo find the square root of a number, use the sqrt() function:\nExample\nRound a Number\nThe ceil() function rounds a number upwards to its nearest integer, and the floor() method rounds a number downwards to its nearest integer, and returns the result:\nExample\nPower\nThe pow() function returns the value of x to the power of y (xy):\nExample\nComplete Math Reference\nFor a complete reference of math functions, go to our C <math.h> Library Reference.",
      "examples": [
        "#include <math.h>",
        "printf(\"%f\", sqrt(16));",
        "printf(\"%f\", ceil(1.4));\nprintf(\"%f\", floor(1.4));",
        "printf(\"%f\", pow(4, 3));",
        "math.h",
        "sqrt()",
        "ceil()",
        "floor()",
        "pow()"
      ]
    },
    {
      "title": "C Files",
      "summary": "File Handling\nIn C, you can create, open, read, and write to files by declaring a pointer of type FILE, and use the fopen() function:\nFILE is basically a data type, and we need to create a pointer variable to work with it (fptr). For now, this line is not important. It's just something you need when working with files.\nTo actually open a file, use the fopen() function, which takes two parameters:\nw - Writes to a file\na - Appends new data to a file\nr - Reads from a file\nCreate a File\nTo create a file, you can use the w mode inside the fopen() function.\nThe w mode is used to write to a file. However, if the file does not exist, it will create one for you:\nExample\nNote: The file is created in the same directory as your other C files, if nothing else is specified.\nOn our computer, it looks like this:\nTip: If you want to create the file in a specific folder, just provide an absolute path (remember to use double backslashes to create a single backslash (\\), like we specified in strings special characters):\nDid you notice the fclose() function in our example above?\nThis will close the file when we are done with it.\nIt is considered as good practice, because it makes sure that:\nChanges are saved properly\nOther programs can use the file (if you want)\nClean up unnecessary memory space\nIn the next chapters, you will learn how to write content to a file and read from it.",
      "examples": [
        "FILE *fptr;\nfptr = fopen(filename, mode);",
        "FILE *fptr;\n\n// Create a file\nfptr = fopen(\"filename.txt\", \"w\");\n\n// Close the file\nfclose(fptr);",
        "fptr = fopen(\"C:\\\\directoryname\\\\filename.txt\", \"w\");",
        "FILE",
        "fopen()",
        "fptr",
        "filename.txt",
        "w",
        "a",
        "r",
        "\\",
        "fclose()"
      ]
    },
    {
      "title": "C Write To Files",
      "summary": "Write To a File\nLet's use the w mode from the previous chapter again, and write something to the file we just created.\nThe w mode means that the file is opened for writing. To insert content to it, you can use the fprintf() function and add the pointer variable (fptr in our example) and some text:\nExample\nAs a result, when we open the file on our computer, it looks like this:\nNote: If you write to a file that already exists, the old content is deleted, and the new content is inserted. This is important to know, as you might accidentally erase existing content.\nFor example:\nExample\nAs a result, when we open the file on our computer, it says \"Hello World!\" instead of \"Some text\":\nAppend Content To a File\nIf you want to add content to a file without deleting the old content, you can use the a mode.\nThe a mode appends content at the end of the file:\nExample\nAs a result, when we open the file on our computer, it looks like this:\nNote: Just like with the w mode; if the file does not exist, the a mode will create a new file with the \"appended\" content.",
      "examples": [
        "FILE *fptr;\n\n// Open a file in writing mode\nfptr = fopen(\"filename.txt\", \"w\");\n\n// Write some text to the file\nfprintf(fptr, \"Some text\");\n\n// Close the file\nfclose(fptr);",
        "fprintf(fptr, \"Hello World!\");",
        "FILE *fptr;\n\n// Open a file in append mode\nfptr = fopen(\"filename.txt\", \"a\");\n\n// Append some text to the file\nfprintf(fptr, \"\\nHi everybody!\");\n\n// Close the file\nfclose(fptr);",
        "w",
        "fprintf()",
        "fptr",
        "a"
      ]
    },
    {
      "title": "C Read Files",
      "summary": "Read a File\nIn the previous chapter, we wrote to a file using w and a modes inside the fopen() function.\nTo read from a file, you can use the r mode:\nExample\nThis will make the filename.txt opened for reading.\nIt requires a little bit of work to read a file in C. Hang in there! We will guide you step-by-step.\nNext, we need to create a string that should be big enough to store the content of the file.\nFor example, let's create a string that can store up to 100 characters:\nExample\nIn order to read the content of filename.txt, we can use the fgets() function.\nThe fgets() function takes three parameters:\nExample\nThe first parameter specifies where to store the file content, which will be in the myString array we just created.\nThe second parameter specifies the maximum size of data to read, which should match the size of myString (100).\nThe third parameter requires a file pointer that is used to read the file (fptr in our example).\nNow, we can print the string, which will output the content of the file:\nExample\nHello World!\nNote: The fgets function only reads the first line of the file. If you remember, there were two lines of text in filename.txt.\nTo read every line of the file, you can use a while loop:\nExample\nHello World!\nHi everybody!\nGood Practice\nIf you try to open a file for reading that does not exist, the fopen() function will return NULL.\nTip: As a good practice, we can use an if statement to test for NULL, and print some text instead (when the file does not exist):\nExample\nIf the file does not exist, the following text is printed:\nNot able to open the file.\nWith this in mind, we can create a more sustainable code if we use our \"read a file\" example above again:\nExample\nIf the file exist, read the content and print it. If the file does not exist, print a message:\nHello World!\nHi everybody!\nNote: You will learn more about NULL in our NULL chapter.",
      "examples": [
        "FILE *fptr;\n\n// Open a file in read mode\nfptr = fopen(\"filename.txt\", \"r\");",
        "FILE *fptr;\n\n// Open a file in read mode\nfptr = fopen(\"filename.txt\", \"r\");\n\n// Store the content of the file\nchar myString[100];",
        "fgets(myString, 100, fptr);",
        "FILE *fptr;\n\n// Open a file in read mode\nfptr = fopen(\"filename.txt\", \"r\");\n\n// Store the content of the file\nchar myString[100];\n\n// Read the content and store it inside myString\nfgets(myString, 100, fptr);\n\n// Print the file content\nprintf(\"%s\", myString);\n\n// Close the file\nfclose(fptr);",
        "FILE *fptr;\n\n// Open a file in read mode\nfptr = fopen(\"filename.txt\", \"r\");\n\n// Store the content of the file\nchar myString[100];\n\n// Read the content and print it\nwhile(fgets(myString, 100, fptr)) {\nprintf(\"%s\", myString);\n}\n\n// Close the file\nfclose(fptr);",
        "FILE *fptr;\n\n// Open a file in read mode\nfptr = fopen(\"loremipsum.txt\", \"r\");\n\n// Print some text if the file does not exist\nif(fptr == NULL) {\nprintf(\"Not able to open the file.\");\n}\n\n// Close the file\nfclose(fptr);",
        "FILE *fptr;\n\n// Open a file in read mode\nfptr = fopen(\"filename.txt\", \"r\");\n\n// Store the content of the file\nchar myString[100];\n\n// If the file exist\nif(fptr != NULL) {\n\n// Read the content and print it\nwhile(fgets(myString, 100, fptr)) {\nprintf(\"%s\", myString);\n}\n\n// If the file does not exist\n} else {\nprintf(\"Not able to open the file.\");\n}\n\n// Close the file\nfclose(fptr);",
        "w",
        "a",
        "fopen()",
        "r",
        "filename.txt",
        "fgets()",
        "myString",
        "100",
        "fptr",
        "Hello World!",
        "fgets",
        "while",
        "Hello World!\nHi everybody!",
        "NULL",
        "if",
        "Not able to open the file."
      ]
    },
    {
      "title": "C Structures (structs)",
      "summary": "Structures\nStructures (also called structs) are a way to group several related variables into one place.\nEach variable in the structure is known as a member of the structure.\nUnlike an array, a structure can contain many different data types (int, float, char, etc.).\nCreate a Structure\nYou can create a structure by using the struct keyword and declare each of its members inside curly braces:\nTo access the structure, you must create a variable of it.\nUse the struct keyword inside the main() method, followed by the name of the structure and then the name of the structure variable:\nCreate a struct variable with the name \"s1\":\nAccess Structure Members\nTo access members of a structure, use the dot syntax (.):\nExample\nNow you can easily create multiple structure variables with different values, using just one structure:\nExample\nREMOVE ADS\nWhat About Strings in Structures?\nRemember that strings in C are actually an array of characters, and unfortunately, you can't assign a value to an array like this:\nExample\nAn error will occur:\nHowever, there is a solution for this! You can use the strcpy() function and assign the value to s1.myString, like this:\nExample\nResult:\nSimpler Syntax\nYou can also assign values to members of a structure variable at declaration time, in a single line.\nJust insert the values in a comma-separated list inside curly braces {}. Note that you don't have to use the strcpy() function for string values with this technique:\nExample\nNote: The order of the inserted values must match the order of the variable types declared in the structure (13 for int, 'B' for char, etc).\nCopy Structures\nYou can also assign one structure to another.\nIn the following example, the values of s1 are copied to s2:\nExample\nModify Values\nIf you want to change/modify a value, you can use the dot syntax (.).\nAnd to modify a string value, the strcpy() function is useful again:\nExample\nModifying values are especially useful when you copy structure values:\nExample\nImagine you have to write a program to store different information about Cars, such as brand, model, and year. What's great about structures is that you can create a single \"Car template\" and use it for every cars you make. See below for a real life example.\nReal-Life Example\nUse a structure to store different information about Cars:\nExample",
      "examples": [
        "struct MyStructure {   // Structure declaration\nint myNum;           // Member (int variable)\nchar myLetter;       // Member (char variable)\n}; // End the structure with a semicolon",
        "struct myStructure {\nint myNum;\nchar myLetter;\n};\n\nint main() {\nstruct myStructure s1;\nreturn 0;\n}",
        "// Create a structure called myStructure\nstruct myStructure {\nint myNum;\nchar myLetter;\n};\n\nint main() {\n// Create a structure variable of myStructure called s1\nstruct myStructure s1;\n\n// Assign values to members of s1\ns1.myNum = 13;\ns1.myLetter = 'B';\n\n// Print values\nprintf(\"My number: %d\\n\", s1.myNum);\nprintf(\"My letter: %c\\n\", s1.myLetter);\n\nreturn 0;\n}",
        "// Create different struct variables\nstruct myStructure s1;\nstruct myStructure s2;\n\n// Assign values to different struct variables\ns1.myNum = 13;\ns1.myLetter = 'B';\n\ns2.myNum = 20;\ns2.myLetter = 'C';",
        "struct myStructure {\nint myNum;\nchar myLetter;\nchar myString[30];  // String\n};\n\nint main() {\nstruct myStructure s1;\n\n// Trying to assign a value to the string\ns1.myString = \"Some text\";\n\n// Trying to print the value\nprintf(\"My string: %s\", s1.myString);\n\nreturn 0;\n}",
        "struct myStructure {\nint myNum;\nchar myLetter;\nchar myString[30]; // String\n};\n\nint main() {\nstruct myStructure s1;\n\n// Assign a value to the string using the strcpy function\nstrcpy(s1.myString, \"Some text\");\n\n// Print the value\nprintf(\"My string: %s\", s1.myString);\n\nreturn 0;\n}",
        "// Create a structure\nstruct myStructure {\nint myNum;\nchar myLetter;\nchar myString[30];\n};\n\nint main() {\n// Create a structure variable and assign values to it\nstruct myStructure s1 = {13, 'B', \"Some text\"};\n\n// Print values\nprintf(\"%d %c %s\", s1.myNum, s1.myLetter, s1.myString);\n\nreturn 0;\n}",
        "struct myStructure s1 = {13, 'B', \"Some text\"};\nstruct myStructure s2;\n\ns2 = s1;",
        "struct myStructure {\nint myNum;\nchar myLetter;\nchar myString[30];\n};\n\nint main() {\n// Create a structure variable and assign values to it\nstruct myStructure s1 = {13, 'B', \"Some text\"};\n\n// Modify values\ns1.myNum = 30;\ns1.myLetter = 'C';\nstrcpy(s1.myString, \"Something else\");\n\n// Print values\nprintf(\"%d %c %s\", s1.myNum, s1.myLetter, s1.myString);\n\nreturn 0;\n}",
        "// Create a structure variable and assign values to it\nstruct myStructure s1 = {13, 'B', \"Some text\"};\n\n// Create another structure variable\nstruct myStructure s2;\n\n// Copy s1 values to s2\ns2 = s1;\n\n// Change s2 values\ns2.myNum = 30;\ns2.myLetter = 'C';\nstrcpy(s2.myString, \"Something else\");\n\n// Print values\nprintf(\"%d %c %s\\n\", s1.myNum, s1.myLetter, s1.myString);\nprintf(\"%d %c %s\\n\", s2.myNum, s2.myLetter, s2.myString);",
        "struct Car {\nchar brand[50];\nchar model[50];\nint year;\n};\n\nint main() {\nstruct Car car1 = {\"BMW\", \"X5\", 1999};\nstruct Car car2 = {\"Ford\", \"Mustang\", 1969};\nstruct Car car3 = {\"Toyota\", \"Corolla\", 2011};\n\nprintf(\"%s %s %d\\n\", car1.brand, car1.model, car1.year);\nprintf(\"%s %s %d\\n\", car2.brand, car2.model, car2.year);\nprintf(\"%s %s %d\\n\", car3.brand, car3.model, car3.year);\n\nreturn 0;\n}",
        "int",
        "float",
        "char",
        "struct",
        "main()",
        ".",
        "prog.c:12:15: error: assignment to expression with array type",
        "strcpy()",
        "s1.myString",
        "My string: Some text",
        "{}"
      ]
    },
    {
      "title": "C Structs and Pointers",
      "summary": "Structures and Pointers\nYou can use pointers with structs to make your code more efficient, especially when passing structs to functions or changing their values.\nTo use a pointer to a struct, just add the * symbol, like you would with other data types.\nTo access its members, you must use the -> operator instead of the dot . syntax:\nExample\nTry it Yourself »\nPassing Struct Pointers to Functions\nHere's how you can pass a struct pointer to a function and change its values:\nExample\nTry it Yourself »\nWhy Use Struct Pointers?\nUsing pointers with structs is helpful when:\nYou want to avoid copying large amounts of data.\nInstead of copying a whole struct, you can just pass a pointer. This makes your program faster and uses less memory.\nYou want to change values inside a function.\nIf you pass a pointer to a struct into a function, the function can change the original values.\nYou want to create structs dynamically using memory allocation.\nWith pointers, you can use malloc() to create structs while the program is running.\nYou will learn more about memory management in a later chapter.\nTip: If you're working with big programs or many values, struct pointers can help make your code cleaner and more efficient.",
      "examples": [
        "// Define a struct struct Car { char brand[50]; int year; }; int main() { struct Car car = {\"Toyota\", 2020}; // Declare a pointer to the struct struct Car *ptr = &car; // Access members using the -> operator printf(\"Brand: %s\\n\", ptr->brand); printf(\"Year: %d\\n\", ptr->year); return 0; }",
        "struct Car { char brand[20]; int year; }; // Function that takes a pointer to a Car struct and updates the year void updateYear(struct Car *c) { c->year = 2025; // Change the year } int main() { struct Car myCar = {\"Toyota\", 2020}; updateYear(&myCar); // Pass a pointer so the function can change the year printf(\"Brand: %s\\n\", myCar.brand); printf(\"Year: %d\\n\", myCar.year); return 0; }",
        "*",
        "->",
        ".",
        "malloc()"
      ]
    },
    {
      "title": "C Unions",
      "summary": "C Unions\nA union is similar to a struct in that it can store members of different data types.\nHowever, there are some differences:\nIn a struct, each member has its own memory.\nIn a union, all members share the same memory, which means you can only use one of the values at a time.\nMost of the time, you will use structs instead of unions, as it can store and access multiple values at the same time, which is more common in everyday programs.\nHowever, unions are useful when you only need to store one of several possible types at a time, and you want to save memory.\nDeclare a Union\nTo create a union, use the union keyword, and then create a variable from it (just like with structs):\nExample\nAccess Union Members\nAnd just like with structs, to access members of a Union, use the dot . syntax.\nImportant: Since all members share the same memory, changing one will affect the others. Only the last assigned member holds a valid value:\nExample\nSize of a Union\nThe size of a union will always be the same as the size of its largest member:\nExample\nSince the largest member is 36 bytes, the entire union will also be 36 bytes.\nIf it was a struct instead, the size would be 44 bytes:\nmyNum (4 bytes) + myLetter (4 bytes) + myString (36 bytes) = 44 bytes total\nWhen to Use Unions\nUse unions when:\nYou need to store different types in the same location\nYou only use one type at a time\nSaving memory is very important",
      "examples": [
        "union myUnion {        // Union declaration\nint myNum;           // Member (int)\nchar myLetter;       // Member (char)\nchar myString[30];   // Member (char array)\n};\n\nint main() {\nunion myUnion u1;  // Create a union variable with the name \"u1\":\nreturn 0;\n}",
        "union myUnion {\nint myNum;\nchar myLetter;\nchar myString[30];\n};\n\nint main() {\nunion myUnion u1;\n\nu1.myNum = 1000;\n\n// Since this is the last value written to the union, myNum no longer holds 1000 - its value is now invalid\nu1.myLetter = 'A';\n\nprintf(\"myNum: %d\\n\", u1.myNum); // This value is no longer reliable\nprintf(\"myLetter: %c\\n\", u1.myLetter); // Prints 'A'\n\nreturn 0;\n}",
        "union myUnion {\nint myNum;\nchar myLetter;\nchar myString[36];\n};\n\nint main() {\nunion myUnion u1;\nprintf(\"Size of union: %zu bytes\\n\", sizeof(u1));\nreturn 0;\n}",
        "struct",
        "union",
        ".",
        "myNum",
        "myLetter",
        "myString"
      ]
    },
    {
      "title": "C Enumeration (enum)",
      "summary": "C Enums\nAn enum is a special type that represents a group of constants (unchangeable values).\nTo create an enum, use the enum keyword, followed by the name of the enum, and separate the enum items with a comma:\nNote that the last item does not need a comma.\nIt is not required to use uppercase, but often considered as good practice.\nEnum is short for \"enumerations\", which means \"specifically listed\".\nTo access the enum, you must create a variable of it.\nInside the main() method, specify the enum keyword, followed by the name of the enum (Level) and then the name of the enum variable (myVar in this example):\nNow that you have created an enum variable (myVar), you can assign a value to it.\nThe assigned value must be one of the items inside the enum (LOW, MEDIUM or HIGH):\nBy default, the first item (LOW) has the value 0, the second (MEDIUM) has the value 1, etc.\nIf you now try to print myVar, it will output 1, which represents MEDIUM:\nChange Values\nAs you know, the first item of an enum has the value 0. The second has the value 1, and so on.\nTo make more sense of the values, you can easily change them:\nNote that if you assign a value to one specific item, the next items will update their numbers accordingly:\nEnum in a Switch Statement\nEnums are often used in switch statements to check for corresponding values:\nEnums are used to give names to constants, which makes the code easier to read and maintain.\nUse enums when you have values that you know aren't going to change, like month days, days, colors, deck of cards, etc.",
      "examples": [
        "enum Level {\nLOW,\nMEDIUM,\nHIGH\n};",
        "enum Level myVar;",
        "enum Level myVar = MEDIUM;",
        "int main() {\n// Create an enum variable and assign a value to it\nenum Level myVar = MEDIUM;\n\n// Print the enum variable\nprintf(\"%d\", myVar);\n\nreturn 0;\n}",
        "enum Level {\nLOW = 25,\nMEDIUM = 50,\nHIGH = 75\n};",
        "printf(\"%d\", myVar); // Now outputs 50",
        "enum Level {\nLOW = 5,\nMEDIUM, // Now 6\nHIGH // Now 7\n};",
        "enum Level {\nLOW = 1,\nMEDIUM,\nHIGH\n};\n\nint main() {\nenum Level myVar = MEDIUM;\n\nswitch (myVar) {\ncase 1:\nprintf(\"Low Level\");\nbreak;\ncase 2:\nprintf(\"Medium level\");\nbreak;\ncase 3:\nprintf(\"High level\");\nbreak;\n}\nreturn 0;\n}",
        "enum",
        "main()",
        "Level",
        "myVar",
        "LOW",
        "MEDIUM",
        "HIGH",
        "0",
        "1"
      ]
    },
    {
      "title": "C Memory Management",
      "summary": "Memory management is the process of handling how much memory a program uses through different operations.\nMemory in C\nUnderstanding how memory works in C is important. When you create a basic variable, C will automatically reserve space for that variable. An int variable for example, will typically occupy 4 bytes of memory, while a double variable will occupy 8 bytes of memory.\nYou can use the sizeof operator to find the size of different types:\nExample\nWhy is it important to know?\nIf you create a program that occupies too much, or unnecessary memory, it can result in slow and poor performance.\nIn C, you have to manage memory yourself. It is a complicated task, but is also quite powerful when used correctly: Properly managing the computer memory optimizes the performance of the program, so it is useful that you know how to release memory when it is no longer required and only use as little as necessary for the task.\nIn previous chapters you learned about memory addresses and pointers.\nBoth have an importance when it comes to memory management, since it is possible to work directly with memory through pointers.\nBut be careful; pointers must be handled with care, since it is possible to damage data stored in other memory addresses.\nMemory Management\nMemory management is the process of handling how much memory a program uses through allocation, reallocation and deallocation (often referred to as \"freeing\"). We will introduce each of these topics in the following chapters.",
      "examples": [
        "int myInt;\nfloat myFloat;\ndouble myDouble;\nchar myChar;\n\nprintf(\"%zu\\n\", sizeof(myInt));      // 4 bytes\nprintf(\"%zu\\n\", sizeof(myFloat));    // 4 bytes\nprintf(\"%zu\\n\", sizeof(myDouble));   // 8 bytes\nprintf(\"%zu\\n\", sizeof(myChar));     // 1 byte",
        "int",
        "double",
        "sizeof"
      ]
    },
    {
      "title": "C Allocate Memory",
      "summary": "The process of reserving memory is called allocation. The way to allocate memory depends on the type of memory.\nC has two types of memory: Static memory and dynamic memory.\nStatic Memory\nStatic memory is memory that is reserved for variables before the program runs. Allocation of static memory is also known as compile time memory allocation.\nC automatically allocates memory for every variable when the program is compiled.\nFor example, if you create an integer array of 20 students (e.g. for a summer semester), C will reserve space for 20 elements which is typically 80 bytes of memory (20 * 4):\nExample\nBut when the semester starts, it turns out that only 12 students are attending. Then you have wasted the space of 8 unused elements.\nSince you are not able to change the size of the array, you are left with unnecessary reserved memory.\nNote that the program will still run, and it is not damaged in any way. But if your program contains a lot of this kind of code, it may run slower than it optimally could.\nIf you want better control of allocated memory, take a look at Dynamic Memory below.\nDynamic Memory\nDynamic memory is memory that is allocated after the program starts running. Allocation of dynamic memory can also be referred to as runtime memory allocation.\nUnlike with static memory, you have full control over how much memory is being used at any time. You can write code to determine how much memory you need and allocate it.\nDynamic memory does not belong to a variable, it can only be accessed with pointers.\nTo allocate dynamic memory, you can use the malloc() or calloc() functions. It is necessary to include the <stdlib.h> header to use them. The malloc() and calloc() functions allocate some memory and return a pointer to its address.\nThe malloc() function has one parameter, size, which specifies how much memory to allocate, measured in bytes.\nThe calloc() function has two parameters:\namount - Specifies the amount of items to allocate\nsize - Specifies the size of each item measured in bytes\nNote: The data in the memory allocated by malloc() is unpredictable. To avoid unexpected values, make sure to write something into the memory before reading it.\nUnlike malloc(), the calloc() function writes zeroes into all of the allocated memory. However, this makes calloc() slightly less efficient.\nThe best way to allocate the right amount of memory for a data type is to use the sizeof operator:\nBe careful: sizeof(*ptr1) tells C to measure the size of the data at the address. If you forget the * and write sizeof(ptr1) instead, it will measure the size of the pointer itself, which is the (usually) 8 bytes that are needed to store a memory address.\nNote: The sizeof operator cannot measure how much dynamic memory is allocated. When measuring dynamic memory, it only tells you the size of the data type of the memory. For example, if you reserve space for 5 float values, the sizeof operator will return 4, which is the number of bytes needed for a single float value.\nLet's use dynamic memory to improve the students example above.\nAs noted previously, we cannot use sizeof to measure how much memory was allocated, we have to calculate that by multiplying the amount of items by the size of the data type:\nExample\nNotes\nWhen working with dynamic memory allocation, you should also check for errors and free memory at the end of the program. You will learn more about this in the next chapters.\nStack Memory\nFor completeness, it is worth mentioning stack memory. Stack memory is a type of dynamic memory which is reserved for variables that are declared inside functions. Variables declared inside a function use stack memory rather than static memory.\nWhen a function is called, stack memory is allocated for the variables in the function. When the function returns the stack memory is freed.\nIt is good to be aware of stack memory to be able to handle the memory usage of nested function calls and recursion. Recursion that repeats itself too many times may take up too much stack memory. When that happens it is called a stack overflow.",
      "examples": [
        "int students[20];\nprintf(\"%zu\", sizeof(students)); // 80 bytes",
        "int *ptr1 = malloc(size);\nint *ptr2 = calloc(amount, size);",
        "int *ptr1, *ptr2;\nptr1 = malloc(sizeof(*ptr1));\nptr2 = calloc(1, sizeof(*ptr2));",
        "int *students;\nint numStudents = 12;\nstudents = calloc(numStudents, sizeof(*students));\nprintf(\"%d\", numStudents * sizeof(*students)); // 48 bytes",
        "malloc()",
        "calloc()",
        "<stdlib.h>",
        "sizeof",
        "sizeof(*ptr1)",
        "*",
        "sizeof(ptr1)",
        "float"
      ]
    },
    {
      "title": "C Access Memory",
      "summary": "Access Dynamic Memory\nDynamic memory behaves like an array, with its data type specified by the type of the pointer.\nAs with arrays, to access an element in dynamic memory, refer to its index number:\nYou can also dereference the pointer to access the first element:\nExample\nRead from and write to dynamic memory:\nA note about data types\nDynamic memory does not have its own data type, it is just a sequence of bytes. The data in the memory can be interpreted as a type based on the data type of the pointer.\nIn this example a pointer to four bytes can be interpreted as one int value (4 bytes) or as an array of 4 char values (1 byte each).\nExample",
      "examples": [
        "ptr[0] = 12;",
        "*ptr = 12;",
        "// Allocate memory\nint *ptr;\nptr = calloc(4, sizeof(*ptr));\n\n// Write to the memory\n*ptr = 2;\nptr[1] = 4;\nptr[2] = 6;\n\n// Read from the memory\nprintf(\"%d\\n\", *ptr);\nprintf(\"%d %d %d\", ptr[1], ptr[2], ptr[3]);",
        "int *ptr1 = malloc(4);\nchar *ptr2 = (char*) ptr1;\nptr1[0] = 1684234849;\nprintf(\"%d is %c %c %c %c\", *ptr1, ptr2[0], ptr2[1], ptr2[2], ptr2[3]);",
        "int",
        "char"
      ]
    },
    {
      "title": "C Reallocate Memory",
      "summary": "Reallocate Memory\nIf the amount of memory you reserved is not enough, you can reallocate it to make it larger.\nReallocating reserves a different (usually larger) amount of memory while keeping the data that was stored in it.\nYou can change the size of allocated memory with the realloc() function.\nThe realloc() function takes two parameters:\nThe first parameter is a pointer to the memory that is being resized.\nThe second parameter specifies the new size of allocated memory, measured in bytes.\nThe realloc() function tries to resize the memory at ptr1 and return the same memory address. If it cannot resize the memory at the current address then it will allocate memory at a different address and return the new address instead.\nNote: When realloc() returns a different memory address, the memory at the original address is no longer reserved and it is not safe to use. When the reallocation is done it is good to assign the new pointer to the previous variable so that the old pointer cannot be used accidentally.\nExample\nIncrease the size of allocated memory:\nNULL Pointer & Error Checking\nThe realloc() function returns a NULL pointer if it is not able to allocate more memory. This is very unlikely, but it is worth keeping in mind when you need your code to be failproof.\nThe following example checks whether realloc() is able to resize the memory or not, by checking for a NULL pointer:\nExample\nCheck for a NULL pointer:\nNote: You should always include error checking (if pointer == NULL) when allocating memory.\nNote: You should also always free, or release, allocated memory when you are done using it. This is important to make sure that your program behaves as expected, but it will also make it more maintainable and efficient.\nTo free memory, simply use the free() function:\nExample\nFree allocated memory:\nYou will learn more about how to free allocated memory and why this is important in the next chapter.",
      "examples": [
        "int *ptr2 = realloc(ptr1, size);",
        "int *ptr1, *ptr2, size;\n\n// Allocate memory for four integers\nsize = 4 * sizeof(*ptr1);\nptr1 = malloc(size);\n\nprintf(\"%d bytes allocated at address %p \\n\", size, ptr1);\n\n// Resize the memory to hold six integers\nsize = 6 * sizeof(*ptr1);\nptr2 = realloc(ptr1, size);\n\nprintf(\"%d bytes reallocated at address %p \\n\", size, ptr2);",
        "int *ptr1, *ptr2;\n\n// Allocate memory\nptr1 = malloc(4);\n\n// Attempt to resize the memory\nptr2 = realloc(ptr1, 8);\n\n// Check whether realloc is able to resize the memory or not\nif (ptr2 == NULL) {\n// If reallocation fails\nprintf(\"Failed. Unable to resize memory\");\n} else {\n// If reallocation is sucessful\nprintf(\"Success. 8 bytes reallocated at address %p \\n\", ptr2);\nptr1 = ptr2;  // Update ptr1 to point to the newly allocated memory\n}",
        "// Free allocated memory\nfree(ptr1);",
        "realloc()",
        "NULL",
        "free()"
      ]
    },
    {
      "title": "C Deallocate Memory",
      "summary": "Deallocate (free) Memory\nWhen you no longer need a block of memory you should deallocate it. Deallocation is also referred to as \"freeing\" the memory.\nDynamic memory stays reserved until it is deallocated or until the program ends.\nOnce the memory is deallocated it can be used by other programs or it may even be allocated to another part of your program.\nFree Memory\nTo deallocate memory, use the free() function:\nThe pointer parameter is a pointer to the address of the memory to be deallocated:\nIt is considered a good practice to set a pointer to NULL after freeing memory so that you cannot accidentally continue using it.\nIf you continue using memory after it has been freed you may corrupt data from other programs or even another part of your own program.\nExample\nA working example including error checking and freeing:\nREMOVE ADS\nMemory Leaks\nA memory leak happens when dynamic memory is allocated but never freed.\nIf a memory leak happens in a loop or in a function that is called frequently it could take up too much memory and cause the computer to slow down.\nThere is a risk of a memory leak if a pointer to dynamic memory is lost before the memory can be freed. This can happen accidentally, so it is important to be careful and keep track of pointers to dynamic memory.\nHere are some examples of how a pointer to dynamic memory may be lost.\nExample 1\nThe pointer is overwritten:\nIn this example, after the pointer is changed to point at x, the memory allocated by calloc() can no longer be accessed.\nExample 2\nThe pointer exists only inside a function:\nIn this example, the memory that was allocated inside of the function remains allocated after the function ends but it cannot be accessed anymore. One way to prevent this problem is to free the memory before the function ends.\nExample 3\nThe pointer gets lost when reallocation fails:\nIf realloc() is unable to reallocate memory it will return a pointer to NULL and the original memory will remain reserved.\nIn this example, if realloc() fails then the NULL pointer is assigned to the ptr variable, overwriting the original memory address so that it cannot be accessed anymore.\nSummary\nIn summary, when managing memory in C, use best practices:\nRemember to check for errors (NULL return values) to find out if memory allocation was sucessful or not\nPrevent memory leaks - always remember to free memory that is no longer used, or else the program might underperform or even worse, crash if it runs out of memory\nSet the pointer to NULL after freeing memory so that you cannot accidentally continue using it\nTip: You will learn more about NULL in our NULL chapter.",
      "examples": [
        "free(pointer);",
        "int *ptr;\nptr = malloc(sizeof(*ptr));\n\nfree(ptr);\nptr = NULL;",
        "int *ptr;\nptr = malloc(sizeof(*ptr)); // Allocate memory for one integer\n\n// If memory cannot be allocated, print a message and end the main() function\nif (ptr == NULL) {\nprintf(\"Unable to allocate memory\");\nreturn 1;  // Exit the program with an error code\n}\n\n// Set the value of the integer\n*ptr = 20;\n\n// Print the integer value\nprintf(\"Integer value: %d\\n\", *ptr);\n\n// Free allocated memory\nfree(ptr);\n\n// Set the pointer to NULL to prevent it from being accidentally used\nptr = NULL;",
        "int x = 5;\nint *ptr;\nptr = calloc(2, sizeof(*ptr));\nptr = &x;",
        "void myFunction() {\nint *ptr;\nptr = malloc(sizeof(*ptr));\n}\n\nint main() {\nmyFunction();\nprintf(\"The function has ended\");\nreturn 0;\n}",
        "int* ptr;\nptr = malloc(sizeof(*ptr));\nptr = realloc(ptr, 2*sizeof(*ptr));",
        "free()",
        "NULL",
        "x",
        "calloc()",
        "realloc()",
        "ptr"
      ]
    },
    {
      "title": "C Structures and Dynamic Memory",
      "summary": "Structures and Dynamic Memory\nYou can also use dynamic memory with structures.\nThis is useful when you don't know how many structs you'll need in advance, or want to save memory by only allocating what's necessary (e.g., in a car dealership program where the number of cars is not fixed).\nAllocating Memory for a Struct\nYou can use the malloc() function to allocate memory for a struct pointer:\nExample\nTry it Yourself »\nExample Explained\nmalloc() allocates memory for one struct\nstrcpy() is used to copy a string into the brand field\nWe use -> to access members through the pointer\nfree() is used at the end to release the memory\nNote: malloc() allocates uninitialized memory. The content will be undefined until you assign values. If you want memory initialized to zero, you can use calloc().\nUsing Arrays of Structs\nYou can also allocate memory for multiple structs at once, like an array:\nExample: Allocate memory for 3 cars\nTry it Yourself »\nGrowing Arrays Later with realloc()\nIf you need more elements later, you can resize your dynamic array with realloc(). This may move the block to a new location and returns a new pointer. Always store the result in a temporary pointer first to avoid losing the original memory if reallocation fails.\nExample: Expand an array of structs\nTry it Yourself »\nNote: New space added by realloc() is uninitialized. Be sure to initialize newly added elements (e.g. strcpy(cars[2].brand, \"Kia\"); cars[2].year = 2022;) before using them.",
      "examples": [
        "#include <stdio.h> #include <stdlib.h> #include <string.h> struct Car { char brand[50]; int year; }; int main() { // Allocate memory for one Car struct struct Car *ptr = (struct Car*) malloc(sizeof(struct Car)); // Check if allocation was successful if (ptr == NULL) { printf(\"Memory allocation failed.\\n\"); return 1; // Exit the program with an error code } // Set values strcpy(ptr->brand, \"Honda\"); ptr->year = 2022; // Print values printf(\"Brand: %s\\n\", ptr->brand); printf(\"Year: %d\\n\", ptr->year); // Free memory free(ptr); return 0; }",
        "#include <stdio.h> #include <stdlib.h> #include <string.h> struct Car { char brand[50]; int year; }; int main() { struct Car *cars = (struct Car*) malloc(3 * sizeof(struct Car)); if (cars == NULL) { printf(\"Memory allocation failed.\\n\"); return 1 // Exit the program with an error code; } // Fill the data strcpy(cars[0].brand, \"Ford\"); cars[0].year = 2015; strcpy(cars[1].brand, \"BMW\"); cars[1].year = 2018; strcpy(cars[2].brand, \"Volvo\"); cars[2].year = 2023; // Print the data for (int i = 0; i < 3; i++) { printf(\"%s - %d\\n\", cars[i].brand, cars[i].year); } free(cars); return 0; }",
        "#include <stdio.h> #include <stdlib.h> #include <string.h> struct Car { char brand[50]; int year; }; int main() { int count = 2; struct Car *cars = (struct Car*) malloc(count * sizeof(struct Car)); if (cars == NULL) { printf(\"Initial allocation failed.\\n\"); return 1; } // Initialize first 2 cars strcpy(cars[0].brand, \"Toyota\"); cars[0].year = 2010; strcpy(cars[1].brand, \"Audi\"); cars[1].year = 2019; // Need one more car -> grow to 3 int newCount = 3; struct Car *tmp = (struct Car*) realloc(cars, newCount * sizeof(struct Car)); if (tmp == NULL) { // 'cars' is still valid here; free it to avoid a leak free(cars); printf(\"Reallocation failed.\\n\"); return 1; } cars = tmp; // use the reallocated block // Initialize the new element at index 2 strcpy(cars[2].brand, \"Kia\"); cars[2].year = 2022; // Print all cars for (int i = 0; i < newCount; i++) { printf(\"%s - %d\\n\", cars[i].brand, cars[i].year); } free(cars); return 0; }",
        "malloc()",
        "strcpy()",
        "brand",
        "->",
        "free()",
        "calloc()",
        "realloc()",
        "strcpy(cars[2].brand, \"Kia\"); cars[2].year = 2022;"
      ]
    },
    {
      "title": "C Memory Management Example",
      "summary": "Real-Life Memory Management Example\nTo demonstrate a practical example of dynamic memory, we created a program that can make a list of any length.\nRegular arrays in C have a fixed length and cannot be changed, but with dynamic memory we can create a list as long as we like:\nExample\nPointers to structures: This example has a pointer to the structure myList. Because we are using a pointer to the structure instead of the structure itself, we use the arrow syntax (->) to access the structure's members.\nExample explained\nThis example has three parts:\nA structure myList that contains a list's data\nThe main() function with the program in it.\nA function addToList() which adds an item to the list\nThe myList structure\nThe myList structure contains all of the information about the list, including its contents. It has three members:\ndata - A pointer to the dynamic memory which contains the contents of the list\nnumItems - Indicates the number of items that list has\nsize - Indicates how many items can fit in the allocated memory\nWe use a structure so that we can easily pass all of this information into a function.\nThe main() function\nThe main() function starts by initializing the list with space for 10 items:\nmyList.numItems is set to 0 because the list starts off empty.\nmyList.size keeps track of how much memory is reserved. We set it to 10 because we will reserve enough memory for 10 items.\nWe then allocate the memory and store a pointer to it in myList.data.\nThen we include error checking to find out if memory allocation was successful:\nIf everything is fine, a loop adds 44 items to the list using the addToList() function:\nIn the code above, &myList is a pointer to the list and i + 1 is a number that we want to add to the list. We chose i + 1 so that the list would start at 1 instead of 0. You can choose any number to add to the list.\nAfter all of the items have been added to the list, the next loop prints the contents of the list.\nWhen we finish printing the list we free the memory to prevent memory leaks.\nThe addToList() function\nOur addToList() function adds an item to the list. It takes two parameters:\nA pointer to the list.\nThe value to be added to the list.\nThe function first checks if the list is full by comparing the number of items in the list to the size (capacity). If the list is full, it tries to grow the memory to fit 10 more items. We use a temporary pointer with realloc so we don't lose the original block if the resize fails. We only update data and size after a successful resize:\nFinally, the function adds the item to the end of the list. The index at myList->numItems is always at the end of the list because it increases by 1 each time a new item is added.:\nWhy do we reserve 10 items at a time?\nOptimizing is a balancing act between memory and performance. Even though we may be allocating some memory that we are not using, reallocating memory too frequently can be inefficient. There is a balance between allocating too much memory and allocating memory too frequently.\nWe chose the number 10 for this example, but it depends on how much data you expect and how often it changes. For example, if we know beforehand that we are going to have exactly 44 items then we can allocate memory for exactly 44 items and only allocate it once.\nComplete stdlib Reference\nFor a complete reference of memory management functions and other functions found in the standard library, go to our C <stdlib.h> Library Reference.",
      "examples": [
        "void addToList(struct list *myList, int item)",
        "// If the list is full then resize the memory to fit 10 more items if (myList->numItems == myList->size) { int newSize = myList->size + 10; // Use a temp pointer so we don't lose the original on failure int *tmp = realloc(myList->data, newSize * sizeof(int)); if (tmp == NULL) { printf(\"Memory resize failed\\n\"); return; // Leave the list unchanged } // Only update fields after a successful reallocation myList->data = tmp; myList->size = newSize; }",
        "// Add the item to the end of the list myList->data[myList->numItems] = item; myList->numItems++;",
        "struct list {\nint *data; // Points to the memory where the list items are stored\nint numItems; // Indicates how many items are currently in the list\nint size; // Indicates how many items fit in the allocated memory\n};\n\nvoid addToList(struct list *myList, int item);\n\nint main() {\nstruct list myList;\nint amount;\nint i, j;\n\n// Create a list and start with enough space for 10 items\nmyList.numItems = 0;\nmyList.size = 10;\nmyList.data = malloc(myList.size * sizeof(int));\n\n// Find out if memory allocation was successful\nif (myList.data == NULL) {\nprintf(\"Memory allocation failed\");\nreturn 1; // Exit the program with an error code\n}\n\n// Add any number of items to the list specified by the amount variable\namount = 44;\nfor (i = 0; i < amount; i++) {\naddToList(&myList, i + 1);\n}\n\n// Display the contents of the list\nfor (j = 0; j < myList.numItems; j++) {\nprintf(\"%d \", myList.data[j]);\n}\n\n// Free the memory when it is no longer needed\nfree(myList.data);\nmyList.data = NULL;\n\nreturn 0;\n}\n\n// This function adds an item to a list\nvoid addToList(struct list *myList, int item) {\n\n// If the list is full then resize the memory to fit 10 more items\nif (myList->numItems == myList->size) {\nint newSize = myList->size + 10;\n\n// Use a temporary pointer so we don't lose the original on failure\nint *tmp = realloc(myList->data, newSize * sizeof(int));\nif (tmp == NULL) {\nprintf(\"Memory resize failed\\n\");\nreturn; // Leave the list unchanged\n}\n\n// Only update fields after a successful reallocation\nmyList->data = tmp;\nmyList->size = newSize;\n}\n\n// Add the item to the end of the list\nmyList->data[myList->numItems] = item;\nmyList->numItems++;\n}",
        "// Create a list and start with enough space for 10 items\nmyList.numItems = 0;\nmyList.size = 10;\nmyList.data = malloc(myList.size * sizeof(int));",
        "// Find out if memory allocation was successful\nif (myList.data == NULL) {\nprintf(\"Memory allocation failed\");\nreturn 1; // Exit the program with an error code\n}",
        "// Add any number of items to the list specified by the amount variable\namount = 44;\nfor (i = 0; i < amount; i++) {\naddToList(&myList, i + 1);\n}",
        "// Display the contents of the list\nfor (j = 0; j < myList.numItems; j++) {\nprintf(\"%d \", myList.data[j]);\n}",
        "// Free the memory when it is no longer needed\nfree(myList.data);\nmyList.data = NULL;",
        "myList",
        "->",
        "main()",
        "addToList()",
        "data",
        "numItems",
        "size",
        "myList.numItems",
        "myList.size",
        "myList.data",
        "&myList",
        "i + 1",
        "realloc",
        "myList->numItems"
      ]
    },
    {
      "title": "C Errors",
      "summary": "Errors\nEven experienced C developers make mistakes. The key is learning how to spot and fix them!\nThese pages cover common errors and helpful debugging tips to help you understand what's going wrong and how to fix it.\nCommon Compile-Time Errors\nCompile-time errors are mistakes that prevent your program from compiling.\n1) Missing semicolon:\nExample\nResult:\n2) Using undeclared variables:\nExample\nResult:\n3) Mismatched types (e.g. assigning a string to an int):\nExample\nResult:\nCommon Runtime Errors\nRuntime errors occur when the program compiles but crashes or behaves unexpectedly.\n1) Dividing by zero:\nExample\n2) Accessing out-of-bounds array elements:\nExample\n3) Using freed memory:\nExample\nGood Habits to Avoid Errors\nAlways initialize your variables\nUse meaningful variable names\nKeep your code clean and use indentation to stay organized\nKeep functions short and focused\nCheck if loops or conditions are running as expected\nRead error messages carefully - they often tell you exactly where the problem is\nIn the next chapter, you will learn how to debug your code - how to find and fix bugs/errors in your C program.",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nint x = 5\nprintf(\"%d\", x);\nreturn 0;\n}",
        "#include <stdio.h>\n\nint main() {\nprintf(\"%d\", myVar);\nreturn 0;\n}",
        "#include <stdio.h>\n\nint main() {\nint x = \"Hello\";\nreturn 0;\n}",
        "#include <stdio.h>\n\nint main() {\nint x = 10;\nint y = 0;\nint result = x / y;\nprintf(\"%d\\\\n\", result); // not possible\nreturn 0;\n}",
        "#include <stdio.h>\n\nint main() {\nint numbers[3] = {1, 2, 3};\nprintf(\"%d\\\\n\", numbers[8]); // element does not exist\nreturn 0;\n}",
        "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\nint* ptr = malloc(sizeof(int));\n*ptr = 10;\nfree(ptr);\nprintf(\"%d\\\\n\", *ptr); // Undefined behavior - accessing memory that was freed\nreturn 0;\n}",
        "error: expected ',' or ';' before 'printf'",
        "error: 'myVar' undeclared",
        "string",
        "int",
        "error: initialization makes integer from pointer without a cast"
      ]
    },
    {
      "title": "C Debugging",
      "summary": "Debugging\nDebugging is the process of finding and fixing errors (bugs) in your program.\nBugs are mistakes that make your program crash, behave incorrectly, or give the wrong output.\nBefore you start debugging, make sure your code is clean and organized:\nUse proper indentation to keep the structure clear.\nGive your variables clear, meaningful names that describe what they store.\nClean code is easier to read - and easier to debug!\nIn the sections below, we'll introduce several common debugging techniques.\n1. Print Debugging\nUse printf() to print values at different points in your code to see what's going wrong:\nIf you don't see \"After division\", the program crashed at x / y.\n2. Check Variable Values\nPrint variables to see if they are what you expect:\nExpected 15? That means the logic is wrong: try using x + y instead.\n3. Use a Debugger Tool\nIDEs like Visual Studio, Code::Blocks, and VS Code have built-in debuggers that work with C. These tools let you:\nPause your program using breakpoints\nStep through your code line by line\nWatch variables and see unexpected values as they change\nTip: Start with printf() debugging. Once you're comfortable, explore your IDE's debugger to get even better insights into your code.\n4. Learn from Error Messages\nThe C compiler and runtime errors often tell you what went wrong and where. For example:\nEasy solution: Fix the missing semicolon!\nDebugging with Safe Checks\nSome bugs, like dividing by zero (used in the first example of this page), are known to cause crashes.\nIf you know an operation could fail, you can check for it in advance and avoid the crash:\nExample\nNow, instead of crashing, the program prints an error message and continues running. This is an important part of writing safe, debuggable code.\nAnother Example - Out-of-Bounds Array Access\nAccessing elements outside the array is another common mistake.\nIn the example below, we use printf() to check the index value before using it:\nExample\nSummary\nUse printf() to print values and trace your code.\nRead error messages carefully - they often tell you what went wrong and where.\nAdd checks (like if (y != 0)) to avoid crashes before they happen.\nUse an IDE's debugger when you're ready for deeper debugging.\nDebugging helps you understand your program better and fix problems faster.\nError Handling\nWhile debugging is about finding and fixing mistakes in your code during development, error handling is a way to deal with problems while the program is running, and run specific code when something goes wrong.\nYou will learn about NULL Pointers and Error Handling in the next chapters.",
      "examples": [
        "int x = 10;\nint y = 0;\nprintf(\"Before division\\n\"); // Debug output\nint z = x / y; // Crashes (division by zero)\nprintf(\"After division\\n\"); // Never runs",
        "int x = 10;\nint y = 5;\nint result = x - y;\n\nprintf(\"Result: %d\\n\", result); // Result: 5",
        "int main() {\nint x = 10;\nint y = 0;\n\nprintf(\"Before division\\n\");\n\nif (y != 0) { // // Check that y is not zero before dividing\nint z = x / y;\nprintf(\"Result: %d\\n\", z);\n} else {\nprintf(\"Error: Division by zero!\\n\"); // // Print error message instead of crashing\n}\n\nprintf(\"After division\\n\");\nreturn 0;\n}",
        "int main() {\nint numbers[3] = {10, 20, 30};\nint index = 5;\n\nprintf(\"Index = %d\\n\", index);\nif (index >= 0 && index < 3) { // Make sure the index is within the valid range (0 to 2)\nprintf(\"Value = %d\\n\", numbers[index]);\n} else {\nprintf(\"Error: Index out of bounds!\\n\");\n}\n\nreturn 0;\n}",
        "printf()",
        "x / y",
        "15",
        "x + y",
        "error: expected ';' before 'printf'",
        "if (y != 0)"
      ]
    },
    {
      "title": "C NULL",
      "summary": "C NULL\nNULL is a special value that represents a \"null pointer\" - a pointer that does not point to anything.\nIt helps you avoid using pointers that are empty or invalid. You can compare a pointer to NULL to check if it is safe to use.\nMany C functions return NULL when something goes wrong. For example, fopen() returns NULL if a file cannot be opened, and malloc() returns NULL if memory allocation fails. We can check for this using an if statement, and print an error message if something goes wrong.\nIn this example, we try to open a file that does not exist. Since fopen() fails, it returns NULL and we print an error message:\nExample\nTry it Yourself »\nIf you try to allocate too much memory, malloc() may fail and return NULL:\nExample\nTry it Yourself »\nSummary\nNULL represents a null (empty) pointer\nIt signals that a pointer is not pointing anywhere\nYou can compare a pointer to NULL to check if it's safe to use\nFunctions like malloc() and fopen() return NULL if they fail\nTip: Always check if a pointer is NULL before using it. This helps avoid crashes caused by accessing invalid memory.",
      "examples": [
        "#include <stdio.h> int main() { FILE *fptr = fopen(\"nothing.txt\", \"r\"); if (fptr == NULL) { printf(\"Could not open file.\\n\"); return 1; } fclose(fptr); return 0; }",
        "#include <stdio.h> #include <stdlib.h> int main() { int *numbers = (int*) malloc(100000000000000 * sizeof(int)); if (numbers == NULL) { printf(\"Memory allocation failed.\\n\"); return 1; } printf(\"Memory allocation successful!\\n\"); free(numbers); numbers = NULL; return 0; }",
        "NULL",
        "fopen()",
        "malloc()",
        "if"
      ]
    },
    {
      "title": "C Error Handling",
      "summary": "Error Handling in C\nError handling lets you detect and respond to problems in your program, like a file that can't be opened or memory that can't be allocated, so your program doesn't crash or behave unexpectedly.\nUnlike some languages, C does not have built-in exception handling (like try/catch). Instead, C uses return values, global error codes, and helper functions like perror() and strerror().\nUsing Return Values\nIn the previous chapter, you learned that functions like fopen() return NULL when something goes wrong.\nYou can check for NULL using an if statement to detect and handle errors before your program crashes.\nIn the example below, we try to open a file that does not exist. Since fopen() fails, it returns NULL and we print an error message:\nResult:\nGet More Details\nIf you want more details about what went wrong, you can use the perror() function.\nIt prints a custom error message followed by a description of the last error that occurred:\nResult:\nUsing strerror() and errno\nerrno is a global variable that stores the error code from the last failed operation. You can include <errno.h> to access it, and strerror(errno) will convert the error code into a readable message:\nResult:\nCommon Error Codes\nError constants are defined in <errno.h>. You can compare errno to them to detect specific issues:\nResult:\nUsing exit() to Stop the Program\nIf you want to stop the program immediately when an error occurs, you can use exit(). It lets you return a status code to the operating system.\nExit codes help signal whether the program finished successfully or with an error, like:\n0 means success\nNon-zero values (like 1 or EXIT_FAILURE) indicate errors\nResult:\nCommon Exit Status Codes\nTip: You can use EXIT_SUCCESS and EXIT_FAILURE instead of numbers to make your code more readable.\nResult:\nSummary\nMany C functions return NULL when something goes wrong\nUse perror() to print a message about the error\nUse strerror(errno) to get the error message as a string\nerrno stores the error code from the last failed action\nYou can compare errno to values like ENOENT (file not found) or ENOMEM (not enough memory)\nUse exit() to stop the program early if there's an error\nTip: Always check for errors after file operations, memory allocation, and system calls. Ignoring errors can lead to unexpected behavior or crashes.",
      "examples": [
        "#include <stdio.h> int main() { FILE *fptr = fopen(\"nothing.txt\", \"r\"); if (fptr == NULL) { printf(\"Error opening file.\\\\n\"); return 1; } fclose(fptr); return 0; }",
        "#include <stdio.h> int main() { FILE *f = fopen(\"nothing.txt\", \"r\"); if (f == NULL) { perror(\"Error opening file\"); return 1; } fclose(f); return 0; }",
        "#include <stdio.h> #include <errno.h> #include <string.h> int main() { FILE *f = fopen(\"nothing.txt\", \"r\"); if (f == NULL) { printf(\"Error: %s\\n\", strerror(errno)); return 1; } fclose(f); return 0; }",
        "#include <stdio.h> #include <errno.h> int main() { FILE *f = fopen(\"nothing.txt\", \"r\"); if (f == NULL) { if (errno == ENOENT) { printf(\"The file was not found.\\n\"); } else { printf(\"Some other file error occurred.\\n\"); } return 1; } fclose(f); return 0; }",
        "#include <stdio.h> #include <stdlib.h> int main() { FILE *f = fopen(\"nothing.txt\", \"r\"); if (f == NULL) { printf(\"Failed to open file.\\n\"); exit(1); } fclose(f); return 0; }",
        "#include <stdio.h> #include <stdlib.h> int main() { FILE *f = fopen(\"nothing.txt\", \"r\"); if (f == NULL) { perror(\"Could not open nothing.txt\"); exit(EXIT_FAILURE); // More readable than exit(1) } fclose(f); return EXIT_SUCCESS; }",
        "perror()",
        "strerror()",
        "fopen()",
        "NULL",
        "if",
        "Error opening file.",
        "Error opening file: No such file or directory",
        "errno",
        "<errno.h>",
        "strerror(errno)",
        "Error: No such file or directory",
        "ENOENT",
        "EACCES",
        "ENOMEM",
        "EINVAL",
        "The file was not found.",
        "exit()",
        "0",
        "1",
        "EXIT_FAILURE",
        "Failed to open file.",
        "<stdlib.h>",
        "EXIT_SUCCESS",
        "Could not open nothing.txt: No such file or directory"
      ]
    },
    {
      "title": "C Input Validation",
      "summary": "Input Validation\nWhen users enter data into a C program, they might type something unexpected. Input validation makes sure the input is correct before the program continues.\nWithout validation, your program might crash or give the wrong result!\nThe examples below show simple ways to check if the user's input is valid in C.\nValidate Number Range\nCheck if the number is within an allowed range (for example, 1 to 5):\nExample\nExample Result:\nValidate Text Input\nCheck that a name is not empty. Use fgets() and check the first character:\nExample\nExample Result:\nValidate Integer Input\nMake sure the user enters a number. If they enter something else (like a letter), ask again using fgets() and sscanf():\nExample\nExample Result:\nTip: You can read more about fgets() and sscanf() in our <stdio.h> library reference.",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nint number; // Variable to store the user's number\n\ndo {\nprintf(\"Choose a number between 1 and 5: \");\nscanf(\"%d\", &number); // Read number input\nwhile (getchar() != '\\n'); // Clear leftover characters from input buffer\n} while (number < 1 || number > 5); // Keep asking until number is between 1 and 5\n\nprintf(\"You chose: %d\\n\", number); // Print the valid number\nreturn 0;\n}",
        "#include <stdio.h>\n#include <string.h>\n\nint main() {\nchar name[100]; // Buffer to store the user's name\n\ndo {\nprintf(\"Enter your name: \");\nfgets(name, sizeof(name), stdin); // Read input as a string\nname[strcspn(name, \"\\n\")] = 0; // Remove the newline character if present\n} while (strlen(name) == 0); // Repeat if the input is empty\n\nprintf(\"Hello, %s\\n\", name); // Greet the user\nreturn 0;\n}",
        "#include <stdio.h>\n\nint main() {\nint number;       // Variable to store the user's number\nchar input[100];  // Buffer to hold user input as a string\n\nprintf(\"Enter a number: \");\n\n// Keep reading input until the user enters a valid integer\nwhile (fgets(input, sizeof(input), stdin)) {\n// Try to read an integer from the input string\nif (sscanf(input, \"%d\", &number) == 1) {\nbreak; // Success: break out of the loop\n} else {\nprintf(\"Invalid input. Try again: \"); // If not an integer, ask again\n}\n}\n\n// Print the valid number entered by the user\nprintf(\"You entered: %d\\n\", number);\nreturn 0;\n}",
        "Choose a number between 1 and 5: 8\nChoose a number between 1 and 5: -2\nChoose a number between 1 and 5: 4\nYou chose: 4",
        "fgets()",
        "Enter your name:\nEnter your name:\nEnter your name: John\nHello, John",
        "sscanf()",
        "Enter a number: AB\nInvalid input. Try again: 3.5\nInvalid input. Try again: 35\nYou entered: 35"
      ]
    },
    {
      "title": "C Date and Time",
      "summary": "Time and Date\nIn C, you can use the <time.h> header to work with dates and times.\nThis library lets you get the current time, format it, and perform time-related calculations.\nGetting the Current Time\nThe <time.h> library has a variety of functions to measure dates and times.\nFor example, the time() function returns the current time as a value of type time_t.\nYou can use ctime() to convert the time into a readable string, like \"Mon Jun 24 10:15:00 2025\":\nExample\nTry it Yourself »\nBreaking Down the Time\nIf you want to access individual parts of the date or time, like the year, month, or hour, you can use the localtime() function.\nThis function converts the current time (from time()) into a struct tm, which is a special structure that holds the date and time in separate fields.\nHere's how you can use it to print each part of the current date and time:\nExample\nTry it Yourself »\nNote: The tm_year stores the number of years since 1900, so we add 1900 to get the full year, and tm_mon starts from 0 (so 0 = January, 11 = December).\nNote: We use -> because localtime() returns a pointer to a struct tm.\nAs you learned in the Structs & Pointers chapter: If you have a pointer to a struct, use -> to access its members. Use the dot . only when you're working with the struct directly, not a pointer to it.\nFormatting Date and Time\nYou can use strftime() to format the date and time as a string:\nExample\nTry it Yourself »\nWhen to use Date and Time\nUse date and time in C when you want to:\nDisplay the current time or date\nLog events like errors or user actions\nAdd timestamps to files or messages\nMeasure how long something takes\nSchedule or delay actions",
      "examples": [
        "#include <stdio.h> #include <time.h> int main() { time_t currentTime; time(&currentTime); // Get the current time printf(\"Current time: %s\", ctime(&currentTime)); return 0; }",
        "#include <stdio.h> #include <time.h> int main() { time_t now = time(NULL); // Get current time struct tm *t = localtime(&now); // Convert to local time structure printf(\"Year: %d\\n\", t->tm_year + 1900); // Add 1900 to get the actual year printf(\"Month: %d\\n\", t->tm_mon + 1); // Months are numbered from 0 to 11, so add 1 to match real month numbers (1-12) printf(\"Day: %d\\n\", t->tm_mday); printf(\"Hour: %d\\n\", t->tm_hour); printf(\"Minute: %d\\n\", t->tm_min); printf(\"Second: %d\\n\", t->tm_sec); return 0; }",
        "#include <stdio.h> #include <time.h> int main() { time_t now = time(NULL); struct tm *t = localtime(&now); char buffer[100]; strftime(buffer, sizeof(buffer), \"%d-%m-%Y %H:%M:%S\", t); printf(\"Formatted time: %s\\n\", buffer); return 0; }",
        "<time.h>",
        "time()",
        "time_t",
        "ctime()",
        "localtime()",
        "struct tm",
        "tm_year",
        "tm_mon",
        "->",
        "struct",
        ".",
        "strftime()"
      ]
    },
    {
      "title": "C Preprocessor and Macros",
      "summary": "Preprocessor and Macros\nIn C, the preprocessor runs before the actual compilation begins. It handles things like including files and defining macros.\nPreprocessor commands begin with a # symbol and are called directives.\n#include - Include Header Files\nYou have already seen the #include directive many times - It tells the compiler to include a file.\nIt is used to add libraries or custom header files:\nExample\nUse angle brackets < > for standard libraries and double quotes \" \" for your own files.\nTip: The most commonly used libraries can be found in our C Reference Documentation.\n#define - Create a Macro\nA macro is a name that represents a value (like PI), or a piece of code, defined using the #define directive.\nIn the example below, PI is replaced with 3.14 before the program is compiled.\nThis means that every time PI appears in the code, it will be replaced with 3.14:\nExample\nMacros can also take parameters, like a function:\nExample\nMacros with parameters work like shortcuts, but be careful with parentheses to avoid mistakes.\n#ifdef and #ifndef - Conditional Compilation\nThe #ifdef and #ifndef directives let you include or skip parts of the code depending on whether a macro is defined.\nThis is called conditional compilation, and it's useful for debugging or creating different versions of a program.\nExample\nIf DEBUG is defined, the message will be printed. If it's not defined, that part of the code is skipped.\nCreate Your own Header Files\nIn the next chapter, you will learn how to create your own header files and organize your code across multiple files using \"modular programming\".",
      "examples": [
        "#include <stdio.h>\n#include \"myfile.h\"",
        "#define PI 3.14\n\nint main() {\nprintf(\"Value of PI: %.2f\\n\", PI);\nreturn 0;\n}",
        "#define SQUARE(x) ((x) * (x))\n\nint main() {\nprintf(\"Square of 4: %d\\n\", SQUARE(4));\nreturn 0;\n}",
        "#define DEBUG\n\nint main() {\n#ifdef DEBUG\nprintf(\"Debug mode is ON\\n\");\n#endif\nreturn 0;\n}",
        "#",
        "#include",
        "< >",
        "\" \"",
        "#define",
        "PI",
        "3.14",
        "#ifdef",
        "#ifndef",
        "DEBUG"
      ]
    },
    {
      "title": "C Organize Code",
      "summary": "Organize Your Code - Modular Programming\nIn C programming, modular programming means splitting your code into smaller, reusable parts.\nThis makes your code easier to read, maintain, and debug.\nThe most common way to organize C programs is by using separate .c files and .h header files.\nEven though this approach is not required for small beginner programs, it is very useful for larger projects or more experienced programmers who want to keep their code clean and well-structured.\nWhy Use Header Files?\nTo declare functions that are defined in another file\nTo share variables, constants, or macros across files\nTo organize your code into logical modules\nTip: Header files usually contain function declarations, macros, and struct definitions.\nExample: Creating a Header File\nIn this example, you will learn how to create your own header file and use it to organize code across multiple files.\nLet's create a simple calculator module with a header file and a source file.\nStart by creating a header file named calc.h to declare the functions:\nThe calc.h file:\nExample Explained\nThe #ifndef, #define, and #endif lines are called an include guard.\nThey prevent the file from being included more than once by mistake, which can cause errors during compilation.\nThis is a common and recommended practice in all C header files.\nThis file itself contains declarations of two functions: add() and subtract().\nWriting the Function Definitions\nNext, write the function definitions inside your calc.c file:\nThe calc.c file:\nThis file defines the functions declared in calc.h.\nUsing the Module in main.c\nFinally, write the main program in main.c and include the header file to use the calculator functions:\nThe main.c file:\nResult:\nHow to Compile Multiple Files\nWhen your program is split across multiple files, you need to compile them together. For example:\nThis tells the compiler to build one executable named program from both main.c and calc.c.",
      "examples": [
        "#ifndef CALC_H #define CALC_H int add(int x, int y); int subtract(int x, int y); #endif",
        "#include \"calc.h\" int add(int x, int y) { return x + y; } int subtract(int x, int y) { return x - y; }",
        "#include <stdio.h> #include \"calc.h\" int main() { printf(\"5 + 5 = %d\\n\", add(5, 5)); printf(\"6 - 4 = %d\\n\", subtract(6, 4)); return 0; }",
        "gcc main.c calc.c -o program",
        ".c",
        ".h",
        "calc.h",
        "#ifndef",
        "#define",
        "#endif",
        "add()",
        "subtract()",
        "calc.c",
        "main.c",
        "5 + 5 = 10\n6 - 4 = 2",
        "program"
      ]
    },
    {
      "title": "C Storage Classes",
      "summary": "C Storage Classes\nStorage classes define the lifetime, visibility, and memory location of variables.\nThere are four main storage class specifiers in C:\nauto\nstatic\nregister\nextern\nScope defines where a variable can be used, and storage classes define how long it lasts and where it's stored. This chapter continues from the C Scope chapter.\nauto\nThe auto keyword is used for local variables. It is default for variables declared inside functions, so it's rarely used explicitly.\nExample\nTry it Yourself »\nstatic\nThe static keyword changes how a variable or function behaves in terms of lifetime and visibility:\nStatic local variables keep their value between function calls.\nStatic global variables/functions are not visible outside their file.\nExample\nResult:\nTry it Yourself »\nTry to remove the static keyword from the example to see the difference.\nregister\nThe register keyword suggests that the variable should be stored in a CPU register (for faster access).\nYou cannot take the address of a register variable using &.\nNote: The register keyword is mostly obsolete - modern compilers automatically choose the best variables to keep in registers, so you usually don't need to use it.\nExample\nTry it Yourself »\nextern\nThe extern keyword tells the compiler that a variable or function is defined in another file.\nIt is commonly used when working with multiple source files.\nFile 1: main.c\nFile 2: data.c\nCompile both files together:",
      "examples": [
        "int main() { auto int x = 50; // Same as just: int x = 50; printf(\"%d\\n\", x); return 0; }",
        "void count() { static int myNum = 0; // Keeps its value between calls myNum++; printf(\"num = %d\\n\", myNum); } int main() { count(); count(); count(); return 0; }",
        "num = 1 num = 2 num = 3",
        "int main() { register int counter = 0; printf(\"Counter: %d\\n\", counter); return 0; }",
        "#include <stdio.h> extern int shared; // Declared here, defined in another file int main() { printf(\"shared = %d\\n\", shared); return 0; }",
        "int shared = 50; // Definition of the variable",
        "gcc main.c data.c -o program",
        "auto",
        "static",
        "register",
        "extern",
        "&",
        "main.c",
        "data.c"
      ]
    },
    {
      "title": "C Projects",
      "summary": "Projects and Practical Applications\nLearn how to apply your C knowledge to real-world projects.\nIn this section, we will build mini applications using the features you've learned throughout the tutorial.\nWhy Build Projects?\nProjects are an essential part of learning C. Start small and gradually add more features:\nUnderstand how real programs are structured\nPractice combining concepts (e.g., functions, loops, file handling)\nImprove your debugging and problem-solving skills\nPrepare for job interviews and relevant exercises\nTip: The more you build, the better you understand.\nProject Examples\nSome examples of fun C projects could be:\nCalculate a Students Average\nSimple Calculator\nAddress Book\nTo-Do List\nGuess a Number Game\nQuiz Game\nProject: Calculate a Students Average\nLet's create a program to calculate a student's average from multiple grades.\nThe program asks the user to enter 1 to 5 grades and calculates the average. Then display the average and a corresponding letter grade (A to F):\nExample\nExample output:\nKey Concepts Used: loops, functions, conditions, input handling, and basic logic.\nPractice Challenge\nTry to make your own projects. For example, write a program that:\nAsks for your name\nAsks for your age\nPrints: Hi <name>! You will turn <age+1> next year.\nOpen CodeBlocks or any similar IDE for C, and experiment on your own!\nStart small. Add one feature at a time. Remember to test often!\nTip: We have also gathered a set of simple projects in our Real Life Examples page.",
      "examples": [
        "// This function returns a letter grade based on the average\nchar gradeFunction(double avg) {\nif (avg >= 90) return 'A';\nelse if (avg >= 80) return 'B';\nelse if (avg >= 70) return 'C';\nelse if (avg >= 60) return 'D';\nelse return 'F';\n}\n\nint main(void) {\nint count;\ndouble sum = 0, grade;\n\n// Ask the user to enter total grades between 1 to 5\nprintf(\"How many grades (1 to 5)? \");\nscanf(\"%d\", &count);\n\n// Validate that count is between 1 and 5\nif (count < 1 || count > 5) {\nprintf(\"Invalid number. You must enter between 1 and 5 grades.\\n\");\nreturn 1;  // Exit\n}\n\n// Loop to collect each grade\nfor (int i = 1; i <= count; i++) {\nprintf(\"Enter grade %d: \", i);\nscanf(\"%lf\", &grade);\nsum += grade;\n}\n\n// Calculate the average score\ndouble avg = sum / count;\n\n// Display numeric average\nprintf(\"Average: %.2f\\n\", avg);\n\n// Display letter grade\nprintf(\"Letter grade: %c\\n\", gradeFunction(avg));\n\nreturn 0;\n}",
        "How many grades (1 to 5)? 3\nEnter grade 1: 85\nEnter grade 2: 91\nEnter grade 3: 78\nAverage: 84.6667\nLetter grade: B",
        "Hi <name>! You will turn <age+1> next year."
      ]
    },
    {
      "title": "C Reference Documentation",
      "summary": "This section contains a C reference documentation.\nC Reference\nA list of C keywords and popular libraries can be found here:",
      "examples": []
    },
    {
      "title": "C Keywords",
      "summary": "C Keywords\nA list of useful C keywords can be found in the table below.",
      "examples": [
        "int",
        "char"
      ]
    },
    {
      "title": "C stdio (stdio.h) Library",
      "summary": "C stdio Functions\nThe <stdio.h> header provides a variety of functions for input, output and file handling.\nA list of all stdio functions can be found in the table below:",
      "examples": [
        "<stdio.h>",
        "char"
      ]
    },
    {
      "title": "C stdlib (stdlib.h) Library",
      "summary": "C stdlib Functions\nThe <stdlib.h> header (standard library) provides a variety of commonly used functions.",
      "examples": [
        "<stdlib.h>",
        "double",
        "int",
        "long int",
        "long long int"
      ]
    },
    {
      "title": "C string (string.h) Library",
      "summary": "C string Functions\nThe <string.h> library has many functions that allow you to perform tasks on strings.\nA list of all string functions can be found in the table below:\nRelated Pages\nC Strings Tutorial",
      "examples": [
        "<string.h>"
      ]
    },
    {
      "title": "C math (math.h) Library",
      "summary": "C Math Functions\nThe <math.h> library has many functions that allow you to perform mathematical tasks on numbers.\nRelated Pages\nC Math Tutorial\nC Functions Tutorial",
      "examples": [
        "<math.h>"
      ]
    },
    {
      "title": "C ctype (ctype.h) Library",
      "summary": "C ctype Functions\nThe <ctype.h> header provides many functions for classifying and modifying characters.",
      "examples": [
        "<ctype.h>"
      ]
    },
    {
      "title": "C time (time.h) Library",
      "summary": "C time Functions\nThe <time.h> header provides functions for working with dates, times, and measuring durations in C.\nA list of common time.h functions can be found in the table below:\nSeveral functions return or use a special structure called struct tm, which holds individual parts of the date and time like year, month, hour, and minute.\nYou can use this structure to format and access each time component separately.\nRelated Pages\nC Date and Time Tutorial",
      "examples": [
        "<time.h>",
        "time.h",
        "time_t",
        "struct tm",
        "Thu Jun 26 10:30:00 2025"
      ]
    },
    {
      "title": "C Examples",
      "summary": "Syntax\nOutput/Print\nComments\nVariables\nData Types and Format Specifiers\nConstants\nOperators\nBooleans\nIf...Else (Conditions)\nSwitch\nLoops\nArrays\nStrings\nUser Input\nMemory Address/References\nPointers\nFunctions\nFiles\nStructures\nEnums\nMemory Management",
      "examples": []
    },
    {
      "title": "C Real-Life Examples",
      "summary": "Practical Examples\nThis page contains a list of practical examples used in real world projects.\nVariables and Data Types\nExample\nUse variables to store different data of a college student:\nExample\nCalculate the area of a rectangle (by multiplying the length and width):\nExample\nUse different data types to calculate and output the total cost of a number of items:\nExample\nCalculate the percentage of a user's score in relation to the maximum score in a game:\nFor a tutorial about variables and data types in C, visit our Variables Chapter and Data Types Chapter.\nBooleans\nExample\nFind out if a person is old enough to vote:\nYou could also wrap the code above in an if...else to perform different actions depending on the result:\nExample\nOutput \"Old enough to vote!\" if myAge is greater than or equal to 18. Otherwise output \"Not old enough to vote.\":\nFor a tutorial about booleans in C, visit our Booleans Chapter.\nConditions (If..Else)\nExample\nUse if..else statements to output some text depending on what time it is:\nExample\nCheck whether the user enters the correct code:\nExample\nFind out if a number is positive or negative:\nExample\nFind out if a person is old enough to vote:\nExample\nFind out if a number is even or odd:\nFor a tutorial about conditions in C, visit our If..Else Chapter.\nSwitch\nExample\nUse the weekday number to calculate and output the weekday name:\nFor a tutorial about switch in C, visit our Switch Chapter.\nWhile Loops\nExample\nUse a while loop to create a simple \"countdown\" program:\nExample\nUse a while loop to play a game of Yatzy:\nExample\nUse a while loop to reverse some numbers:\nFor a tutorial about while loops in C, visit our While Loop Chapter.\nFor Loops\nExample\nUse a for loop to create a program that only print even values between 0 and 10:\nExample\nUse a for loop to create a program that counts to 100 by tens:\nExample\nUse a for loop to print the powers of 2 up to 512:\nExample\nUse a for loop to create a program that prints the multiplication table of a specified number (2 in this example):\nFor a tutorial about for loops in C, visit our For Loop Chapter.\nArrays\nExample\nCreate a program that calculates the average of different ages:\nExample\nCreate a program that finds the lowest age among different ages:\nFor a tutorial about arrays in C, visit our Arrays Chapter.\nStrings\nExample\nUse strings to create a simple welcome message:\nExample\nCreate a program that counts the number of characters found in a specific word:\nFor a tutorial about strings in C, visit our Strings Chapter.\nUser Input\nExample\nGet the name of a user and print it:\nFor a tutorial about user input in C, visit our User Input Chapter.\nFunctions\nExample\nUse a function to create a program that converts a value from fahrenheit to celsius:\nFor a tutorial about functions in C, visit our Functions Chapter.\nStructures\nExample\nUse a structure to store and output different information about Cars:\nFor a tutorial about structures in C, visit our Structures Chapter.\nMemory Management\nExample\nFor a tutorial about memory management in C, visit our Memory Management Chapter.",
      "examples": [
        "// Student data\nint studentID = 15;\nint studentAge = 23;\nfloat studentFee = 75.25;\nchar studentGrade = 'B';\n\n// Print variables\nprintf(\"Student id: %d\\n\", studentID);\nprintf(\"Student age: %d\\n\", studentAge);\nprintf(\"Student fee: %f\\n\", studentFee);\nprintf(\"Student grade: %c\", studentGrade);",
        "// Create integer variables\nint length = 4;\nint width = 6;\nint area;\n\n// Calculate the area of a rectangle\narea = length * width;\n\n// Print the variables\nprintf(\"Length is: %d\\n\", length);\nprintf(\"Width is: %d\\n\", width);\nprintf(\"Area of the rectangle is: %d\", area);",
        "// Create variables of different data types\nint items = 50;\nfloat cost_per_item = 9.99;\nfloat total_cost = items * cost_per_item;\nchar currency = '$';\n\n// Print variables\nprintf(\"Number of items: %d\\n\", items);\nprintf(\"Cost per item: %.2f %c\\n\", cost_per_item, currency);\nprintf(\"Total cost = %.2f %c\\n\", total_cost, currency);",
        "// Set the maximum possible score in the game to 500\nint maxScore = 500;\n\n// The actual score of the user\nint userScore = 423;\n\n// Calculate the percantage of the user's score in relation to the maximum available score\nfloat percentage = (float) userScore / maxScore * 100.0;\n\n// Print the percentage\nprintf(\"User's percentage is %.2f\", percentage);",
        "int myAge = 25;\nint votingAge = 18;\n\nprintf(\"%d\", myAge >= votingAge); // Returns 1 (true), meaning 25 year olds are allowed to vote!",
        "int myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\nprintf(\"Old enough to vote!\");\n} else {\nprintf(\"Not old enough to vote.\");\n}",
        "int time = 20;\nif (time < 18) {\nprintf(\"Good day.\");\n} else {\nprintf(\"Good evening.\");\n}",
        "int doorCode = 1337;\n\nif (doorCode == 1337) {\nprintf(\"Correct code.\\nThe door is now open.\");\n} else {\nprintf(\"Wrong code.\\nThe door remains closed.\");\n}",
        "int myNum = 10;\n\nif (myNum > 0) {\nprintf(\"The value is a positive number.\");\n} else if (myNum < 0) {\nprintf(\"The value is a negative number.\");\n} else {\nprintf(\"The value is 0.\");\n}",
        "int myNum = 5;\n\nif (myNum % 2 == 0) {\nprintf(\"%d is even.\\n\", myNum);\n} else {\nprintf(\"%d is odd.\\n\", myNum);\n}",
        "int day = 4;\n\nswitch (day) {\ncase 1:\nprintf(\"Monday\");\nbreak;\ncase 2:\nprintf(\"Tuesday\");\nbreak;\ncase 3:\nprintf(\"Wednesday\");\nbreak;\ncase 4:\nprintf(\"Thursday\");\nbreak;\ncase 5:\nprintf(\"Friday\");\nbreak;\ncase 6:\nprintf(\"Saturday\");\nbreak;\ncase 7:\nprintf(\"Sunday\");\nbreak;\n}",
        "int countdown = 3;\n\nwhile (countdown > 0) {\nprintf(\"%d\\n\", countdown);\ncountdown--;\n}\n\nprintf(\"Happy New Year!!\\n\");",
        "int dice = 1;\n\nwhile (dice <= 6) {\nif (dice < 6) {\nprintf(\"No Yatzy\\n\");\n} else {\nprintf(\"Yatzy!\\n\");\n}\ndice = dice + 1;\n}",
        "// A variable with some specific numbers\nint numbers = 12345;\n\n// A variable to store the reversed number\nint revNumbers = 0;\n\n// Reverse and reorder the numbers\nwhile (numbers) {\n// Get the last number of 'numbers' and add it to 'revNumber'\nrevNumbers = revNumbers * 10 + numbers % 10;\n// Remove the last number of 'numbers'\nnumbers /= 10;\n}",
        "int i;\n\nfor (i = 0; i <= 10; i = i + 2) {\nprintf(\"%d\\n\", i);\n}",
        "for (i = 0; i <= 100; i += 10) {\nprintf(\"%d\\n\", i);\n}",
        "for (i = 2; i <= 512; i *= 2) {\nprintf(\"%d\\n\", i);\n}",
        "int number = 2;\nint i;\n\n// Print the multiplication table for the number 2\nfor (i = 1; i <= 10; i++) {\nprintf(\"%d x %d = %d\\n\", number, i, number * i);\n}\n\nreturn 0;",
        "// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\nint i;\n\n// Get the length of the array\nint length = sizeof(ages) / sizeof(ages[0]);\n\n// Loop through the elements of the array\nfor (int i = 0; i < length; i++) {\nsum += ages[i];\n}\n\n// Calculate the average by dividing the sum by the length\navg = sum / length;\n\n// Print the average\nprintf(\"The average age is: %.2f\", avg);",
        "// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\n// Get the length of the array\nint length = sizeof(ages) / sizeof(ages[0]);\n\n// Create a variable and assign the first array element of ages to it\nint lowestAge = ages[0];\n\n// Loop through the elements of the ages array to find the lowest age\nfor (int i = 0; i < length; i++) {\nif (lowestAge > ages[i]) {\nlowestAge = ages[i];\n}\n}",
        "char message[] = \"Good to see you,\";\nchar fname[] = \"John\";\n\nprintf(\"%s %s!\", message, fname);",
        "char word[] = \"Computer\";\nprintf(\"The word '%s' has %d characters in it.\", word, strlen(word));",
        "char fullName[30];\n\nprintf(\"Type your full name: \\n\");\nfgets(fullName, sizeof(fullName), stdin);\n\nprintf(\"Hello %s\", fullName);",
        "// Function to convert Fahrenheit to Celsius\nfloat toCelsius(float fahrenheit) {\nreturn (5.0 / 9.0) * (fahrenheit - 32.0);\n}\n\nint main() {\n// Set a fahrenheit value\nfloat f_value = 98.8;\n\n// Call the function with the fahrenheit value\nfloat result = toCelsius(f_value);\n\n// Print the fahrenheit value\nprintf(\"Fahrenheit: %.2f\\n\", f_value);\n\n// Print the result\nprintf(\"Convert Fahrenheit to Celsius: %.2f\\n\", result);\n\nreturn 0;\n}",
        "struct Car {\nchar brand[50];\nchar model[50];\nint year;\n};\n\nint main() {\nstruct Car car1 = {\"BMW\", \"X5\", 1999};\nstruct Car car2 = {\"Ford\", \"Mustang\", 1969};\nstruct Car car3 = {\"Toyota\", \"Corolla\", 2011};\n\nprintf(\"%s %s %d\\n\", car1.brand, car1.model, car1.year);\nprintf(\"%s %s %d\\n\", car2.brand, car2.model, car2.year);\nprintf(\"%s %s %d\\n\", car3.brand, car3.model, car3.year);\n\nreturn 0;\n}",
        "struct list {\nint *data; // Points to the memory where the list items are stored\nint numItems; // Indicates how many items are currently in the list\nint size; // Indicates how many items fit in the allocated memory\n};\n\nvoid addToList(struct list *myList, int item);\n\nint main() {\nstruct list myList;\nint amount;\n\n// Create a list and start with enough space for 10 items\nmyList.numItems = 0;\nmyList.size = 10;\nmyList.data = malloc(myList.size * sizeof(int));\n\n// Find out if memory allocation was successful\nif (myList.data == NULL) {\nprintf(\"Memory allocation failed\");\nreturn 1; // Exit the program with an error code\n}\n\n// Add any number of items to the list specified by the amount variable\namount = 44;\nfor (int i = 0; i < amount; i++) {\naddToList(&myList, i + 1);\n}\n\n// Display the contents of the list\nfor (int j = 0; j < myList.numItems; j++) {\nprintf(\"%d \", myList.data[j]);\n}\n\n// Free the memory when it is no longer needed\nfree(myList.data);\nmyList.data = NULL;\n\nreturn 0;\n}\n\n// This function adds an item to a list\nvoid addToList(struct list *myList, int item) {\n\n// If the list is full then resize the memory to fit 10 more items\nif (myList->numItems == myList->size) {\nmyList->size += 10;\nmyList->data = realloc( myList->data, myList->size * sizeof(int) );\n}\n\n// Add the item to the end of the list\nmyList->data[myList->numItems] = item;\nmyList->numItems++;\n}",
        "if...else",
        "myAge",
        "18"
      ]
    },
    {
      "title": "C Exercises",
      "summary": "Exercises\nTest your C skills with exercises from all categories:\nSyntax\nStatements\nOutput\nNew Lines\nComments\nVariables\nFormat Specifiers\nChange Values\nMultiple Variables\nVariable Names\nData Types\nCharacter Data Types\nNumeric Data Types\nDecimal Precision\nThe sizeof Operator\nType Conversion\nConstants\nOperators\nBooleans\nIf\nElse\nElse If\nShort Hand If Else\nSwitch\nWhile Loop\nDo While Loop\nFor Loop\nNested Loops\nBreak and Continue\nArrays\nArray Size\nMultidimensional Arrays\nStrings\nSpecial Characters\nString Functions\nUser Input\nMemory Address\nPointers\nPointers and Arrays\nFunctions\nFunction Parameters\nScope\nFunction Declaration\nRecursion\nMath\nCreate Files\nWrite To Files\nRead Files\nStructures\nStructures and Pointers\nUnions\nEnums\nMemory Management\nAllocate Memory\nAccess Memory\nReallocate Memory\nDeallocate Memory\nErrors\nLog in to track your progress\nIf you haven't already, sign up to become a W3Schooler, and get points for every exercise you complete.\nAs a logged on W3Schools user you will have access to many features like having your own web page, track your learning progress, receive personal guided paths, and more.\nThe Exercise\nThe exercises are a mix of \"multiple choice\" and \"fill in the blanks\" questions. There are between 3 and 9 questions in each category. The answer can be found in the corresponding tutorial chapter. If you're stuck, or answer wrong, you can try again or hit the \"Show Answer\" button to see the correct answer.\nIf you don't know C, we suggest that you read our C Tutorial from scratch.",
      "examples": []
    },
    {
      "title": "C Quiz",
      "summary": "You can test your C skills with W3Schools' Quiz.\nThe Test\nThe test contains 25 questions and there is no time limit.\nThe test is not official, it's just a nice way to see how much you know about C.\nCount Your Score\nYou will get 1 point for each correct answer. At the end of the Quiz, your total score will be displayed. Maximum score is 25 points.\nStart the Quiz\nGood luck!\nStart the C Quiz ❯\nIf you do not know C, we suggest that you read our C Tutorial from scratch.",
      "examples": []
    },
    {
      "title": "C Compiler",
      "summary": "C Compiler (Editor)\nWith our online C compiler, you can edit C code, and view the result in your browser.\nExample\nClick on the \"Try it Yourself\" button to see how it works.\nC Compiler Explained\nThe window to the left is editable - edit the code and click on the \"Run\" button to view the result in the right window.\nThe icons are explained in the table below:\nIf you don't know C, we suggest that you read our C Tutorial from scratch.",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\");\nreturn 0;\n}",
        "Hello World!"
      ]
    },
    {
      "title": "C Syllabus",
      "summary": "Introduction\nThe W3Schools C Tutorial is comprehensive and beginner-friendly.\nIt will give you a fundamental knowledge of C.\nIt is designed for beginners and requires no prior experience with programming.\nThe content has been carefully made to be bite-sized, simple, and easy to understand.\nThe content has been proven by millions of users over the years. It is updated and improved frequently.\nThe syllabus outline and its sequence are structured so you can learn C step by step, from the introduction to creating your first application with C.\nGet Started With C »\nLearning Outcomes\nUnderstand what the C programming language is and how to write code.\nLearn C syntax and structure.\nUse variables and data types to store and manage data.\nUnderstand and use printf() and scanf() for input and output.\nWrite simple decision-making code with if, else, and switch.\nCreate loops using for, while, and do...while.\nLearn about functions to create reusable code.\nWork with arrays to store multiple values.\nUnderstand pointers and how they are used in C.\nLearn file handling for reading and writing files.\nWrite and run C programs.\nNote: Are you a teacher teaching C programming? W3Schools Academy is a toolbox of features that can help you teach. It offers classroom features such as pre-built study plans, classroom administration and much more. Read more about Academy here.\nWhich Subjects Are C Relevant For?\nComputer Science:\nC is used to teach programming concepts, data structures, algorithms, and system programming. C is often taught as an introductory programming language in CS classes. The reason for this is that it is foundational to understanding programming concepts.\nSoftware Engineering:\nC is important for developing embedded systems, optimization of software, and building system applications.\nElectrical and Computer Engineering:\nC is used for programming microcontrollers, embedded systems, and working with hardware.\nInformation Technology (IT):\nC can help to understand system programming, network protocols, and IT infrastructure.\nRobotics:\nC is used to program robots, automate tasks, and manage real-time controls. C is one of the most used programming languages in Robotics, because it is fast, efficient, and can control hardware directly.\nMathematics:\nC can be used for building algorithms and solving math problems.\nPhysics:\nC can be used to create simulations and software for analyzing data.\nCybersecurity:\nC is used to understand vulnerabilities, develop security software, and manage low-level analysis.\nGame Development:\nC is used to create game engines, rendering, and perform simulations.\nMechanical Engineering:\nC is applied in programming for CAD tools, automation, and control systems.\nGet Started\nActivities\nIn this tutorial we offer different activities for you to learn C for free:\nLessons\nExercises\nQuizzes\nSign in to Track Progress\nYou can also create a free account to track your progress.\nAs a signed-in user, you get access to features such as:\nLearning paths\nSandbox and lab environments\nAchievements\nAnd much more!\nSign Up - It's free\nOverview of the Modules\nC Introduction\nC Get Started\nC Syntax\nC Statements\nC Output\nC Comments\nC Variables\nC Data Types\nC Constants\nC Operators\nC Booleans\nC If...Else\nC Switch\nC While Loop\nC For Loop\nC Break and Continue\nC Arrays\nC Strings\nC User Input\nC Memory Address\nC Pointers\nC Functions\nC Function Parameters\nC Scope\nC Function Declaration\nC Recursion\nC Math Functions\nC Create Files\nC Write To Files\nC Read Files\nC Structures\nC Enums\nC Memory Management\nGet Started\nSandbox and Lab Environment\nC, like any other programming language, is best learned by working hands-on with code.\nEasily try code with our \"Try it Yourself\" editor.\nHere, you can edit C code and view the result:\nExample\nC Certification\nW3Schools offers an end-of-pathway certification program.\nHere you can take exams to get certified.\nThe C exam is a test that summarizes the W3Schools C syllabus.\nAfter passing the exam you get the \"Certified C Developer\" Certification.\nThe exam is adaptive and graded, the students will get a grade from intermediate, advanced to professional.\nThe adaptive exam adjusts to your skill level. If you answer correctly, you get harder questions. If you answer incorrectly, you get easier questions. This to match the questions to your skill level.\nBuy Certificate »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach C programming?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": [
        "#include <stdio.h>\n\nint main() {\nprintf(\"Hello World!\");\nreturn 0;\n}"
      ]
    },
    {
      "title": "C Study Plan",
      "summary": "Introduction\nThe C study plan helps you teach your students C step-by-step.\nCreating a study plan for C is easy.\nYou can use a pre-built study plan or customize it.\nStudents have different skill levels. The study plans can be customized to ensure that everyone is challenged.\nSave time with pre-built teacher materials and study plans. Easily organize your class with a timeline from the introduction of C to the final exam.\nW3Schools Academy\nThis study plan is a feature of W3Schools Academy.\nW3Schools Academy is a platform that has everything you need to teach coding, all in one place.\nIt offers you as a teacher a toolbox of features that helps you succeed with teaching in your classroom.\nYou need to have an active subscription to access the study plan feature. There are two different subscription tiers:\nEssentials ($1.99 / month per student)\nFull Access ($5.99 / month per student)\nCalculate your price and order here.\nLearn More »\nAcademy also offer other features such as:\nManaging your classroom\nTracking of student progress and reports\nLabs, assignments, and code challenges (prebuilt challenges or create your own ones)\nAuto-grading\nTeaching materials\nCertification exams\nGet a free demo »\nTeacher Materials\nW3Schools has everything you need to teach C.\nThe C training materials is available for you to include and use in your study plan:\nW3Schools C Tutorial\nC Exercises\nC Quiz\nC Challenges (Coding challenges)\nC Certification Exam (End of Pathway Exam)\nC Syllabus\nWith the C Syllabus, your students will start with the basics, like understanding variables, data types, and simple input/output, and move to more advanced topics, like working with pointers, functions, and memory management. Each chapter has examples, try-it-yourself sections, exercises, and quizzes to make learning easy, interactive, and fun.\nRead more about C Syllabus.\nStudy Plan Overview\nThe study plan features are made to help teachers and students. They make learning easy, flexible, and fun. These features work for different types of classes, learning styles and student level.\nLearning Paths\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nInteractive Content\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTimeline and Pace\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nTrack Student Progress\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nEnd of Pathway Exam\nThe C study plan aligns with the C Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the C Tutorial.\nYou get reports of the students' results.\nThe C study plan aligns with the C Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the C Tutorial.\nYou get reports of the students' results.\nAccessibility\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nLearn More »\nSample Study Plan\nYou choose the timeline and pace of your study plans.\nSchools have different preferences.\nSome would like more intensive pace, e.g. 5 weeks, others 12 or more weeks.\nIt is completely up to you.\nFor example, this is how a 5-week C study plan could look like:\nWeek 1: Introduction, Input and Output\nWeek 2: Data Types & Type Conversion, Variables & Constants, Operators & Booleans, Conditionals\nWeek 3: Loops, Arrays, Strings, Memory Address & Pointers\nWeek 4: Memory Management, Functions, Files\nWeek 5: Structures, Enums, C Certification Exam\nImage of Sample C study plan:\nReady to get started?\nStart with C Study Plans today.\nGet Started »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach C programming?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": []
    },
    {
      "title": "W3Schools C Certificate",
      "summary": "W3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nW3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nWho Should Consider Getting Certified?\nAny student or professional within the digital industry.\nCertifications are valuable assets to gain trust and demonstrate knowledge to your clients, current or future employers on a ever increasing competitive market.\nW3Schools is Trusted by Top Companies\nW3Schools has over two decades of experience with teaching coding online.\nOur certificates are recognized and valued by companies looking to employ skilled developers.\nSave Time and Money\nShow the world your coding skills by getting a certification.\nThe prices is a small fraction compared to the price of traditional education.\nDocument and validate your competence by getting certified!\nExam overview\nFee: 95 USD\nAchievable certification levels:\nIntermediate (40%)\nAdvanced (75%)\nProfessional (90%)\nNumber of questions:\nAdaptive, 60 on average\nRequirement to pass:\nMinimum 40% - Intermediate level\nTime limit: 60 minutes\nNumber of attempts to pass: 3\nExam deadline: None\nCertification Expiration: None\nFormat: Online, multiple choice\nRegister now »\nAdvance Faster in Your Career\nGetting a certificate proves your commitment to upgrading your skills.\nThe certificate can be added as credentials to your CV, Resume, LinkedIn profile, and so on.\nIt gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nKnowledge is power, especially in the current job market.\nDocumentation of your skills enables you to advance your career or helps you to start a new one.\nHow Does It Work?\nStudy for free at W3Schools.com\nStudy at your own speed\nTest your skills with W3Schools online quizzes\nApply for your certificate by paying an exam fee\nTake your exam online, at any time, and from any location\nGet Your Certificate and Share It With The World\nExample certificate:\nEach certificate gets a unique link that can be shared with others.\nValidate your certification with the link or QR code.\nCheck how it looks like in this Example.\nShare your certificate on Linked in the Certifications section in just one click!\nDocument Your Skills\nGetting a certificate proves your commitment to upgrade your skills, gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nGet Your Certificate »\nLooking to add multiple users?\nAre you an educator, manager or business owner looking for courses or certifications?\nWe are working with schools, companies and organizations from all over the world.\nGet courses and/or certifications for your team here.",
      "examples": []
    }
  ],
  "glossary": [
    "arithmetic operators",
    "array size",
    "assignment operators",
    "backend",
    "c arrays",
    "c booleans",
    "c comments",
    "c compiler",
    "c constants",
    "c ctype.h",
    "c date",
    "c debugging",
    "c enums",
    "c errors",
    "c exercises",
    "c files",
    "c functions",
    "c home",
    "c if...else",
    "c intro",
    "c keywords",
    "c macros",
    "c math.h",
    "c memory",
    "c more",
    "c null",
    "c operators",
    "c output",
    "c pointers",
    "c projects",
    "c quiz",
    "c recursion",
    "c reference",
    "c scope",
    "c statements",
    "c stdio.h",
    "c stdlib.h",
    "c string.h",
    "c strings",
    "c structures",
    "c switch",
    "c syllabus",
    "c syntax",
    "c time.h",
    "c unions",
    "c variables",
    "change values",
    "characters",
    "comparison operators",
    "decimal precision",
    "else",
    "else if",
    "exercises",
    "format specifiers",
    "free",
    "javascript",
    "logical operators",
    "memory size",
    "multidimensional arrays",
    "multiple variables",
    "nested loops",
    "new lines",
    "note",
    "numbers",
    "operator precedence",
    "pointers arrays",
    "programs",
    "report error",
    "special characters",
    "string functions",
    "type conversion",
    "variable names",
    "w3.css",
    "w3schools spaces"
  ],
  "objectives": [
    "View your completed tutorials, exercises, and quizzes",
    "Keep an eye on your progress and daily streaks",
    "Set goals and create learning paths",
    "Create your own personal website"
  ]
}