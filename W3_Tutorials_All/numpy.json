{
  "course_name": "Numpy",
  "description": "NumPy is a Python library. NumPy is used for working with arrays. NumPy is short for \"Numerical Python\". We have created 43 tutorial pages for you to learn more about NumPy. Starting with a basic introduction and ends up with creating and plotting random data sets, and working with NumPy functions: REMOVE ADS In our \"Try it Yourself\" editor, you can use the NumPy module, and modify the code to see the result. Create a NumPy array: Click on the \"Try it Yourself\" button to see how it works. Many chapters in this tutorial end with an exercise where you can check your level of knowledge. See all NumPy Exercises Test your NumPy skills with a quiz test. Start NumPy Quiz",
  "course_summary": [
    {
      "title": "NumPy Introduction",
      "summary": "What is NumPy?\nNumPy is a Python library used for working with arrays.\nIt also has functions for working in domain of linear algebra, fourier transform, and matrices.\nNumPy was created in 2005 by Travis Oliphant. It is an open source project and you can use it freely.\nNumPy stands for Numerical Python.\nWhy Use NumPy?\nIn Python we have lists that serve the purpose of arrays, but they are slow to process.\nNumPy aims to provide an array object that is up to 50x faster than traditional Python lists.\nThe array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.\nArrays are very frequently used in data science, where speed and resources are very important.\nData Science: is a branch of computer science where we study how to store, use and analyze data for deriving information from it.\nWhy is NumPy Faster Than Lists?\nNumPy arrays are stored at one continuous place in memory unlike lists, so processes can access and manipulate them very efficiently.\nThis behavior is called locality of reference in computer science.\nThis is the main reason why NumPy is faster than lists. Also it is optimized to work with latest CPU architectures.\nWhich Language is NumPy written in?\nNumPy is a Python library and is written partially in Python, but most of the parts that require fast computation are written in C or C++.\nWhere is the NumPy Codebase?\nThe source code for NumPy is located at this github repository https://github.com/numpy/numpy\ngithub: enables many people to work on the same codebase.",
      "examples": [
        "ndarray"
      ]
    },
    {
      "title": "NumPy Getting Started",
      "summary": "Installation of NumPy\nIf you have Python and PIP already installed on a system, then installation of NumPy is very easy.\nInstall it using this command:\nIf this command fails, then use a python distribution that already has NumPy installed like, Anaconda, Spyder etc.\nImport NumPy\nOnce NumPy is installed, import it in your applications by adding the import keyword:\nNow NumPy is imported and ready to use.\nExampleGet your own Python Server\nNumPy as np\nNumPy is usually imported under the np alias.\nalias: In Python alias are an alternate name for referring to the same thing.\nCreate an alias with the as keyword while importing:\nNow the NumPy package can be referred to as np instead of numpy.\nExample\nChecking NumPy Version\nThe version string is stored under __version__ attribute.\nExample",
      "examples": [
        "C:\\Users\\Your Name>pip install numpy",
        "import numpy",
        "import numpy\n\narr = numpy.array([1, 2, 3, 4, 5])\n\nprint(arr)",
        "import numpy as np",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr)",
        "import numpy as np\n\nprint(np.__version__)",
        "import",
        "np",
        "as",
        "numpy",
        "__version__"
      ]
    },
    {
      "title": "NumPy Creating Arrays",
      "summary": "Create a NumPy ndarray Object\nNumPy is used to work with arrays. The array object in NumPy is called ndarray.\nWe can create a NumPy ndarray object by using the array() function.\nExampleGet your own Python Server\ntype(): This built-in Python function tells us the type of the object passed to it. Like in above code it shows that arr is numpy.ndarray type.\nTo create an ndarray, we can pass a list, tuple or any array-like object into the array() method, and it will be converted into an ndarray:\nExample\nUse a tuple to create a NumPy array:\nDimensions in Arrays\nA dimension in arrays is one level of array depth (nested arrays).\nnested array: are arrays that have arrays as their elements.\nREMOVE ADS\n0-D Arrays\n0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array.\nExample\nCreate a 0-D array with value 42\n1-D Arrays\nAn array that has 0-D arrays as its elements is called uni-dimensional or 1-D array.\nThese are the most common and basic arrays.\nExample\nCreate a 1-D array containing the values 1,2,3,4,5:\n2-D Arrays\nAn array that has 1-D arrays as its elements is called a 2-D array.\nThese are often used to represent matrix or 2nd order tensors.\nNumPy has a whole sub module dedicated towards matrix operations called numpy.mat\nExample\nCreate a 2-D array containing two arrays with the values 1,2,3 and 4,5,6:\n3-D arrays\nAn array that has 2-D arrays (matrices) as its elements is called 3-D array.\nThese are often used to represent a 3rd order tensor.\nExample\nCreate a 3-D array with two 2-D arrays, both containing two arrays with the values 1,2,3 and 4,5,6:\nCheck Number of Dimensions?\nNumPy Arrays provides the ndim attribute that returns an integer that tells us how many dimensions the array have.\nExample\nCheck how many dimensions the arrays have:\nHigher Dimensional Arrays\nAn array can have any number of dimensions.\nWhen the array is created, you can define the number of dimensions by using the ndmin argument.\nExample\nCreate an array with 5 dimensions and verify that it has 5 dimensions:\nIn this array the innermost dimension (5th dim) has 4 elements, the 4th dim has 1 element that is the vector, the 3rd dim has 1 element that is the matrix with the vector, the 2nd dim has 1 element that is 3D array and 1st dim has 1 element that is a 4D array.",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr)\n\nprint(type(arr))",
        "import numpy as np\n\narr = np.array((1, 2, 3, 4, 5))\n\nprint(arr)",
        "import numpy as np\n\narr = np.array(42)\n\nprint(arr)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr)",
        "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(arr)",
        "import numpy as np\n\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])\n\nprint(arr)",
        "import numpy as np\n\na = np.array(42)\nb = np.array([1, 2, 3, 4, 5])\nc = np.array([[1, 2, 3], [4, 5, 6]])\nd = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])\n\nprint(a.ndim)\nprint(b.ndim)\nprint(c.ndim)\nprint(d.ndim)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4], ndmin=5)\n\nprint(arr)\nprint('number of dimensions :', arr.ndim)",
        "ndarray",
        "array()",
        "arr",
        "numpy.ndarray",
        "numpy.mat",
        "ndim",
        "ndmin"
      ]
    },
    {
      "title": "NumPy Array Indexing",
      "summary": "Access Array Elements\nArray indexing is the same as accessing an array element.\nYou can access an array element by referring to its index number.\nThe indexes in NumPy arrays start with 0, meaning that the first element has index 0, and the second has index 1 etc.\nExampleGet your own Python Server\nGet the first element from the following array:\nExample\nGet the second element from the following array.\nExample\nGet third and fourth elements from the following array and add them.\nREMOVE ADS\nAccess 2-D Arrays\nTo access elements from 2-D arrays we can use comma separated integers representing the dimension and the index of the element.\nThink of 2-D arrays like a table with rows and columns, where the dimension represents the row and the index represents the column.\nExample\nAccess the element on the first row, second column:\nExample\nAccess the element on the 2nd row, 5th column:\nAccess 3-D Arrays\nTo access elements from 3-D arrays we can use comma separated integers representing the dimensions and the index of the element.\nExample\nAccess the third element of the second array of the first array:\nExample Explained\narr[0, 1, 2] prints the value 6.\nAnd this is why:\nThe first number represents the first dimension, which contains two arrays:\n[[1, 2, 3], [4, 5, 6]]\nand:\n[[7, 8, 9], [10, 11, 12]]\nSince we selected 0, we are left with the first array:\n[[1, 2, 3], [4, 5, 6]]\nThe second number represents the second dimension, which also contains two arrays:\n[1, 2, 3]\nand:\n[4, 5, 6]\nSince we selected 1, we are left with the second array:\n[4, 5, 6]\nThe third number represents the third dimension, which contains three values:\n4\n5\n6\nSince we selected 2, we end up with the third value:\n6\nNegative Indexing\nUse negative indexing to access an array from the end.\nExample\nPrint the last element from the 2nd dim:",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4])\n\nprint(arr[0])",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4])\n\nprint(arr[2] + arr[3])",
        "import numpy as np\n\narr = np.array([[1,2,3,4,5], [6,7,8,9,10]])\n\nprint('2nd element on 1st row: ', arr[0, 1])",
        "import numpy as np\n\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\nprint(arr[0, 1, 2])",
        "import numpy as np\n\narr = np.array([[1,2,3,4,5], [6,7,8,9,10]])\n\nprint('Last element from 2nd dim: ', arr[1, -1])",
        "arr[0, 1, 2]",
        "6",
        "0",
        "1",
        "2"
      ]
    },
    {
      "title": "NumPy Array Slicing",
      "summary": "Slicing arrays\nSlicing in python means taking elements from one given index to another given index.\nWe pass slice instead of index like this: [start:end].\nWe can also define the step, like this: [start:end:step].\nIf we don't pass start its considered 0\nIf we don't pass end its considered length of array in that dimension\nIf we don't pass step its considered 1\nExampleGet your own Python Server\nSlice elements from index 1 to index 5 from the following array:\nNote: The result includes the start index, but excludes the end index.\nExample\nSlice elements from index 4 to the end of the array:\nExample\nSlice elements from the beginning to index 4 (not included):\nREMOVE ADS\nNegative Slicing\nUse the minus operator to refer to an index from the end:\nExample\nSlice from the index 3 from the end to index 1 from the end:\nSTEP\nUse the step value to determine the step of the slicing:\nExample\nReturn every other element from index 1 to index 5:\nExample\nReturn every other element from the entire array:\nSlicing 2-D Arrays\nExample\nFrom the second element, slice elements from index 1 to index 4 (not included):\nNote: Remember that second element has index 1.\nExample\nFrom both elements, return index 2:\nExample\nFrom both elements, slice index 1 to index 4 (not included), this will return a 2-D array:",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7])\n\nprint(arr[1:5])",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7])\n\nprint(arr[4:])",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7])\n\nprint(arr[-3:-1])",
        "import numpy as np\n\narr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n\nprint(arr[1, 1:4])",
        "import numpy as np\n\narr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n\nprint(arr[0:2, 1:4])",
        "[start:end]",
        "[start:end:step]",
        "step"
      ]
    },
    {
      "title": "NumPy Data Types",
      "summary": "Data Types in Python\nBy default Python have these data types:\nstrings - used to represent text data, the text is given under quote marks. e.g. \"ABCD\"\ninteger - used to represent integer numbers. e.g. -1, -2, -3\nfloat - used to represent real numbers. e.g. 1.2, 42.42\nboolean - used to represent True or False.\ncomplex - used to represent complex numbers. e.g. 1.0 + 2.0j, 1.5 + 2.5j\nData Types in NumPy\nNumPy has some extra data types, and refer to data types with one character, like i for integers, u for unsigned integers etc.\nBelow is a list of all data types in NumPy and the characters used to represent them.\ni - integer\nb - boolean\nu - unsigned integer\nf - float\nc - complex float\nm - timedelta\nM - datetime\nO - object\nS - string\nU - unicode string\nV - fixed chunk of memory for other type ( void )\nChecking the Data Type of an Array\nThe NumPy array object has a property called dtype that returns the data type of the array:\nExampleGet your own Python Server\nGet the data type of an array object:\nExample\nGet the data type of an array containing strings:\nREMOVE ADS\nCreating Arrays With a Defined Data Type\nWe use the array() function to create arrays, this function can take an optional argument: dtype that allows us to define the expected data type of the array elements:\nExample\nCreate an array with data type string:\nFor i, u, f, S and U we can define size as well.\nExample\nCreate an array with data type 4 bytes integer:\nWhat if a Value Can Not Be Converted?\nIf a type is given in which elements can't be casted then NumPy will raise a ValueError.\nValueError: In Python ValueError is raised when the type of passed argument to a function is unexpected/incorrect.\nExample\nA non integer string like 'a' can not be converted to integer (will raise an error):\nConverting Data Type on Existing Arrays\nThe best way to change the data type of an existing array, is to make a copy of the array with the astype() method.\nThe astype() function creates a copy of the array, and allows you to specify the data type as a parameter.\nThe data type can be specified using a string, like 'f' for float, 'i' for integer etc. or you can use the data type directly like float for float and int for integer.\nExample\nChange data type from float to integer by using 'i' as parameter value:\nExample\nChange data type from float to integer by using int as parameter value:\nExample\nChange data type from integer to boolean:",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4])\n\nprint(arr.dtype)",
        "import numpy as np\n\narr = np.array(['apple', 'banana', 'cherry'])\n\nprint(arr.dtype)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4], dtype='S')\n\nprint(arr)\nprint(arr.dtype)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4], dtype='i4')\n\nprint(arr)\nprint(arr.dtype)",
        "import numpy as np\n\narr = np.array(['a', '2', '3'], dtype='i')",
        "import numpy as np\n\narr = np.array([1.1, 2.1, 3.1])\n\nnewarr = arr.astype('i')\n\nprint(newarr)\nprint(newarr.dtype)",
        "import numpy as np\n\narr = np.array([1, 0, 3])\n\nnewarr = arr.astype(bool)\n\nprint(newarr)\nprint(newarr.dtype)",
        "strings",
        "integer",
        "float",
        "boolean",
        "complex",
        "i",
        "u",
        "b",
        "f",
        "c",
        "m",
        "M",
        "O",
        "S",
        "U",
        "V",
        "dtype",
        "array()",
        "astype()",
        "'f'",
        "'i'",
        "int"
      ]
    },
    {
      "title": "NumPy Array Copy vs View",
      "summary": "The Difference Between Copy and View\nThe main difference between a copy and a view of an array is that the copy is a new array, and the view is just a view of the original array.\nThe copy owns the data and any changes made to the copy will not affect original array, and any changes made to the original array will not affect the copy.\nThe view does not own the data and any changes made to the view will affect the original array, and any changes made to the original array will affect the view.\nCOPY:\nExampleGet your own Python Server\nMake a copy, change the original array, and display both arrays:\nThe copy SHOULD NOT be affected by the changes made to the original array.\nVIEW:\nExample\nMake a view, change the original array, and display both arrays:\nThe view SHOULD be affected by the changes made to the original array.\nMake Changes in the VIEW:\nExample\nMake a view, change the view, and display both arrays:\nThe original array SHOULD be affected by the changes made to the view.\nREMOVE ADS\nCheck if Array Owns its Data\nAs mentioned above, copies owns the data, and views does not own the data, but how can we check this?\nEvery NumPy array has the attribute base that returns None if the array owns the data.\nOtherwise, the base  attribute refers to the original object.\nExample\nPrint the value of the base attribute to check if an array owns it's data or not:\nThe copy returns None.\nThe view returns the original array.",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\nx = arr.copy()\narr[0] = 42\n\nprint(arr)\nprint(x)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\nx = arr.view()\nx[0] = 31\n\nprint(arr)\nprint(x)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nx = arr.copy()\ny = arr.view()\n\nprint(x.base)\nprint(y.base)",
        "base",
        "None"
      ]
    },
    {
      "title": "NumPy Array Shape",
      "summary": "Shape of an Array\nThe shape of an array is the number of elements in each dimension.\nGet the Shape of an Array\nNumPy arrays have an attribute called shape that returns a tuple with each index having the number of corresponding elements.\nExampleGet your own Python Server\nPrint the shape of a 2-D array:\nThe example above returns (2, 4), which means that the array has 2 dimensions, where the first dimension has 2 elements and the second has 4.\nExample\nCreate an array with 5 dimensions using ndmin using a vector with values 1,2,3,4 and verify that last dimension has value 4:\nWhat does the shape tuple represent?\nIntegers at every index tells about the number of elements the corresponding dimension has.\nIn the example above at index-4 we have value 4, so we can say that 5th ( 4 + 1 th) dimension has 4 elements.",
      "examples": [
        "import numpy as np\n\narr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n\nprint(arr.shape)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4], ndmin=5)\n\nprint(arr)\nprint('shape of array :', arr.shape)",
        "shape",
        "(2, 4)",
        "ndmin"
      ]
    },
    {
      "title": "NumPy Array Reshaping",
      "summary": "Reshaping arrays\nReshaping means changing the shape of an array.\nThe shape of an array is the number of elements in each dimension.\nBy reshaping we can add or remove dimensions or change number of elements in each dimension.\nReshape From 1-D to 2-D\nExampleGet your own Python Server\nConvert the following 1-D array with 12 elements into a 2-D array.\nThe outermost dimension will have 4 arrays, each with 3 elements:\nReshape From 1-D to 3-D\nExample\nConvert the following 1-D array with 12 elements into a 3-D array.\nThe outermost dimension will have 2 arrays that contains 3 arrays, each with 2 elements:\nREMOVE ADS\nCan We Reshape Into any Shape?\nYes, as long as the elements required for reshaping are equal in both shapes.\nWe can reshape an 8 elements 1D array into 4 elements in 2 rows 2D array but we cannot reshape it into a 3 elements 3 rows 2D array as that would require 3x3 = 9 elements.\nExample\nTry converting 1D array with 8 elements to a 2D array with 3 elements in each dimension (will raise an error):\nReturns Copy or View?\nExample\nCheck if the returned array is a copy or a view:\nThe example above returns the original array, so it is a view.\nUnknown Dimension\nYou are allowed to have one \"unknown\" dimension.\nMeaning that you do not have to specify an exact number for one of the dimensions in the reshape method.\nPass -1 as the value, and NumPy will calculate this number for you.\nExample\nConvert 1D array with 8 elements to 3D array with 2x2 elements:\nNote: We can not pass -1 to more than one dimension.\nFlattening the arrays\nFlattening array means converting a multidimensional array into a 1D array.\nWe can use reshape(-1) to do this.\nExample\nConvert the array into a 1D array:\nNote: There are a lot of functions for changing the shapes of arrays in numpy flatten, ravel and also for rearranging the elements rot90, flip, fliplr, flipud etc. These fall under Intermediate to Advanced section of numpy.",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n\nnewarr = arr.reshape(4, 3)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n\nnewarr = arr.reshape(2, 3, 2)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8])\n\nnewarr = arr.reshape(3, 3)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8])\n\nprint(arr.reshape(2, 4).base)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8])\n\nnewarr = arr.reshape(2, 2, -1)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nnewarr = arr.reshape(-1)\n\nprint(newarr)",
        "-1",
        "reshape(-1)",
        "flatten",
        "ravel",
        "rot90",
        "flip",
        "fliplr",
        "flipud"
      ]
    },
    {
      "title": "NumPy Array Iterating",
      "summary": "Iterating Arrays\nIterating means going through elements one by one.\nAs we deal with multi-dimensional arrays in numpy, we can do this using basic for loop of python.\nIf we iterate on a 1-D array it will go through each element one by one.\nExampleGet your own Python Server\nIterate on the elements of the following 1-D array:\nIterating 2-D Arrays\nIn a 2-D array it will go through all the rows.\nExample\nIterate on the elements of the following 2-D array:\nIf we iterate on a n-D array it will go through n-1th dimension one by one.\nTo return the actual values, the scalars, we have to iterate the arrays in each dimension.\nExample\nIterate on each scalar element of the 2-D array:\nREMOVE ADS\nIterating 3-D Arrays\nIn a 3-D array it will go through all the 2-D arrays.\nExample\nIterate on the elements of the following 3-D array:\nTo return the actual values, the scalars, we have to iterate the arrays in each dimension.\nExample\nIterate down to the scalars:\nIterating Arrays Using nditer()\nThe function nditer() is a helping function that can be used from very basic to very advanced iterations. It solves some basic issues which we face in iteration, lets go through it with examples.\nIterating on Each Scalar Element\nIn basic for loops, iterating through each scalar of an array we need to use n for loops which can be difficult to write for arrays with very high dimensionality.\nExample\nIterate through the following 3-D array:\nIterating Array With Different Data Types\nWe can use op_dtypes argument and pass it the expected datatype to change the datatype of elements while iterating.\nNumPy does not change the data type of the element in-place (where the element is in array) so it needs some other space to perform this action, that extra space is called buffer, and in order to enable it in nditer() we pass flags=['buffered'].\nExample\nIterate through the array as a string:\nIterating With Different Step Size\nWe can use filtering and followed by iteration.\nExample\nIterate through every scalar element of the 2D array skipping 1 element:\nEnumerated Iteration Using ndenumerate()\nEnumeration means mentioning sequence number of somethings one by one.\nSometimes we require corresponding index of the element while iterating, the ndenumerate() method can be used for those usecases.\nExample\nEnumerate on following 1D arrays elements:\nExample\nEnumerate on following 2D array's elements:",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3])\n\nfor x in arr:\nprint(x)",
        "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nfor x in arr:\nprint(x)",
        "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nfor x in arr:\nfor y in x:\nprint(y)",
        "import numpy as np\n\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\nfor x in arr:\nprint(x)",
        "import numpy as np\n\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\nfor x in arr:\nfor y in x:\nfor z in y:\nprint(z)",
        "import numpy as np\n\narr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n\nfor x in np.nditer(arr):\nprint(x)",
        "import numpy as np\n\narr = np.array([1, 2, 3])\n\nfor x in np.nditer(arr, flags=['buffered'], op_dtypes=['S']):\nprint(x)",
        "import numpy as np\n\narr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n\nfor x in np.nditer(arr[:, ::2]):\nprint(x)",
        "import numpy as np\n\narr = np.array([1, 2, 3])\n\nfor idx, x in np.ndenumerate(arr):\nprint(idx, x)",
        "import numpy as np\n\narr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\n\nfor idx, x in np.ndenumerate(arr):\nprint(idx, x)",
        "for",
        "nditer()",
        "op_dtypes",
        "flags=['buffered']",
        "ndenumerate()"
      ]
    },
    {
      "title": "NumPy Joining Array",
      "summary": "Joining NumPy Arrays\nJoining means putting contents of two or more arrays in a single array.\nIn SQL we join tables based on a key, whereas in NumPy we join arrays by axes.\nWe pass a sequence of arrays that we want to join to the concatenate() function, along with the axis. If axis is not explicitly passed, it is taken as 0.\nExampleGet your own Python Server\nJoin two arrays\nExample\nJoin two 2-D arrays along rows (axis=1):\nJoining Arrays Using Stack Functions\nStacking is same as concatenation, the only difference is that stacking is done along a new axis.\nWe can concatenate two 1-D arrays along the second axis which would result in putting them one over the other, ie. stacking.\nWe pass a sequence of arrays that we want to join to the stack() method along with the axis. If axis is not explicitly passed it is taken as 0.\nExample\nREMOVE ADS\nStacking Along Rows\nNumPy provides a helper function: hstack() to stack along rows.\nExample\nStacking Along Columns\nNumPy provides a helper function: vstack()  to stack along columns.\nExample\nStacking Along Height (depth)\nNumPy provides a helper function: dstack() to stack along height, which is the same as depth.\nExample",
      "examples": [
        "import numpy as np\n\narr1 = np.array([1, 2, 3])\n\narr2 = np.array([4, 5, 6])\n\narr = np.concatenate((arr1, arr2))\n\nprint(arr)",
        "import numpy as np\n\narr1 = np.array([[1, 2], [3, 4]])\n\narr2 = np.array([[5, 6], [7, 8]])\n\narr = np.concatenate((arr1, arr2), axis=1)\n\nprint(arr)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3])\n\narr2 = np.array([4, 5, 6])\n\narr = np.stack((arr1, arr2), axis=1)\n\nprint(arr)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3])\n\narr2 = np.array([4, 5, 6])\n\narr = np.hstack((arr1, arr2))\n\nprint(arr)",
        "concatenate()",
        "stack()",
        "hstack()",
        "vstack()",
        "dstack()"
      ]
    },
    {
      "title": "NumPy Splitting Array",
      "summary": "Splitting NumPy Arrays\nSplitting is reverse operation of Joining.\nJoining merges multiple arrays into one and Splitting breaks one array into multiple.\nWe use array_split() for splitting arrays, we pass it the array we want to split and the number of splits.\nExampleGet your own Python Server\nSplit the array in 3 parts:\nNote: The return value is a list containing three arrays.\nIf the array has less elements than required, it will adjust from the end accordingly.\nExample\nSplit the array in 4 parts:\nNote: We also have the method split() available but it will not adjust the elements when elements are less in source array for splitting like in example above, array_split() worked properly but split() would fail.\nREMOVE ADS\nSplit Into Arrays\nThe return value of the array_split() method is a list containing each of the split as an array.\nIf you split an array into 3 arrays, you can access them from the result just like any array element:\nExample\nAccess the splitted arrays:\nSplitting 2-D Arrays\nUse the same syntax when splitting 2-D arrays.\nUse the array_split() method, pass in the array you want to split and the number of splits you want to do.\nExample\nSplit the 2-D array into three 2-D arrays.\nThe example above returns three 2-D arrays.\nLet's look at another example, this time each element in the 2-D arrays contains 3 elements.\nExample\nSplit the 2-D array into three 2-D arrays.\nThe example above returns three 2-D arrays.\nIn addition, you can specify which axis you want to do the split around.\nThe example below also returns three 2-D arrays, but they are split along the column (axis=1).\nExample\nSplit the 2-D array into three 2-D arrays along columns.\nAn alternate solution is using hsplit() opposite of hstack()\nExample\nUse the hsplit() method to split the 2-D array into three 2-D arrays along columns.\nNote: Similar alternates to vstack() and dstack() are available as vsplit() and dsplit().",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6])\n\nnewarr = np.array_split(arr, 3)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6])\n\nnewarr = np.array_split(arr, 3)\n\nprint(newarr[0])\nprint(newarr[1])\nprint(newarr[2])",
        "import numpy as np\n\narr = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])\n\nnewarr = np.array_split(arr, 3)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])\n\nnewarr = np.array_split(arr, 3)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])\n\nnewarr = np.array_split(arr, 3, axis=1)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]])\n\nnewarr = np.hsplit(arr, 3)\n\nprint(newarr)",
        "array_split()",
        "split()",
        "hsplit()",
        "hstack()",
        "vstack()",
        "dstack()",
        "vsplit()",
        "dsplit()"
      ]
    },
    {
      "title": "NumPy Searching Arrays",
      "summary": "Searching Arrays\nYou can search an array for a certain value, and return the indexes that get a match.\nTo search an array, use the where() method.\nExampleGet your own Python Server\nFind the indexes where the value is 4:\nThe example above will return a tuple: (array([3, 5, 6],)\nWhich means that the value 4 is present at index 3, 5, and 6.\nExample\nFind the indexes where the values are even:\nExample\nFind the indexes where the values are odd:\nREMOVE ADS\nSearch Sorted\nThere is a method called searchsorted() which performs a binary search in the array, and returns the index where the specified value would be inserted to maintain the search order.\nThe searchsorted() method is assumed to be used on sorted arrays.\nExample\nFind the indexes where the value 7 should be inserted:\nExample explained: The number 7 should be inserted on index 1 to remain the sort order.\nThe method starts the search from the left and returns the first index where the number 7 is no longer larger than the next value.\nSearch From the Right Side\nBy default the left most index is returned, but we can give side='right' to return the right most index instead.\nExample\nFind the indexes where the value 7 should be inserted, starting from the right:\nExample explained: The number 7 should be inserted on index 2 to remain the sort order.\nThe method starts the search from the right and returns the first index where the number 7 is no longer less than the next value.\nMultiple Values\nTo search for more than one value, use an array with the specified values.\nExample\nFind the indexes where the values 2, 4, and 6 should be inserted:\nThe return value is an array: [1 2 3] containing the three indexes where 2, 4, 6 would be inserted in the original array to maintain the order.",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 4, 4])\n\nx = np.where(arr == 4)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8])\n\nx = np.where(arr%2 == 0)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([6, 7, 8, 9])\n\nx = np.searchsorted(arr, 7)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([6, 7, 8, 9])\n\nx = np.searchsorted(arr, 7, side='right')\n\nprint(x)",
        "import numpy as np\n\narr = np.array([1, 3, 5, 7])\n\nx = np.searchsorted(arr, [2, 4, 6])\n\nprint(x)",
        "where()",
        "(array([3, 5, 6],)",
        "searchsorted()",
        "side='right'",
        "[1 2 3]"
      ]
    },
    {
      "title": "NumPy Sorting Arrays",
      "summary": "Sorting Arrays\nSorting means putting elements in an ordered sequence.\nOrdered sequence is any sequence that has an order corresponding to elements, like numeric or alphabetical, ascending or descending.\nThe NumPy ndarray object has a function called sort(), that will sort a specified array.\nExampleGet your own Python Server\nSort the array:\nNote: This method returns a copy of the array, leaving the original array unchanged.\nYou can also sort arrays of strings, or any other data type:\nExample\nSort the array alphabetically:\nExample\nSort a boolean array:\nSorting a 2-D Array\nIf you use the sort() method on a 2-D array, both arrays will be sorted:\nExample\nSort a 2-D array:",
      "examples": [
        "import numpy as np\n\narr = np.array([3, 2, 0, 1])\n\nprint(np.sort(arr))",
        "import numpy as np\n\narr = np.array(['banana', 'cherry', 'apple'])\n\nprint(np.sort(arr))",
        "import numpy as np\n\narr = np.array([True, False, True])\n\nprint(np.sort(arr))",
        "import numpy as np\n\narr = np.array([[3, 2, 4], [5, 0, 1]])\n\nprint(np.sort(arr))",
        "sort()"
      ]
    },
    {
      "title": "NumPy Filter Array",
      "summary": "Filtering Arrays\nGetting some elements out of an existing array and creating a new array out of them is called filtering.\nIn NumPy, you filter an array using a boolean index list.\nA boolean index list is a list of booleans corresponding to indexes in the array.\nIf the value at an index is True that element is contained in the filtered array, if the value at that index is False that element is excluded from the filtered array.\nExampleGet your own Python Server\nCreate an array from the elements on index 0 and 2:\nThe example above will return [41, 43], why?\nBecause the new array contains only the values where the filter array had the value True, in this case, index 0 and 2.\nCreating the Filter Array\nIn the example above we hard-coded the True and False values, but the common use is to create a filter array based on conditions.\nExample\nCreate a filter array that will return only values higher than 42:\nREMOVE ADS\nExample\nCreate a filter array that will return only even elements from the original array:\nCreating Filter Directly From Array\nThe above example is quite a common task in NumPy and NumPy provides a nice way to tackle it.\nWe can directly substitute the array instead of the iterable variable in our condition and it will work just as we expect it to.\nExample\nCreate a filter array that will return only values higher than 42:\nExample\nCreate a filter array that will return only even elements from the original array:",
      "examples": [
        "import numpy as np\n\narr = np.array([41, 42, 43, 44])\n\nx = [True, False, True, False]\n\nnewarr = arr[x]\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([41, 42, 43, 44])\n\n# Create an empty list\nfilter_arr = []\n\n# go through each element in arr\nfor element in arr:\n# if the element is higher than 42, set the value to True, otherwise False:\nif element > 42:\nfilter_arr.append(True)\nelse:\nfilter_arr.append(False)\n\nnewarr = arr[filter_arr]\n\nprint(filter_arr)\nprint(newarr)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7])\n\n# Create an empty list\nfilter_arr = []\n\n# go through each element in arr\nfor element in arr:\n# if the element is completely divisble by 2, set the value to True, otherwise False\nif element % 2 == 0:\nfilter_arr.append(True)\nelse:\nfilter_arr.append(False)\n\nnewarr = arr[filter_arr]\n\nprint(filter_arr)\nprint(newarr)",
        "import numpy as np\n\narr = np.array([41, 42, 43, 44])\n\nfilter_arr = arr > 42\n\nnewarr = arr[filter_arr]\n\nprint(filter_arr)\nprint(newarr)",
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5, 6, 7])\n\nfilter_arr = arr % 2 == 0\n\nnewarr = arr[filter_arr]\n\nprint(filter_arr)\nprint(newarr)",
        "True",
        "False",
        "[41, 43]"
      ]
    },
    {
      "title": "Random Numbers in NumPy",
      "summary": "What is a Random Number?\nRandom number does NOT mean a different number every time. Random means something that can not be predicted logically.\nPseudo Random and True Random.\nComputers work on programs, and programs are definitive set of instructions. So it means there must be some algorithm to generate a random number as well.\nIf there is a program to generate random number it can be predicted, thus it is not truly random.\nRandom numbers generated through a generation algorithm are called pseudo random.\nCan we make truly random numbers?\nYes. In order to generate a truly random number on our computers we need to get the random data from some outside source. This outside source is generally our keystrokes, mouse movements, data on network etc.\nWe do not need truly random numbers, unless it is related to security (e.g. encryption keys) or the basis of application is the randomness (e.g. Digital roulette wheels).\nIn this tutorial we will be using pseudo random numbers.\nGenerate Random Number\nNumPy offers the random module to work with random numbers.\nExampleGet your own Python Server\nGenerate a random integer from 0 to 100:\nGenerate Random Float\nThe random module's rand() method returns a random float between 0 and 1.\nExample\nGenerate a random float from 0 to 1:\nREMOVE ADS\nGenerate Random Array\nIn NumPy we work with arrays, and you can use the two methods from the above examples to make random arrays.\nIntegers\nThe randint() method takes a size parameter where you can specify the shape of an array.\nExample\nGenerate a 1-D array containing 5 random integers from 0 to 100:\nExample\nGenerate a 2-D array with 3 rows, each row containing 5 random integers from 0 to 100:\nFloats\nThe rand() method also allows you to specify the shape of the array.\nExample\nGenerate a 1-D array containing 5 random floats:\nExample\nGenerate a 2-D array with 3 rows, each row containing 5 random numbers:\nGenerate Random Number From Array\nThe choice() method allows you to generate a random value based on an array of values.\nThe choice() method takes an array as a parameter and randomly returns one of the values.\nExample\nReturn one of the values in an array:\nThe choice() method also allows you to return an array of values.\nAdd a size parameter to specify the shape of the array.\nExample\nGenerate a 2-D array that consists of the values in the array parameter (3, 5, 7, and 9):",
      "examples": [
        "from numpy import random\n\nx = random.randint(100)\n\nprint(x)",
        "from numpy import random\n\nx = random.rand()\n\nprint(x)",
        "from numpy import random\n\nx=random.randint(100, size=(5))\n\nprint(x)",
        "from numpy import random\n\nx = random.randint(100, size=(3, 5))\n\nprint(x)",
        "from numpy import random\n\nx = random.rand(5)\n\nprint(x)",
        "from numpy import random\n\nx = random.rand(3, 5)\n\nprint(x)",
        "from numpy import random\n\nx = random.choice([3, 5, 7, 9])\n\nprint(x)",
        "from numpy import random\n\nx = random.choice([3, 5, 7, 9], size=(3, 5))\n\nprint(x)",
        "random",
        "rand()",
        "randint()",
        "size",
        "choice()"
      ]
    },
    {
      "title": "Random Data Distribution",
      "summary": "What is Data Distribution?\nData Distribution is a list of all possible values, and how often each value occurs.\nSuch lists are important when working with statistics and data science.\nThe random module offer methods that returns randomly generated data distributions.\nRandom Distribution\nA random distribution is a set of random numbers that follow a certain probability density function.\nProbability Density Function: A function that describes a continuous probability. i.e. probability of all values in an array.\nWe can generate random numbers based on defined probabilities using the choice() method of the random module.\nThe choice() method allows us to specify the probability for each value.\nThe probability is set by a number between 0 and 1, where 0 means that the value will never occur and 1 means that the value will always occur.\nExampleGet your own Python Server\nGenerate a 1-D array containing 100 values, where each value has to be 3, 5, 7 or 9.\nThe probability for the value to be 3 is set to be 0.1\nThe probability for the value to be 5 is set to be 0.3\nThe probability for the value to be 7 is set to be 0.6\nThe probability for the value to be 9 is set to be 0\nThe sum of all probability numbers should be 1.\nEven if you run the example above 100 times, the value 9 will never occur.\nYou can return arrays of any shape and size by specifying the shape in the size parameter.\nExample\nSame example as above, but return a 2-D array with 3 rows, each containing 5 values.",
      "examples": [
        "from numpy import random\n\nx = random.choice([3, 5, 7, 9], p=[0.1, 0.3, 0.6, 0.0], size=(100))\n\nprint(x)",
        "from numpy import random\n\nx = random.choice([3, 5, 7, 9], p=[0.1, 0.3, 0.6, 0.0], size=(3, 5))\n\nprint(x)",
        "choice()",
        "random",
        "size"
      ]
    },
    {
      "title": "Random Permutations",
      "summary": "Random Permutations of Elements\nA permutation refers to an arrangement of elements. e.g. [3, 2, 1] is a permutation of [1, 2, 3] and vice-versa.\nThe NumPy Random module provides two methods for this: shuffle() and permutation().\nShuffling Arrays\nShuffle means changing arrangement of elements in-place. i.e. in the array itself.\nExampleGet your own Python Server\nRandomly shuffle elements of following array:\nThe shuffle() method makes changes to the original array.\nGenerating Permutation of Arrays\nExample\nGenerate a random permutation of elements of following array:\nThe permutation() method returns a re-arranged array (and leaves the original array un-changed).",
      "examples": [
        "from numpy import random\nimport numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nrandom.shuffle(arr)\n\nprint(arr)",
        "from numpy import random\nimport numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(random.permutation(arr))",
        "shuffle()",
        "permutation()"
      ]
    },
    {
      "title": "Seaborn",
      "summary": "Visualize Distributions With Seaborn\nSeaborn is a library that uses Matplotlib underneath to plot graphs. It will be used to visualize random distributions.\nInstall Seaborn.\nIf you have Python and PIP already installed on a system, install it using this command:\nIf you use Jupyter, install Seaborn using this command:\nDisplots\nDisplot stands for distribution plot, it takes as input an array and plots a curve corresponding to the distribution of points in the array.\nImport Matplotlib\nYou can learn about the Matplotlib module in our Matplotlib Tutorial.\nImport Seaborn\nPlotting a Displot\nExampleGet your own Python Server\nPlotting a Displot Without the Histogram\nExample\nNote: We will be using: sns.displot(arr, kind=\"kde\") to visualize random distributions in this tutorial.",
      "examples": [
        "C:\\Users\\Your Name>pip install seaborn",
        "C:\\Users\\Your Name>!pip install seaborn",
        "import matplotlib.pyplot as plt",
        "import seaborn as sns",
        "import matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot([0, 1, 2, 3, 4, 5])\n\nplt.show()",
        "import matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot([0, 1, 2, 3, 4, 5], kind=\"kde\")\n\nplt.show()",
        "sns.displot(arr, kind=\"kde\")"
      ]
    },
    {
      "title": "Normal (Gaussian) Distribution",
      "summary": "Normal Distribution\nThe Normal Distribution is one of the most important distributions.\nIt is also called the Gaussian Distribution after the German mathematician Carl Friedrich Gauss.\nIt fits the probability distribution of many events, eg. IQ Scores, Heartbeat etc.\nUse the random.normal() method to get a Normal Data Distribution.\nIt has three parameters:\nloc - (Mean) where the peak of the bell exists.\nscale - (Standard Deviation) how flat the graph distribution should be.\nsize - The shape of the returned array.\nExampleGet your own Python Server\nGenerate a random normal distribution of size 2x3:\nExample\nGenerate a random normal distribution of size 2x3 with mean at 1 and standard deviation of 2:\nVisualization of Normal Distribution\nExample\nResult\nNote: The curve of a Normal Distribution is also known as the Bell Curve because of the bell-shaped curve.",
      "examples": [
        "from numpy import random\n\nx = random.normal(size=(2, 3))\n\nprint(x)",
        "from numpy import random\n\nx = random.normal(loc=1, scale=2, size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.normal(size=1000), kind=\"kde\")\n\nplt.show()",
        "random.normal()",
        "loc",
        "scale",
        "size"
      ]
    },
    {
      "title": "Binomial Distribution",
      "summary": "Binomial Distribution\nBinomial Distribution is a Discrete Distribution.\nIt describes the outcome of binary scenarios, e.g. toss of a coin, it will either be head or tails.\nIt has three parameters:\nn - number of trials.\np - probability of occurrence of each trial (e.g. for toss of a coin 0.5 each).\nsize - The shape of the returned array.\nDiscrete Distribution:The distribution is defined at separate set of events, e.g. a coin toss's result is discrete as it can be only head or tails whereas height of people is continuous as it can be 170, 170.1, 170.11 and so on.\nExampleGet your own Python Server\nGiven 10 trials for coin toss generate 10 data points:\nVisualization of Binomial Distribution\nExample\nResult\nDifference Between Normal and Binomial Distribution\nThe main difference is that normal distribution is continous whereas binomial is discrete, but if there are enough data points it will be quite similar to normal distribution with certain loc and scale.\nExample\nResult",
      "examples": [
        "from numpy import random\n\nx = random.binomial(n=10, p=0.5, size=10)\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.binomial(n=10, p=0.5, size=1000))\n\nplt.show()",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = {\n\"normal\": random.normal(loc=50, scale=5, size=1000),\n\"binomial\": random.binomial(n=100, p=0.5, size=1000)\n}\n\nsns.displot(data, kind=\"kde\")\n\nplt.show()",
        "n",
        "p",
        "size"
      ]
    },
    {
      "title": "Poisson Distribution",
      "summary": "Poisson Distribution\nPoisson Distribution is a Discrete Distribution.\nIt estimates how many times an event can happen in a specified time. e.g. If someone eats twice a day what is the probability he will eat thrice?\nIt has two parameters:\nlam - rate or known number of occurrences e.g. 2 for above problem.\nsize - The shape of the returned array.\nExampleGet your own Python Server\nGenerate a random 1x10 distribution for occurrence 2:\nVisualization of Poisson Distribution\nExample\nResult\nREMOVE ADS\nDifference Between Normal and Poisson Distribution\nNormal distribution is continuous whereas poisson is discrete.\nBut we can see that similar to binomial for a large enough poisson distribution it will become similar to normal distribution with certain std dev and mean.\nExample\nResult\nDifference Between Binomial and Poisson Distribution\nBinomial distribution only has two possible outcomes, whereas poisson distribution can have unlimited possible outcomes.\nBut for very large n and near-zero p binomial distribution is near identical to poisson distribution such that n * p is nearly equal to lam.\nExample\nResult",
      "examples": [
        "from numpy import random\n\nx = random.poisson(lam=2, size=10)\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.poisson(lam=2, size=1000))\n\nplt.show()",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = {\n\"normal\": random.normal(loc=50, scale=7, size=1000),\n\"poisson\": random.poisson(lam=50, size=1000)\n}\n\nsns.displot(data, kind=\"kde\")\n\nplt.show()",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = {\n\"binomial\": random.binomial(n=1000, p=0.01, size=1000),\n\"poisson\": random.poisson(lam=10, size=1000)\n}\n\nsns.displot(data, kind=\"kde\")\n\nplt.show()",
        "lam",
        "size",
        "n",
        "p",
        "n * p"
      ]
    },
    {
      "title": "Uniform Distribution",
      "summary": "Uniform Distribution\nUsed to describe probability where every event has equal chances of occuring.\nE.g. Generation of random numbers.\nIt has three parameters:\nlow - lower bound - default 0 .0.\nhigh - upper bound - default 1.0.\nsize - The shape of the returned array.\nExampleGet your own Python Server\nCreate a 2x3 uniform distribution sample:\nVisualization of Uniform Distribution\nExample\nResult",
      "examples": [
        "from numpy import random\n\nx = random.uniform(size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.uniform(size=1000), kind=\"kde\")\n\nplt.show()",
        "low",
        "high",
        "size"
      ]
    },
    {
      "title": "Logistic Distribution",
      "summary": "Logistic Distribution\nLogistic Distribution is used to describe growth.\nUsed extensively in machine learning in logistic regression, neural networks etc.\nIt has three parameters:\nloc - mean, where the peak is. Default 0.\nscale - standard deviation, the flatness of distribution. Default 1.\nsize - The shape of the returned array.\nExampleGet your own Python Server\nDraw 2x3 samples from a logistic distribution with mean at 1 and stddev 2.0:\nVisualization of Logistic Distribution\nExample\nResult\nDifference Between Logistic and Normal Distribution\nBoth distributions are near identical, but logistic distribution has more area under the tails, meaning it represents more possibility of occurrence of an event further away from mean.\nFor higher value of scale (standard deviation) the normal and logistic distributions are near identical apart from the peak.\nExample\nResult",
      "examples": [
        "from numpy import random\n\nx = random.logistic(loc=1, scale=2, size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.logistic(size=1000), kind=\"kde\")\n\nplt.show()",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndata = {\n\"normal\": random.normal(scale=2, size=1000),\n\"logistic\": random.logistic(size=1000)\n}\n\nsns.displot(data, kind=\"kde\")\n\nplt.show()",
        "loc",
        "scale",
        "size"
      ]
    },
    {
      "title": "Multinomial Distribution",
      "summary": "Multinomial Distribution\nMultinomial distribution is a generalization of binomial distribution.\nIt describes outcomes of multi-nomial scenarios unlike binomial where scenarios must be only one of two. e.g. Blood type of a population, dice roll outcome.\nIt has three parameters:\nn - number of times to run the experiment.\npvals - list of probabilties of outcomes (e.g. [1/6, 1/6, 1/6, 1/6, 1/6, 1/6] for dice roll).\nsize - The shape of the returned array.\nExampleGet your own Python Server\nDraw out a sample for dice roll:\nNote: Multinomial samples will NOT produce a single value! They will produce one value for each pval.\nNote: As they are generalization of binomial distribution their visual representation and similarity of normal distribution is same as that of multiple binomial distributions.",
      "examples": [
        "from numpy import random\n\nx = random.multinomial(n=6, pvals=[1/6, 1/6, 1/6, 1/6, 1/6, 1/6])\n\nprint(x)",
        "n",
        "pvals",
        "size",
        "pval"
      ]
    },
    {
      "title": "Exponential Distribution",
      "summary": "Exponential Distribution\nExponential distribution is used for describing time till next event e.g. failure/success etc.\nIt has two parameters:\nscale - inverse of rate ( see lam in poisson distribution ) defaults to 1.0.\nsize - The shape of the returned array.\nExampleGet your own Python Server\nDraw out a sample for exponential distribution with 2.0 scale with 2x3 size:\nVisualization of Exponential Distribution\nExample\nResult\nRelation Between Poisson and Exponential Distribution\nPoisson distribution deals with number of occurences of an event in a time period whereas exponential distribution deals with the time between these events.",
      "examples": [
        "from numpy import random\n\nx = random.exponential(scale=2, size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.exponential(size=1000), kind=\"kde\")\n\nplt.show()",
        "scale",
        "size"
      ]
    },
    {
      "title": "Chi Square Distribution",
      "summary": "Chi Square Distribution\nChi Square distribution is used as a basis to verify the hypothesis.\nIt has two parameters:\ndf - (degree of freedom).\nsize - The shape of the returned array.\nExampleGet your own Python Server\nDraw out a sample for chi squared distribution with degree of freedom 2 with size 2x3:\nVisualization of Chi Square Distribution\nExample\nResult",
      "examples": [
        "from numpy import random\n\nx = random.chisquare(df=2, size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.chisquare(df=1, size=1000), kind=\"kde\")\n\nplt.show()",
        "df",
        "size"
      ]
    },
    {
      "title": "Rayleigh Distribution",
      "summary": "Rayleigh Distribution\nRayleigh distribution is used in signal processing.\nIt has two parameters:\nscale - (standard deviation) decides how flat the distribution will be default 1.0).\nsize - The shape of the returned array.\nExampleGet your own Python Server\nDraw out a sample for rayleigh distribution with scale of 2 with size 2x3:\nVisualization of Rayleigh Distribution\nExample\nResult\nSimilarity Between Rayleigh and Chi Square Distribution\nAt unit stddev and 2 degrees of freedom rayleigh and chi square represent the same distributions.",
      "examples": [
        "from numpy import random\n\nx = random.rayleigh(scale=2, size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.rayleigh(size=1000), kind=\"kde\")\n\nplt.show()",
        "scale",
        "size"
      ]
    },
    {
      "title": "Pareto Distribution",
      "summary": "Pareto Distribution\nA distribution following Pareto's law i.e. 80-20 distribution (20% factors cause 80% outcome).\nIt has two parameter:\na - shape parameter.\nsize - The shape of the returned array.\nExampleGet your own Python Server\nDraw out a sample for pareto distribution with shape of 2 with size 2x3:\nVisualization of Pareto Distribution\nExample\nResult",
      "examples": [
        "from numpy import random\n\nx = random.pareto(a=2, size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.displot(random.pareto(a=2, size=1000))\n\nplt.show()",
        "a",
        "size"
      ]
    },
    {
      "title": "Zipf Distribution",
      "summary": "Zipf distributions are used to sample data based on zipf's law.\nZipf's Law: In a collection, the nth common term is 1/n times of the most common term. E.g. the 5th most common word in English occurs nearly 1/5 times as often as the most common word.\nIt has two parameters:\na - distribution parameter.\nsize - The shape of the returned array.\nExampleGet your own Python Server\nDraw out a sample for zipf distribution with distribution parameter 2 with size 2x3:\nVisualization of Zipf Distribution\nSample 1000 points but plotting only ones with value < 10 for more meaningful chart.\nExample\nResult",
      "examples": [
        "from numpy import random\n\nx = random.zipf(a=2, size=(2, 3))\n\nprint(x)",
        "from numpy import random\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nx = random.zipf(a=2, size=1000)\nsns.displot(x[x<10])\n\nplt.show()",
        "a",
        "size"
      ]
    },
    {
      "title": "NumPy ufuncs",
      "summary": "What are ufuncs?\nufuncs stands for \"Universal Functions\" and they are NumPy functions that operate on the ndarray object.\nWhy use ufuncs?\nufuncs are used to implement vectorization in NumPy which is way faster than iterating over elements.\nThey also provide broadcasting and additional methods like reduce, accumulate etc. that are very helpful for computation.\nufuncs also take additional arguments, like:\nwhere boolean array or condition defining where the operations should take place.\ndtype defining the return type of elements.\nout output array where the return value should be copied.\nWhat is Vectorization?\nConverting iterative statements into a vector based operation is called vectorization.\nIt is faster as modern CPUs are optimized for such operations.\nAdd the Elements of Two Lists\nlist 1: [1, 2, 3, 4]\nlist 2: [4, 5, 6, 7]\nOne way of doing it is to iterate over both of the lists and then sum each elements.\nExampleGet your own Python Server\nWithout ufunc, we can use Python's built-in zip() method:\nNumPy has a ufunc for this, called add(x, y) that will produce the same result.\nExample\nWith ufunc, we can use the add() function:",
      "examples": [
        "x = [1, 2, 3, 4]\ny = [4, 5, 6, 7]\nz = []\n\nfor i, j in zip(x, y):\nz.append(i + j)\nprint(z)",
        "import numpy as np\n\nx = [1, 2, 3, 4]\ny = [4, 5, 6, 7]\nz = np.add(x, y)\n\nprint(z)",
        "ndarray",
        "where",
        "dtype",
        "out",
        "zip()",
        "add(x, y)",
        "add()"
      ]
    },
    {
      "title": "Create Your Own ufunc",
      "summary": "How To Create Your Own ufunc\nTo create your own ufunc, you have to define a function, like you do with normal functions in Python, then you add it to your NumPy ufunc library with the frompyfunc() method.\nThe frompyfunc() method takes the following arguments:\nfunction - the name of the function.\ninputs - the number of input arguments (arrays).\noutputs - the number of output arrays.\nExampleGet your own Python Server\nCreate your own ufunc for addition:\nCheck if a Function is a ufunc\nCheck the type of a function to check if it is a ufunc or not.\nA ufunc should return <class 'numpy.ufunc'>.\nExample\nCheck if a function is a ufunc:\nIf it is not a ufunc, it will return another type, like this built-in NumPy function for joining two or more arrays:\nExample\nCheck the type of another function: concatenate():\nIf the function is not recognized at all, it will return an error:\nExample\nCheck the type of something that does not exist. This will produce an error:\nTo test if the function is a ufunc in an if statement, use the numpy.ufunc value (or np.ufunc if you use np as an alias for numpy):\nExample\nUse an if statement to check if the function is a ufunc or not:",
      "examples": [
        "import numpy as np\n\ndef myadd(x, y):\nreturn x+y\n\nmyadd = np.frompyfunc(myadd, 2, 1)\n\nprint(myadd([1, 2, 3, 4], [5, 6, 7, 8]))",
        "import numpy as np\n\nprint(type(np.add))",
        "import numpy as np\n\nprint(type(np.concatenate))",
        "import numpy as np\n\nprint(type(np.blahblah))",
        "import numpy as np\n\nif type(np.add) == np.ufunc:\nprint('add is ufunc')\nelse:\nprint('add is not ufunc')",
        "frompyfunc()",
        "function",
        "inputs",
        "outputs",
        "<class 'numpy.ufunc'>",
        "numpy.ufunc",
        "np.ufunc"
      ]
    },
    {
      "title": "Simple Arithmetic",
      "summary": "Simple Arithmetic\nYou could use arithmetic operators + - * / directly between NumPy arrays, but this section discusses an extension of the same where we have functions that can take any array-like objects e.g. lists, tuples etc. and perform arithmetic conditionally.\nArithmetic Conditionally: means that we can define conditions where the arithmetic operation should happen.\nAll of the discussed arithmetic functions take a where parameter in which we can specify that condition.\nAddition\nThe add() function sums the content of two arrays, and return the results in a new array.\nExampleGet your own Python Server\nAdd the values in arr1 to the values in arr2:\nThe example above will return [30 32 34 36 38 40] which is the sums of 10+20, 11+21, 12+22 etc.\nSubtraction\nThe subtract() function subtracts the values from one array with the values from another array, and return the results in a new array.\nExample\nSubtract the values in arr2 from the values in arr1:\nThe example above will return [-10 -1 8 17 26 35] which is the result of 10-20, 20-21, 30-22 etc.\nREMOVE ADS\nMultiplication\nThe multiply() function multiplies the values from one array with the values from another array, and return the results in a new array.\nExample\nMultiply the values in arr1 with the values in arr2:\nThe example above will return [200 420 660 920 1200 1500] which is the result of 10*20, 20*21, 30*22 etc.\nDivision\nThe divide() function divides the values from one array with the values from another array, and return the results in a new array.\nExample\nDivide the values in arr1 with the values in arr2:\nThe example above will return [3.33333333 4. 3. 5. 25. 1.81818182] which is the result of 10/3, 20/5, 30/10 etc.\nPower\nThe power() function rises the values from the first array to the power of the values of the second array, and return the results in a new array.\nExample\nRaise the valules in arr1 to the power of values in arr2:\nThe example above will return [1000 3200000 729000000 6553600000000 2500 0] which is the result of 10*10*10, 20*20*20*20*20, 30*30*30*30*30*30 etc.\nRemainder\nBoth the mod() and the remainder() functions return the remainder of the values in the first array corresponding to the values in the second array, and return the results in a new array.\nExample\nReturn the remainders:\nThe example above will return [1 6 3 0 0 27] which is the remainders when you divide 10 with 3 (10%3), 20 with 7 (20%7) 30 with 9 (30%9) etc.\nYou get the same result when using the remainder() function:\nExample\nReturn the remainders:\nQuotient and Mod\nThe divmod() function return both the quotient and the mod. The return value is two arrays, the first array contains the quotient and second array contains the mod.\nExample\nReturn the quotient and mod:\nThe example above will return:\n(array([3, 2, 3, 5, 25, 1]), array([1, 6, 3, 0, 0, 27]))\nThe first array represents the quotients, (the integer value when you divide 10 with 3, 20 with 7, 30 with 9 etc.\nThe second array represents the remainders of the same divisions.\nAbsolute Values\nBoth the absolute() and the abs() functions do the same absolute operation element-wise but we should use absolute() to avoid confusion with python's inbuilt math.abs()\nExample\nReturn the absolute values of the array:\nThe example above will return [1 2 1 2 3 4].",
      "examples": [
        "import numpy as np\n\narr1 = np.array([10, 11, 12, 13, 14, 15])\narr2 = np.array([20, 21, 22, 23, 24, 25])\n\nnewarr = np.add(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([10, 20, 30, 40, 50, 60])\narr2 = np.array([20, 21, 22, 23, 24, 25])\n\nnewarr = np.subtract(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([10, 20, 30, 40, 50, 60])\narr2 = np.array([3, 5, 10, 8, 2, 33])\n\nnewarr = np.divide(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([10, 20, 30, 40, 50, 60])\narr2 = np.array([3, 5, 6, 8, 2, 33])\n\nnewarr = np.power(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([10, 20, 30, 40, 50, 60])\narr2 = np.array([3, 7, 9, 8, 2, 33])\n\nnewarr = np.mod(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([10, 20, 30, 40, 50, 60])\narr2 = np.array([3, 7, 9, 8, 2, 33])\n\nnewarr = np.remainder(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([10, 20, 30, 40, 50, 60])\narr2 = np.array([3, 7, 9, 8, 2, 33])\n\nnewarr = np.divmod(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([-1, -2, 1, 2, 3, -4])\n\nnewarr = np.absolute(arr)\n\nprint(newarr)",
        "+",
        "-",
        "*",
        "/",
        "where",
        "add()",
        "subtract()",
        "multiply()",
        "divide()",
        "power()",
        "mod()",
        "remainder()",
        "divmod()",
        "absolute()",
        "abs()",
        "math.abs()"
      ]
    },
    {
      "title": "Rounding Decimals",
      "summary": "Rounding Decimals\nThere are primarily five ways of rounding off decimals in NumPy:\ntruncation\nfix\nrounding\nfloor\nceil\nTruncation\nRemove the decimals, and return the float number closest to zero. Use the trunc() and fix() functions.\nExampleGet your own Python Server\nTruncate elements of following array:\nExample\nSame example, using fix():\nRounding\nThe around() function increments preceding digit or decimal by 1 if >=5 else do nothing.\nE.g. round off to 1 decimal point, 3.16666 is 3.2\nExample\nRound off 3.1666 to 2 decimal places:\nREMOVE ADS\nFloor\nThe floor() function rounds off decimal to nearest lower integer.\nE.g. floor of 3.166 is 3.\nExample\nFloor the elements of following array:\nCeil\nThe ceil() function rounds off decimal to nearest upper integer.\nE.g. ceil of 3.166 is 4.\nExample\nCeil the elements of following array:",
      "examples": [
        "import numpy as np\n\narr = np.trunc([-3.1666, 3.6667])\n\nprint(arr)",
        "import numpy as np\n\narr = np.fix([-3.1666, 3.6667])\n\nprint(arr)",
        "import numpy as np\n\narr = np.around(3.1666, 2)\n\nprint(arr)",
        "import numpy as np\n\narr = np.floor([-3.1666, 3.6667])\n\nprint(arr)",
        "import numpy as np\n\narr = np.ceil([-3.1666, 3.6667])\n\nprint(arr)",
        "trunc()",
        "fix()",
        "around()"
      ]
    },
    {
      "title": "NumPy Logs",
      "summary": "Logs\nNumPy provides functions to perform log at the base 2, e and 10.\nWe will also explore how we can take log for any base by creating a custom ufunc.\nAll of the log functions will place -inf or inf in the elements if the log can not be computed.\nLog at Base 2\nUse the log2() function to perform log at the base 2.\nExampleGet your own Python Server\nFind log at base 2 of all elements of following array:\nNote: The arange(1, 10) function returns an array with integers starting from 1 (included) to 10 (not included).\nLog at Base 10\nUse the log10() function to perform log at the base 10.\nExample\nFind log at base 10 of all elements of following array:\nNatural Log, or Log at Base e\nUse the log() function to perform log at the base e.\nExample\nFind log at base e of all elements of following array:\nLog at Any Base\nNumPy does not provide any function to take log at any base, so we can use the frompyfunc() function along with inbuilt function math.log() with two input parameters and one output parameter:\nExample",
      "examples": [
        "import numpy as np\n\narr = np.arange(1, 10)\n\nprint(np.log2(arr))",
        "import numpy as np\n\narr = np.arange(1, 10)\n\nprint(np.log10(arr))",
        "import numpy as np\n\narr = np.arange(1, 10)\n\nprint(np.log(arr))",
        "from math import log\nimport numpy as np\n\nnplog = np.frompyfunc(log, 2, 1)\n\nprint(nplog(100, 15))",
        "log2()",
        "arange(1, 10)",
        "log10()",
        "log()",
        "frompyfunc()",
        "math.log()"
      ]
    },
    {
      "title": "NumPy Summations",
      "summary": "Summations\nWhat is the difference between summation and addition?\nAddition is done between two arguments whereas summation happens over n elements.\nExampleGet your own Python Server\nAdd the values in arr1 to the values in arr2:\nReturns: [2 4 6]\nExample\nSum the values in arr1 and the values in arr2:\nReturns: 12\nSummation Over an Axis\nIf you specify axis=1, NumPy will sum the numbers in each array.\nExample\nPerform summation in the following array over 1st axis:\nReturns: [6 6]\nCummulative Sum\nCummulative sum means partially adding the elements in array.\nE.g. The partial sum of [1, 2, 3, 4] would be [1, 1+2, 1+2+3, 1+2+3+4] = [1, 3, 6, 10].\nPerfom partial sum with the cumsum() function.\nExample\nPerform cummulative summation in the following array:\nReturns: [1 3 6]",
      "examples": [
        "import numpy as np\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2, 3])\n\nnewarr = np.add(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2, 3])\n\nnewarr = np.sum([arr1, arr2])\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3])\narr2 = np.array([1, 2, 3])\n\nnewarr = np.sum([arr1, arr2], axis=1)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([1, 2, 3])\n\nnewarr = np.cumsum(arr)\n\nprint(newarr)",
        "[2 4 6]",
        "12",
        "axis=1",
        "[6 6]",
        "cumsum()",
        "[1 3 6]"
      ]
    },
    {
      "title": "NumPy Products",
      "summary": "Products\nTo find the product of the elements in an array, use the prod() function.\nExampleGet your own Python Server\nFind the product of the elements of this array:\nReturns: 24 because 1*2*3*4 = 24\nExample\nFind the product of the elements of two arrays:\nReturns: 40320 because 1*2*3*4*5*6*7*8 = 40320\nProduct Over an Axis\nIf you specify axis=1, NumPy will return the product of each array.\nExample\nPerform summation in the following array over 1st axis:\nReturns: [24 1680]\nCummulative Product\nCummulative product means taking the product partially.\nE.g. The partial product of [1, 2, 3, 4] is [1, 1*2, 1*2*3, 1*2*3*4] = [1, 2, 6, 24]\nPerfom partial sum with the cumprod() function.\nExample\nTake cummulative product of all elements for following array:\nReturns: [5 30 210 1680]",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4])\n\nx = np.prod(arr)\n\nprint(x)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3, 4])\narr2 = np.array([5, 6, 7, 8])\n\nx = np.prod([arr1, arr2])\n\nprint(x)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3, 4])\narr2 = np.array([5, 6, 7, 8])\n\nnewarr = np.prod([arr1, arr2], axis=1)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([5, 6, 7, 8])\n\nnewarr = np.cumprod(arr)\n\nprint(newarr)",
        "prod()",
        "24",
        "40320",
        "axis=1",
        "[24 1680]",
        "cumprod()",
        "[5 30 210 1680]"
      ]
    },
    {
      "title": "NumPy Differences",
      "summary": "Differences\nA discrete difference means subtracting two successive elements.\nE.g. for [1, 2, 3, 4], the discrete difference would be [2-1, 3-2, 4-3] = [1, 1, 1]\nTo find the discrete difference, use the diff() function.\nExampleGet your own Python Server\nCompute discrete difference of the following array:\nReturns: [5 10 -20] because 15-10=5, 25-15=10, and 5-25=-20\nWe can perform this operation repeatedly by giving parameter n.\nExample\nCompute discrete difference of the following array twice:\nReturns: [5 -30] because: 15-10=5, 25-15=10, and 5-25=-20 AND 10-5=5 and -20-10=-30",
      "examples": [
        "import numpy as np\n\narr = np.array([10, 15, 25, 5])\n\nnewarr = np.diff(arr)\n\nprint(newarr)",
        "import numpy as np\n\narr = np.array([10, 15, 25, 5])\n\nnewarr = np.diff(arr, n=2)\n\nprint(newarr)",
        "diff()",
        "[5 10 -20]",
        "n",
        "[5 -30]"
      ]
    },
    {
      "title": "NumPy LCM Lowest Common Multiple",
      "summary": "Finding LCM (Lowest Common Multiple)\nThe Lowest Common Multiple is the smallest number that is a common multiple of two numbers.\nExampleGet your own Python Server\nFind the LCM of the following two numbers:\nReturns: 12 because that is the lowest common multiple of both numbers (4*3=12 and 6*2=12).\nFinding LCM in Arrays\nTo find the Lowest Common Multiple of all values in an array, you can use the reduce() method.\nThe reduce() method will use the ufunc, in this case the lcm() function, on each element, and reduce the array by one dimension.\nExample\nFind the LCM of the values of the following array:\nReturns: 18 because that is the lowest common multiple of all three numbers (3*6=18, 6*3=18 and 9*2=18).\nExample\nFind the LCM of all values of an array where the array contains all integers from 1 to 10:",
      "examples": [
        "import numpy as np\n\nnum1 = 4\nnum2 = 6\n\nx = np.lcm(num1, num2)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([3, 6, 9])\n\nx = np.lcm.reduce(arr)\n\nprint(x)",
        "import numpy as np\n\narr = np.arange(1, 11)\n\nx = np.lcm.reduce(arr)\n\nprint(x)",
        "12",
        "reduce()",
        "lcm()",
        "18"
      ]
    },
    {
      "title": "NumPy GCD Greatest Common Divisor",
      "summary": "Finding GCD (Greatest Common Divisor)\nThe GCD (Greatest Common Divisor), also known as HCF (Highest Common Factor) is the biggest number that is a common factor of both of the numbers.\nExampleGet your own Python Server\nFind the HCF of the following two numbers:\nReturns: 3 because that is the highest number both numbers can be divided by (6/3=2 and 9/3=3).\nFinding GCD in Arrays\nTo find the Highest Common Factor of all values in an array, you can use the reduce() method.\nThe reduce() method will use the ufunc, in this case the gcd() function, on each element, and reduce the array by one dimension.\nExample\nFind the GCD for all of the numbers in the following array:\nReturns: 4 because that is the highest number all values can be divided by.",
      "examples": [
        "import numpy as np\n\nnum1 = 6\nnum2 = 9\n\nx = np.gcd(num1, num2)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([20, 8, 32, 36, 16])\n\nx = np.gcd.reduce(arr)\n\nprint(x)",
        "3",
        "reduce()",
        "gcd()",
        "4"
      ]
    },
    {
      "title": "NumPy Trigonometric Functions",
      "summary": "Trigonometric Functions\nNumPy provides the ufuncs sin(), cos() and tan() that take values in radians and produce the corresponding sin, cos and tan values.\nExampleGet your own Python Server\nFind sine value of PI/2:\nExample\nFind sine values for all of the values in arr:\nConvert Degrees Into Radians\nBy default all of the trigonometric functions take radians as parameters but we can convert radians to degrees and vice versa as well in NumPy.\nNote: radians values are pi/180 * degree_values.\nExample\nConvert all of the values in following array arr to radians:\nREMOVE ADS\nRadians to Degrees\nExample\nConvert all of the values in following array arr to degrees:\nFinding Angles\nFinding angles from values of sine, cos, tan. E.g. sin, cos and tan inverse (arcsin, arccos, arctan).\nNumPy provides ufuncs arcsin(), arccos() and arctan() that produce radian values for corresponding sin, cos and tan values given.\nExample\nFind the angle of 1.0:\nAngles of Each Value in Arrays\nExample\nFind the angle for all of the sine values in the array\nHypotenues\nFinding hypotenues using pythagoras theorem in NumPy.\nNumPy provides the hypot() function that takes the base and perpendicular values and produces hypotenues based on pythagoras theorem.\nExample\nFind the hypotenues for 4 base and 3 perpendicular:",
      "examples": [
        "import numpy as np\n\nx = np.sin(np.pi/2)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([np.pi/2, np.pi/3, np.pi/4, np.pi/5])\n\nx = np.sin(arr)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([90, 180, 270, 360])\n\nx = np.deg2rad(arr)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi])\n\nx = np.rad2deg(arr)\n\nprint(x)",
        "import numpy as np\n\nx = np.arcsin(1.0)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([1, -1, 0.1])\n\nx = np.arcsin(arr)\n\nprint(x)",
        "import numpy as np\n\nbase = 3\nperp = 4\n\nx = np.hypot(base, perp)\n\nprint(x)",
        "sin()",
        "cos()",
        "tan()",
        "arcsin()",
        "arccos()",
        "arctan()",
        "hypot()"
      ]
    },
    {
      "title": "NumPy Hyperbolic Functions",
      "summary": "Hyperbolic Functions\nNumPy provides the ufuncs sinh(), cosh() and tanh() that take values in radians and produce the corresponding sinh, cosh and tanh values..\nExampleGet your own Python Server\nFind sinh value of PI/2:\nExample\nFind cosh values for all of the values in arr:\nFinding Angles\nFinding angles from values of hyperbolic sine, cos, tan. E.g. sinh, cosh and tanh inverse (arcsinh, arccosh, arctanh).\nNumpy provides ufuncs arcsinh(), arccosh() and arctanh() that produce radian values for corresponding sinh, cosh and tanh values given.\nExample\nFind the angle of 1.0:\nAngles of Each Value in Arrays\nExample\nFind the angle for all of the tanh values in array:",
      "examples": [
        "import numpy as np\n\nx = np.sinh(np.pi/2)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([np.pi/2, np.pi/3, np.pi/4, np.pi/5])\n\nx = np.cosh(arr)\n\nprint(x)",
        "import numpy as np\n\nx = np.arcsinh(1.0)\n\nprint(x)",
        "import numpy as np\n\narr = np.array([0.1, 0.2, 0.5])\n\nx = np.arctanh(arr)\n\nprint(x)",
        "sinh()",
        "cosh()",
        "tanh()",
        "arcsinh()",
        "arccosh()",
        "arctanh()"
      ]
    },
    {
      "title": "NumPy Set Operations",
      "summary": "What is a Set\nA set in mathematics is a collection of unique elements.\nSets are used for operations involving frequent intersection, union and difference operations.\nCreate Sets in NumPy\nWe can use NumPy's unique() method to find unique elements from any array. E.g. create a set array, but remember that the set arrays should only be 1-D arrays.\nExampleGet your own Python Server\nConvert following array with repeated elements to a set:\nFinding Union\nTo find the unique values of two arrays, use the union1d() method.\nExample\nFind union of the following two set arrays:\nFinding Intersection\nTo find only the values that are present in both arrays, use the intersect1d() method.\nExample\nFind intersection of the following two set arrays:\nNote: the intersect1d() method takes an optional argument assume_unique, which if set to True can speed up computation. It should always be set to True when dealing with sets.\nFinding Difference\nTo find only the values in the first set that is NOT present in the seconds set, use the setdiff1d() method.\nExample\nFind the difference of the set1 from set2:\nNote: the setdiff1d() method takes an optional argument assume_unique, which if set to True can speed up computation. It should always be set to True when dealing with sets.\nFinding Symmetric Difference\nTo find only the values that are NOT present in BOTH sets, use the setxor1d() method.\nExample\nFind the symmetric difference of the set1 and set2:\nNote: the setxor1d() method takes an optional argument assume_unique, which if set to True can speed up computation. It should always be set to True when dealing with sets.",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 1, 1, 2, 3, 4, 5, 5, 6, 7])\n\nx = np.unique(arr)\n\nprint(x)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3, 4])\narr2 = np.array([3, 4, 5, 6])\n\nnewarr = np.union1d(arr1, arr2)\n\nprint(newarr)",
        "import numpy as np\n\narr1 = np.array([1, 2, 3, 4])\narr2 = np.array([3, 4, 5, 6])\n\nnewarr = np.intersect1d(arr1, arr2, assume_unique=True)\n\nprint(newarr)",
        "import numpy as np\n\nset1 = np.array([1, 2, 3, 4])\nset2 = np.array([3, 4, 5, 6])\n\nnewarr = np.setdiff1d(set1, set2, assume_unique=True)\n\nprint(newarr)",
        "import numpy as np\n\nset1 = np.array([1, 2, 3, 4])\nset2 = np.array([3, 4, 5, 6])\n\nnewarr = np.setxor1d(set1, set2, assume_unique=True)\n\nprint(newarr)",
        "unique()",
        "union1d()",
        "intersect1d()",
        "assume_unique",
        "setdiff1d()",
        "setxor1d()"
      ]
    },
    {
      "title": "NumPy Online Compiler (Editor)",
      "summary": "NumPy (Python) Editor\nWith our \"Try it Yourself\" editor, you can edit Python code and use the NumPy module, and view the result in your browser.\nExample\nClick on the \"Try it Yourself\" button to see how it works.\nPublish Your Code\nIf you want to create your own website or build Python applications, check out W3Schools Spaces.\nW3Schools Spaces is a website-building tool that enables you to create and share your own website. You can also get a Python server, allowing you to develop and host your Python applications with ease.\nNote: This includes Python libraries such as: Django, Pandas, NumPy, SciPy and more.\nYou can change the website's look and how it works by editing the code right in your web browser.\nIt's easy to use and doesn't require any setup\nThe code editor is packed with features to help you achieve more:\nTemplates: Start from scratch or use a template\nCloud-based: no installations required. You only need your browser\nTerminal & Log: debug and troubleshoot your code easily\nFile Navigator: switch between files inside the code editor\nAnd much more!\nLearn Faster\nPractice is key to mastering coding, and the best way to put your Python knowledge into practice is by getting practical with code.\nUse W3Schools Spaces to build, test and deploy code.\nThe code editor lets you write and practice different types of computer languages. It includes Python, but you can use it for other languages too.\nNew languages are added all the time:\nIf you don't know Python, we suggest that you read our Python Tutorial from scratch.\nEasy Package Management\nGet an overview of your packages and easily add or delete frameworks and libraries. Then, with just one click, you can make changes to your packages without manual installation.\nBuild Powerful Websites\nYou can also use the code editor in W3School Spaces to build frontend or full-stack websites from scratch.\nOr you can use the 60+ templates available and save time:\nCreate your Spaces account today and explore them all!\nShare Your Website With The World\nHost and publish your websites in no time with W3School Spaces.\nW3Schools subdomain and SSL certificate are included for free with W3School Spaces. An SSL certificate makes your website safe and secure. It also helps people trust your website and makes it easier to find it online.\nWant a custom domain for your website?\nYou can buy a domain or transfer an existing one and connect it to your space.\nHow Does It Work?\nGet started in a few clicks with W3School Spaces.",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr)\n\nprint(type(arr))",
        "[1 2 3 4 5]\n<class 'numpy.ndarray'>"
      ]
    },
    {
      "title": "NumPy Quiz",
      "summary": "You can test your NumPy skills with W3Schools' Quiz.\nThe Test\nThe test contains 25 questions and there is no time limit.\nThe test is not official, it's just a nice way to see how much you know, or don't know, about NumPy.\nCount Your Score\nYou will get 1 point for each correct answer. At the end of the Quiz, your total score will be displayed. Maximum score is 25 points.\nStart the Quiz\nGood luck!\nStart the NumPy Quiz ❯\nIf you don't know NumPy, we suggest that you read our NumPy Tutorial from scratch.\nKickstart your career\nGet certified by completing the PYTHON course",
      "examples": []
    },
    {
      "title": "NumPy Exercises",
      "summary": "Exercises\nTest your NumPy skills with exercises from all categories:\nIntroduction\nCreating Arrays\nIndexing Arrays\nSlicing Arrays\nData Types\nCopy vs View\nShape Arrays\nReshape Arrays\nIteration Arrays\nJoin Arrays\nSplit Arrays\nSearch Arrays\nSort Arrays\nFilter Arrays\nRandom\nRandom Data Distribution\nRandom Permutation\nNormal Distribution\nBinomial Distribution\nPoisson Distribution\nUniform Distribution\nLogistic Distribution\nMultinomial Distribution\nExponential Distribution\nChi Square Distribution\nRayleigh Distribution\nPareto Distribution\nZipf Distribution\nUfuncs\nCreate Ufunc\nSimple Arithmetic\nRounding Decimals\nLogs\nSummations\nProducts\nDifferences\nFinding LCM\nFinding GCD\nTrigonometric\nHyperbolic\nSet Operations\nLog in to track your progress\nIf you haven't already, sign up to become a W3Schooler, and get points for every exercise you complete.\nAs a logged on W3Schools user you will have access to many features like having your own web page, track your learning progress, receive personal guided paths, and more.\nThe Exercise\nThe exercises are a mix of \"multiple choice\" and \"fill in the blanks\" questions. There are between 3 and 9 questions in each category. The answer can be found in the corresponding tutorial chapter. If you're stuck, or answer wrong, you can try again or hit the \"Show Answer\" button to see the correct answer.\nKickstart your career\nGet certified by completing the PYTHON course",
      "examples": []
    },
    {
      "title": "NumPy Syllabus",
      "summary": "Introduction\nThe W3Schools NumPy Tutorial is comprehensive and beginner-friendly.\nIt will give you a fundamental knowledge of NumPy.\nIt is designed for beginners and requires only basic Python knowledge.\nThe content has been carefully made to be bite-sized, simple, and easy to understand.\nThe content has been proven by millions of users over the years. It is updated and improved frequently.\nThe syllabus outline and its sequence are structured so you can learn NumPy step by step, from the introduction to creating your first array operations.\nGet Started With NumPy »\nLearning Outcomes\nUnderstand the basic structure of NumPy arrays.\nCreate and manipulate arrays efficiently.\nPerform mathematical operations on arrays.\nApply array indexing and slicing.\nUse array functions and methods.\nPerform array reshaping and stacking.\nWork with random number generation.\nApply linear algebra operations.\nCreate efficient numerical computations.\nNote: Are you a teacher teaching NumPy? W3Schools Academy is a toolbox of features that can help you teach. It offers classroom features such as pre-built study plans, classroom administration and much more. Read more about Academy here.\nWhich Subjects Are NumPy Relevant For?\nData Science:\nNumPy is essential for numerical computing and data manipulation.\nScientific Computing:\nNumPy provides powerful tools for scientific calculations and analysis.\nMachine Learning:\nNumPy is fundamental for handling numerical data in Machine Learning applications.\nStatistics:\nNumPy offers efficient tools for statistical calculations.\nImage Processing:\nNumPy arrays are perfect for handling image data.\nEngineering:\nNumPy supports mathematical operations for engineering applications.\nResearch:\nNumPy is widely used in scientific research and data analysis.\nGet Started\nActivities\nIn this tutorial we offer different activities for you to learn NumPy for free:\nLessons\nExercises\nQuizzes\nSign in to Track Progress\nYou can also create a free account to track your progress.\nAs a signed-in user, you get access to features such as:\nLearning paths\nSandbox and lab environments\nAchievements\nAnd much more!\nSign Up - It's free\nOverview of the Modules\nNumPy HOME\nNumPy Intro\nNumPy Getting Started\nNumPy Creating Arrays\nNumPy Array Indexing\nNumPy Array Slicing\nNumPy Data Types\nNumPy Copy vs View\nNumPy Array Shape\nNumPy Array Reshape\nNumPy Array Iterating\nNumPy Array Join\nNumPy Array Split\nNumPy Array Search\nNumPy Array Sort\nNumPy Array Filter\nRandom Intro\nData Distribution\nRandom Permutation\nSeaborn Module\nNormal Distribution\nBinomial Distribution\nPoisson Distribution\nUniform Distribution\nLogistic Distribution\nMultinomial Distribution\nExponential Distribution\nChi Square Distribution\nRayleigh Distribution\nPareto Distribution\nZipf Distribution\nufunc Intro\nufunc Create Function\nufunc Simple Arithmetic\nufunc Rounding Decimals\nufunc Logs\nufunc Summations\nufunc Products\nufunc Differences\nufunc Finding LCM\nufunc Finding GCD\nufunc Trigonometric\nufunc Hyperbolic\nufunc Set Operations\nGet Started\nSandbox and Lab Environment\nNumPy, like any other library, is best learned through hands-on practice.\nTry this example using our editor:\nExampleGet your own Python Server\nCreate a NumPy array:\nIf you want to explore more and host your project, we have a feature called Spaces that allows you to build, test and deploy Python projects for free.\nHere you get a secure sandbox environment called Spaces, where you can practice NumPy code and test projects in real-time.\nSpaces allow you to test, build, and deploy code. This includes a W3Schools subdomain, hosting, and secure SSL certificates.\nSpaces require no installation and run directly in the browser.\nFeatures include:\nCollaboration\nFile navigator\nTerminal & log\nPackage manager\nDatabase\nEnvironment manager\nAnalytics\nCreate a Spaces Account\nNumPy Certification\nW3Schools offers an end-of-pathway certification program.\nHere you can take exams to get certified.\nThe NumPy exam is a test that summarizes the W3Schools NumPy syllabus.\nAfter passing the exam you get the \"Certified NumPy Developer\" Certification.\nThere are two different types of certifications:\nNon-adaptive\nAdaptive\nThe non-adaptive is pass or no pass.\nThe adaptive certification is adaptive and graded; students will get a grade from intermediate, advanced to professional.\nBuy Certificate »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach NumPy?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": [
        "import numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr)\n\nprint(type(arr))"
      ]
    },
    {
      "title": "NumPy Study Plan",
      "summary": "Introduction\nThe NumPy study plan helps you teach your students NumPy step-by-step.\nCreating a study plan for NumPy is easy.\nYou can use a pre-built study plan or customize it.\nStudents have different skill levels. The study plans can be customized to ensure that everyone is challenged.\nSave time with pre-built teacher materials and study plans. Easily organize your class with a timeline from the introduction of NumPy to the final exam.\nW3Schools Academy\nThis study plan is a feature of W3Schools Academy.\nW3Schools Academy is a platform that has everything you need to teach coding, all in one place.\nIt offers you as a teacher a toolbox of features that helps you succeed with teaching in your classroom.\nYou need to have an active subscription to access the study plan feature. There are two different subscription tiers:\nEssentials ($1.99 / month per student)\nFull Access ($5.99 / month per student)\nCalculate your price and order here.\nLearn More »\nAcademy also offer other features such as:\nManaging your classroom\nTracking of student progress and reports\nLabs, assignments, and code challenges (prebuilt challenges or create your own ones)\nAuto-grading\nTeaching materials\nCertification exams\nGet a free demo »\nTeacher Materials\nW3Schools has everything you need to teach NumPy.\nThe NumPy training materials is available for you to include and use in your study plan:\nW3Schools NumPy Tutorial\nNumPy Exercises\nNumPy Quiz\nNumPy Challenges (Coding challenges)\nNumPy Certification Exam (End of Pathway Exam)\nNumPy Syllabus\nWith the NumPy Syllabus, your students will start with the basics, like creating arrays and performing basic operations, and move to more advanced topics, like slicing arrays, working with array shapes, and performing mathematical calculations. Each chapter includes examples, try-it-yourself sections, exercises, and quizzes to make learning easy, interactive, and fun.\nRead more about NumPy Syllabus.\nStudy Plan Overview\nThe study plan features are made to help teachers and students. They make learning easy, flexible, and fun. These features work for different types of classes, learning styles and student level.\nLearning Paths\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nYou can add ready-made learning paths.\nThe learning paths are by default ordered by our recommended order.\nYou can change the order.\nYou can add custom activities with text, links, or multi-media files.\nDrag and drop or click to make changes to the path.\nInteractive Content\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTutorials\nTry-its (test code snippets)\nExercises\nQuiz\nChallenges\nLabs\nTimeline and Pace\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nYou can set a timeline of your study plan (e.g., 4-week, 8-week, 12-week, 24-week plans).\nYou can decide the learning pace for your class.\nDifferent study plans can be assigned to different students in the same class.\nThe flexibility can help to make sure that everyone is challenged.\nTrack Student Progress\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nThere are tools to track student progress.\nThe analytic tools include: chapter progress, exercises results, quiz results, exam results, and much more.\nThe challenges can be auto-graded or manually graded. The results are available to you as a teacher.\nEnd of Pathway Exam\nThe NumPy study plan aligns with the NumPy Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the NumPy Tutorial.\nYou get reports of the students' results.\nThe NumPy study plan aligns with the NumPy Certification Exam.\nThe exam can be taken at the end of the study plan, at your selected date.\nThe exam summarizes the NumPy Tutorial.\nYou get reports of the students' results.\nAccessibility\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nStudy plans and learning materials are accessible on desktops, tablets, and smartphones.\nThis ensures students can learn anytime, anywhere.\nLearn More »\nSample Study Plan\nYou choose the timeline and pace of your study plans.\nSchools have different preferences.\nSome would like more intensive pace, e.g. 3 weeks, others 12 or more weeks.\nIt is completely up to you.\nFor example, this is how a 3-week NumPy study plan could look like:\nWeek 1: Introduction, Getting Started\nWeek 2: Arrays\nWeek 3: Random, ufunc, NumPy Certification Exam\nImage of Sample NumPy study plan:\nReady to get started?\nStart with NumPy Study Plans today.\nGet Started »\nAre You a Teacher?\nAre you interested in learning how you can use W3Schools Academy to Teach NumPy programming?\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\nWatch Demo »",
      "examples": []
    },
    {
      "title": "NumPy Certification",
      "summary": "W3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nW3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate »\nWho Should Consider Getting Certified?\nAny student or professional within the digital industry.\nCertifications are valuable assets to gain trust and demonstrate knowledge to your clients, current or future employers on a ever increasing competitive market.\nW3Schools is Trusted by Top Companies\nW3Schools has over two decades of experience with teaching coding online.\nOur certificates are recognized and valued by companies looking to employ skilled developers.\nSave Time and Money\nShow the world your coding skills by getting a certification.\nThe prices is a small fraction compared to the price of traditional education.\nDocument and validate your competence by getting certified!\nExam overview\nFee: 95 USD\nAchievable certification levels:\nIntermediate (40%)\nAdvanced (75%)\nProfessional (90%)\nNumber of questions:\nAdaptive, 60 on average\nRequirement to pass:\nMinimum 40% - Intermediate level\nTime limit: 60 minutes\nNumber of attempts to pass: 3\nExam deadline: None\nCertification Expiration: None\nFormat: Online, multiple choice\nRegister now »\nAdvance Faster in Your Career\nGetting a certificate proves your commitment to upgrading your skills.\nThe certificate can be added as credentials to your CV, Resume, LinkedIn profile, and so on.\nIt gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nKnowledge is power, especially in the current job market.\nDocumentation of your skills enables you to advance your career or helps you to start a new one.\nHow Does It Work?\nStudy for free at W3Schools.com\nStudy at your own speed\nTest your skills with W3Schools online quizzes\nApply for your certificate by paying an exam fee\nTake your exam online, at any time, and from any location\nGet Your Certificate and Share It With The World\nExample certificate:\nEach certificate gets a unique link that can be shared with others.\nValidate your certification with the link or QR code.\nCheck how it looks like in this Example.\nShare your certificate on Linked in the Certifications section in just one click!\nDocument Your Skills\nGetting a certificate proves your commitment to upgrade your skills, gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nGet Your Certificate »\nLooking to add multiple users?\nAre you an educator, manager or business owner looking for courses or certifications?\nWe are working with schools, companies and organizations from all over the world.\nGet courses and/or certifications for your team here.",
      "examples": []
    }
  ],
  "glossary": [
    "backend",
    "basic",
    "binomial distribution",
    "data distribution",
    "exercises",
    "exponential distribution",
    "free",
    "javascript",
    "logistic distribution",
    "multinomial distribution",
    "normal distribution",
    "numpy editor",
    "numpy exercises",
    "numpy home",
    "numpy intro",
    "numpy quiz",
    "numpy random",
    "numpy syllabus",
    "numpy ufunc",
    "pareto distribution",
    "poisson distribution",
    "programs",
    "quiz exercises",
    "random",
    "random intro",
    "random permutation",
    "rayleigh distribution",
    "references",
    "report error",
    "seaborn module",
    "ufunc",
    "ufunc differences",
    "ufunc hyperbolic",
    "ufunc intro",
    "ufunc logs",
    "ufunc products",
    "ufunc summations",
    "ufunc trigonometric",
    "uniform distribution",
    "w3schools spaces",
    "zipf distribution"
  ]
}