{
  "course_name": "Rust",
  "description": "Rust is a popular programming language used to build everything from web servers to game engines. Rust is known for being very fast, and is similar to C and C++ in language. Our \"Try it Yourself\" editor makes it easy to learn Rust. You can edit code and view the result in your browser: Click on the \"Try it Yourself\" button to see how it works. We recommend reading this tutorial, in the sequence listed in the left menu. Sign Up for Free Note: This is an optional feature. You can study at W3Schools without creating an account.",
  "course_summary": [
    {
      "title": "Rust Introduction",
      "summary": "What is Rust?\nRust is a modern programming language.\nIt is designed for performance, reliability, and safety - especially safe handling of memory.\nWhy Learn Rust?\nIt is one of the fastest-growing programming languages in the world\nLearning Rust makes it easier to pick up other languages like Java, Python, C++, and C#, because the syntax is similar.\nRust is very fast\nRust requires less memory compared to many other languages\nRust is used to build web servers, creating games, operating systems, and much more!\nDifference between Rust and C\\C++\nThe main difference is that Rust is \"safe by default\".\nIn Rust, memory access is automatically checked by the compiler, which helps you avoid common bugs like crashes, leaks, and unsafe memory behavior.\nIn C and C++, you must manually manage memory, which can lead to errors if you are not careful\nGet Started\nThis tutorial will teach you the basics of Rust.\nIt is not necessary to have any prior programming experience.",
      "examples": []
    },
    {
      "title": "Rust Get Started",
      "summary": "Get Started With Rust\nAt W3Schools, you can try Rust without installing anything.\nOur Online Rust Editor runs directly in your browser, and shows both the code and the result:\nCode:\nResult:\nInstall Rust\nHowever, if you want to download and install rust, you can go to rust-lang.org and follow the instructions there.\nOr, if you are using the terminal, you can run:\nCheck Installation\nAfter installing, check if Rust is installed correctly by running:\nThe output will look something like this, depending on your version number:\nCreate a New Project\nUse Cargo to create a new Rust project:\nThe output will look something like this:\nThis creates a folder called my_project with the following files:\nCargo.toml: Project settings\nsrc/main.rs: Main Rust file\nThe main.rs file contains this default code:\nBuild and Run the Project\nNext, write the following code to go into the project folder:\nThen build and run the project:\nThe output should be:\nCongratulations! You have just run your first Rust program.",
      "examples": [
        "fn main() {\nprintln!(\"Hello World!\");\n}",
        "curl https://sh.rustup.rs -sSf | sh",
        "rustc --version",
        "rustc 1.86.0 (05f9846f8 2025-03-31)",
        "cargo new my_project",
        "Creating binary (application) `my_project` package\nnote: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html",
        "fn main() {\nprintln!(\"Hello, world!\");\n}",
        "cd my_project",
        "cargo run",
        "Hello World!",
        "my_project",
        "Cargo.toml",
        "src/main.rs",
        "main.rs",
        "Hello, world!"
      ]
    },
    {
      "title": "Rust Syntax",
      "summary": "Syntax\nYou have already seen the following code a couple of times in the first chapters. Let's break it down to understand it better:\nExample\nExample explained\nLine 1: fn main() is something that always appears at the beginning of every Rust program. main() is called a function, and any code inside its curly brackets {} will be executed.\nLine 2: println!() is a macro, used to output/print text to the screen. In our example it will output \"Hello World!\". To end the code, you must remember a semicolon (;).\nWhat is a macro?\nA macro is like a function, but with an exclamation mark (!) after it. Don't worry about the terminology for now. For now, just know that macros are similar to functions (they execute things), but they do not always follow the same rules as functions. You will learn more about macros later.\nGood to know: The Rust compiler ignores white spaces.\nThe code above could also been written as:\nfn main(){println!(\"Hello World!\");}\nHowever, multiple lines and indentation makes the code more readable.",
      "examples": [
        "fn main() {\nprintln!(\"Hello World!\");\n}",
        "fn main()",
        "main()",
        "{}",
        "println!()",
        ";",
        "!",
        "fn main(){println!(\"Hello World!\");}"
      ]
    },
    {
      "title": "Rust Output (Print Text)",
      "summary": "Output (Print Text)\nTo print text in Rust, you can use the println!() macro:\nExample\nYou can use as many println!() macros as you want. Note that it will add a new line for each macro:\nExample\nThe Print Macro\nThere is also a print!() macro, which is similar to println!().\nThe only difference is that it does not insert a new line at the end of the output:\nExample\nNote that we add an extra space when needed (after \"Hello World!\" in the example above), for better readability.\nIn this tutorial, we will only use println!() as it makes it easier to read the output of code.\nAdd New Lines Manually\nIf you really want to add a new line in print!(), you can use the \\n character:\nExample\nJust like with many other programming languages, you can use the newline character (\\n) to break up lines. It is an escape sequence, and it forces the cursor to change its position to the beginning of the next line on the screen. This results in a new line.\nYou can also break up a line in the middle of a sentence. This goes for both print!() and println!():\nExample",
      "examples": [
        "println!(\"Hello World!\");",
        "println!(\"Hello World!\");\nprintln!(\"I am learning Rust.\");\nprintln!(\"It is awesome!\");",
        "print!(\"Hello World! \");\nprint!(\"I will print on the same line.\");",
        "print!(\"Hello World!\\n\");\nprint!(\"I will print on the same line.\");",
        "println!(\"Hello World!\\nThis line was broken up!\");",
        "println!()",
        "print!()",
        "\\n"
      ]
    },
    {
      "title": "Rust Comments",
      "summary": "Comments in Rust\nComments can be used to explain code, and to make it more readable. It can also be used to prevent execution when testing alternative code.\nComments can be singled-lined or multi-lined.\nSingle-line Comments\nSingle-line comments start with two forward slashes (//).\nAny text between // and the end of the line is ignored by the compiler (will not be executed).\nThis example uses a single-line comment before a line of code:\nExample\nThis example uses a single-line comment at the end of a line of code:\nExample\nMulti-line Comments\nMulti-line comments start with /* and ends with */.\nAny text between /* and */ will be ignored by the compiler:\nExample\nIt is up to you which you want to use. Normally, we use // for short comments, and /* */ for longer.",
      "examples": [
        "// This is a comment\nprintln!(\"Hello World!\");",
        "println!(\"Hello World!\"); // This is a comment",
        "/* The code below will print the words Hello World!\nto the screen, and it is amazing */\nprintln!(\"Hello World!\");",
        "//",
        "/*",
        "*/",
        "/* */"
      ]
    },
    {
      "title": "Rust Variables",
      "summary": "Variables\nVariables are containers for storing data values, like numbers and characters.\nTo create a variable in Rust, use the let keyword and specify the name of the variable (name in this example):\nExample\nWhat is {}?\nRust uses {} as a placeholder in println!() to show variable values.\nIn the example above, the output will be \"My first name is: John\".\nYou can use as many placeholders as you like:\nExample\nUsing Placeholders in Order\nWhen you use many placeholders, the values you pass are used in the same order.\nIn the example above:\nThe first {} gets replaced with name (\"John\")\nThe second {} gets replaced with age (30)\nImportant: The order matters. If you switch the values, the output will change:\nExample\nThis example shows wrong order:\nVariable Values Cannot be Changed by Default\nBy default, variables in Rust cannot be changed after they are created:\nChange Variable Values\nIf you want to change the value of a variable, you must use the mut keyword (which means mutable/changeable):\nExample",
      "examples": [
        "let name = \"John\";\nprintln!(\"My first name is: {}\", name);",
        "let name = \"John\";\nlet age = 30;\nprintln!(\"{} is {} years old.\", name, age);",
        "let name = \"John\";\nlet age = 30;\nprintln!(\"{} is {} years old.\", age, name);Â  // Outputs 30 is John years old",
        "let x = 5;\nx = 10; // Error\nprintln!(\"{}\", x);",
        "let mut x = 5;\nprintln!(\"Before: {}\", x);\nx = 10;\nprintln!(\"After: {}\", x);",
        "let",
        "{}",
        "println!()",
        "name",
        "age",
        "mut"
      ]
    },
    {
      "title": "Rust Data Types",
      "summary": "Data Types\nUnlike many other programming languages, variables in Rust do not need to be declared with a specified type (like \"String\" for text or \"Int\" for numbers, if you are familiar with those from C or Java).\nIn Rust, the type of a variable is decided by the value you give it. Rust looks at the value and automatically chooses the right type:\nExample\nHowever, it is possible to explicitly tell Rust what type a value should be:\nExample\nYou will learn more about when you need to specify the type later in this tutorial. Either way, it is good to understand what the different types mean.\nBasic data types in Rust are divided into different groups:\nNumbers - Whole numbers and decimal numbers (i32, f64)\nCharacters - Single letters or symbols (char)\nStrings - Text, a sequence of characters (&str)\nBooleans - True or false values (bool)\nNumbers\nNumber types are divided into two groups: integer types and floating point types.\nInteger (i32)\nThe i32 type is used to store whole numbers, positive or negative (such as 123 or -456), without decimals:\nExample\nFloating Point (f64)\nThe f64 type is used to store numbers containing one or more decimals:\nExample\nCharacters (char)\nThe char type is used to store a single character. A char value must be surrounded by single quotes, like 'A' or 'c':\nExample\nStrings (&str)\nThe &str type is used to store a sequence of characters (text). String values must be surrounded by double quotes:\nExample\nBooleans (bool)\nThe bool type can only take the values true or false:\nExample\nCombining Data Types\nYou can mix different types in the same program:\nExample",
      "examples": [
        "let my_num = 5;Â Â Â Â Â Â Â Â Â // integer\nlet my_double = 5.99;Â Â Â // float\nlet my_letter = 'D';Â Â Â Â // character\nlet my_bool = true;Â Â Â Â Â // boolean\nlet my_text = \"Hello\";Â Â // string",
        "let my_num: i32 = 5;Â Â Â Â Â Â Â Â Â Â // integer\nlet my_double: f64 = 5.99;Â Â Â Â // float\nlet my_letter: char = 'D';Â Â Â Â // character\nlet my_bool: bool = true;Â Â Â Â Â // boolean\nlet my_text: &str = \"Hello\";Â Â // string",
        "let age: i32 = 25;\nprintln!(\"Age is: {}\", age);",
        "let price: f64 = 19.99;\nprintln!(\"Price is: ${}\", price);",
        "let myGrade: char = 'B';\nprintln!(\"{}\", myGrade);",
        "let name: &str = \"John\";\nprintln!(\"Hello, {}!\", name);",
        "let is_logged_in: bool = true;\nprintln!(\"User logged in? {}\", is_logged_in);",
        "let name = \"John\";\nlet age = 28;\nlet is_admin = false;\nprintln!(\"Name: {}\", name);\nprintln!(\"Age: {}\", age);\nprintln!(\"Admin: {}\", is_admin);",
        "i32",
        "f64",
        "char",
        "&str",
        "bool",
        "true",
        "false"
      ]
    },
    {
      "title": "Rust Constants",
      "summary": "Constants\nConstant variables are used to store values that never change.\nUnlike regular variables, constants must be defined with a type (e.g. i32 or char).\nCreating a Constant\nTo create a constant, use the const keyword, followed by the name, type, and value:\nExample\nConstants Must Have a Type\nYou must write the type when creating a constant. You cannot let Rust guess the type like you can with regular variables:\nExample\nNaming Rules\nAnother thing about constants, is that it is considered good practice to declare them with uppercase.\nIt is not required, but useful for code readability and common for Rust programmers:\nExamples:\nMAX_SPEED\nPI\nMINUTES_PER_HOUR\nConstants vs Variables\nHere's a quick comparison:",
      "examples": [
        "const BIRTHYEAR: i32 = 1980;\nconst MINUTES_PER_HOUR: i32 = 60;",
        "const BIRTHYEAR: i32 = 1980; // Ok\nconst BIRTHYEAR = 1980;Â // Error: missing type",
        "i32",
        "char",
        "const",
        "MAX_SPEED",
        "PI",
        "MINUTES_PER_HOUR",
        "let",
        "mut"
      ]
    },
    {
      "title": "Rust Operators",
      "summary": "Operators\nOperators are used to perform operations on values and variables.\nRust supports many common operators, like:\nArithmetic Operators\nAssignment Operators\nComparison Operators\nLogical Operators\nArithmetic Operators\nArithmetic operators are used to do basic math:\nExample\nAssignment Operators\nAssignment operators are used to assign and update values:\nExample\nComparison Operators\nComparison operators compare values and return true or false:\nExample\nLogical Operators\nLogical operators are used to work with boolean values:\nExample",
      "examples": [
        "fn main() {\nlet add = 5 + 3;\nlet sub = 10 - 4;\nlet mul = 6 * 2;\nlet div = 12 / 3;\nlet rem = 10 % 3;\n\nprintln!(\"Add: {}\", add);\nprintln!(\"Sub: {}\", sub);\nprintln!(\"Mul: {}\", mul);\nprintln!(\"Div: {}\", div);\nprintln!(\"Rem: {}\", rem);\n}",
        "fn main() {\nlet mut x = 10;\nprintln!(\"Start: {}\", x);\n\nx += 5;\nprintln!(\"After += 5: {}\", x);\n\nx -= 2;\nprintln!(\"After -= 2: {}\", x);\n\nx *= 2;\nprintln!(\"After *= 2: {}\", x);\n\nx /= 3;\nprintln!(\"After /= 3: {}\", x);\n\nx %= 4;\nprintln!(\"After %= 4: {}\", x);\n}",
        "fn main() {\nlet a = 5;\nlet b = 10;\n\nprintln!(\"5 == 10: {}\", a == b);\nprintln!(\"5 != 10: {}\", a != b);\nprintln!(\"5 < 10: {}\", a < b);\nprintln!(\"5 >= 10: {}\", a >= b);\n}",
        "fn main() {\nlet logged_in = true;\nlet is_admin = false;\n\nprintln!(\"Is regular user: {}\", logged_in && !is_admin);\nprintln!(\"Has any access: {}\", logged_in || is_admin);\nprintln!(\"Not logged in: {}\", !logged_in);\n}",
        "5 + 3",
        "5 - 3",
        "5 * 3",
        "10 / 2",
        "10 % 3",
        "x = 5",
        "x += 3",
        "x = x + 3",
        "x -= 2",
        "x = x - 2",
        "x *= 4",
        "x = x * 4",
        "x /= 2",
        "x = x / 2",
        "x %= 2",
        "x = x % 2",
        "true",
        "false",
        "5 == 5",
        "5 != 3",
        "7 > 3",
        "2 < 5",
        "5 >= 5",
        "3 <= 4"
      ]
    },
    {
      "title": "Rust Booleans",
      "summary": "Booleans\nVery often, in programming, you will need a data type that can only have one of two values, like:\nYES / NO\nON / OFF\nTRUE / FALSE\nFor this, Rust has a bool data type, which is known as booleans.\nBooleans represent values that are either true or false.\nCreating Boolean Variables\nYou can store a boolean value in a variable using the bool type:\nExample\nRemember that Rust is smart enough to understand that true and false values are boolean values, meaning that you don't have to specify the bool keyword:\nExample\nBoolean from Comparison\nMost of the time, there is no need to type true or false yourself. Instead, boolean values come from comparing values using operators like == or >:\nExample\nHere, age >= 18 returns true, as long as age is 18 or older.\nUsing Booleans in if Statements\nBoolean values are often used in if statements to decide what code should run:\nExample\nCool, right? Booleans are the basis for all Rust comparisons and conditions. You will learn more about if and else statements in the next chapter.",
      "examples": [
        "let is_programming_fun: bool = true;\nlet is_fish_tasty: bool = false;\n\nprintln!(\"Is Programming Fun? {}\", is_programming_fun);\nprintln!(\"Is Fish Tasty? {}\", is_fish_tasty);",
        "let is_programming_fun = true;\nlet is_fish_tasty = false;\n\nprintln!(\"Is Programming Fun? {}\", is_programming_fun);\nprintln!(\"Is Fish Tasty? {}\", is_fish_tasty);",
        "let age = 20;\nlet can_vote = age >= 18;\n\nprintln!(\"Can vote? {}\", can_vote);",
        "let is_logged_in = true;\n\nif is_logged_in {\nprintln!(\"Welcome back!\");\n} else {\nprintln!(\"Please log in.\");\n}",
        "bool",
        "true",
        "false",
        "==",
        ">",
        "age >= 18",
        "if"
      ]
    },
    {
      "title": "Rust If .. Else Conditions",
      "summary": "Conditions and If..Else\nYou already know that Rust supports familiar comparison conditions from mathematics, such as:\nLess than: a < b\nLess than or equal to: a <= b\nGreater than: a > b\nGreater than or equal to: a >= b\nEqual to a == b\nNot Equal to: a != b\nYou can use these conditions to perform different actions for different decisions.\nRust has the following conditional statements:\nUse if to specify a block of code to be executed, if a specified condition is true\nUse else to specify a block of code to be executed, if the same condition is false\nUse else if to specify a new condition to test, if the first condition is false\nUse switch to specify many alternative blocks of code to be executed\nNote: Unlike many other programming languages, if..else can be used as a statement or as an expression (to assign a value to a variable) in Rust. See an example at the bottom of the page to better understand it.\nif\nUse if to specify a block of code to be executed if a condition is true.\nExample\nYou can also test variables:\nExample\nif...else\nIf the condition is not true, you can use else to run different code:\nExample\nelse if\nYou can check multiple conditions using else if:\nExample\nUsing if as an Expression\nIn Rust, if...else can also be used as an expression.\nThis means you can assign the result of an if to a variable:\nExample\nWhen using if as an expression, you must include else. This ensures the result always has a value.\nSimplified Syntax\nIf each block only contains a single expression, you can write it in a shorter way on one line:\nExample\nTip: This works similarly to the ternary operator (condition ? value1 : value2) in languages like Java or C. However, Rust does not have a ternary operator, but using if...else as an expression gives you the same effect.\nDon't Mix Types\nNote: The value from if and else must be the same type, like two pieces of text or two numbers (in the example above, both are strings).\nWhen you mix types, like a string and an integer, you'll get an error:\nExample\nResult:",
      "examples": [
        "if 7 > 5 {\nprintln!(\"7 is greater than 5.\");\n}",
        "let x = 7;\nlet y = 5;\n\nif x > y {\nprintln!(\"x is greater than y.\");\n}",
        "let age = 16;\n\nif age >= 18 {\nprintln!(\"You can vote.\");\n} else {\nprintln!(\"You are too young to vote.\");\n}",
        "let score = 85;\n\nif score >= 90 {\nprintln!(\"Grade: A\");\n} else if score >= 80 {\nprintln!(\"Grade: B\");\n} else if score >= 70 {\nprintln!(\"Grade: C\");\n} else {\nprintln!(\"Grade: F\");\n}",
        "let time = 20;\nlet greeting = if time < 18 {\n\"Good day.\"\n} else {\n\"Good evening.\"\n};\nprintln!(\"{}\", greeting);",
        "let time = 20;\nlet greeting = if time < 18 { \"Good day.\" } else { \"Good evening.\" };\nprintln!(\"{}\", greeting);",
        "let number = 5;\nlet result = if number < 10 { \"Too small\" } else { 100 };\nprintln!(\"{}\", result);",
        "if",
        "true",
        "else",
        "false",
        "else if",
        "switch",
        "if..else",
        "if...else",
        "condition ? value1 : value2",
        "error[E0308]: `if` and `else` have incompatible types"
      ]
    },
    {
      "title": "Rust Match",
      "summary": "Match\nWhen you have many choices, using match is easier than writing lots of if...else.\nmatch is used to select one of many code blocks to be executed:\nExample\nExample explained:\nThe match variable (day) is evaluated once.\nThe value of the day variable is compared with the values of each \"branch\"\nEach branch starts with a value, followed by => and a result\nIf there is a match, the associated block of code is executed\n_ is used to specify some code to run if there is no match (like default in other languages).\nIn the example above, the value of day is 4, meaning \"Thursday\" will be printed\nMultiple Matches\nYou can match multiple values at once using the | operator (OR):\nExample\nmatch with a Return Value\nJust like if, match can also return a value:\nThis means you can save the result of a match into a variable:\nExample\nNote: Each part of the match branches must be the same type - just like with if...else.",
      "examples": [
        "fn main() {\nlet day = 4;\n\nmatch day {\n1 => println!(\"Monday\"),\n2 => println!(\"Tuesday\"),\n3 => println!(\"Wednesday\"),\n4 => println!(\"Thursday\"),\n5 => println!(\"Friday\"),\n6 => println!(\"Saturday\"),\n7 => println!(\"Sunday\"),\n_ => println!(\"Invalid day.\"),\n}\n}",
        "fn main() {\nlet day = 6;\n\nmatch day {\n1 | 2 | 3 | 4 | 5 => println!(\"Weekday\"),\n6 | 7 => println!(\"Weekend\"),\n_ => println!(\"Invalid day\"),\n}\n}",
        "fn main() {\nlet day = 4;\n\nlet result = match day {\n1 => \"Monday\",\n2 => \"Tuesday\",\n3 => \"Wednesday\",\n4 => \"Thursday\",\n5 => \"Friday\",\n6 => \"Saturday\",\n7 => \"Sunday\",\n_ => \"Invalid day.\",\n};\n\nprintln!(\"{}\", result);\n}",
        "match",
        "if...else",
        "=>",
        "_",
        "default",
        "|",
        "if"
      ]
    },
    {
      "title": "Rust Loops",
      "summary": "Loops\nLoops can execute a block of code as long as a specified condition is reached.\nLoops are handy because they save time, reduce errors, and they make code more readable. For example, instead of writing the same line 10 times to print some text, you can use a loop to repeat it for you.\nRust has three types of loops: loop, while, and for.\nloop\nloop is the simplest of Rust's three loop types.\nIt will run forever unless you tell it to stop:\nWarning: This loop never stops! You will need to press Ctrl + C to end the program.\nTo stop a loop, use the break keyword:\nExample\nExample explained:\nThis prints \"Hello World!\" 3 times.\nIt uses a counter to keep track of how many times it has looped.\nThe counter starts at 1 (let mut count = 1;).\nEach time the loop runs, the counter goes up by 1: (count += 1;).\nWhen it reaches 3, the loop stops.\nReturn a Value\nYou can also return a value from a loop using break with a value.\nThis lets you save the result of the loop into a variable:\nExample\nThis loop prints \"Hello!\" until count reaches 3, then stops and returns that number.\nNote: When you save the result of a loop into a variable, you must put a semicolon (;) at the end.\nNext: Learn how to use while loops to repeat code while a condition is true.",
      "examples": [
        "loop {\nprintln!(\"This will repeat forever!\");\n}",
        "let mut count = 1;\n\nloop {\nprintln!(\"Hello World!\");\n\nif count == 3 {\nbreak;\n}\n\ncount += 1;\n}",
        "let mut count = 1;\n\nlet result = loop {\nprintln!(\"Hello!\");\n\nif count == 3 {\nbreak count; // Stop the loop and return the number 3\n}\n\ncount += 1;\n};\n\nprintln!(\"The loop stopped at: {}\", result);",
        "loop",
        "while",
        "for",
        "Ctrl + C",
        "break",
        "let mut count = 1;",
        "count += 1;",
        "count",
        ";"
      ]
    },
    {
      "title": "Rust While Loops",
      "summary": "The while Loop\nThe while loop runs as long as a condition is true.\nExample\nIn the example above, the loop keeps running as long as the counter is less than or equal to 5.\nIt prints the numbers from 1 to 5, one on each line.\nFalse Condition\nThe while loop checks the condition before each loop, so if the condition is false at the start, the loop will not run at all:\nExample\nStop a While Loop\nYou can stop a while loop when you want by using break:\nExample\nThis prints numbers from 1 to 5 (stops the loop when num reaches 6).\nNext: Learn how to use the for loop to go through a range of values.\nSkip a Value\nYou can skip a value by using the continue statement:\nExample\nThis prints numbers from 1 to 10, except for the number 6.\nNext: Learn how to use the for loop to go through a range of values.",
      "examples": [
        "let mut count = 1;\n\nwhile count <= 5 {\nprintln!(\"Count: {}\", count);\ncount += 1;\n}",
        "let count = 10;\n\nwhile count <= 5 {\nprintln!(\"This won't be printed.\");\n}",
        "let mut num = 1;\n\nwhile num <= 10 {\nif num == 6 {\nbreak;\n}\nprintln!(\"Number: {}\", num);\nnum += 1;\n}",
        "let mut num = 1;\n\nwhile num <= 10 {\nif num == 6 {\nnum += 1;\ncontinue;\n}\n\nprintln!(\"Number: {}\", num);\nnum += 1;\n}",
        "while",
        "true",
        "false",
        "break",
        "num",
        "for",
        "continue"
      ]
    },
    {
      "title": "Rust For Loop",
      "summary": "The for Loop\nWhen you know exactly how many times you want to loop through a block of code, use the for loop together with the in keyword, instead of a while loop:\nExample\nThis prints numbers from 1 to 5.\nNote: 1..6 means from 1 up to (but not including) 6.\nNote: Rust handles the counter variable (i) automatically, unlike many other programming languages. You don't need to declare or increment it manually.\nInclusive Range\nIf you want to include the last number, use ..= (two dots and an equals sign):\nExample\nThis prints numbers from 1 to 6, including 6.\nBreak and Continue\nJust like other loops, you can use break to stop the loop and continue to skip a value:\nExample\nThis prints 1, 2, and 4. It skips 3 and stops before 5.\nRust Loops Summary\nRust has three types of loops that let you run code over and over again. Each one is used in different situations:\n1. loop\nThe simplest kind of loop. It runs forever unless you stop it with break.\nUse loop when you don't know in advance how many times to repeat.\n2. while\nRepeats code while a condition is true. It checks the condition before each loop.\nUse while when you want to repeat code until something happens.\n3. for\nRepeats code a fixed number of times.\nUse for when you know exactly what to loop through.\nExtra Keywords\nYou can use these in any loop:\nbreak - stop the loop\ncontinue - skip a value in the loop\nNow that you know how loops work, you are ready to start working with functions and reusable code!",
      "examples": [
        "for i in 1..6 {\nprintln!(\"i is: {}\", i);\n}",
        "for i in 1..=6 {\nprintln!(\"i is: {}\", i);\n}",
        "for i in 1..=10 {\nif i == 3 {\ncontinue; // skip 3\n}\nif i == 5 {\nbreak; // stop before printing 5\n}\nprintln!(\"i is: {}\", i);\n}",
        "loop {\n// do something\nif condition {\nbreak;\n}\n}",
        "while count <= 5 {\nprintln!(\"{}\", count);\ncount += 1;\n}",
        "for i in 1..=5 {\nprintln!(\"{}\", i);\n}",
        "for",
        "in",
        "while",
        "1..6",
        "i",
        "..=",
        "break",
        "continue",
        "loop"
      ]
    },
    {
      "title": "Rust Functions",
      "summary": "Functions\nA function is a block of code that only runs when you call it.\nFunctions are used to organize your code, avoid repeating yourself, and make your program easier to understand.\nCreating a Function\nTo create a function, use the fn keyword, followed by the function name and a set of parentheses () and curly braces {}:\nExample\nCalling a Function\nNow that you have created a function, you can execute it by calling it.\nTo call a function, write the name of the function followed by two parantheses ().\nExample\nFunctions with Parameters\nYou can send information into a function using parameters. Parameters are written inside the parentheses ().\nExample\nIn this example, the function takes a string parameter called name and prints it in the greeting message.\nFunctions with Return Values\nA function can also return a value.\nUse theÂ  -> symbol in the function header to show what type of value will be returned.\nInside the function, use the return keyword to send the value back:\nExample\nThis function adds two numbers and returns the result.\nIn Rust, you can omit the return keyword. Just write the value on the last line of the function, without a semicolon:\nExample\nThe last line a + b is automatically returned.\nBoth examples do the same thing. It is up to you which one to use.\nWhy Use Functions?\nTo organize your code\nTo avoid repeating the same code\nTo make your programs easier to read and change",
      "examples": [
        "fn function_name() {\n// code to be executed\n}",
        "// Create a function\nfn say_hello() {\nprintln!(\"Hello from a function!\");\n}\n\nsay_hello(); // Call the function",
        "fn greet(name: &str) {\nprintln!(\"Hello, {}!\", name);\n}\n\ngreet(\"John\");",
        "fn add(a: i32, b: i32) -> i32 {\nreturn a + b;\n}\n\nlet sum = add(3, 4);\nprintln!(\"Sum is: {}\", sum);",
        "fn add(a: i32, b: i32) -> i32 {\na + b\n}\n\nlet sum = add(3, 4);\nprintln!(\"Sum is: {}\", sum);",
        "fn",
        "()",
        "{}",
        "name",
        "->",
        "return",
        "a + b"
      ]
    },
    {
      "title": "Rust Scope",
      "summary": "Scope\nNow that you understand how functions work, it is important to learn how variables act inside and outside of functions.\nScope refers to where a variable is allowed to be used.\nA variable only lives inside the block where it was created. A block is anything inside curly braces { }.\nVariable Inside a Function\nA variable created inside a function only exists inside that function:\nExample\nNote: The variable message only exists inside the function. Trying to use it outside the function will cause an error.\nVariable Inside a Block\nYou can also create blocks inside other code, like in if statements or loops. Variables created in these blocks are only valid inside them.\nExample\nVariables in the Same Scope\nIn Rust, you can declare a new variable with the same name in the same scope using let. This is called shadowing:\nExample\nThe second x replaces the first one. The value 5 is no longer accessible after the second declaration.\nThis is different from languages that disallow reusing variable names. In Rust, it's a feature used to transform or update values safely.\nYou can also reuse a variable name inside a new block:\nExample\nHere, the two x variables are in different scopes. The inner x only exists inside the block. Outside the block, the original value remains.\nNote: Even though shadowing is allowed, using the same name too often can make your code harder to read. Use clear names when possible.\nWhy Scope Matters\nUnderstanding scope helps you:\nKnow where a variable can be used\nPrevent naming conflicts\nAvoid errors when working with functions, loops, and conditionals",
      "examples": [
        "fn myFunction() {\nlet message = \"Hello!\";\nprintln!(\"{}\", message);Â  // You can access the message variable here\n}\n\nmyFunction();\n\nprintln!(\"{}\", message); // Error - you cannot access the message variable outside of the function",
        "let score = 80;\n\nif score > 50 {\nlet result = \"Pass\";\nprintln!(\"Result: {}\", result);\n}\n\nprintln!(\"Result: {}\", result); // Error: result is out of scope here",
        "let x = 5;\nlet x = 10;\n\nprintln!(\"x is: {}\", x); // prints 10",
        "let x = 5;\n\n{\nlet x = 10;\nprintln!(\"Inside block: {}\", x);\n}\n\nprintln!(\"Outside block: {}\", x);",
        "{ }",
        "message",
        "if",
        "let",
        "x",
        "5"
      ]
    },
    {
      "title": "Rust Strings",
      "summary": "Strings\nStrings are used to store text.\nYou have already learned that you can use the &str type to create a string:\nExample\nNote that strings are surrounded by double quotes (\"Hello\").\nThere are two main types of strings in Rust:\n&str - is called \"string slices\", and is used for fixed text like \"Hello\"\nString - used when you need a string that can change\nIn this chapter, you will mostly work with the String type because it is more flexible and can be changed over time.\nCreate a String\nYou can create a String from a string literal using the to_string() method or the String::from() function:\nExample\nExample\nIt is up to you which one to choose - both to_string() and String::from() are very common in Rust.\nChange a String\nStrings are mutable, so you can change them if they are declared with mut.\nUse push_str() to add text to a string:\nExample\nUse push() to add one character:\nExample\nConcatenate Strings\nYou can combine strings using the format! macro:\nExample\nYou can also use the + operator to combine strings, but it can get messy with many values.\nExample\nNote: You can only add a &str to a String with +. That is why &s2 and &s3 (a string slice) is used here.\nGood to know: format! is often the preferred choice than using + for combining strings.\nString Length\nYou can use the .len() method to get the length of a string:\nExample",
      "examples": [
        "let greeting: &str = \"Hello\";\nprintln!(\"{}\", greeting);",
        "let text1 = \"Hello World\".to_string();",
        "let text2 = String::from(\"Hello World\");",
        "let mut greeting = String::from(\"Hello\");\ngreeting.push_str(\" World\");\nprintln!(\"{}\", greeting); // Hello World",
        "let mut word = String::from(\"Hi\");\nword.push('!');\nprintln!(\"{}\", word); // Hi!",
        "let s1 = String::from(\"Hello\");\nlet s2 = String::from(\"World!\");\nlet s3 = String::from(\"What a beautiful day!\");\nlet result = format!(\"{} {} {}\", s1, s2, s3);\nprintln!(\"{}\", result);",
        "let s1 = String::from(\"Hello\");\nlet s2 = String::from(\"World!\");\nlet s3 = String::from(\"What a beautiful day!\");\nlet result = s1 + \" \" + &s2 + \" \" + &s3;\nprintln!(\"{}\", result);",
        "let name = String::from(\"John\");\nprintln!(\"Length: {}\", name.len()); // 4",
        "&str",
        "\"Hello\"",
        "String",
        "to_string()",
        "String::from()",
        "mut",
        "push_str()",
        "push()",
        "format!",
        "+",
        "&s2",
        "&s3",
        ".len()"
      ]
    },
    {
      "title": "Rust Ownership",
      "summary": "Ownership\nRust uses \"ownership\" to manage memory in a safe way.\nEvery value in Rust has an owner. The owner is usually a variable.\nOwnership Rules\nEach value has one owner\nWhen the owner goes out of scope, the value is deleted\nYou can only have one owner at a time, unless you borrow it (covered in the next chapter)\nBasic Ownership Example\nIn this example, a owns the string. Then we move it to b:\nExample\nWhen we assign a to b, the ownership moves. This means only b can use the value now, because a is no longer valid.\nBut simple types like numbers, characters and booleans are copied, not moved.\nThis means you can still use the original variable after assigning it to another:\nExample\nHere, a is copied into b, not moved, so you can still use b.\nClone\nFor other types, like String, if you really want to keep the original value and also assign it to another variable, you can use the .clone() method, which makes a copy of the data:\nExample\nHowever, if you don't need to own the value twice, using a reference (&) is usually better than cloning, which you will learn more about in the next chapter.\nWhy Ownership Matters\nRust uses ownership to automatically free memory when it's no longer needed\nIt prevents bugs like using memory that's already been deleted\nIt is one of the reasons Rust is so safe and fast\nNext: Learn about borrowing - how to let other parts of your program use a value without taking ownership.",
      "examples": [
        "let a = String::from(\"Hello\");\nlet b = a;\n\n// println!(\"{}\", a); Error: a no longer owns the value\nprintln!(\"{}\", b); // Ok: b now owns the value",
        "let a = 5;\nlet b = a;\nprintln!(\"a = {}\", a);Â  // Works\nprintln!(\"b = {}\", b);Â  // Works",
        "let a = String::from(\"Hello\");\nlet b = a.clone(); // Now both have the same value\n\nprintln!(\"a = {}\", a);Â  // Works\nprintln!(\"b = {}\", b);Â  // Works",
        "a",
        "b",
        "String",
        ".clone()",
        "&"
      ]
    },
    {
      "title": "Rust Borrowing and References",
      "summary": "Borrowing and References\nSometimes you want to use a value without taking ownership of it.\nRust lets you do this using a reference - this is called borrowing:\nWhat is a Reference?\nA reference lets you look at a value without owning it. You create a reference using the & symbol:\nExample\nSince b is only borrowing the value, a still owns it.\nMutable References\nIf you want to change a value through a reference, you need to make the reference mut:\nExample\nNote: You can only have one mutable reference to a value at a time!\nWhy Borrowing is Important\nBorrowing helps you reuse values safely, without giving them away.\nIt lets you use values without taking ownership\nIt avoids cloning, which can be slow for large data\nIt makes your programs safer and faster",
      "examples": [
        "let a = String::from(\"Hello\");\nlet b = &a;\n\nprintln!(\"a = {}\", a);\nprintln!(\"b = {}\", b);",
        "let mut name = String::from(\"John\");\nlet name_ref = &mut name;\nname_ref.push_str(\" Doe\");\n\nprintln!(\"{}\", name_ref); // John Doe",
        "&",
        "b",
        "a",
        "mut"
      ]
    },
    {
      "title": "Rust Data Structures",
      "summary": "Data Structures\nIn Rust, data structures are used to store and organize values.\nRust provides many built-in data structures. Each is used to handle data in different ways.\nSome of the most common are:\nArray\nVector (Vec)\nTuple\nHashMap\nWe will explore all of them in detail later, but for now, here's a quick introduction to each one.\nArrays\nAn array in Rust is a fixed-size list of values, all of the same type.\nYou cannot grow or shrink an array after it's created.\nTo access an array element, refer to its index number.\nArray indexes start with 0: [0] is the first element, [1] is the second element, etc.\nExample\nVectors\nA vector is a resizable array. Unlike regular arrays, vectors can grow or shrink in size.\nExample\nTuples\nA tuple can hold multiple values of different types. It is useful when grouping different types together.\nYou access tuple elements using a dot and an index number, like person.1, etc:\nExample\nHashMaps\nA HashMap stores key-value pairs. It lets you look up a value using a key.\nTo use HashMap, you must import it from the standard library.\nExample\nData Structures Overview\nNext, let's take a closer look at each data structure in more detail.",
      "examples": [
        "let fruits = [\"apple\", \"banana\", \"orange\"];\nprintln!(\"Last fruit: {}\", fruits[2]);",
        "let mut fruits = vec![\"apple\", \"banana\"];\nfruits.push(\"cherry\");\n\nprintln!(\"Last fruit: {}\", fruits[2]);",
        "let person = (\"John\", 30, true);\nprintln!(\"Name: {}\", person.0);\nprintln!(\"Age: {}\", person.1);\nprintln!(\"Is active: {}\", person.2);",
        "// Import HashMap\nuse std::collections::HashMap;\n\nfn main() {\nlet mut capitalCities = HashMap::new();\ncapitalCities.insert(\"France\", \"Paris\");\ncapitalCities.insert(\"Japan\", \"Tokyo\");\n\nprintln!(\"Capital of Japan is {}\", capitalCities[\"Japan\"]);\n}",
        "person.1"
      ]
    },
    {
      "title": "Rust Arrays",
      "summary": "Arrays\nArrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.\nCreate an Array\nYou can create an array using square brackets [ ], and separate the values with commas.\nNote: Make sure all values are of the same data type (integers in the example below):\nExample\nThis creates an array with five integers.\nAccess Array Elements\nTo access an array element, refer to its index number.\nArray indexes start with 0: [0] is the first element. [1] is the second element, etc.\nThis statement accesses the value of the first element [0] in numbers:\nExample\nChange Array Values\nTo change the value of a specified element, refer to the index number and assign a new value.\nRemember to make the array mutable (using the mut keyword):\nExample\nArray Length\nYou can get the number of elements in an array using the .len() method:\nExample\nLoop Through an Array\nYou can loop through the array elements with the for loop.\nExample\nPrint the Entire Array\nNote: When printing the whole array, you must use {:?} inside println!:\nExample\nIf you are just printing one element from the array, you can use {}.\nExample\nTo Sum Up:\nWhen printing a single element from an array, use {}.\nWhen printing the entire array, use {:?}.\nIf you are wondering why we didn't use {:?} inside the loop (in the example earlier on this page), it is because in a loop, you are printing each single value from the array. Since each value is a string, {} works. But to print the whole array, you need to use {:?}.\nA good rule is to use {} for basic types like strings, numbers, and booleans, and {:?} for data structures like arrays and vectors - when printing the entire structure.\nFixed Size (Arrays) vs. Dynamic Size (Vectors)\nYou will often hear the terms fixed size and dynamic size when talking about arrays in Rust.\nThis is because arrays in Rust have a fixed size, meaning you cannot add or remove elements after the array is created:\nExample\nVectors - Dynamic Size Example\nFor operations that require adding and removing array elements, you can use Vectors, which are resizable arrays.\nThe size of a vector is dynamic, meaning it can grow and shrink as needed.\nYou can use the vec! macro to create a vector:\nExample\nThis was just a short introduction to vectors. You will learn more about them in the next chapter.",
      "examples": [
        "let numbers = [1, 2, 3, 4, 5];",
        "let numbers = [1, 2, 3, 4, 5];\nprintln!(\"The first number is: {}\", numbers[0]);",
        "let mut numbers = [1, 2, 3, 4, 5];\nnumbers[0] = 10;\nprintln!(\"The new first number is: {}\", numbers[0]);",
        "let numbers = [1, 2, 3, 4, 5];\nprintln!(\"This array has {} elements.\", numbers.len());",
        "let fruits = [\"apple\", \"banana\", \"orange\"];\nfor fruit in fruits {\nprintln!(\"I like {}.\", fruit);\n}",
        "let numbers = [1, 2, 3, 4, 5];\nprintln!(\"{:?}\", numbers);",
        "let numbers = [1, 2, 3, 4, 5];\nprintln!(\"{}\", numbers[0]);",
        "// An array with 3 elements\nlet mut cars = [\"Volvo\", \"BMW\", \"Ford\"];\n\n// Trying to add another element (a fourth element) to the cars array will result in an error\ncars[3] = \"Mazda\";Â Â  // Error: index out of bounds",
        "// A vector with 3 elements\nlet mut cars = vec![\"Volvo\", \"BMW\", \"Ford\"];\n\n// Add another element\ncars.push(\"Mazda\");\n\nprintln!(\"{:?}\", cars); // [\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"]",
        "[ ]",
        "0",
        "numbers",
        "mut",
        ".len()",
        "for",
        "{:?}",
        "println!",
        "{}",
        "vec!"
      ]
    },
    {
      "title": "Rust Vectors",
      "summary": "Vectors\nA vector is a resizable array. Unlike regular arrays, vectors can grow or shrink in size.\nCreating a Vector\nTo create a vector, use the vec! macro:\nExample\nThis creates a vector with three string elements.\nAccess Vector Elements\nYou can access values in a vector using index numbers (just like arrays):\nExample\nChange Vector Values\nTo change a value in the vector, refer to the index number and assign a new value.\nRemember to make the vector mutable (using the mut keyword):\nExample\nAdd Elements to a Vector\nYou can add a new element to the end of a vector using the push() method:\nExample\nRemove Elements from a Vector\nTo remove the last element from a vector, use pop():\nExample\nAdd or Remove Elements at a Specified Index\nRust vectors are designed to grow and shrink at the end, but you can also add or remove elements at the beginning or at a specified index.\nUse insert() to add an item at a specified index:\nExample\nAdd \"apple\" to the beginning of the vector:\nExample\nAdd \"apple\" in the middle of the vector:\nUse remove() to remove an element from a specified index:\nExample\nRemove the first item in the vector:\nNote: Adding or removing elements from the beginning is slower than at the end, because all the other elements have to shift positions.\nVector Length\nYou can find out how many elements there are in a vector using the .len() method:\nExample\nLoop Through a Vector\nJust like arrays, you can use a for loop to go through all the values in a vector:\nExample\nNote: Use &fruits to borrow the vector instead of moving it.\nIn Rust, borrowing means using a reference to a value instead of taking ownership of it. When you loop through a vector without &, the values are moved out, and you can no longer use the vector. But when you borrow the vector using &, you can still use it later in your program.\nYou can learn more about ownership in our chapters on Ownership and Borrowing and References.",
      "examples": [
        "let fruits = vec![\"apple\", \"banana\", \"orange\"];",
        "let fruits = vec![\"apple\", \"banana\", \"orange\"];\nprintln!(\"First fruit: {}\", fruits[0]);",
        "let mut fruits = vec![\"apple\", \"banana\", \"orange\"];\nfruits[0] = \"grape\";\nprintln!(\"New first fruit: {}\", fruits[0]);",
        "let mut fruits = vec![\"apple\", \"banana\"];\nfruits.push(\"cherry\");\nprintln!(\"{:?}\", fruits); // [\"apple\", \"banana\", \"cherry\"]",
        "let mut fruits = vec![\"apple\", \"banana\", \"cherry\"];\nfruits.pop();\nprintln!(\"{:?}\", fruits); // [\"apple\", \"banana\"]",
        "let mut fruits = vec![\"banana\", \"orange\"];\nfruits.insert(0, \"apple\");\nprintln!(\"{:?}\", fruits); // [\"apple\", \"banana\", \"orange\"]",
        "let mut fruits = vec![\"banana\", \"orange\"];\nfruits.insert(1, \"apple\");\nprintln!(\"{:?}\", fruits); // [\"banana\", \"apple\", \"orange\"]",
        "let mut fruits = vec![\"apple\", \"banana\", \"orange\"];\nfruits.remove(0);\nprintln!(\"{:?}\", fruits); // [\"banana\", \"orange\"]",
        "let fruits = vec![\"apple\", \"banana\", \"cherry\"];\nprintln!(\"There are {} fruits.\", fruits.len());",
        "let fruits = vec![\"apple\", \"banana\", \"orange\"];\nfor fruit in &fruits {\nprintln!(\"I like {}.\", fruit);\n}",
        "vec!",
        "mut",
        "push()",
        "pop()",
        "insert()",
        "remove()",
        ".len()",
        "for",
        "&fruits",
        "&"
      ]
    },
    {
      "title": "Rust Tuples",
      "summary": "Tuples\nA tuple is a group of values of different types, stored in a single variable.\nTuples are useful when you want to return or work with multiple values together.\nCreate a Tuple\nTuples are written using parentheses (), with values separated by commas:\nExample\nThis tuple contains a &str, an i32, and a bool.\nAccess Tuple Values\nYou can access tuple values by using a dot . followed by the index:\nExample\nUnpack a Tuple\nWhen we create a tuple, we normally assign values to it. This is called \"packing\" a tuple:\nExample\nBut, in Rust, we are also allowed to extract the values back into variables. This is called \"unpacking\":\nExample\nReturn a Tuple from a Function\nTuples are often used to return multiple values from a function:\nExample",
      "examples": [
        "let person = (\"John\", 30, true);",
        "let person = (\"John\", 30, true);\nprintln!(\"Name: {}\", person.0);\nprintln!(\"Age: {}\", person.1);\nprintln!(\"Is active: {}\", person.2);",
        "let person = (\"Jenny\", 45, false);",
        "let person = (\"Jenny\", 45, false);\nlet (name, age, active) = person;\n\nprintln!(\"Name: {}\", name);\nprintln!(\"Age: {}\", age);\nprintln!(\"Active: {}\", active);",
        "fn get_user() -> (String, i32) {\n(String::from(\"Liam\"), 25)\n}\n\nfn main() {\nlet user = get_user();\nprintln!(\"User: {} ({} years old)\", user.0, user.1);\n}",
        "()",
        "&str",
        "i32",
        "bool",
        "."
      ]
    },
    {
      "title": "Rust HashMap",
      "summary": "HashMap\nA HashMap is a collection of key/value pairs.\nHashMaps are great when you want to store values and find them by a key.\nTo use HashMap, you must import it from Rust's standard library:\nCreate a HashMap\nYou can create a new, empty HashMap and add items to it:\nExample\nAccess Values\nYou can use the .get() method to access a value in a HashMap by its key:\nExample\nUpdate Values\nIf you insert a new value using a key that already exists, the old value is replaced with the new one:\nExample\nRemove Values\nTo remove a key from a HashMap, use the .remove() method:\nExample\nLoop Through a HashMap\nYou can use a for loop to go through all key/value pairs:\nExample\nWhy Use HashMaps?\nTo store data by key\nTo quickly look up values\nTo group related data (like names and scores)\nNote: HashMaps require keys to be unique. Inserting the same key again will overwrite the old value.",
      "examples": [
        "use std::collections::HashMap;",
        "// Import HashMap\nuse std::collections::HashMap;\n\nfn main() {\n// Create a HashMap called capitalCities\nlet mut capitalCities = HashMap::new();\n\n// Add keys and values (Country, City)\ncapitalCities.insert(\"England\", \"London\");\ncapitalCities.insert(\"Germany\", \"Berlin\");\ncapitalCities.insert(\"Norway\", \"Oslo\");\n\nprintln!(\"{:?}\", capitalCities);\n}",
        "let mut capitalCities = HashMap::new();\n\ncapitalCities.insert(\"England\", \"London\");\ncapitalCities.insert(\"Germany\", \"Berlin\");\ncapitalCities.insert(\"Norway\", \"Oslo\");\n\nif let Some(city) = capitalCities.get(\"England\") {\nprintln!(\"The capital of England is {}.\", city);\n} else {\nprintln!(\"England is not in the map.\");\n}",
        "let mut capitalCities = HashMap::new();\n\ncapitalCities.insert(\"England\", \"London\");\ncapitalCities.insert(\"England\", \"Berlin\");\n\nprintln!(\"{:?}\", capitalCities);",
        "let mut capitalCities = HashMap::new();\n\n// Add keys and values (Country, City)\ncapitalCities.insert(\"England\", \"London\");\ncapitalCities.insert(\"Germany\", \"Berlin\");\ncapitalCities.insert(\"Norway\", \"Oslo\");\n\n// Remove the key \"England\"\ncapitalCities.remove(\"England\");\n\nprintln!(\"{:?}\", capitalCities);",
        "let mut capitalCities = HashMap::new();\n\n// Add keys and values (Country, City)\ncapitalCities.insert(\"England\", \"London\");\ncapitalCities.insert(\"Germany\", \"Berlin\");\ncapitalCities.insert(\"Norway\", \"Oslo\");\n\n// Loop through the HashMap\nfor (country, city) in &capitalCities {\nprintln!(\"The capital of {} is {}.\", country, city);\n}",
        ".get()",
        ".remove()",
        "for"
      ]
    },
    {
      "title": "Rust Structs",
      "summary": "Structs\nA struct (short for \"structure\") is a custom data structure that lets you group related values together.\nYou can think of a struct like a mini-database for one thing, like a person with a name and age.\nCreate a Struct\nYou define a struct using the struct keyword and place the fields (variables) inside:\nExample\nOnce you have a struct, you can create an object of it.\nThen, you can access the fields of the struct using dot syntax (.):\nExample\nFields are similar to variables, but they belong to a struct. Since they are part of a larger structure (like Person or Car), they are called fields in Rust, not regular variables.\nChange a Field\nTo change a value inside a struct, you must make the struct object mutable by using mut:\nExample\nWhy Use Structs?\nTo group related data in a clean way\nTo make your code easier to read and maintain\nTo create real-world examples, like users, books, cars, etc.",
      "examples": [
        "struct Person {\nname: String,\nage: u32,\ncan_vote: bool,\n}",
        "// Create a Struct called Person\nstruct Person {\nname: String,\nage: u32,\ncan_vote: bool,\n}\n\n// Create a Person object\nlet user = Person {\nname: String::from(\"John\"),\nage: 35,\ncan_vote: true,\n};\n\n// Access and print the values\nprintln!(\"Name: {}\", user.name);\nprintln!(\"Age: {}\", user.age);\nprintln!(\"Can vote? {}\", user.can_vote);",
        "struct Person {\nname: String,\nage: u32,\n}\n\nlet mut user = Person {\nname: String::from(\"John\"),\nage: 35,\n};\n\nuser.age = 36; // Change value of age\nprintln!(\"Name: {}\", user.name);\nprintln!(\"Updated age: {}\", user.age);",
        "struct",
        ".",
        "mut"
      ]
    },
    {
      "title": "Rust Enums",
      "summary": "Enums\nAn enum (short for \"enumeration\") is a way to define a type that can be one of a few different values.\nEach value in the enum is called a variant.\nEnums are useful when you want to represent a value that can only be one of a set of options - like days of the week, directions, or results like success and error.\nCreate an Enum\nTo create an enum, use the enum keyword and add a set of named values (variants) separated by commas:\nExample\nTo use the enum, create a variable and assign it one of the enum's variants (use :: to access a variant):\nExample\nMatch on Enum Values\nEnums work great with the match statement. You can run different code depending on which variant is used:\nExample\nEnums with Data\nEnum variants can also hold data. This is useful when each variant needs to store extra information:\nExample\nWhy Use Enums?\nTo group related values into one type\nTo make your code more readable and safe\nTo handle different cases with match",
      "examples": [
        "enum Direction {\nUp,\nDown,\nLeft,\nRight,\n}",
        "enum Direction {\nUp,\nDown,\nLeft,\nRight,\n}\n\nfn main() {\nlet my_direction = Direction::Up;\nprintln!(\"We are going up!\");\n}",
        "enum Direction {\nUp,\nDown,\nLeft,\nRight,\n}\n\nfn main() {\nlet my_direction = Direction::Left;\n\nmatch my_direction {\nDirection::Up => println!(\"Going up\"),\nDirection::Down => println!(\"Going down\"),\nDirection::Left => println!(\"Going left\"),\nDirection::Right => println!(\"Going right\"),\n}\n}",
        "enum LoginStatus {\nSuccess(String),\nError(String),\n}\n\nfn main() {\nlet result1 = LoginStatus::Success(String::from(\"Welcome, John!\"));\nlet result2 = LoginStatus::Error(String::from(\"Incorrect password\"));\n\nmatch result1 {\nLoginStatus::Success(message) => println!(\"Success: {}\", message),\nLoginStatus::Error(message) => println!(\"Error: {}\", message),\n}\n}",
        "enum",
        "::",
        "match"
      ]
    },
    {
      "title": "W3Schools Rust Certificate",
      "summary": "W3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate Â»\nW3Schools offers an Online Certification Program.\nThe perfect solution for busy professionals who need to balance work, family, and career building.\nMore than 50 000 certificates already issued!\nGet Your Certificate Â»\nWho Should Consider Getting Certified?\nAny student or professional within the digital industry.\nCertifications are valuable assets to gain trust and demonstrate knowledge to your clients, current or future employers on a ever increasing competitive market.\nW3Schools is Trusted by Top Companies\nW3Schools has over two decades of experience with teaching coding online.\nOur certificates are recognized and valued by companies looking to employ skilled developers.\nSave Time and Money\nShow the world your coding skills by getting a certification.\nThe prices is a small fraction compared to the price of traditional education.\nDocument and validate your competence by getting certified!\nExam overview\nFee: 95 USD\nNumber of questions: 60\nRequirement to pass: 75%\nTime limit: 60 minutes\nNumber of attempts to pass: 3\nExam deadline: None\nCertification Expiration: Never\nFormat: Online, multiple choice\nRegister now Â»\nAdvance Faster in Your Career\nGetting a certificate proves your commitment to upgrading your skills.\nThe certificate can be added as credentials to your CV, Resume, LinkedIn profile, and so on.\nIt gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nKnowledge is power, especially in the current job market.\nDocumentation of your skills enables you to advance your career or helps you to start a new one.\nHow Does It Work?\nStudy for free at W3Schools.com\nStudy at your own speed\nTest your skills with W3Schools online quizzes\nApply for your certificate by paying an exam fee\nTake your exam online, at any time, and from any location\nGet Your Certificate and Share It With The World\nExample certificate:\nEach certificate gets a unique link that can be shared with others.\nValidate your certification with the link or QR code.\nCheck how it looks like in this Example.\nShare your certificate on Linked in the Certifications section in just one click!\nDocument Your Skills\nGetting a certificate proves your commitment to upgrade your skills, gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\nGet Your Certificate Â»\nLooking to add multiple users?\nAre you an educator, manager or business owner looking for courses or certifications?\nWe are working with schools, companies and organizations from all over the world.\nGet courses and/or certifications for your team here.",
      "examples": []
    }
  ],
  "glossary": [
    "backend",
    "exercises",
    "free",
    "javascript",
    "note",
    "programs",
    "report error",
    "rust arrays",
    "rust booleans",
    "rust borrowing",
    "rust comments",
    "rust constants",
    "rust enums",
    "rust functions",
    "rust hashmap",
    "rust home",
    "rust if..else",
    "rust intro",
    "rust loops",
    "rust match",
    "rust operators",
    "rust output",
    "rust ownership",
    "rust scope",
    "rust strings",
    "rust structs",
    "rust syntax",
    "rust tuples",
    "rust variables",
    "rust vectors",
    "w3.css",
    "w3schools spaces"
  ]
}